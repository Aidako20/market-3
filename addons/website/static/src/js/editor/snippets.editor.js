flectra.define('website.snippet.editor',function(require){
'usestrict';

const{qweb,_t,_lt}=require('web.core');
constDialog=require('web.Dialog');
constpublicWidget=require('web.public.widget');
constweSnippetEditor=require('web_editor.snippet.editor');
constwSnippetOptions=require('website.editor.snippets.options');

constFontFamilyPickerUserValueWidget=wSnippetOptions.FontFamilyPickerUserValueWidget;

weSnippetEditor.Class.include({
    xmlDependencies:(weSnippetEditor.Class.prototype.xmlDependencies||[])
        .concat(['/website/static/src/xml/website.editor.xml']),
    events:_.extend({},weSnippetEditor.Class.prototype.events,{
        'click.o_we_customize_theme_btn':'_onThemeTabClick',
    }),
    custom_events:Object.assign({},weSnippetEditor.Class.prototype.custom_events,{
        'gmap_api_request':'_onGMapAPIRequest',
        'gmap_api_key_request':'_onGMapAPIKeyRequest',
    }),
    tabs:_.extend({},weSnippetEditor.Class.prototype.tabs,{
        THEME:'theme',
    }),
    optionsTabStructure:[
        ['theme-colors',_lt("ThemeColors")],
        ['theme-options',_lt("ThemeOptions")],
        ['website-settings',_lt("WebsiteSettings")],
    ],

    //--------------------------------------------------------------------------
    //Private
    //--------------------------------------------------------------------------

    /**
     *@override
     */
    _computeSnippetTemplates:function(html){
        const$html=$(html);
        constfontVariables=_.map($html.find('we-fontfamilypicker[data-variable]'),el=>{
            returnel.dataset.variable;
        });
        FontFamilyPickerUserValueWidget.prototype.fontVariables=fontVariables;

        returnthis._super(...arguments);
    },
    /**
     *Dependingofthedemand,reconfiguretheygmapkeyorconfigureit
     *ifnotalreadydefined.
     *
     *@private
     *@param{boolean}[reconfigure=false]//TODOnameisconfusing"alwaysReconfigure"isbetter
     *@param{boolean}[onlyIfUndefined=false]//TODOnameisconfusing"configureIfNecessary"isbetter
     */
    async_configureGMapAPI({reconfigure,onlyIfUndefined}){
        if(!reconfigure&&!onlyIfUndefined){
            returnfalse;
        }

        constapiKey=awaitnewPromise(resolve=>{
            this.getParent().trigger_up('gmap_api_key_request',{
                onSuccess:key=>resolve(key),
            });
        });
        constapiKeyValidation=apiKey?awaitthis._validateGMapAPIKey(apiKey):{
            isValid:false,
            message:undefined,
        };
        if(!reconfigure&&onlyIfUndefined&&apiKey&&apiKeyValidation.isValid){
            returnfalse;
        }

        letwebsiteId;
        this.trigger_up('context_get',{
            callback:ctx=>websiteId=ctx['website_id'],
        });

        functionapplyError(message){
            const$apiKeyInput=this.find('#api_key_input');
            const$apiKeyHelp=this.find('#api_key_help');
            $apiKeyInput.addClass('is-invalid');
            $apiKeyHelp.empty().text(message);
        }

        const$content=$(qweb.render('website.s_google_map_modal',{
            apiKey:apiKey,
        }));
        if(!apiKeyValidation.isValid&&apiKeyValidation.message){
            applyError.call($content,apiKeyValidation.message);
        }

        returnnewPromise(resolve=>{
            letinvalidated=false;
            constdialog=newDialog(this,{
                size:'medium',
                title:_t("GoogleMapAPIKey"),
                buttons:[
                    {text:_t("Save"),classes:'btn-primary',click:async(ev)=>{
                        constvalueAPIKey=dialog.$('#api_key_input').val();
                        if(!valueAPIKey){
                            applyError.call(dialog.$el,_t("EnteranAPIKey"));
                            return;
                        }
                        const$button=$(ev.currentTarget);
                        $button.prop('disabled',true);
                        constres=awaitthis._validateGMapAPIKey(valueAPIKey);
                        if(res.isValid){
                            awaitthis._rpc({
                                model:'website',
                                method:'write',
                                args:[
                                    [websiteId],
                                    {google_maps_api_key:valueAPIKey},
                                ],
                            });
                            invalidated=true;
                            dialog.close();
                        }else{
                            applyError.call(dialog.$el,res.message);
                        }
                        $button.prop("disabled",false);
                    }},
                    {text:_t("Cancel"),close:true}
                ],
                $content:$content,
            });
            dialog.on('closed',this,()=>resolve(invalidated));
            dialog.open();
        });
    },
    /**
     *@private
     */
    async_validateGMapAPIKey(key){
        try{
            constresponse=awaitfetch(`https://maps.googleapis.com/maps/api/staticmap?center=belgium&size=10x10&key=${encodeURIComponent(key)}`);
            constisValid=(response.status===200);
            return{
                isValid:isValid,
                message:!isValid&&
                    _t("InvalidAPIKey.ThefollowingerrorwasreturnedbyGoogle:")+""+(awaitresponse.text()),
            };
        }catch(err){
            return{
                isValid:false,
                message:_t("Checkyourconnectionandtryagain"),
            };
        }
    },
    /**
     *@override
     */
    _getScrollOptions(options={}){
        constfinalOptions=this._super(...arguments);
        if(!options.offsetElements||!options.offsetElements.$top){
            const$header=$('#top');
            if($header.length){
                finalOptions.offsetElements=finalOptions.offsetElements||{};
                finalOptions.offsetElements.$top=$header;
            }
        }
        returnfinalOptions;
    },
    /**
     *@private
     *@param{FlectraEvent}ev
     *@param{string}gmapRequestEventName
     */
    async_handleGMapRequest(ev,gmapRequestEventName){
        ev.stopPropagation();
        constreconfigured=awaitthis._configureGMapAPI({
            reconfigure:ev.data.reconfigure,
            onlyIfUndefined:ev.data.configureIfNecessary,
        });
        this.getParent().trigger_up(gmapRequestEventName,{
            refetch:reconfigured,
            editableMode:true,
            onSuccess:key=>ev.data.onSuccess(key),
        });
    },
    /**
     *@override
     */
    _updateLeftPanelContent:function({content,tab}){
        this._super(...arguments);
        this.$('.o_we_customize_theme_btn').toggleClass('active',tab===this.tabs.THEME);
    },

    //--------------------------------------------------------------------------
    //Handlers
    //--------------------------------------------------------------------------

    /**
     *@private
     *@param{FlectraEvent}ev
     */
    _onGMapAPIRequest(ev){
        this._handleGMapRequest(ev,'gmap_api_request');
    },
    /**
     *@private
     *@param{FlectraEvent}ev
     */
    _onGMapAPIKeyRequest(ev){
        this._handleGMapRequest(ev,'gmap_api_key_request');
    },
    /**
     *@private
     */
    async_onThemeTabClick(ev){
        //Note:nothingasyncherebutstarttheloadingeffectasap
        letreleaseLoader;
        try{
            constpromise=newPromise(resolve=>releaseLoader=resolve);
            this._execWithLoadingEffect(()=>promise,false,0);
            //loaderisaddedtotheDOMsynchronously
            awaitnewPromise(resolve=>requestAnimationFrame(()=>requestAnimationFrame(resolve)));
            //ensureloaderisrendered:firstcallasksforthe(alreadydone)DOMupdate,
            //secondcallhappensonlyafterrenderingthefirst"updates"

            if(!this.topFakeOptionEl){
                letel;
                for(const[elementName,title]ofthis.optionsTabStructure){
                    constnewEl=document.createElement(elementName);
                    newEl.dataset.name=title;
                    if(el){
                        el.appendChild(newEl);
                    }else{
                        this.topFakeOptionEl=newEl;
                    }
                    el=newEl;
                }
                this.bottomFakeOptionEl=el;
                this.el.appendChild(this.topFakeOptionEl);
            }

            //Needallofthisinthatordersothat:
            //-theelementisvisibleandcanbeenabledandtheonFocusmethodis
            //  calledeachtime.
            //-theelementishiddenafterwardssoitdoesnottakespaceinthe
            //  DOM,sameastheoverlaywhichmaymakeascrollbarappear.
            this.topFakeOptionEl.classList.remove('d-none');
            consteditorPromise=this._activateSnippet($(this.bottomFakeOptionEl));
            releaseLoader();//because_activateSnippetusesthesamemutexastheloader
            releaseLoader=undefined;
            consteditor=awaiteditorPromise;
            this.topFakeOptionEl.classList.add('d-none');
            editor.toggleOverlay(false);

            this._updateLeftPanelContent({
                tab:this.tabs.THEME,
            });
        }catch(e){
            //Normallytheloadingeffectisremovedincaseoferrorduringtheactionbuthere
            //theactualactivityishappeningoutsideoftheaction,theeffectmusttherefore
            //beclearedincaseoferroraswell
            if(releaseLoader){
                releaseLoader();
            }
            throwe;
        }
    },
});

weSnippetEditor.Editor.include({
    layoutElementsSelector:[
        weSnippetEditor.Editor.prototype.layoutElementsSelector,
        '.s_parallax_bg',
        '.o_bg_video_container',
    ].join(','),
});

//Editmodecustomizationsofpublicwidgets.

publicWidget.registry.hoverableDropdown.include({
    /**
     *@override
     */
    start(){
        if(this.editableMode){
            this._onPageClick=this._onPageClick.bind(this);
            this.el.closest('#wrapwrap').addEventListener('click',this._onPageClick,{capture:true});
        }
        returnthis._super.apply(this,arguments);
    },
    /**
     *@override
     */
    destroy(){
        if(this.editableMode){
            this.el.closest('#wrapwrap').removeEventListener('click',this._onPageClick,{capture:true});
        }
        returnthis._super.apply(this,arguments);
    },

    //--------------------------------------------------------------------------
    //Private
    //--------------------------------------------------------------------------
    
    /**
     *Hidesallopeneddropdowns.
     *
     *@private
     */
    _hideDropdowns(){
        for(consttoggleElofthis.el.querySelectorAll('.dropdown.show.dropdown-toggle')){
            $(toggleEl).dropdown('hide');
        }
    },

    //--------------------------------------------------------------------------
    //Handlers
    //--------------------------------------------------------------------------

    /**
     *Calledwhenthepageisclickedanywhere.
     *Closestheshowndropdowniftheclickisoutsideofit.
     *
     *@private
     *@param{Event}ev
     */
    _onPageClick(ev){
        if(ev.target.closest('.dropdown.show')){
            return;
        }
        this._hideDropdowns();
    },
    /**
     *@override
     */
    _onMouseEnter(ev){
        if(this.editableMode){
            //Donothandlehoverifanotherdropdownisopened.
            if(this.el.querySelector('.dropdown.show')){
                return;
            }
        }
        this._super(...arguments);
    },
    /**
     *@override
     */
    _onMouseLeave(ev){
        if(this.editableMode){
            //Cancelhandlingfromviewmode.
            return;
        }
        this._super(...arguments);
    },
});
});

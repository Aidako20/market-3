flectra.define('web.ActionManager',function(require){
"usestrict";

/**
 *ActionManager
 *
 *TheActionManagerisoneofthecentrepiecesintheWebClientarchitecture.
 *ItsroleistomakessurethatFlectraactionsareproperlystartedand
 *coordinated.
 */

varAbstractAction=require('web.AbstractAction');
varconcurrency=require('web.concurrency');
varContext=require('web.Context');
varcore=require('web.core');
varDialog=require('web.Dialog');
vardom=require('web.dom');
varframework=require('web.framework');
varpyUtils=require('web.py_utils');
varWidget=require('web.Widget');

var_t=core._t;
varActionManager=Widget.extend({
    className:'o_action_manager',
    custom_events:{
        breadcrumb_clicked:'_onBreadcrumbClicked',
        history_back:'_onHistoryBack',
        push_state:'_onPushState',
        redirect:'_onRedirect',
    },

    /**
     *@override
     *@param{Object}[userContext={}]
     */
    init:function(parent,userContext){
        this._super.apply(this,arguments);
        this.userContext=userContext||{};

        //useaDropPrevioustodroppreviousactionswhenmultipleactionsare
        //runsimultaneously
        this.dp=newconcurrency.DropPrevious();

        //'actions'isanObjectthatregisterstheactionsthatarecurrently
        //handledbytheActionManager(eitherstackedinthecurrentwindow,
        //oropenedindialogs)
        this.actions={};

        //'controllers'isanObjectthatregistersthealivecontrollers
        //linkedregisteredactions,acontrollerbeingObjectwithkeys
        //(amongstothers)'jsID'(alocalidentifier)and'widget'(the
        //instanceofthecontroller'swidget)
        this.controllers={};

        //'controllerStack'isthestackofidsofthecontrollerscurrently
        //displayedinthecurrentwindow
        this.controllerStack=[];

        //'currentDialogController'isthecurrentcontrolleropenedina
        //dialog(i.e.comingfromanactionwithtarget='new')
        this.currentDialogController=null;
    },
    /**
     *CalledeachtimetheactionmanagerisattachedintotheDOM.
     */
    on_attach_callback:function(){
        this.isInDOM=true;
        varcurrentController=this.getCurrentController();
        if(currentController){
            currentController.widget.on_attach_callback();
        }
    },
    /**
     *CalledeachtimetheactionmanagerisdetachedfromtheDOM.
     */
    on_detach_callback:function(){
        this.isInDOM=false;
        varcurrentController=this.getCurrentController();
        if(currentController){
            currentController.widget.on_detach_callback();
        }
    },

    //--------------------------------------------------------------------------
    //Public
    //--------------------------------------------------------------------------

    /**
     *Thisfunctioniscalledwhenthecurrentcontrollerisabouttobe
     *removedfromtheDOM,becauseanewonewillbepushed,oranoldone
     *willberestored.Itensuresthatthecurrentcontrollercanbeleft(for
     *instance,thatithasnounsavedchanges).
     *
     *@returns{Promise}resolvedifthecurrentcontrollercanbeleft,
     *  rejectedotherwise.
     */
    clearUncommittedChanges:function(){
        varcurrentController=this.getCurrentController();
        if(currentController){
            returncurrentController.widget.canBeRemoved();
        }
        returnPromise.resolve();
    },
    /**
     *ThisistheentrypointtoexecuteFlectraactions,givenasanIDin
     *database,anxmlID,aclientactiontagoranactiondescriptor.
     *
     *@param{number|string|Object}actiontheactiontoexecute
     *@param{Object}[options]
     *@param{Object}[options.additional_context]additionalcontexttobe
     *  mergedwiththeaction'scontext.
     *@param{boolean}[options.clear_breadcrumbs=false]settotruetoclear
     *  thebreadcrumbshistorylist
     *@param{Function}[options.on_close]callbacktobeexecutedwhenthe
     *  currentactionisactiveagain(typically,ifthenewactionis
     *  executedintarget="new",on_closewillbeexecutedwhenthedialogis
     *  closed,ifthecurrentcontrollerisstillactive)
     *@param{Function}[options.on_reverse_breadcrumb]callbacktobeexecuted
     *  wheneverananteriorbreadcrumbitemisclickedon
     *@param{boolean}[options.pushState=true]settofalsetopreventthe
     *  ActionManagerfrompushingthestatewhentheactionisexecuted(this
     *  isusefulwhenwecomefromaloadState())
     *@param{boolean}[options.replace_last_action=false]settotrueto
     *  replacelastpartofthebreadcrumbswiththeaction
     *@return{Promise<Object>}resolvedwiththeactionwhentheactionis
     *  loadedandappendedtotheDOM;rejectediftheactioncan'tbe
     *  executed(e.g.ifdoActionhasbeencalledtoexecuteanotheraction
     *  beforethisonewascomplete).
     */
    doAction:function(action,options){
        varself=this;
        options=_.defaults({},options,{
            additional_context:{},
            clear_breadcrumbs:false,
            on_close:function(){},
            on_reverse_breadcrumb:function(){},
            pushState:true,
            replace_last_action:false,
        });

        //buildorloadanactiondescriptorforthegivenaction
        vardef;
        if(_.isString(action)&&core.action_registry.contains(action)){
            //actionisatagofaclientaction
            action={type:'ir.actions.client',tag:action};
        }elseif(_.isNumber(action)||_.isString(action)){
            //actionisanidorxmlid
            def=this._loadAction(action,{
                active_id:options.additional_context.active_id,
                active_ids:options.additional_context.active_ids,
                active_model:options.additional_context.active_model,
            }).then(function(result){
                action=result;
            });
        }

        returnthis.dp.add(Promise.resolve(def)).then(function(){
            //action.target'main'isequivalentto'current'exceptthatit
            //alsoclearsthebreadcrumbs
            options.clear_breadcrumbs=action.target==='main'||
                                        options.clear_breadcrumbs;

            self._preprocessAction(action,options);

            returnself._handleAction(action,options).then(function(){
                //nowthattheactionhasbeenexecuted,forceits'pushState'
                //flagto'true',aswedon'twanttopreventitscontroller
                //frompushingitsstateifitchangesinthefuture
                action.pushState=true;

                returnaction;
            });
        }).then(function(action){
            self.trigger_up('webclient_started');
            returnaction;
        });
    },
    /**
     *Compatibilitywithclientactionsthatarestillusingdo_push_state.
     *
     *@todo:convertallofthemtotrigger_up('push_state')instead.
     *@param{Object}state
     */
    do_push_state:function(state){
        this.trigger_up('push_state',{state:state});
    },
    /**
     *ReturnstheactionofthelastcontrollerinthecontrollerStack,i.e.
     *theactionofthecurrentlydisplayedcontrollerinthemainwindow(not
     *inadialog),andnullifthereisnocontrollerinthestack.
     *
     *@returns{Object|null}
     */
    getCurrentAction:function(){
        varcontroller=this.getCurrentController();
        returncontroller?this.actions[controller.actionID]:null;
    },
    /**
     *ReturnsthelastcontrollerinthecontrollerStack,i.e.thecurrently
     *displayedcontrollerinthemainwindow(notinadialog),and
     *nullifthereisnocontrollerinthestack.
     *
     *@returns{Object|null}
     */
    getCurrentController:function(){
        varcurrentControllerID=_.last(this.controllerStack);
        returncurrentControllerID?this.controllers[currentControllerID]:null;
    },
    /**
     *UpdatestheUIaccordingtothegivenstate,forinstance,executesanew
     *action,orupdatesthestateofthecurrentaction.
     *
     *@param{Object}state
     *@param{integer|string}[state.action]theactiontoexecute(givenits
     *  idortagforclientactions)
     *@returns{Promise}resolvedwhentheUIhasbeenupdated
     */
    loadState:function(state){
        varaction;
        if(!state.action){
            returnPromise.resolve();
        }
        if(_.isString(state.action)&&core.action_registry.contains(state.action)){
            action={
                params:state,
                tag:state.action,
                type:'ir.actions.client',
            };
        }else{
            action=state.action;
        }
        returnthis.doAction(action,{
            clear_breadcrumbs:true,
            pushState:false,
        });
    },

    //--------------------------------------------------------------------------
    //Private
    //--------------------------------------------------------------------------

    /**
     *AppendsthegivencontrollertotheDOMandrestoresitsscrollposition.
     *Alsoupdatesthecontrolpanel.
     *
     *@private
     *@param{Object}controller
     */
    _appendController:function(controller){
        dom.append(this.$el,controller.widget.$el,{
            in_DOM:this.isInDOM,
            callbacks:[{widget:controller.widget}],
        });

        if(controller.scrollPosition){
            this.trigger_up('scrollTo',controller.scrollPosition);
        }
    },
    /**
     *Closesthecurrentdialog,ifany.Becausewelistentothe'closed'
     *eventtriggeredbythedialogwhenitisclosed,thisalsodestroysthe
     *embeddedcontrollerandremovesthereferencetothecorrespondingaction.
     *Thisalsoexecutesthe'on_close'handlerinsomecases,andmayalso
     *provideinfosforclosingthisdialog.
     *
     *@private
     *@param{Object}options
     *@param{Object}[options.infos]someinfosrelatedtotheclosingthe
     *  dialog.
     *@param{boolean}[options.silent=false]iftrue,the'on_close'handler
     *  won'tbecalled;thisisingeneralthecasewhenthecurrentdialog
     *  isclosedbecauseanotheractionisopened,sowedon'twanttheformer
     *  actiontoexecuteitshandlerasitwon'tbedisplayedanyway
     */
    _closeDialog:function(options){
        if(this.currentDialogController){
            this.currentDialogController.dialog.destroy(options);
        }
    },
    /**
     *DetachesthecurrentcontrollerfromtheDOMandstoresitsscroll
     *position,incasewe'dcomebacktothatcontrollerlater.
     *
     *@private
     */
    _detachCurrentController:function(){
        varcurrentController=this.getCurrentController();
        if(currentController){
            currentController.scrollPosition=this._getScrollPosition();
            dom.detach([{widget:currentController.widget}]);
        }
    },
    /**
     *ExecutesactionsforwhichacontrollerhastobeappendedtotheDOM,
     *eitherinthemaincontent(target="current",bydefault),orinadialog
     *(target="new").
     *
     *@private
     *@param{Object}action
     *@param{widget}action.controlleraWidgetinstancetoappendtotheDOM
     *@param{string}[action.target="current"]setto"new"torenderthe
     *  controllerinadialog
     *@param{Object}options@seedoActionfordetails
     *@returns{Promise}resolvedwhenthecontrollerisstartedandappended
     */
    _executeAction:function(action,options){
        varself=this;
        this.actions[action.jsID]=action;

        if(action.target==='new'){
            returnthis._executeActionInDialog(action,options);
        }

        varcontroller=self.controllers[action.controllerID];
        returnthis.clearUncommittedChanges()
            .then(function(){
                returnself.dp.add(self._startController(controller));
            })
            .then(function(){
                if(self.currentDialogController){
                    self._closeDialog({silent:true});
                }

                //storetheoptional'on_reverse_breadcrumb'handler
                //AAB:storeitontheAbstractActioninstance,andcallit
                //automaticallywhentheactionisrestored
                if(options.on_reverse_breadcrumb){
                    varcurrentAction=self.getCurrentAction();
                    if(currentAction){
                        currentAction.on_reverse_breadcrumb=options.on_reverse_breadcrumb;
                    }
                }

                //updatetheinternalstateandtheDOM
                self._pushController(controller);

                //storetheactionintothesessionStoragesothatitcanbe
                //fullyrestoredonF5
                self.call('session_storage','setItem','current_action',action._originalAction);

                returnaction;
            })
            .guardedCatch(function(){
                self._removeAction(action.jsID);
            });
    },
    /**
     *Executesactionswithattributetarget='new'.Suchactionsarerendered
     *inadialog.
     *
     *@private
     *@param{Object}action
     *@param{Object}options@seedoActionfordetails
     *@returns{Promise}resolvedwhenthecontrollerisrenderedinsidea
     *  dialogappendedtotheDOM
     */
    _executeActionInDialog:function(action,options){
        varself=this;
        varcontroller=this.controllers[action.controllerID];
        varwidget=controller.widget;

        returnthis._startController(controller).then(function(controller){
            varprevDialogOnClose;
            if(self.currentDialogController){
                prevDialogOnClose=self.currentDialogController.onClose;
                self._closeDialog({silent:true});
            }

            controller.onClose=prevDialogOnClose||options.on_close;
            vardialog=newDialog(self,_.defaults({},options,{
                buttons:[],
                dialogClass:controller.className,
                title:action.name,
                size:action.context.dialog_size,
            }));
            /**
             *@param{Object}[options={}]
             *@param{Object}[options.infos]ifprovidedand`silent`is
             *  unset,the`on_close`handlerwillpassthisinformation,
             *  whichgivessomecontextforclosingthisdialog.
             *@param{boolean}[options.silent=false]ifset,donotcallthe
             *  `on_close`handler.
             */
            dialog.on('closed',self,function(options){
                options=options||{};
                self._removeAction(action.jsID);
                self.currentDialogController=null;
                if(options.silent!==true){
                    controller.onClose(options.infos);
                }
            });
            controller.dialog=dialog;

            returndialog.open().opened(function(){
                self.currentDialogController=controller;
                widget.setParent(dialog);
                dom.append(dialog.$el,widget.$el,{
                    in_DOM:true,
                    callbacks:[{widget:controller.widget}],
                });
                widget.renderButtons(dialog.$footer);
                dialog.rebindButtonBehavior();

                returnaction;
            });
        }).guardedCatch(function(){
            self._removeAction(action.jsID);
        });
    },
    /**
     *Executesactionsoftype'ir.actions.client'.
     *
     *@private
     *@param{Object}actionthedescriptionoftheactiontoexecute
     *@param{string}action.tagthekeyoftheactionintheaction_registry
     *@param{Object}options@seedoActionfordetails
     *@returns{Promise}resolvedwhentheclientactionhasbeenexecuted
     */
    _executeClientAction:function(action,options){
        varself=this;
        varClientAction=core.action_registry.get(action.tag);
        if(!ClientAction){
            console.error("Couldnotfindclientaction"+action.tag,action);
            returnPromise.reject();
        }
        if(!(ClientAction.prototypeinstanceofWidget)){
            //theclientactionmightbeafunction,whichisexecutedand
            //whosereturnedvaluemightbeanotheractiontoexecute
            varnext=ClientAction(this,action);
            if(next){
                returnthis.doAction(next,options);
            }
            returnPromise.resolve();
        }
        if(!(ClientAction.prototypeinstanceofAbstractAction)){
            console.warn('Theclientaction'+action.tag+'shouldbeaninstanceofAbstractAction!');
        }

        varcontrollerID=_.uniqueId('controller_');

        varindex=this._getControllerStackIndex(options);
        options.breadcrumbs=this._getBreadcrumbs(this.controllerStack.slice(0,index));
        options.controllerID=controllerID;
        varwidget=newClientAction(this,action,options);
        varcontroller={
            actionID:action.jsID,
            index:index,
            jsID:controllerID,
            title:widget.getTitle(),
            widget:widget,
        };
        this.controllers[controllerID]=controller;
        action.controllerID=controllerID;
        varprom=this._executeAction(action,options);
        prom.then(function(){
            self._pushState(controllerID,{});
        });
        returnprom;
    },
    /**
     *Executesactionsoftype'ir.actions.act_window_close',i.e.closesthe
     *lastopeneddialog.
     *
     *Theactionmayalsospecifyaneffecttodisplayrightaftertheclose
     *action(e.g.rainbowman),orprovideareasonforthecloseaction.
     *Thisisusefulfordecisionmakingforthe`on_close`handler.
     *
     *@private
     *@param{Object}action
     *@param{Object}[action.effect]effecttoshowup,e.g.rainbowman.
     *@param{Object}[action.infos]infosonperformingthecloseaction.
     *  Usefulforprovidingsomecontextforthe`on_close`handler.
     *@returns{Promise}resolvedimmediately
     */
    _executeCloseAction:function(action,options){
        varresult;
        if(!this.currentDialogController){
            result=options.on_close(action.infos);
        }

        this._closeDialog({infos:action.infos});

        //displaysomeeffect(likerainbowman)onappropriateactions
        if(action.effect){
            this.trigger_up('show_effect',action.effect);
        }

        returnPromise.resolve(result);
    },
    /**
     *Executesactionsoftype'ir.actions.server'.
     *
     *@private
     *@param{Object}actionthedescriptionoftheactiontoexecute
     *@param{integer}action.idthedbIDoftheactiontoexecute
     *@param{Object}[action.context]
     *@param{Object}options@seedoActionfordetails
     *@returns{Promise}resolvedwhentheactionhasbeenexecuted
     */
    _executeServerAction:function(action,options){
        varself=this;
        varrunDef=this._rpc({
            route:'/web/action/run',
            params:{
                action_id:action.id,
                context:action.context||{},
            },
        });
        returnthis.dp.add(runDef).then(function(action){
            action=action||{type:'ir.actions.act_window_close'};
            returnself.doAction(action,options);
        });
    },
    /**
     *Executesactionsoftype'ir.actions.act_url',i.e.redirectstothe
     *givenurl.
     *
     *@private
     *@param{Object}actionthedescriptionoftheactiontoexecute
     *@param{string}action.url
     *@param{string}[action.target]setto'self'toredirectinthecurrentpage,
     *  redirectstoanewpagebydefault
     *@param{Object}options@seedoActionfordetails
     *@returns{Promise}resolvedwhentheredirectionisdone(immediately
     *  whenredirectingtoanewpage)
     */
    _executeURLAction:function(action,options){
        varurl=action.url;

        if(action.target==='self'){
            framework.redirect(url);
            returnPromise.resolve();
        }else{
            varw=window.open(url,'_blank');
            if(!w||w.closed||typeofw.closed==='undefined'){
                varmessage=_t('Apopupwindowhasbeenblocked.You'+
                             'mayneedtochangeyourbrowsersettingstoallow'+
                             'popupwindowsforthispage.');
                this.do_warn(false,message,true);
            }
        }

        options.on_close();

        returnPromise.resolve();
    },
    /**
     *Returnsadescriptionofthecontrollersinthegiven controllerstack.
     *Itisusedtorenderthebreadcrumbs.ItisanarrayofObjectswithkeys
     *'title'(whattodisplayinthebreadcrumbs)and'controllerID'(theID
     *ofthecorrespondingcontroller,usedtorestoreitwhenthispartofthe
     *breadcrumbsisclicked).
     *
     *@private
     *@param{string[]}controllerStack
     *@returns{Object[]}
     */
    _getBreadcrumbs:function(controllerStack){
        varself=this;
        return_.map(controllerStack,function(controllerID){
            return{
                controllerID:controllerID,
                title:self.controllers[controllerID].title,
            };
        });
    },
    /**
     *Returnstheindexwhereacontrollershouldbeinsertedinthecontroller
     *stackaccordingtothegivenoptions.Bydefault,acontrollerispushed
     *onthetopofthestack.
     *
     *@private
     *@param{options}[options.clear_breadcrumbs=false]iftrue,insertat
     *  index0andremoveallothercontrollers
     *@param{options}[options.index=null]ifgiven,thatindexisreturned
     *@param{options}[options.replace_last_action=false]iftrue,replacethe
     *  lastcontrollerofthestack
     *@returns{integer}index
     */
    _getControllerStackIndex:function(options){
        varindex;
        if('index'inoptions){
            index=options.index;
        }elseif(options.clear_breadcrumbs){
            index=0;
        }elseif(options.replace_last_action){
            index=this.controllerStack.length-1;
        }else{
            index=this.controllerStack.length;
        }
        returnindex;
    },
    /**
     *Returnsanobjectcontaininginformationaboutthegivencontroller,like
     *itstitle,itsaction'sid,theactive_idandactive_idsoftheaction...
     *
     *@private
     *@param{string}controllerID
     *@returns{Object}
     */
    _getControllerState:function(controllerID){
        varcontroller=this.controllers[controllerID];
        varaction=this.actions[controller.actionID];
        varstate={
            title:controller.widget.getTitle(),
        };
        if(action.id){
            state.action=action.id;
        }elseif(action.type==='ir.actions.client'){
            state.action=action.tag;
            varparams=_.pick(action.params,function(v){
                return_.isString(v)||_.isNumber(v);
            });
            state=_.extend(params||{},state);
        }
        if(action.context){
            varactive_id=action.context.active_id;
            if(active_id){
                state.active_id=active_id;
            }
            varactive_ids=action.context.active_ids;
            //wedon'tpushactive_idsifit'sasingleelementarraycontainingtheactive_id
            //tomaketheurlshorterinmostcases
            if(active_ids&&!(active_ids.length===1&&active_ids[0]===active_id)){
                state.active_ids=action.context.active_ids.join(',');
            }
        }
        state=_.extend({},controller.widget.getState(),state);
        returnstate;
    },
    /**
     *Returnsthecurrenthorizontalandverticalscrollpositions.
     *
     *@private
     *@returns{Object}
     */
    _getScrollPosition:function(){
        varscrollPosition;
        this.trigger_up('getScrollPosition',{
            callback:function(_scrollPosition){
                scrollPosition=_scrollPosition;
            }
        });
        returnscrollPosition;
    },
    /**
     *Dispatchesthegivenactiontothecorrespondinghandlertoexecuteit,
     *accordingtoitstype.Thisfunctioncanbeoverriddentoextendthe
     *rangeofsupportedactiontypes.
     *
     *@private
     *@param{Object}action
     *@param{string}action.type
     *@param{Object}options
     *@returns{Promise}resolvedwhentheactionhasbeenexecuted;rejected
     *  ifthetypeofactionisn'tsupported,oriftheactioncan'tbe
     *  executed
     */
    _handleAction:function(action,options){
        if(!action.type){
            console.error("Notypeforaction",action);
            returnPromise.reject();
        }
        switch(action.type){
            case'ir.actions.act_url':
                returnthis._executeURLAction(action,options);
            case'ir.actions.act_window_close':
                returnthis._executeCloseAction(action,options);
            case'ir.actions.client':
                returnthis._executeClientAction(action,options);
            case'ir.actions.server':
                returnthis._executeServerAction(action,options);
            default:
                console.error("TheActionManagercan'thandleactionsoftype"+
                    action.type,action);
                returnPromise.reject();
        }
    },
    /**
     *UpdatestheinternalstateandtheDOMwiththegivencontrolleras
     *currentcontroller.
     *
     *@private
     *@param{Object}controller
     *@param{string}controller.jsID
     *@param{Widget}controller.widget
     *@param{integer}controller.indexthecontrollerispushedatthat
     *  positioninthecontrollerstackandcontrollerswithanhigherindex
     *  aredestroyed
     */
    _pushController:function(controller){
        varself=this;

        //detachthecurrentcontroller
        this._detachCurrentController();

        //pushthenewcontrollertothestackatthegivenposition,and
        //destroycontrollerswithanhigherindex
        vartoDestroy=this.controllerStack.slice(controller.index);
        //rejectfromthelistofcontrollerstodestroytheonethatweare
        //currentlypushing,orthoselinkedtothesameactionastheone
        //linkedtothecontrollerthatwearepushing
        toDestroy=_.reject(toDestroy,function(controllerID){
            returncontrollerID===controller.jsID||
                   self.controllers[controllerID].actionID===controller.actionID;
        });
        this._removeControllers(toDestroy);
        this.controllerStack=this.controllerStack.slice(0,controller.index);
        this.controllerStack.push(controller.jsID);

        //appendthenewcontrollertotheDOM
        this._appendController(controller);

        //notifytheenvironmentofthenewaction
        this.trigger_up('current_action_updated',{
            action:this.getCurrentAction(),
            controller:controller,
        });

        //closealldialogswhenthecurrentcontrollerchanges
        core.bus.trigger('close_dialogs');

        //togglethefullscreenmodeforactionsintarget='fullscreen'
        this._toggleFullscreen();
    },
    /**
     *Pushesthegivenstate,withadditionalinformationaboutthegiven
     *controller,liketheaction'sidandthecontroller'stitle.
     *
     *@private
     *@param{string}controllerID
     *@param{Object}[state={}]
     */
    _pushState:function(controllerID,state){
        varcontroller=this.controllers[controllerID];
        if(controller){
            varaction=this.actions[controller.actionID];
            if(action.target==='new'){
                //donotpushstateforactionsintarget="new"
                return;
            }
            if(action.pushState===false){
                //donotpushstateforactionsthathavebeenexplicitly
                //markedasnotpushablebuttriggerthetitlechange
                this.trigger_up('set_title_part',{
                    part:"action",
                    title:controller.widget.getTitle()
                });
                return;
            }
            state=_.extend({},state,this._getControllerState(controller.jsID));
            this.trigger_up('push_state',{state:state});
        }
    },
    /**
     *LoadsanactionfromthedatabasegivenitsID.
     *
     *@todo:turnthisinaservice(DataManager)
     *@private
     *@param{integer|string}action'sIDorxmlID
     *@param{Object}context
     *@returns{Promise<Object>}resolvedwiththedescriptionoftheaction
     */
    _loadAction:function(actionID,context){
        varself=this;
        returnnewPromise(function(resolve,reject){
            self.trigger_up('load_action',{
                actionID:actionID,
                context:context,
                on_success:resolve,
            });
        });
    },
    /**
     *PreprocessestheactionbeforeitishandledbytheActionManager
     *(assignsaJSid,evaluatesitscontextanddomains,etc.).
     *
     *@param{Object}action
     *@param{Object}optionssee@doActionoptions
     */
    _preprocessAction:function(action,options){
        //ensurethatthecontextanddomainareevaluated
        varcontext=newContext(this.userContext,options.additional_context,action.context);
        action.context=pyUtils.eval('context',context);
        if(action.domain){
            action.domain=pyUtils.eval('domain',action.domain,action.context);
        }

        action._originalAction=JSON.stringify(action);

        action.jsID=_.uniqueId('action_');
        action.pushState=options.pushState;
    },
    /**
     *Unlinksthegivenactionanditscontrollerfromtheinternalstructures
     *anddestroysitscontrollers.
     *
     *@private
     *@param{string}actionIDtheidoftheactiontoremove
     */
    _removeAction:function(actionID){
        varaction=this.actions[actionID];
        varcontroller=this.controllers[action.controllerID];
        deletethis.actions[action.jsID];
        deletethis.controllers[action.controllerID];
        controller.widget.destroy();
    },
    /**
     *Removesthegivencontrollersandtheircorrespondingactions.
     *
     *@see_removeAction
     *@private
     *@param{string[]}controllerIDs
     */
    _removeControllers:function(controllerIDs){
        varself=this;
        varactionsToRemove=_.map(controllerIDs,function(controllerID){
            returnself.controllers[controllerID].actionID;
        });
        _.each(_.uniq(actionsToRemove),this._removeAction.bind(this));
    },
    /**
     *RestoresacontrollerfromthecontrollerStackanddestroysall
     *controllersstackedoverthegivencontroller(calledwhencomingback
     *usingthebreadcrumbs).
     *
     *@private
     *@param{string}controllerID
     *@returns{Promise}resolvedwhenthecontrollerhasbeenrestored
     */
    _restoreController:function(controllerID){
        varself=this;
        varcontroller=this.controllers[controllerID];
        //AAB:AbstractActionshoulddefineaproperhooktoexecutecodewhen
        //itisrestored(otherthando_show),anditshouldreturnapromise
        varaction=this.actions[controller.actionID];
        vardef;
        if(action.on_reverse_breadcrumb){
            def=action.on_reverse_breadcrumb();
        }
        returnPromise.resolve(def).then(function(){
            returnPromise.resolve(controller.widget.do_show()).then(function(){
                varindex=_.indexOf(self.controllerStack,controllerID);
                self._pushController(controller,index);
            });
        });
    },
    /**
     *Startsthecontrollerbyappendingitinadocumentfragment,sothatit
     *isreadywhenitwillbeappendedtotheDOM.Thisallowstoprevent
     *flickeringforwidgetsdoingasyncstuffinwillStart()orstart().
     *
     *Alsoupdatesthecontrolpanelonanychangeofthetitleoncontroller's
     *widget.
     *
     *@private
     *@param{Object}controller
     *@returns{Promise<Object>}resolvedwiththecontrollerwhenitisready
     */
    _startController:function(controller){
        varfragment=document.createDocumentFragment();
        returncontroller.widget.appendTo(fragment).then(function(){
            returncontroller;
        });
    },
    /**
     *Togglesthefullscreenmodeifthereisanactionintarget='fullscreen'
     *inthecurrentstack.
     *
     *@private
     */
    _toggleFullscreen:function(){
        varself=this;
        varfullscreen=_.some(this.controllerStack,function(controllerID){
            varcontroller=self.controllers[controllerID];
            returnself.actions[controller.actionID].target==='fullscreen';
        });
        this.trigger_up('toggle_fullscreen',{fullscreen:fullscreen});
    },

    //--------------------------------------------------------------------------
    //Handlers
    //--------------------------------------------------------------------------

    /**
     *@private
     *@param{FlectraEvent}ev
     *@param{string}ev.data.controllerID
     */
    _onBreadcrumbClicked:function(ev){
        ev.stopPropagation();
        this._restoreController(ev.data.controllerID);
    },
    /**
     *Goesbackinthehistory:ifacontrollerisopenedinadialog,closes
     *thedialog,otherwise,restoresthesecondtolastcontrollerfromthe
     *stack.
     *
     *@private
     */
    _onHistoryBack:function(){
        if(this.currentDialogController){
            this._closeDialog();
        }else{
            varlength=this.controllerStack.length;
            if(length>1){
                this._restoreController(this.controllerStack[length-2]);
            }
        }
    },
    /**
     *Interceptsandtriggersanewpush_stateevent,withadditional
     *informationaboutthegivencontroller.
     *
     *@private
     *@param{FlectraEvent}ev
     *@param{string}ev.controllerID
     *@param{Object}[ev.state={}]
     */
    _onPushState:function(ev){
        if(ev.target!==this){
            ev.stopPropagation();
            this._pushState(ev.data.controllerID,ev.data.state);
        }
    },
    /**
     *Interceptsandtriggersaredirectiononalink.
     *
     *@private
     *@param{FlectraEvent}ev
     *@param{integer}ev.data.res_id
     *@param{string}ev.data.res_model
     */
    _onRedirect:function(ev){
        this.do_action({
            type:'ir.actions.act_window',
            view_mode:'form',
            res_model:ev.data.res_model,
            views:[[false,'form']],
            res_id:ev.data.res_id,
        });
    },
});

returnActionManager;

});

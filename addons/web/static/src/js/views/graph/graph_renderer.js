flectra.define('web.GraphRenderer',function(require){
"usestrict";

/**
 *Thegraphrendererturnsthedatafromthegraphmodelintoanicelooking
 *canvaschart. ThiscodeusestheChart.jslibrary.
 */

varAbstractRenderer=require('web.AbstractRenderer');
varconfig=require('web.config');
varcore=require('web.core');
vardataComparisonUtils=require('web.dataComparisonUtils');
varfieldUtils=require('web.field_utils');

var_t=core._t;
varDateClasses=dataComparisonUtils.DateClasses;
varqweb=core.qweb;

varCHART_TYPES=['pie','bar','line'];

varCOLORS=["#1f77b4","#ff7f0e","#aec7e8","#ffbb78","#2ca02c","#98df8a","#d62728",
    "#ff9896","#9467bd","#c5b0d5","#8c564b","#c49c94","#e377c2","#f7b6d2",
    "#7f7f7f","#c7c7c7","#bcbd22","#dbdb8d","#17becf","#9edae5"];
varCOLOR_NB=COLORS.length;

functionhexToRGBA(hex,opacity){
    varresult=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    varrgb=result.slice(1,4).map(function(n){
        returnparseInt(n,16);
    }).join(',');
    return'rgba('+rgb+','+opacity+')';
}

//usedtoformatvaluesintooltipsandyAxes.
varFORMAT_OPTIONS={
    //allowtodecideifutils.human_numbershouldbeused
    humanReadable:function(value){
        returnMath.abs(value)>=1000;
    },
    //withthechoicesbelow,1236isrepresentedby1.24k
    minDigits:1,
    decimals:2,
    //avoidcommaseparatorsforthousandsinnumberswhenhuman_numberisused
    formatterCallback:function(str){
        returnstr;
    },
};

varNO_DATA=[_t('Nodata')];
NO_DATA.isNoData=true;

varFAKE_DATA=[""];
FAKE_DATA.isFakeData=true;

//hidetoplegendwhentoomanyitemsfordevicesize
varMAX_LEGEND_LENGTH=4*(Math.max(1,config.device.size_class));

returnAbstractRenderer.extend({
    className:"o_graph_renderer",
    sampleDataTargets:['.o_graph_canvas_container'],
    /**
     *@override
     *@param{Widget}parent
     *@param{Object}state
     *@param{Object}params
     *@param{boolean}[params.isEmbedded]
     *@param{Object}[params.fields]
     *@param{string}[params.title]
     */
    init:function(parent,state,params){
        this._super.apply(this,arguments);
        this.isEmbedded=params.isEmbedded||false;
        this.title=params.title||'';
        this.fields=params.fields||{};
        this.disableLinking=params.disableLinking;

        this.chart=null;
        this.chartId=_.uniqueId('chart');
        this.$legendTooltip=null;
        this.$tooltip=null;
    },
    /**
     *Chart.jsdoesnotneedthecanvastobeindominorder
     *tobeabletoworkwell.Wecouldavoidthecallstoon_attach_callback
     *andon_detach_callback.
     *
     *@override
     */
    on_attach_callback:function(){
        this._super.apply(this,arguments);
        this.isInDOM=true;
        this._render();
    },
    /**
     *@override
     */
    on_detach_callback:function(){
        this._super.apply(this,arguments);
        this.isInDOM=false;
    },

    //--------------------------------------------------------------------------
    //Private
    //--------------------------------------------------------------------------

    /**
     *Thisfunctionaimstoremoveasuitablenumberoflinesfromthetooltipinordertomakeitreasonablyvisible.
     *Amessageindicatingthenumberoflinesisaddedifnecessary.
     *
     *@private
     *@param{Number}maxTooltipHeightthisthemaxheightinpixelsofthetooltip
     */
    _adjustTooltipHeight:function(maxTooltipHeight){
        varsizeOneLine=this.$tooltip.find('tbodytr')[0].clientHeight;
        vartbodySize=this.$tooltip.find('tbody')[0].clientHeight;
        vartoKeep=Math.floor((maxTooltipHeight-(this.$tooltip[0].clientHeight-tbodySize))/sizeOneLine)-1;
        var$lines=this.$tooltip.find('tbodytr');
        vartoRemove=$lines.length-toKeep;
        if(toRemove>0){
            $lines.slice(toKeep).remove();
            vartr=document.createElement('tr');
            vartd=document.createElement('td');
            tr.classList.add('o_show_more');
            td.innerHTML=_t("...");
            tr.appendChild(td);
            this.$tooltip.find('tbody').append(tr);
        }
    },
    /**
     *ThisfunctioncreatesacustomHTMLtooltip.
     *
     *@private
     *@param{Object}tooltipModelseechartjsdocumentation
     */
    _customTooltip:function(tooltipModel){
        this.$el.css({cursor:'default'});
        if(this.$tooltip){
            this.$tooltip.remove();
        }
        if(tooltipModel.opacity===0){
            return;
        }
        if(tooltipModel.dataPoints.length===0){
            return;
        }

        if(this._isRedirectionEnabled()){
            this.$el.css({cursor:'pointer'});
        }

        constchartArea=this.chart.chartArea;
        constchartAreaLeft=chartArea.left;
        constchartAreaRight=chartArea.right;
        constchartAreaTop=chartArea.top;
        constrendererTop=this.$el[0].getBoundingClientRect().top;

        constmaxTooltipLabelWidth=Math.floor((chartAreaRight-chartAreaLeft)/1.68)+'px';

        consttooltipItems=this._getTooltipItems(tooltipModel);

        this.$tooltip=$(qweb.render('GraphView.CustomTooltip',{
            measure:this.fields[this.state.measure].string,
            tooltipItems:tooltipItems,
            maxWidth:maxTooltipLabelWidth,
        })).css({top:'2px',left:'2px'});
        const$container=this.$el.find('.o_graph_canvas_container');
        $container.append(this.$tooltip);

        lettop;
        consttooltipHeight=this.$tooltip[0].clientHeight;
        constminTopAllowed=Math.floor(chartAreaTop);
        constmaxTopAllowed=Math.floor(window.innerHeight-rendererTop-tooltipHeight)-2;
        consty=Math.floor(tooltipModel.y);
        if(minTopAllowed<=maxTopAllowed){
            //Hereweknowthatthefulltooltipcanfitinthescreen.
            //WeputitinthepositionwhereChart.jswouldputit
            //iftwoconditionsarerespected:
            // 1:thetooltipisnotcut(becauseweknowitispossibletonotcutit)
            // 2:thetooltipdoesnothidethelegend.
            //IfitisnotpossibletousetheChart.jsproposition(y)
            //weusethebestapproximatedvalue.
            if(y<=maxTopAllowed){
                if(y>=minTopAllowed){
                    top=y;
                }else{
                    top=minTopAllowed;
                }
            }else{
                top=maxTopAllowed;
            }
        }else{
            //Hereweknowthatwecannotsatisfycondition1above,
            //sowepositionthetooltipattheminimalpositionand
            //cutittheminimumpossible.
            top=minTopAllowed;
            constmaxTooltipHeight=window.innerHeight-(rendererTop+chartAreaTop)-2;
            this._adjustTooltipHeight(maxTooltipHeight);
        }
        this.$tooltip[0].style.top=Math.floor(top)+'px';

        this._fixTooltipLeftPosition(this.$tooltip[0],tooltipModel.x);
    },
    /**
     *FilteroutsomedataPointsbecausetheywouldleadtobadgraphics.
     *Thefilteringisdonewithrespecttothegraphviewmode.
     *Notethatthemethoddoesnotalterthis.state.dataPoints,sincewe
     *wanttobeabletochangeofmodewithoutfetchingdataagain:
     *wesimplypresentthesamedatainadifferentway.
     *
     *@private
     *@returns{Object[]}
     */
    _filterDataPoints:function(){
        vardataPoints=[];
        if(_.contains(['bar','pie'],this.state.mode)){
            dataPoints=this.state.dataPoints.filter(function(dataPt){
                returndataPt.count>0;
            });
        }elseif(this.state.mode==='line'){
            varcounts=0;
            this.state.dataPoints.forEach(function(dataPt){
                if(dataPt.labels[0]!==_t("Undefined")){
                    dataPoints.push(dataPt);
                }
                counts+=dataPt.count;
            });
            //datapointswithzerocountmighthavebeencreatedonpurpose
            //weonlyremovethemiftherearenodatapointwithpositivecount
            if(counts===0){
                dataPoints=[];
            }
        }
        returndataPoints;
    },
    /**
     *Setsbestleftpositionofatooltipapproachingtheproposalx
     *
     *@private
     *@param{DOMElement}tooltip
     *@param{number}x,leftoffsetproposed
     */
    _fixTooltipLeftPosition:function(tooltip,x){
        letleft;
        consttooltipWidth=tooltip.clientWidth;
        constminLeftAllowed=Math.floor(this.chart.chartArea.left+2);
        constmaxLeftAllowed=Math.floor(this.chart.chartArea.right-tooltipWidth-2);
        x=Math.floor(x);
        if(x<=maxLeftAllowed){
            if(x>=minLeftAllowed){
                left=x;
            }else{
                left=minLeftAllowed;
            }
        }else{
            left=maxLeftAllowed;
        }
        tooltip.style.left=left+'px';
    },
    /**
     *UsedtoformatcorrectlythevaluesintooltipsandyAxes
     *
     *@private
     *@param{number}value
     *@returns{string}ThevalueformattedusingfieldUtils.format.float
     */
    _formatValue:function(value){
        varmeasureField=this.fields[this.state.measure];
        varformatter=fieldUtils.format.float;
        varformatedValue=formatter(value,measureField,FORMAT_OPTIONS);
        returnformatedValue;
    },
    /**
     *Usedanytimeweneedanewcolorinourcharts.
     *
     *@private
     *@param{number}index
     *@returns{string}acolorinHEXformat
     */
    _getColor:function(index){
        returnCOLORS[index%COLOR_NB];
    },
    /**
     *Determinestheinitialsectionofthelabelsarray
     *overadatasethastobecompleted.Thesectiononlydepends
     *onthedatasetsorigins.
     *
     *@private
     *@param{number}originIndex
     *@param{number}defaultLength
     *@returns{number}
     */
    _getDatasetDataLength:function(originIndex,defaultLength){
        if(_.contains(['bar','line'],this.state.mode)&&this.state.comparisonFieldIndex===0){
            returnthis.dateClasses.dateSets[originIndex].length;
        }
        returndefaultLength;
    },
    /**
     *Determinestowhichdatasetbelongthedatapoint
     *
     *@private
     *@param{Object}dataPt
     *@returns{string}
     */
    _getDatasetLabel:function(dataPt){
        if(_.contains(['bar','line'],this.state.mode)){
            //([origin]+secondtolastgroupBys)ormeasure
            vardatasetLabel=dataPt.labels.slice(1).join("/");
            if(this.state.origins.length>1){
                datasetLabel=this.state.origins[dataPt.originIndex]+
                    (datasetLabel?('/'+datasetLabel):'');
            }
            datasetLabel=datasetLabel||this.fields[this.state.measure].string;
            returndatasetLabel;
        }
        returnthis.state.origins[dataPt.originIndex];
    },
    /**
     *Returnsanobjectusedtostylechartelementsindependentlyfromthedatasets.
     *
     *@private
     *@returns{Object}
     */
    _getElementOptions:function(){
        varelementOptions={};
        if(this.state.mode==='bar'){
            elementOptions.rectangle={borderWidth:1};
        }elseif(this.state.mode==='line'){
            elementOptions.line={
                tension:0,
                fill:false,
            };
        }
        returnelementOptions;
    },
    /**
     *ReturnsaDateClassesinstanceusedtomanageequivalenceofdates.
     *
     *@private
     *@param{Object[]}dataPoints
     *@returns{DateClasses}
     */
    _getDateClasses:function(dataPoints){
        varself=this;
        vardateSets=this.state.origins.map(function(){
            return[];
        });
        dataPoints.forEach(function(dataPt){
            dateSets[dataPt.originIndex].push(dataPt.labels[self.state.comparisonFieldIndex]);
        });
        dateSets=dateSets.map(function(dateSet){
            return_.uniq(dateSet);
        });
        returnnewDateClasses(dateSets);
    },
    /**
     *Determinesoverwhichlabelisthedatapoint
     *
     *@private
     *@param{Object}dataPt
     *@returns{Array}
     */
    _getLabel:function(dataPt){
        vari=this.state.comparisonFieldIndex;
        if(_.contains(['bar','line'],this.state.mode)){
            if(i===0){
                return[this.dateClasses.dateClass(dataPt.originIndex,dataPt.labels[i])];
            }else{
                returndataPt.labels.slice(0,1);
            }
        }elseif(i===0){
            returnArray.prototype.concat.apply([],[
                        this.dateClasses.dateClass(dataPt.originIndex,dataPt.labels[i]),
                        dataPt.labels.slice(i+1)
                    ]);
        }else{
            returndataPt.labels;
        }
    },
    /**
     *Returnstheoptionsusedtogeneratethechartlegend.
     *
     *@private
     *@param{Number}datasetsCount
     *@returns{Object}
     */
    _getLegendOptions:function(datasetsCount){
        varlegendOptions={
            display:datasetsCount<=MAX_LEGEND_LENGTH,
            //position:this.state.mode==='pie'?'right':'top',
            position:'top',
            onHover:this._onlegendTooltipHover.bind(this),
            onLeave:this._onLegendTootipLeave.bind(this),
        };
        varself=this;
        if(_.contains(['bar','line'],this.state.mode)){
            varreferenceColor;
            if(this.state.mode==='bar'){
                referenceColor='backgroundColor';
            }else{
                referenceColor='borderColor';
            }
            legendOptions.labels={
                generateLabels:function(chart){
                    vardata=chart.data;
                    returndata.datasets.map(function(dataset,i){
                        return{
                            text:self._shortenLabel(dataset.label),
                            fullText:dataset.label,
                            fillStyle:dataset[referenceColor],
                            hidden:!chart.isDatasetVisible(i),
                            lineCap:dataset.borderCapStyle,
                            lineDash:dataset.borderDash,
                            lineDashOffset:dataset.borderDashOffset,
                            lineJoin:dataset.borderJoinStyle,
                            lineWidth:dataset.borderWidth,
                            strokeStyle:dataset[referenceColor],
                            pointStyle:dataset.pointStyle,
                            datasetIndex:i,
                        };
                    });
                },
            };
        }else{
            legendOptions.labels={
                generateLabels:function(chart){
                    vardata=chart.data;
                    varmetaData=data.datasets.map(function(dataset,index){
                        returnchart.getDatasetMeta(index).data;
                    });
                    returndata.labels.map(function(label,i){
                        varhidden=metaData.reduce(
                            function(hidden,data){
                                if(data[i]){
                                    hidden=hidden||data[i].hidden;
                                }
                                returnhidden;
                            },
                            false
                        );
                        varfullText=self._relabelling(label);
                        vartext=self._shortenLabel(fullText);
                        return{
                            text:text,
                            fullText:fullText,
                            fillStyle:label.isNoData?'#d3d3d3':self._getColor(i),
                            hidden:hidden,
                            index:i,
                        };
                    });
                },
            };
        }
        returnlegendOptions;
    },
    /**
     *Returnstheoptionsusedtogeneratethechartaxes.
     *
     *@private
     *@returns{Object}
     */
    _getScaleOptions:function(){
        varself=this;
        if(_.contains(['bar','line'],this.state.mode)){
            return{
                xAxes:[{
                    type:'category',
                    scaleLabel:{
                        display:this.state.processedGroupBy.length&&!this.isEmbedded,
                        labelString:this.state.processedGroupBy.length?
                            this.fields[this.state.processedGroupBy[0].split(':')[0]].string:'',
                    },
                    ticks:{
                        //don'tusebind: callbackiscalledwith'index'assecondparameter
                        //withvaluelabels.indexOf(label)!
                        callback:function(label){
                            varfullText=self._relabelling(label);
                            returnself._shortenLabel(fullText);
                        },
                    },
                }],
                yAxes:[{
                    type:'linear',
                    scaleLabel:{
                        display:!this.isEmbedded,
                        labelString:this.fields[this.state.measure].string,
                    },
                    ticks:{
                        callback:this._formatValue.bind(this),
                        suggestedMax:0,
                        suggestedMin:0,
                    }
                }],
            };
        }
        return{};
    },
    /**
     *ExtractstheimportantinformationfromatooltipItemgeneratedbyCharts.js
     *(atooltipitemcorrespondstoaline(differentfrommeasurename)ofatooltip)
     *
     *@private
     *@param{Object}item
     *@param{Object}data
     *@returns{Object}
     */
    _getTooltipItemContent:function(item,data){
        vardataset=data.datasets[item.datasetIndex];
        varlabel=data.labels[item.index];
        varvalue;
        varboxColor;
        if(this.state.mode==='bar'){
            label=this._relabelling(label,dataset.originIndex);
            if(this.state.processedGroupBy.length>1||this.state.origins.length>1){
                label=label+"/"+dataset.label;
            }
            value=this._formatValue(item.yLabel);
            boxColor=dataset.backgroundColor;
        }elseif(this.state.mode==='line'){
            label=this._relabelling(label,dataset.originIndex);
            if(this.state.processedGroupBy.length>1||this.state.origins.length>1){
                label=label+"/"+dataset.label;
            }
            value=this._formatValue(item.yLabel);
            boxColor=dataset.borderColor;
        }else{
            if(label.isNoData){
                value=this._formatValue(0);
            }else{
                value=this._formatValue(dataset.data[item.index]);
            }
            label=this._relabelling(label,dataset.originIndex);
            if(this.state.origins.length>1){
                label=dataset.label+"/"+label;
            }
            boxColor=dataset.backgroundColor[item.index];
        }
        return{
            label:label,
            value:value,
            boxColor:boxColor,
        };
    },
    /**
     *ThisfunctionextractstheinformationfromthedatapointsintooltipModel.dataPoints
     *(correspondingtodatapointsoveragivenlabeldeterminedbythemouseposition)
     *thatwillbedisplayedinacustomtooltip.
     *
     *@private
     *@param{Object}tooltipModelseechartjsdocumentation
     *@return{Object[]}
     */
    _getTooltipItems:function(tooltipModel){
        varself=this;
        vardata=this.chart.config.data;

        varorderedItems=tooltipModel.dataPoints.sort(function(dPt1,dPt2){
            returndPt2.yLabel-dPt1.yLabel;
        });
        returnorderedItems.reduce(
            function(acc,item){
                acc.push(self._getTooltipItemContent(item,data));
                returnacc;
            },
            []
        );
    },
    /**
     *Returnstheoptionsusedtogeneratecharttooltips.
     *
     *@private
     *@returns{Object}
     */
    _getTooltipOptions:function(){
        vartooltipOptions={
            //disableChart.jstooltips
            enabled:false,
            custom:this._customTooltip.bind(this),
        };
        if(this.state.mode==='line'){
            tooltipOptions.mode='index';
            tooltipOptions.intersect=false;
        }
        returntooltipOptions;
    },
    /**
     *Returnstrueiffthecurrentgraphcanbeclickedontoredirecttothe
     *listofrecords.
     *
     *@private
     *@returns{boolean}
     */
    _isRedirectionEnabled:function(){
        return!this.disableLinking&&
               (this.state.mode==='bar'||this.state.mode==='pie');
    },
    /**
     *Returnthefirstindexofthearraylistwherelabelcanbefound
     *or-1.
     *
     *@private
     *@param{Array[]}list
     *@param{Array}label
     *@returns{number}
     */
    _indexOf:function(list,label){
        varindex=-1;
        for(varj=0;j<list.length;j++){
            varotherLabel=list[j];
            if(label.length===otherLabel.length){
                varequal=true;
                for(vari=0;i<label.length;i++){
                    if(label[i]!==otherLabel[i]){
                        equal=false;
                    }
                }
                if(equal){
                    index=j;
                    break;
                }
            }
        }
        returnindex;
    },
    /**
     *SeparatedataPointscomingfromtheread_group(s)intodifferentdatasets.
     *Thisfunctionreturnstheparametersdataandlabelsusedtoproducethecharts.
     *
     *@private
     *@param{Object[]}dataPoints
     *@param{function}getLabel,
     *@param{function}getDatasetLabel,determinestowhichdatasetbelongagivendatapoint
     *@param{function}[getDatasetDataLength],determinestheinitialsectionofthelabelsarray
     *                   overwhichthedatasetshavetobecompleted.Thesesectionsonlydepend
     *                   onthedatasetsorigins.Defaultistheconstantfunction_=>labels.length.
     *@returns{Object}theparameterdatausedtoinstantiatethechart.
     */
    _prepareData:function(dataPoints){
        varself=this;

        varlabelMap={};
        varlabels=dataPoints.reduce(
            function(acc,dataPt){
                varlabel=self._getLabel(dataPt);
                varlabelKey=dataPt.resId+':'+JSON.stringify(label);
                varindex=labelMap[labelKey];
                if(index===undefined){
                    labelMap[labelKey]=dataPt.labelIndex=acc.length;
                    acc.push(label);
                }
                else{
                    dataPt.labelIndex=index;
                }
                returnacc;
            },
            []
        );

        varnewDataset=function(datasetLabel,originIndex){
            vardata=newArray(self._getDatasetDataLength(originIndex,labels.length)).fill(0);
            constdomain=newArray(self._getDatasetDataLength(originIndex,labels.length)).fill([]);
            return{
                label:datasetLabel,
                data:data,
                domain:domain,
                originIndex:originIndex,
            };
        };

        //dataPoints-->datasets
        vardatasets=_.values(dataPoints.reduce(
            function(acc,dataPt){
                vardatasetLabel=self._getDatasetLabel(dataPt);
                if(!(datasetLabelinacc)){
                    acc[datasetLabel]=newDataset(datasetLabel,dataPt.originIndex);
                }
                varlabelIndex=dataPt.labelIndex;
                acc[datasetLabel].data[labelIndex]=dataPt.value;
                acc[datasetLabel].domain[labelIndex]=dataPt.domain;
                returnacc;
            },
            {}
        ));

        //sortbyorigin
        datasets=datasets.sort(function(dataset1,dataset2){
            returndataset1.originIndex-dataset2.originIndex;
        });

        return{
            datasets:datasets,
            labels:labels,
        };
    },
    /**
     *Prepareoptionsforthechartaccordingtothecurrentmode(=charttype).
     *Thisfunctionreturnstheparameteroptionsusedtoinstantiatethechart
     *
     *@private
     *@param{number}datasetsCount
     *@returns{Object}thechartoptionsusedforthecurrentmode
     */
    _prepareOptions:function(datasetsCount){
        constoptions={
            maintainAspectRatio:false,
            scales:this._getScaleOptions(),
            legend:this._getLegendOptions(datasetsCount),
            tooltips:this._getTooltipOptions(),
            elements:this._getElementOptions(),
        };
        if(this._isRedirectionEnabled()){
            options.onClick=this._onGraphClicked.bind(this);
        }
        returnoptions;
    },
    /**
     *Determinehowtorelabelalabelaccordingtoagivenorigin.
     *TheideaisthatthegetLabelfunctionisingeneralnotinvertiblebut
     *itiswhenrestrictedtothesetofdataPointscomingfromasameorigin.

     *@private
     *@param{Array}label
     *@param{Array}originIndex
     *@returns{string}
     */
    _relabelling:function(label,originIndex){
        if(label.isNoData||label.isFakeData){
            returnlabel[0];
        }
        vari=this.state.comparisonFieldIndex;
        if(_.contains(['bar','line'],this.state.mode)&&i===0){
            //herelabelisanarrayoflength1andcontainsanumber
            returnthis.dateClasses.representative(label,originIndex)||'';
        }elseif(this.state.mode==='pie'&&i===0){
            //herelabelisanarrayoflengthatleastonecontainingstringornumbers
            varlabelCopy=label.slice(0);
            if(originIndex!==undefined){
                labelCopy.splice(i,1,this.dateClasses.representative(label[i],originIndex));
            }else{
                labelCopy.splice(i,1,this.dateClasses.dateClassMembers(label[i]));
            }
            returnlabelCopy.join('/');
        }
        //herelabelisanarraycontainingstringsornumbers.
        returnlabel.join('/')||_t('Total');
    },
    /**
     *Renderthechartordisplayamessageerrorincasedataisnotgoodenough.
     *
     *NotethatThismethodissynchronous,buttheactualrenderingisdone
     *asynchronously. ThereasonforthatisthatChart.jsneedstobeinthe
     *DOMtocorrectlyrenderitself. So,wetrickFlectrabyreturning
     *immediately,thenwerenderthechartwhenthewidgetisintheDOM.
     *
     *@override
     */
    async_renderView(){
        if(this.chart){
            this.chart.destroy();
        }
        this.$el.empty();
        if(!_.contains(CHART_TYPES,this.state.mode)){
            this.trigger_up('warning',{
                title:_t('Invalidmodeforchart'),
                message:_t('Cannotrenderchartwithmode:')+this.state.mode
            });
        }
        vardataPoints=this._filterDataPoints();
        dataPoints=this._sortDataPoints(dataPoints);
        if(this.isInDOM){
            this._renderTitle();

            //detectifsomepathologiesarestillpresentafterthefiltering
            if(this.state.mode==='pie'){
                constsomeNegative=dataPoints.some(dataPt=>dataPt.value<0);
                constsomePositive=dataPoints.some(dataPt=>dataPt.value>0);
                if(someNegative&&somePositive){
                    constcontext={
                        title:_t("Invaliddata"),
                        description:[
                            _t("Piechartcannotmixpositiveandnegativenumbers."),
                            _t("Trytochangeyourdomaintoonlydisplaypositiveresults")
                        ].join("")
                    };
                    this._renderNoContentHelper(context);
                    return;
                }
            }

            if(this.state.isSample&&!this.isEmbedded){
                this._renderNoContentHelper();
            }

            //onlyrenderthegraphifthewidgetisalreadyintheDOM(this
            //happenstypicallyafteranupdate),otherwise,itwillbe
            //renderedwhenthewidgetwillbeattachedtotheDOM(see
            //'on_attach_callback')
            var$canvasContainer=$('<div/>',{class:'o_graph_canvas_container'});
            var$canvas=$('<canvas/>').attr('id',this.chartId);
            $canvasContainer.append($canvas);
            this.$el.append($canvasContainer);

            vari=this.state.comparisonFieldIndex;
            if(i===0){
                this.dateClasses=this._getDateClasses(dataPoints);
            }
            if(this.state.mode==='bar'){
                this._renderBarChart(dataPoints);
            }elseif(this.state.mode==='line'){
                this._renderLineChart(dataPoints);
            }elseif(this.state.mode==='pie'){
                this._renderPieChart(dataPoints);
            }
        }
    },
    /**
     *createbarchart.
     *
     *@private
     *@param{Object[]}dataPoints
     */
    _renderBarChart:function(dataPoints){
        varself=this;

        //preparedata
        vardata=this._prepareData(dataPoints);

        data.datasets.forEach(function(dataset,index){
            //usedwhenstacked
            dataset.stack=self.state.stacked?self.state.origins[dataset.originIndex]:undefined;
            //setdatasetcolor
            varcolor=self._getColor(index);
            dataset.backgroundColor=color;
        });

        //prepareoptions
        varoptions=this._prepareOptions(data.datasets.length);

        //createchart
        varctx=document.getElementById(this.chartId);
        this.chart=newChart(ctx,{
            type:'bar',
            data:data,
            options:options,
        });
    },
    /**
     *createlinechart.
     *
     *@private
     *@param{Object[]}dataPoints
     */
    _renderLineChart:function(dataPoints){
        varself=this;

        //preparedata
        vardata=this._prepareData(dataPoints);
        data.datasets.forEach(function(dataset,index){
            if(self.state.processedGroupBy.length<=1&&self.state.origins.length>1){
                if(dataset.originIndex===0){
                    dataset.fill='origin';
                    dataset.backgroundColor=hexToRGBA(COLORS[0],0.4);
                    dataset.borderColor=hexToRGBA(COLORS[0],1);
                }elseif(dataset.originIndex===1){
                    dataset.borderColor=hexToRGBA(COLORS[1],1);
                }else{
                    dataset.borderColor=self._getColor(index);
                }
            }else{
                dataset.borderColor=self._getColor(index);
            }
            if(data.labels.length===1){
                //shiftoftherealvaluetoright.Thisisdonetocenterthepointsinthechart
                //Seedata.labelsbelowinChartparameters
                dataset.data.unshift(undefined);
            }
            dataset.pointBackgroundColor=dataset.borderColor;
            dataset.pointBorderColor='rgba(0,0,0,0.2)';
        });
        if(data.datasets.length===1&&data.datasets[0].originIndex===0){
            constdataset=data.datasets[0];
            dataset.fill='origin';
            dataset.backgroundColor=hexToRGBA(COLORS[0],0.4);
        }

        //centerthepointsinthechart(withoutthatcodetheyareputontheleftandthegraphseemsempty)
        data.labels=data.labels.length>1?
            data.labels:
            Array.prototype.concat.apply([],[[FAKE_DATA],data.labels,[FAKE_DATA]]);

        //prepareoptions
        varoptions=this._prepareOptions(data.datasets.length);

        //createchart
        varctx=document.getElementById(this.chartId);
        this.chart=newChart(ctx,{
            type:'line',
            data:data,
            options:options,
        });
    },
    /**
     *createpiechart
     *
     *@private
     *@param{Object[]}dataPoints
     */
    _renderPieChart:function(dataPoints){
        varself=this;
        //preparedata
        vardata={};
        varcolors=[];
        constallZero=dataPoints.every(dataPt=>dataPt.value===0);
        if(allZero){
            //addfakedatatodisplayapiechartwithagreyzoneassociated
            //witheveryorigin
            data.labels=[NO_DATA];
            data.datasets=this.state.origins.map(function(origin){
                return{
                    label:origin,
                    data:[1],
                    backgroundColor:['#d3d3d3'],
                };
            });
        }else{
            data=this._prepareData(dataPoints);
            //givesamecolortosamegroupsfromdifferentorigins
            colors=data.labels.map(function(label,index){
                returnself._getColor(index);
            });
            data.datasets.forEach(function(dataset){
                dataset.backgroundColor=colors;
                dataset.borderColor='rgba(255,255,255,0.6)';
            });
            //makesurethereisazoneassociatedwitheveryorigin
            varrepresentedOriginIndexes=data.datasets.map(function(dataset){
                returndataset.originIndex;
            });
            varaddNoDataToLegend=false;
            varfakeData=(newArray(data.labels.length)).concat([1]);
            this.state.origins.forEach(function(origin,originIndex){
                if(!_.contains(representedOriginIndexes,originIndex)){
                    data.datasets.splice(originIndex,0,{
                        label:origin,
                        data:fakeData,
                        backgroundColor:colors.concat(['#d3d3d3']),
                    });
                    addNoDataToLegend=true;
                }
            });
            if(addNoDataToLegend){
                data.labels.push(NO_DATA);
            }
        }

        //prepareoptions
        varoptions=this._prepareOptions(data.datasets.length);

        //createchart
        varctx=document.getElementById(this.chartId);
        this.chart=newChart(ctx,{
            type:'pie',
            data:data,
            options:options,
        });
    },
    /**
     *Addthegraphtitle(ifany)abovethecanvas
     *
     *@private
     */
    _renderTitle:function(){
        if(this.title){
            this.$el.prepend($('<label/>',{
                text:this.title,
            }));
        }
    },
    /**
     *Usedtoavoidtoolonglegenditems
     *
     *@private
     *@param{string}label
     *@returns{string}shortenedversionoftheinputlabel
     */
    _shortenLabel:function(label){
        //stringreturnedcouldbe'wrong'ifagroupbyvaluecontaina'/'!
        vargroups=label.split("/");
        varshortLabel=groups.slice(0,3).join("/");
        if(shortLabel.length>30){
            shortLabel=shortLabel.slice(0,30)+'...';
        }elseif(groups.length>3){
            shortLabel=shortLabel+'/...';
        }
        returnshortLabel;
    },
    /**
     *Sortdatapointsaccordingtothecurrentorder(ASCorDESC).
     *
     *Note:thisshouldbemovedtothemodelatsomepoint.
     *
     *@private
     *@param{Object[]}dataPoints
     *@returns{Object[]}sorteddataPointsiforderbysetonstate
     */
    _sortDataPoints(dataPoints){
        if(!Object.keys(this.state.timeRanges).length&&this.state.orderBy&&
            ['bar','line'].includes(this.state.mode)&&this.state.groupBy.length){
            //groupdatabytheirx-axisvalue,andthensortdatapoints
            //basedonthesumofvaluesbygroupinascending/descendingorder
            constgroupByFieldName=this.state.groupBy[0].split(':')[0];
            constgroupedByMany2One=this.fields[groupByFieldName].type==='many2one';
            constgroupedDataPoints={};
            dataPoints.forEach(function(dataPoint){
                constkey=groupedByMany2One?dataPoint.resId:dataPoint.labels[0];
                groupedDataPoints[key]=groupedDataPoints[key]||[];
                groupedDataPoints[key].push(dataPoint);
            });
            dataPoints=_.sortBy(groupedDataPoints,function(group){
                returngroup.reduce((sum,dataPoint)=>sum+dataPoint.value,0);
            });
            dataPoints=dataPoints.flat();
            if(this.state.orderBy==='desc'){
                dataPoints=dataPoints.reverse('value');
            }
        }
        returndataPoints;
    },

    //--------------------------------------------------------------------------
    //Handlers
    //--------------------------------------------------------------------------

    /**
     *@private
     *@param{MouseEvent}ev
     */
    _onGraphClicked:function(ev){
        constactiveElement=this.chart.getElementAtEvent(ev);
        if(activeElement.length===0){
            return;
        }
        constdomain=this.chart.data.datasets[activeElement[0]._datasetIndex].domain;
        if(!domain){
            return;//emptydataset
        }
        this.trigger_up('open_view',{
            domain:domain[activeElement[0]._index],
        });
    },
    /**
     *Ifthetextofalegenditemhasbeenshortenedandtheusermouseover
     *thatitem(actuallytheeventtypeismousemove),atooltipwiththeitem
     *fulltextisdisplayed.
     *
     *@private
     *@param{MouseEvent}e
     *@param{Object}legendItem
     */
    _onlegendTooltipHover:function(e,legendItem){
        //setcursorpointeronhoveroflegend
        e.target.style.cursor='pointer';
        //ThestringlegendItem.textisaninitialsegmentoflegendItem.fullText.
        //Ifthetwocoincide,noneedtogenerateatooltip.
        //Ifatooltipforthelegendalreadyexists,itisalreadygoodanddon'tneed
        //toberecreated.
        if(legendItem.text===legendItem.fullText||this.$legendTooltip){
            return;
        }

        constchartAreaLeft=this.chart.chartArea.left;
        constchartAreaRight=this.chart.chartArea.right;
        constrendererTop=this.$el[0].getBoundingClientRect().top;

        this.$legendTooltip=$('<div>',{
            class:"o_tooltip_legend",
            text:legendItem.fullText,
            css:{
                maxWidth:Math.floor((chartAreaRight-chartAreaLeft)/1.68)+'px',
                top:(e.clientY-rendererTop)+'px',
            }
        });
        const$container=this.$el.find('.o_graph_canvas_container');
        $container.append(this.$legendTooltip);

        this._fixTooltipLeftPosition(this.$legendTooltip[0],e.clientX);
    },
    /**
     *Ifthere'salegendtooltipandtheusermouseoutofthecorresponding
     *legenditem,thetooltipisremoved.
     *
     *@private
     */
    _onLegendTootipLeave:function(e){
        //removecursorstylepointeronmouseleavefromlegend
        e.target.style.cursor="";
        if(this.$legendTooltip){
            this.$legendTooltip.remove();
            this.$legendTooltip=null;
        }
    },
});
});

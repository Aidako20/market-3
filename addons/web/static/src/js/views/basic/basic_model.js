flectra.define('web.BasicModel',function(require){
"usestrict";

/**
 *BasicModel
 *
 *Thisclasscontainsallthelogicnecessarytocommunicatebetweenthe
 *pythonmodelsandthewebclient.Morespecifically,itsjobistogivea
 *simpleunifiedAPItotherestofthewebclient(inparticular,theviewsand
 *thefieldwidgets)toqueryandmodifyactualrecordsindb.
 *
 *Fromahighlevelperspective,BasicModelisessentiallyahashmapwith
 *integerkeysandsomedataandmetadataobjectasvalue. Eachobjectinthis
 *hashmaprepresentsapieceofdata,andcanbereloadedandmodifiedbyusing
 *itsidaskeyinmanymethods.
 *
 *Hereisadescriptionofwhatthosedatapointlooklike:
 *  vardataPoint={
 *     _cache:{Object|undefined}
 *     _changes:{Object|null},
 *     aggregateValues:{Object},
 *     context:{Object},
 *     count:{integer},
 *     data:{Object|Object[]},
 *     domain:{*[]},
 *     fields:{Object},
 *     fieldsInfo:{Object},
 *     getContext:{function},
 *     getDomain:{function},
 *     getFieldNames:{function},
 *     groupedBy:{string[]},
 *     id:{integer},
 *     isOpen:{boolean},
 *     loadMoreOffset:{integer},
 *     limit:{integer},
 *     model:{string},
 *     offset:{integer},
 *     openGroupByDefault:{boolean},
 *     orderedBy:{Object[]},
 *     orderedResIDs:{integer[]},
 *     parentID:{string},
 *     rawContext:{Object},
 *     relationField:{string},
 *     res_id:{integer|null},
 *     res_ids:{integer[]},
 *     specialData:{Object},
 *     _specialDataCache:{Object},
 *     static:{boolean},
 *     type:{string}'record'|'list'
 *     value:?,
 * };
 *
 *Notes:
 *-id:istotallyunrelatedtores_id. idisawebclientlocalconcept
 *-res_id:ifsettoanumberoravirtualid(avirtualidisacharacter
 *    stringcomposedofanintegerandhasadashandotherinformation),it
 *    isanactualidforarecordintheserverdatabase.Ifsetto
 *   'virtual_'+number,itisarecordnotyetsaved(so,increatemode).
 *-res_ids:ifset,itrepresentthecontextinwhichthedatapointisactually
 *    used. Forexample,agivenrecordinaformview(openedfromalistview)
 *    mighthaveares_id=2andres_ids=[1,2,3]
 *-offset:thisismainlyusedforpagination. Usefulwhenweneedtoload
 *    anotherpage,thenwecansimplychangetheoffsetandreload.
 *-countisbasicallythenumberofrecordsbeingmanipulated. Wecan'tuse
 *    res_ids,becausewemighthaveaverylargenumberofrecords,ora
 *    domain,andtheres_idswouldbethecurrentpage,notthefullset.
 *-modelistheactualnameofa(flectra)model,suchas'res.partner'
 *-fieldscontainsthedescriptionofallthefieldsfromthemodel. Notethat
 *    thesepropertiesmighthavebeenmodifiedbyaview(forexample,with
 *    required=true. So,thefieldskindofdependsofthecontextofthe
 *    datapoint.
 *-field_names:listofsomerelevantfieldnames(string). Usually,it
 *    denotesthefieldspresentintheview. Onlythosefieldsshouldbe
 *    loaded.
 *-_cacheand_changesareprivate,theyshouldnotleakoutofthebasicModel
 *  andbeusedbyanyoneelse.
 *
 *Commands:
 *  commandsarethebasecommandsforx2many(0->6),butwitha
 *  slighttwist:each[0,_,values]commandisaugmentedwithavirtualid:
 *  itmeansthatwhenthecommandisaddedinbasicmodel,itgeneratesanid
 *  lookinglikethis:'virtual_'+number,andusesthisidtoidentifythe
 *  element,soitcanbeeditedlater.
 */

varAbstractModel=require('web.AbstractModel');
varconcurrency=require('web.concurrency');
varContext=require('web.Context');
varcore=require('web.core');
varDomain=require('web.Domain');
constpyUtils=require('web.py_utils');
varsession=require('web.session');
varutils=require('web.utils');
varviewUtils=require('web.viewUtils');
varlocalStorage=require('web.local_storage');

var_t=core._t;

//fieldtypesthatcanbeaggregatedingroupedviews
constAGGREGATABLE_TYPES=['float','integer','monetary'];

varx2ManyCommands={
    //(0,virtualID,{values})
    CREATE:0,
    create:function(virtualID,values){
        deletevalues.id;
        return[x2ManyCommands.CREATE,virtualID||false,values];
    },
    //(1,id,{values})
    UPDATE:1,
    update:function(id,values){
        deletevalues.id;
        return[x2ManyCommands.UPDATE,id,values];
    },
    //(2,id[,_])
    DELETE:2,
    delete:function(id){
        return[x2ManyCommands.DELETE,id,false];
    },
    //(3,id[,_])removesrelation,butnotlinkedrecorditself
    FORGET:3,
    forget:function(id){
        return[x2ManyCommands.FORGET,id,false];
    },
    //(4,id[,_])
    LINK_TO:4,
    link_to:function(id){
        return[x2ManyCommands.LINK_TO,id,false];
    },
    //(5[,_[,_]])
    DELETE_ALL:5,
    delete_all:function(){
        return[5,false,false];
    },
    //(6,_,ids)replacesalllinkedrecordswithprovidedids
    REPLACE_WITH:6,
    replace_with:function(ids){
        return[6,false,ids];
    }
};

varBasicModel=AbstractModel.extend({
    //constants
    OPEN_GROUP_LIMIT:10,//afterthislimit,groupsareautomaticallyfolded

    //listofmodelsforwhichtheDataManager'scacheshouldbeclearedon
    //create,updateanddeleteoperations
    noCacheModels:[
        'ir.actions.act_window',
        'ir.filters',
        'ir.ui.view',
    ],

    /**
     *@override
     */
    init:function(){
        //thismutexisnecessarytomakesuresomeoperationsaredone
        //sequentially,forexample,anonchangeneedstobecompletedbeforea
        //saveisperformed.
        this.mutex=newconcurrency.Mutex();

        //thisarrayisusedtoaccumulateRPCrequestsdoneinthesamecall
        //stack,sothattheycanbebatchedintheminimumnumberofRPCs
        this.batchedRPCsRequests=[];

        this.localData=Object.create(null);
        //usedtogeneratedataPointids.Notethatthecounterissetto0for
        //eachinstance,andthisismandatoryforthesampledatafeatureto
        //work:weneedboththemainmodelandthesamplemodeltogeneratethe
        //samedatapointidsfortheircommondata(groups,whentherearereal
        //groupsindatabase),sothatwecaneasilydothemappingbetween
        //realandsampledata.
        this.__id=0;
        this._super.apply(this,arguments);
    },

    //--------------------------------------------------------------------------
    //Public
    //--------------------------------------------------------------------------

    /**
     *Addadefaultrecordtoalistobject.Thismethodactuallymakesanew
     *recordwiththe_makeDefaultRecordmethod,thenaddsittothelistobject.
     *Thedefaultrecordisaddedinthedatadirectly.Thisismeanttobeused
     *bylistorkanbancontrollers(i.e.notforx2manysinformviews,asin
     *thiscase,westorechangesascommands).
     *
     *@param{string}listIDavalidhandleforalistobject
     *@param{Object}[options]
     *@param{string}[options.position=top]ifthenewrecordshouldbeadded
     *  ontoporonbottomofthelist
     *@returns{Promise<string>}resolvestotheidofthenewcreatedrecord
     */
    addDefaultRecord:function(listID,options){
        varself=this;
        varlist=this.localData[listID];
        varcontext=_.extend({},this._getDefaultContext(list),this._getContext(list));

        varposition=(options&&options.position)||'top';
        varparams={
            context:context,
            fields:list.fields,
            fieldsInfo:list.fieldsInfo,
            parentID:list.id,
            position:position,
            viewType:list.viewType,
        };
        returnthis._makeDefaultRecord(list.model,params).then(function(id){
            list.count++;
            if(position==='top'){
                list.data.unshift(id);
            }else{
                list.data.push(id);
            }
            varrecord=self.localData[id];
            list._cache[record.res_id]=id;
            returnid;
        });
    },
    /**
     *CompletesthefieldsandfieldsInfoofadataPointwiththegivenones.
     *Itisusefulforthecaseswherearecordelementissharedbetween
     *variousviews,suchasaone2manywithatreeandaformview.
     *
     *@param{string}datapointIDavalidelementID(oftype'list'or'record')
     *@param{Object}viewInfo
     *@param{Object}viewInfo.fields
     *@param{Object}viewInfo.fieldInfo
     *@param{string}viewInfo.viewType
     *@returns{Promise}resolvedwhenthefieldInfohavebeensetonthegiven
     *  datapointandallitschildren,andallrawChangeshavebeenapplied
     */
    addFieldsInfo:asyncfunction(dataPointID,viewInfo){
        vardataPoint=this.localData[dataPointID];
        dataPoint.fields=_.extend({},dataPoint.fields,viewInfo.fields);
        //completethegivenfieldInfowiththefieldsofthemainview,so
        //thatthosefieldwillbereloadedifareloadistriggeredbythe
        //secondaryview
        dataPoint.fieldsInfo=dataPoint.fieldsInfo||{};
        constmainFieldInfo=dataPoint.fieldsInfo[dataPoint[viewInfo.viewType]];
        dataPoint.fieldsInfo[viewInfo.viewType]=_.defaults({},viewInfo.fieldInfo,mainFieldInfo);

        //Somefieldsinthenewfieldsinfomightnotbeinthepreviousone,
        //sowemighthavestoredchangesforthem(e.g.comingfromonchange
        //RPCs),thatwehaven'tbeenabletoprocessearlier(becausethose
        //fieldswereunknownatthattime).Sowenowtrytoprocessthem.
        if(dataPoint.type==='record'){
            awaitthis.applyRawChanges(dataPointID,viewInfo.viewType);
        }
            constproms=[];
            constfieldInfo=dataPoint.fieldsInfo[viewInfo.viewType];
            //recursivelyapplythenewfieldinfoonsubdatapoints
            if(dataPoint.type==='list'){
                //case'list':onalldatapointsinthelist
                Object.values(dataPoint._cache).forEach(subDataPointID=>{
                    proms.push(this.addFieldsInfo(subDataPointID,{
                        fields:dataPoint.fields,
                        fieldInfo:dataPoint.fieldsInfo[viewInfo.viewType],
                        viewType:viewInfo.viewType,
                    }));
                });
            }else{
                //case'record':ondatapointsofallx2manyfields
                constvalues=_.extend({},dataPoint.data,dataPoint._changes);
                Object.keys(fieldInfo).forEach(fieldName=>{
                    constfieldType=dataPoint.fields[fieldName].type;
                    if(fieldType==='one2many'||fieldType==='many2many'){
                        constmode=fieldInfo[fieldName].mode;
                        constviews=fieldInfo[fieldName].views;
                        constx2mDataPointID=values[fieldName];
                        if(views[mode]&&x2mDataPointID){
                            proms.push(this.addFieldsInfo(x2mDataPointID,{
                                fields:views[mode].fields,
                                fieldInfo:views[mode].fieldsInfo[mode],
                                viewType:mode,
                            }));
                        }
                    }
                });
            }
            returnPromise.all(proms);
    },
    /**
     *OnchangeRPCsmayreturnvaluesforfieldsthatarenotinthecurrent
     *view.Thosefieldsmightevenbeunknownwhentheonchangereturns(e.g.
     *inx2manys,weonlyknowthefieldsthatareusedintheinnerview,but
     *notthoseusedinthepotentialformviewopenedinadialogwhenasub-
     *recordisclicked).Whenthishappens,wecan'tinfertheirtype,sothe
     *givenvaluecan'tbeprocessed.Itisinsteadstoredinthe'_rawChanges'
     *keyoftherecord,withoutanyprocessing.Lateron,ifthisrecordis
     *displayedinanotherview(e.g.theuserclickedonitinthex2many
     *list,andtherecordopensinadialog),thosechangesthatwereleft
     *behindmustbeapplied.Thisfunctionapplieschangesstoredin
     *'_rawChanges'foragivenviewType.
     *
     *@param{string}recordIDlocalresourceidofarecord
     *@param{string}viewTypethecurrentviewType
     *@returns{Promise<string>}resolvestotheidoftherecord
     */
    applyRawChanges:function(recordID,viewType){
        varrecord=this.localData[recordID];
        returnthis._applyOnChange(record._rawChanges,record,{viewType}).then(function(){
            returnrecord.id;
        });
    },
    /**
     *Returnstrueifarecordcanbeabandoned.
     *
     *Casefornotabandoningtherecord:
     *
     *1.flaggedas'noabandon'(i.e.duringa`default_get`,includingany
     *   `onchange`froma`default_get`)
     *2.registeredinalistonaddition
     *
     *   2.1.registeredasnon-newaddition
     *   2.2.registeredasnewadditononupdate
     *
     *3.recordisnotnew
     *
     *Otherwise,therecordcanbeabandoned.
     *
     *Thisisusefulwhendiscardingchangesonthisrecord,asitmeansthat
     *wemustkeeptherecordevenifsomefieldsareinvalids(e.g.required
     *fieldisempty).
     *
     *@param{string}ididforalocalresource
     *@returns{boolean}
     */
    canBeAbandoned:function(id){
        //1.nodropifflagged
        if(this.localData[id]._noAbandon){
            returnfalse;
        }
        //2.nodropinaliston"ADDinsomecases
        varrecord=this.localData[id];
        varparent=this.localData[record.parentID];
        if(parent){
            varentry=_.findWhere(parent._savePoint,{operation:'ADD',id:id});
            if(entry){
                //2.1.nodroponnon-newadditioninlist
                if(!entry.isNew){
                    returnfalse;
                }
                //2.2.nodroponnewadditionon"UPDATE"
                varlastEntry=_.last(parent._savePoint);
                if(lastEntry.operation==='UPDATE'&&lastEntry.id===id){
                    returnfalse;
                }
            }
        }
        //3.dropnewrecords
        returnthis.isNew(id);
    },
    /**
     *Deletealistofrecords,then,iftherecordshaveaparent,reloadit.
     *
     *@todoweshouldremovethedeletedrecordsfromthelocalData
     *@todowhycan'tweinfermodelName?Becauseofgroupeddatapoint
     *      -->res_iddoesn'tcorrespondtothemodelandwedon'thavethe
     *          informationabouttherelatedmodel
     *
     *@param{string[]}recordIdslistoflocalresourcesids.Theyshouldall
     *  beoftype'record',beofthesamemodelandhavethesameparent.
     *@param{string}modelNamemodenameusedtounlinktherecords
     *@returns{Promise}
     */
    deleteRecords:function(recordIds,modelName){
        varself=this;
        varrecords=_.map(recordIds,function(id){returnself.localData[id];});
        varcontext=_.extend(records[0].getContext(),session.user_context);
        returnthis._rpc({
                model:modelName,
                method:'unlink',
                args:[_.pluck(records,'res_id')],
                context:context,
            })
            .then(function(){
                _.each(records,function(record){
                    varparent=record.parentID&&self.localData[record.parentID];
                    if(parent&&parent.type==='list'){
                        parent.data=_.without(parent.data,record.id);
                        deleteself.localData[record.id];
                        //Checkifweareonlastpageandallrecordsaredeletedfromcurrent
                        //pagei.e.ifthereisnostate.data.lengththengotopreviouspage
                        if(!parent.data.length&&parent.offset>0){
                            parent.offset=Math.max(parent.offset-parent.limit,0);
                        }
                    }else{
                        record.res_ids.splice(record.offset,1);
                        record.offset=Math.min(record.offset,record.res_ids.length-1);
                        record.res_id=record.res_ids[record.offset];
                        record.count--;
                    }
                });
                //optionallycleartheDataManager'scache
                self._invalidateCache(records[0]);
            });
    },
    /**
     *Discardallchangesinalocalresource. Basically,itremoves
     *everythingthatwasstoredina_changeskey.
     *
     *@param{string}idlocalresourceid
     *@param{Object}[options]
     *@param{boolean}[options.rollback=false]iftrue,thechangeswill
     *  beresettothelast_savePoint,otherwise,theyareresettonull
     */
    discardChanges:function(id,options){
        options=options||{};
        varelement=this.localData[id];
        varisNew=this.isNew(id);
        varrollback='rollback'inoptions?options.rollback:isNew;
        varinitialOffset=element.offset;
        element._domains={};
        this._visitChildren(element,function(elem){
            if(rollback&&elem._savePoint){
                if(elem._savePointinstanceofArray){
                    elem._changes=elem._savePoint.slice(0);
                }else{
                    elem._changes=_.extend({},elem._savePoint);
                }
                elem._isDirty=!isNew;
            }else{
                elem._changes=null;
                elem._isDirty=false;
            }
            elem.offset=0;
            if(elem.tempLimitIncrement){
                elem.limit-=elem.tempLimitIncrement;
                deleteelem.tempLimitIncrement;
            }
        });
        element.offset=initialOffset;
    },
    /**
     *Duplicatearecord(bycallingthe'copy'route)
     *
     *@param{string}recordIDidforalocalresource
     *@returns{Promise<string>}resolvestotheidofduplicaterecord
     */
    duplicateRecord:function(recordID){
        varself=this;
        varrecord=this.localData[recordID];
        varcontext=this._getContext(record);
        returnthis._rpc({
                model:record.model,
                method:'copy',
                args:[record.data.id],
                context:context,
            })
            .then(function(res_id){
                varindex=record.res_ids.indexOf(record.res_id);
                record.res_ids.splice(index+1,0,res_id);
                returnself.load({
                    fieldsInfo:record.fieldsInfo,
                    fields:record.fields,
                    modelName:record.model,
                    res_id:res_id,
                    res_ids:record.res_ids.slice(0),
                    viewType:record.viewType,
                    context:context,
                });
            });
    },
    /**
     *Forlistresources,thisfreezesthecurrentrecordsorder.
     *
     *@param{string}listIDavalidelementIDoftypelist
     */
    freezeOrder:function(listID){
        varlist=this.localData[listID];
        if(list.type==='record'){
            return;
        }
        list=this._applyX2ManyOperations(list);
        this._sortList(list);
        this.localData[listID].orderedResIDs=list.res_ids;
    },
    /**
     *The__getmethodfirstargumentisthehandlereturnedbytheloadmethod.
     *Itisoptional(thehandlecanbeundefined). Insomecase,itmakes
     *sensetousethehandleasakey,forexampletheBasicModelholdsthe
     *dataforvariousrecords,eachwithitslocalID.
     *
     *synchronousmethod,itassumesthattheresourcehasalreadybeenloaded.
     *
     *@param{string}idlocalidfortheresource
     *@param{any}options
     *@param{boolean}[options.env=false]iftrue,willonly returnres_id
     *  (ifrecord)orres_ids(iflist)
     *@param{boolean}[options.raw=false]iftrue,willnotfollowrelations
     *@returns{Object}
     */
    __get:function(id,options){
        varself=this;
        options=options||{};

        if(!(idinthis.localData)){
            returnnull;
        }

        varelement=this.localData[id];

        if(options.env){
            varenv={
                ids:element.res_ids?element.res_ids.slice(0):[],
            };
            if(element.type==='record'){
                env.currentId=this.isNew(element.id)?undefined:element.res_id;
            }
            returnenv;
        }

        if(element.type==='record'){
            vardata=_.extend({},element.data,element._changes);
            varrelDataPoint;
            for(varfieldNameindata){
                varfield=element.fields[fieldName];
                if(data[fieldName]===null){
                    data[fieldName]=false;
                }
                if(!field){
                    continue;
                }

                //getrelationaldatapoint
                if(field.type==='many2one'){
                    if(options.raw){
                        relDataPoint=this.localData[data[fieldName]];
                        data[fieldName]=relDataPoint?relDataPoint.res_id:false;
                    }else{
                        data[fieldName]=this.__get(data[fieldName])||false;
                    }
                }elseif(field.type==='reference'){
                    if(options.raw){
                        relDataPoint=this.localData[data[fieldName]];
                        data[fieldName]=relDataPoint?
                            relDataPoint.model+','+relDataPoint.res_id:
                            false;
                    }else{
                        data[fieldName]=this.__get(data[fieldName])||false;
                    }
                }elseif(field.type==='one2many'||field.type==='many2many'){
                    if(options.raw){
                        if(typeofdata[fieldName]==='string'){
                            relDataPoint=this.localData[data[fieldName]];
                            relDataPoint=this._applyX2ManyOperations(relDataPoint);
                            data[fieldName]=relDataPoint.res_ids;
                        }else{
                            //nodatapointhasbeencreatedyet(becausetheloadingofrelational
                            //datahasbeenbatched,andhasn'tstartedyet),sothevalueisstill
                            //thelistofidsintherelation
                            data[fieldName]=data[fieldName]||[];
                        }
                    }else{
                        data[fieldName]=this.__get(data[fieldName])||[];
                    }
                }
            }
            varrecord={
                context:_.extend({},element.context),
                count:element.count,
                data:data,
                domain:element.domain.slice(0),
                evalModifiers:element.evalModifiers,
                fields:element.fields,
                fieldsInfo:element.fieldsInfo,
                getContext:element.getContext,
                getDomain:element.getDomain,
                getFieldNames:element.getFieldNames,
                id:element.id,
                isDirty:element.isDirty,
                limit:element.limit,
                model:element.model,
                offset:element.offset,
                ref:element.ref,
                res_ids:element.res_ids.slice(0),
                specialData:_.extend({},element.specialData),
                type:'record',
                viewType:element.viewType,
            };

            if(!this.isNew(element.id)){
                record.res_id=element.res_id;
            }
            varevalContext;
            Object.defineProperty(record,'evalContext',{
                get:function(){
                    evalContext=evalContext||self._getEvalContext(element);
                    returnevalContext;
                },
            });
            returnrecord;
        }

        //applypotentialchanges(onlyforx2manylists)
        element=this._applyX2ManyOperations(element);
        this._sortList(element);

        if(!element.orderedResIDs&&element._changes){
            _.each(element._changes,function(change){
                if(change.operation==='ADD'&&change.isNew){
                    element.data=_.without(element.data,change.id);
                    if(change.position==='top'){
                        element.data.unshift(change.id);
                    }else{
                        element.data.push(change.id);
                    }
                }
            });
        }

        varlist={
            aggregateValues:_.extend({},element.aggregateValues),
            context:_.extend({},element.context),
            count:element.count,
            data:_.map(element.data,function(elemID){
                returnself.__get(elemID,options);
            }),
            domain:element.domain.slice(0),
            fields:element.fields,
            getContext:element.getContext,
            getDomain:element.getDomain,
            getFieldNames:element.getFieldNames,
            groupedBy:element.groupedBy,
            groupsCount:element.groupsCount,
            groupsLimit:element.groupsLimit,
            groupsOffset:element.groupsOffset,
            id:element.id,
            isDirty:element.isDirty,
            isOpen:element.isOpen,
            isSample:this.isSampleModel,
            limit:element.limit,
            model:element.model,
            offset:element.offset,
            orderedBy:element.orderedBy,
            res_id:element.res_id,
            res_ids:element.res_ids.slice(0),
            type:'list',
            value:element.value,
            viewType:element.viewType,
        };
        if(element.fieldsInfo){
            list.fieldsInfo=element.fieldsInfo;
        }
        returnlist;
    },
    /**
     *Generatedefaultvaluesforagivenrecord.Thosevaluesarestoredin
     *the'_changes'keyoftherecord.Forrelationalfields,sub-dataPoints
     *arecreated,andmissingrelationaldataisfetched.
     *Typically,thisfunctioniscalledwhenanewrecordiscreated.Itmay
     *alsobecalledwhenaone2manysubrecordisopeninaformview(dialog),
     *togeneratethedefaultvaluesforthefieldsdisplayedintheo2mform
     *view,butnotinthelistorkanban(mainlytocorrectlycreate
     *sub-dataPointsforrelationalfields).
     *
     *@param{string}recordIDlocalidforarecord
     *@param{Object}[options]
     *@param{string}[options.viewType]currentviewType.Ifnotset,wewill
     *  assumemainviewTypefromtherecord
     *@param{Array}[options.fieldNames]listoffieldnamesforwhicha
     *  defaultvaluemustbegenerated(usedtocompletethevaluesdict)
     *@returns{Promise}
     */
    generateDefaultValues(recordID,options={}){
        constrecord=this.localData[recordID];
        constviewType=options.viewType||record.viewType;
        constfieldNames=options.fieldNames||Object.keys(record.fieldsInfo[viewType]);
        constnumericFields=['float','integer','monetary'];
        constproms=[];
        record._changes=record._changes||{};
        fieldNames.forEach(fieldName=>{
            record.data[fieldName]=null;
            if(!(fieldNameinrecord._changes)){
                constfield=record.fields[fieldName];
                if(numericFields.includes(field.type)){
                    record._changes[fieldName]=0;
                }elseif(field.type==='one2many'||field.type==='many2many'){
                    proms.push(this._processX2ManyCommands(record,fieldName,[],options));
                }else{
                    record._changes[fieldName]=null;
                }
            }
        });
        returnPromise.all(proms);
    },
    /**
     *Returnsthecurrentdisplay_namefortherecord.
     *
     *@param{string}idthelocalIDforavalidrecordelement
     *@returns{string}
     */
    getName:function(id){
        varrecord=this.localData[id];
        varreturnValue='';
        if(record._changes&&'display_name'inrecord._changes){
            returnValue=record._changes.display_name;
        }
        elseif('display_name'inrecord.data){
            returnValue=record.data.display_name;
        }
        returnreturnValue||_t("New");
    },
    /**
     *Returnstrueifarecordisdirty.Arecordisconsidereddirtyifithas
     *someunsavedchanges,markedbythe_isDirtypropertyontherecordor
     *oneofitssubrecords.
     *
     *@param{string}id-thelocalresourceid
     *@returns{boolean}
     */
    isDirty:function(id){
        varisDirty=false;
        this._visitChildren(this.localData[id],function(r){
            if(r._isDirty){
                isDirty=true;
            }
        });
        returnisDirty;
    },
    /**
     *Returnstrueiffthedatapointisoftypelistandeither:
     *  -isnotgrouped,andcontainsnorecords
     *  -isgrouped,andcontainscolumns,butallcolumnsareempty
     *Inthesecases,wewillgeneratesampledatatodisplay,insteadofan
     *emptystate.
     *
     *@override
     */
    _isEmpty(dataPointID){
        constdataPoint=this.localData[dataPointID];
        if(dataPoint.type==='list'){
            consthasRecords=dataPoint.count===0;
            if(dataPoint.groupedBy.length){
                returndataPoint.data.length>0&&hasRecords;
            }else{
                returnhasRecords;
            }
        }
        returnfalse;
    },
    /**
     *CheckifalocalDataisnew,meaningifitisintheprocessofbeing
     *createdandnoactualrecordexistsindb.Note:ifthelocalDataisnot
     *ofthe"record"type,thenitisalwaysconsideredasnotnew.
     *
     *Note:Avirtualidisacharacterstringcomposedofanintegerandhas
     *adashandotherinformation.
     *E.g:incalendar,therecursiveeventhavevirtualidlinkedtoarealid
     *virtualeventid"23-20170418020000"islinkedtotheeventid23
     *
     *@param{string}ididforalocalresource
     *@returns{boolean}
     */
    isNew:function(id){
        vardata=this.localData[id];
        if(data.type!=="record"){
            returnfalse;
        }
        varres_id=data.res_id;
        if(typeofres_id==='number'){
            returnfalse;
        }elseif(typeofres_id==='string'&&/^[0-9]+-/.test(res_id)){
            returnfalse;
        }
        returntrue;
    },
    /**
     *Mainentrypoint,thegoalofthismethodistofetchandprocessall
     *data(followingrelationsifnecessary)foragivenrecord/list.
     *
     *@tododocumentallparams
     *
     *@private
     *@param{any}params
     *@param{Object}[params.fieldsInfo={}]containsthefieldInfoofeachfield
     *@param{Object}params.fieldscontainsthedescriptionofeachfield
     *@param{string}[params.type]'record'or'list'
     *@param{string}[params.recordID]anIDforanexistingresource.
     *@returns{Promise<string>}resolvestoalocalid,orhandle
     */
    __load:asyncfunction(params){
        awaitthis._super(...arguments);
        params.type=params.type||(params.res_id!==undefined?'record':'list');
        //FIXME:thefollowingseemsonlytobeusedbythebasic_model_tests
        //soitshouldprobablyberemovedandthetestsshouldbeadapted
        params.viewType=params.viewType||'default';
        if(!params.fieldsInfo){
            varfieldsInfo={};
            for(varfieldNameinparams.fieldNames){
                fieldsInfo[params.fieldNames[fieldName]]={};
            }
            params.fieldsInfo={};
            params.fieldsInfo[params.viewType]=fieldsInfo;
        }

        if(params.type==='record'&&params.res_id===undefined){
            params.allowWarning=true;
            returnthis._makeDefaultRecord(params.modelName,params);
        }
        vardataPoint=this._makeDataPoint(params);
        returnthis._load(dataPoint).then(function(){
            returndataPoint.id;
        });
    },
    /**
     *Returnsthelistofres_idsforagivenlistoflocalids.
     *
     *@param{string[]}localIds
     *@returns{integer[]}
     */
    localIdsToResIds:function(localIds){
        returnlocalIds.map(localId=>this.localData[localId].res_id);
    },
    /**
     *Thishelpermethodisdesignedtohelpdeveloppersthatwanttousea
     *fieldwidgetoutsideofaview. Inthatcase,wewantawaytocreate
     *datawithoutactuallyperformingafetch.
     *
     *@param{string}modelnameofthemodel
     *@param{Object[]}fieldsadescriptionoffieldproperties
     *@param{Object}[fieldInfo]variousfieldinfothatwewanttoset
     *@returns{Promise<string>}thelocalidforthecreatedresource
     */
    makeRecord:function(model,fields,fieldInfo){
        varself=this;
        vardefs=[];
        varrecord_fields={};
        _.each(fields,function(field){
            record_fields[field.name]=_.pick(field,'type','relation','domain','selection');
        });
        fieldInfo=fieldInfo||{};
        varfieldsInfo={};
        fieldsInfo.default={};
        _.each(fields,function(field){
            fieldsInfo.default[field.name]=fieldInfo[field.name]||{};
        });
        varrecord=this._makeDataPoint({
            modelName:model,
            fields:record_fields,
            fieldsInfo:fieldsInfo,
            viewType:'default',
        });
        _.each(fields,function(field){
            vardataPoint;
            record.data[field.name]=null;
            if(field.type==='many2one'){
                if(field.value){
                    varid=_.isArray(field.value)?field.value[0]:field.value;
                    vardisplay_name=_.isArray(field.value)?field.value[1]:undefined;
                    dataPoint=self._makeDataPoint({
                        modelName:field.relation,
                        data:{
                            id:id,
                            display_name:display_name,
                        },
                        parentID:record.id,
                    });
                    record.data[field.name]=dataPoint.id;
                    if(display_name===undefined){
                        defs.push(self._fetchNameGet(dataPoint));
                    }
                }
            }elseif(field.type==='reference'&&field.value){
                constref=field.value.split(',');
                dataPoint=self._makeDataPoint({
                    context:record.context,
                    data:{id:parseInt(ref[1],10)},
                    modelName:ref[0],
                    parentID:record.id,
                });
                defs.push(self._fetchNameGet(dataPoint));
                record.data[field.name]=dataPoint.id;
            }elseif(field.type==='one2many'||field.type==='many2many'){
                varrelatedFieldsInfo={};
                relatedFieldsInfo.default={};
                _.each(field.fields,function(field){
                    relatedFieldsInfo.default[field.name]={};
                });
                vardpParams={
                    fieldsInfo:relatedFieldsInfo,
                    modelName:field.relation,
                    parentID:record.id,
                    static:true,
                    type:'list',
                    viewType:'default',
                };
                varneedLoad=false;
                //Asvalue,youcouldeitherpass:
                // -alistofidsrelatedtotherecord
                // -alistofobject
                //Weonlyneedtoloadthedatapointinthefirstcase.
                if(field.value&&field.value.length){
                    if(_.isObject(field.value[0])){
                        dpParams.res_ids=_.pluck(field.value,'id');
                        dataPoint=self._makeDataPoint(dpParams);
                        _.each(field.value,function(data){
                            varrecordDP=self._makeDataPoint({
                                data:data,
                                modelName:field.relation,
                                parentID:dataPoint.id,
                                type:'record',
                            });
                            dataPoint.data.push(recordDP.id);
                            dataPoint._cache[recordDP.res_id]=recordDP.id;
                        });
                    }else{
                        dpParams.res_ids=field.value;
                        dataPoint=self._makeDataPoint(dpParams);
                        needLoad=true;
                    }
                }else{
                    dpParams.res_ids=[];
                    dataPoint=self._makeDataPoint(dpParams);
                }

                if(needLoad){
                    defs.push(self._load(dataPoint));
                }
                record.data[field.name]=dataPoint.id;
            }elseif(field.value){
                record.data[field.name]=field.value;
            }
        });
        returnPromise.all(defs).then(function(){
            returnrecord.id;
        });
    },
    /**
     *Thisisanextremelyimportantmethod. Allchangesinanyfieldgo
     *throughthismethod. Itwillthenapplytheminthelocalstate,check
     *ifonchangesneedstobeapplied,actuallydothemifnecessary,then
     *resolveswiththelistofchangedfields.
     *
     *@param{string}record_id
     *@param{Object}changesamapfield=>newvalue
     *@param{Object}[options]willbetransferredtotheapplyChangemethod
     *  @see_applyChange
     *@returns{Promise<string[]>}listofchangedfields
     */
    notifyChanges:function(record_id,changes,options){
        returnthis.mutex.exec(this._applyChange.bind(this,record_id,changes,options));
    },
    /**
     *Reloadalldataforagivenresource.Atanytimethereisatmostone
     *reloadoperationactive.
     *
     *@private
     *@param{string}idlocalidforaresource
     *@param{Object}[options]
     *@param{boolean}[options.keepChanges=false]iftrue,doesn'tdiscardthe
     *  changesontherecordbeforereloadingit
     *@returns{Promise<string>}resolvestotheidoftheresource
     */
    __reload:asyncfunction(id,options){
        awaitthis._super(...arguments);
        returnthis.mutex.exec(this._reload.bind(this,id,options));
    },
    /**
     *Insomecase,wemayneedtoremoveanelementfromalist,withoutgoing
     *throughthenotifyChangesmachinery. Themotivationforthisiswhenthe
     *userclickon'Addaline'inafieldone2manywitharequiredfield,
     *thenclickssomewhereelse. Thenewlineneedtobediscarded,butwe
     *don'twanttotriggerarealnotifyChanges(noneedforthat,andalso,
     *wedon'twanttorerendertheUI).
     *
     *@param{string}elementIDsomevalidelementid.Itisnecessarythatthe
     *  correspondingelementhasaparent.
     */
    removeLine:function(elementID){
        varrecord=this.localData[elementID];
        varparent=this.localData[record.parentID];
        if(parent.static){
            //x2Manycase:thenewrecordhasbeenstoredin_changes,asa
            //commandsoweremovethecommand(s)relatedtothatrecord
            parent._changes=_.filter(parent._changes,function(change){
                if(change.id===elementID&&
                    change.operation==='ADD'&&//Fornow,onlyanADDcommandincreaseslimits
                    parent.tempLimitIncrement){
                        //Therecordwillbedeletedfromthe_changes.
                        //Sowewon'tbepassingintothelogicof_applyX2ManyOperationsanymore
                        //implyingthatwehavetocancelouttheeffectsofanADDcommandhere
                        parent.tempLimitIncrement--;
                        parent.limit--;
                }
                returnchange.id!==elementID;
            });
        }else{
            //mainlistviewcase:thenewrecordisindata
            parent.data=_.without(parent.data,elementID);
            parent.count--;
        }
    },
    /**
     *Resequencesrecords.
     *
     *@param{string}modelNametheresIDsmodel
     *@param{Array<integer>}resIDsthenewsequenceofids
     *@param{string}parentIDthelocalIDoftheparent
     *@param{object}[options]
     *@param{integer}[options.offset]
     *@param{string}[options.field]thefieldnameusedassequence
     *@returns{Promise<string>}resolvestothelocalidoftheparent
     */
    resequence:function(modelName,resIDs,parentID,options){
        options=options||{};
        if((resIDs.length<=1)){
            returnPromise.resolve(parentID);//thereisnothingtosort
        }
        varself=this;
        vardata=this.localData[parentID];
        varparams={
            model:modelName,
            ids:resIDs,
            context:data.getContext(),
        };
        if(options.offset){
            params.offset=options.offset;
        }
        if(options.field){
            params.field=options.field;
        }
        returnthis._rpc({
                route:'/web/dataset/resequence',
                params:params,
            })
            .then(function(wasResequenced){
                if(!wasResequenced){
                    //thefieldonwhichtheresequencewastriggereddoesnot
                    //exist,sonoresequencehappenedserver-side
                    returnPromise.resolve();
                }
                varfield=params.field?params.field:'sequence';

                returnself._rpc({
                    model:modelName,
                    method:'read',
                    args:[resIDs,[field]],
                    context:data.getContext(),
                }).then(function(records){
                    if(data.data.length){
                        vardataType=self.localData[data.data[0]].type;
                        if(dataType==='record'){
                            _.each(data.data,function(dataPoint){
                                varrecordData=self.localData[dataPoint].data;
                                varinRecords=_.findWhere(records,{id:recordData.id});
                                if(inRecords){
                                    recordData[field]=inRecords[field];
                                }
                            });
                            data.data=_.sortBy(data.data,function(d){
                                returnself.localData[d].data[field];
                            });
                        }
                        if(dataType==='list'){
                            data.data=_.sortBy(data.data,function(d){
                                return_.indexOf(resIDs,self.localData[d].res_id)
                            });
                        }
                    }
                    data.res_ids=[];
                    _.each(data.data,function(d){
                        vardataPoint=self.localData[d];
                        if(dataPoint.type==='record'){
                            data.res_ids.push(dataPoint.res_id);
                        }else{
                            data.res_ids=data.res_ids.concat(dataPoint.res_ids);
                        }
                    });
                    self._updateParentResIDs(data);
                    returnparentID;
                })
            });
    },
    /**
     *Savealocalresource,ifneeded. Thisisacomplicatedoperation,
     *-itneedstocheckallchanges,
     *-generatecommandsforx2manyfields,
     *-callthe/createor/writemethodaccordingtotherecordstatus
     *-Afterthat,ithastoreloadalldata,incasesomethingchanged,serverside.
     *
     *@param{string}recordIDlocalresource
     *@param{Object}[options]
     *@param{boolean}[options.reload=true]iftrue,datawillbereloaded
     *@param{boolean}[options.savePoint=false]iftrue,therecordwillonly
     *  be'locally'saved:itschangeswrittenina_savePointkeythatcan
     *  berestoredlaterbycalldiscardChangeswithoptionrollbacktotrue
     *@param{string}[options.viewType]currentviewType.Ifnotset,wewill
     *  assumemainviewTypefromtherecord
     *@returns{Promise}
     *  Resolvedwiththelistoffieldnames(whosevaluehasbeenmodified)
     */
    save:function(recordID,options){
        varself=this;
        returnthis.mutex.exec(function(){
            options=options||{};
            varrecord=self.localData[recordID];
            if(options.savePoint){
                self._visitChildren(record,function(rec){
                    varnewValue=rec._changes||rec.data;
                    if(newValueinstanceofArray){
                        rec._savePoint=newValue.slice(0);
                    }else{
                        rec._savePoint=_.extend({},newValue);
                    }
                });

                //savetheviewTypeofedition,sothatthecorrectreadonlymodifiers
                //canbeevaluatedwhentherecordwillbesaved
                for(letfieldNamein(record._changes||{})){
                    record._editionViewType[fieldName]=options.viewType;
                }
            }
            varshouldReload='reload'inoptions?options.reload:true;
            varmethod=self.isNew(recordID)?'create':'write';
            if(record._changes){
                //idneverchanges,andshouldnotbewritten
                deleterecord._changes.id;
            }
            varchanges=self._generateChanges(record,{viewType:options.viewType,changesOnly:method!=='create'});

            //idfieldshouldneverbewritten/changed
            deletechanges.id;

            if(method==='create'){
                varfieldNames=record.getFieldNames();
                _.each(fieldNames,function(name){
                    if(changes[name]===null){
                        deletechanges[name];
                    }
                });
            }

            varprom=newPromise(function(resolve,reject){
                varchangedFields=Object.keys(changes);

                if(options.savePoint){
                    resolve(changedFields);
                    return;
                }

                //inthecaseofawrite,onlyperformtheRPCiftherearechangestosave
                if(method==='create'||changedFields.length){
                    varargs=method==='write'?[[record.data.id],changes]:[changes];
                    self._rpc({
                            model:record.model,
                            method:method,
                            args:args,
                            context:record.getContext(),
                        }).then(function(id){
                            if(method==='create'){
                                record.res_id=id; //createreturnsanid,writereturnsaboolean
                                record.data.id=id;
                                record.offset=record.res_ids.length;
                                record.res_ids.push(id);
                                record.count++;
                            }

                            var_changes=record._changes;

                            //Erasechangesastheyhavebeenapplied
                            record._changes={};

                            //OptionallycleartheDataManager'scache
                            self._invalidateCache(record);

                            self.unfreezeOrder(record.id);

                            //Updatethedatadirectlyorreloadthem
                            if(shouldReload){
                                self._fetchRecord(record).then(function(){
                                    resolve(changedFields);
                                });
                            }else{
                                _.extend(record.data,_changes);
                                resolve(changedFields);
                            }
                        }).guardedCatch(reject);
                }else{
                    resolve(changedFields);
                }
            });
            prom.then(function(){
                record._isDirty=false;
            });
            returnprom;
        });
    },
    /**
     *Manuallysetsaresourceasdirty.Thisisusedtonotifythatafield
     *hasbeenmodified,butwithaninvalidvalue.Inthatcase,thevalueis
     *notsenttothebasicmodel,buttherecordshouldstillbeflaggedas
     *dirtysothatitisn'tdiscardedwithoutanywarning.
     *
     *@param{string}idaresourceid
     */
    setDirty:function(id){
        this.localData[id]._isDirty=true;
    },
    /**
     *Forlistresources,thischangestheorderedBykey.
     *
     *@param{string}list_ididforthelistresource
     *@param{string}fieldNamevalidfieldname
     *@returns{Promise}
     */
    setSort:function(list_id,fieldName){
        varlist=this.localData[list_id];
        if(list.type==='record'){
            return;
        }elseif(list._changes){
            _.each(list._changes,function(change){
                deletechange.isNew;
            });
        }
        if(list.orderedBy.length===0){
            list.orderedBy.push({name:fieldName,asc:true});
        }elseif(list.orderedBy[0].name===fieldName){
            if(!list.orderedResIDs){
                list.orderedBy[0].asc=!list.orderedBy[0].asc;
            }
        }else{
            varorderedBy=_.reject(list.orderedBy,function(o){
                returno.name===fieldName;
            });
            list.orderedBy=[{name:fieldName,asc:true}].concat(orderedBy);
        }

        list.orderedResIDs=null;
        if(list.static){
            //sortingmightrequiretofetchthefieldforrecordswherethe
            //sortfieldisstillunknown(i.e.onotherpagesforexample)
            returnthis._fetchUngroupedList(list);
        }
        returnPromise.resolve();
    },
    /**
     *Foragivenresourceoftype'record',gettheactivefield,ifany.
     *
     *SincetheORMcansupportboth`active`and`x_active`fieldsfor
     *thearchivingmechanism,checkifanysuchfieldexistsandprioritize
     *them.The`active`fieldshouldalwaystakepriorityoveritscustom
     *version.
     *
     *@param{Object}recordlocalresource
     *@returns{String|undefined}thefieldnametouseforarchivingpurposes
     *  ('active','x_active')orundefinedifnosuchfieldispresent
     */
    getActiveField:function(record){
        constfields=Object.keys(record.fields);
        consthas_active=fields.includes('active');
        if(has_active){
            return'active';
        }
        consthas_x_active=fields.includes('x_active');
        returnhas_x_active?'x_active':undefined
    },
    /**
     *Toggletheactivevalueofgivenrecords(toarchive/unarchivethem)
     *
     *@param{Array}recordIDslocalidsoftherecordsto(un)archive
     *@param{boolean}valuefalsetoarchive,truetounarchive(valueoftheactivefield)
     *@param{string}parentIDidoftheparentresourcetoreload
     *@returns{Promise<string>}resolvestotheparentid
     */
    toggleActive:function(recordIDs,parentID){
        varself=this;
        varparent=this.localData[parentID];
        varresIDs=_.map(recordIDs,function(recordID){
            returnself.localData[recordID].res_id;
        });
        returnthis._rpc({
                model:parent.model,
                method:'toggle_active',
                args:[resIDs],
            })
            .then(function(action){
                //optionallycleartheDataManager'scache
                self._invalidateCache(parent);
                if(!_.isEmpty(action)){
                    returnself.do_action(action,{
                        on_close:function(){
                            returnself.trigger_up('reload');
                        }
                    });
                }else{
                    returnself.reload(parentID);
                }
            });
    },
    /**
     *Archivethegivenrecords
     *
     *@param{integer[]}resIDsidsoftherecordstoarchive
     *@param{string}parentIDidoftheparentresourcetoreload
     *@returns{Promise<string>}resolvestotheparentid
     */
    actionArchive:function(resIDs,parentID){
        varself=this;
        varparent=this.localData[parentID];
        returnthis._rpc({
                model:parent.model,
                method:'action_archive',
                args:[resIDs],
            })
            .then(function(action){
                //optionallycleartheDataManager'scache
                self._invalidateCache(parent);
                if(!_.isEmpty(action)){
                    returnnewPromise(function(resolve,reject){
                        self.do_action(action,{
                            on_close:function(result){
                                returnself.trigger_up('reload',{
                                    onSuccess:resolve,
                                });
                            }
                        });
                    });
                }else{
                    returnself.reload(parentID);
                }
            }).then(function(datapoint){
                //iftherearenorecordstodisplayandwearenotonfirstpage(wecheckit
                //bycheckingoffsetisgreaterthanlimiti.e.wearenotonfirstpage)
                //reasonforaddinglogicafterreloadtomakesurethereisnorecordsafteroperation
                if(parent&&parent.type==='list'&&!parent.data.length&&parent.offset>0){
                    parent.offset=Math.max(parent.offset-parent.limit,0);
                    returnself.reload(parentID);
                }
                returndatapoint;
            });
    },
    /**
     *Unarchivethegivenrecords
     *
     *@param{integer[]}resIDsidsoftherecordstounarchive
     *@param{string}parentIDidoftheparentresourcetoreload
     *@returns{Promise<string>}resolvestotheparentid
     */
    actionUnarchive:function(resIDs,parentID){
        varself=this;
        varparent=this.localData[parentID];
        returnthis._rpc({
                model:parent.model,
                method:'action_unarchive',
                args:[resIDs],
            })
            .then(function(action){
                //optionallycleartheDataManager'scache
                self._invalidateCache(parent);
                if(!_.isEmpty(action)){
                    returnnewPromise(function(resolve,reject){
                        self.do_action(action,{
                            on_close:function(){
                                returnself.trigger_up('reload',{
                                    onSuccess:resolve,
                                });
                            }
                        });
                    });
                }else{
                    returnself.reload(parentID);
                }
            }).then(function(datapoint){
                //iftherearenorecordstodisplayandwearenotonfirstpage(wecheckit
                //bycheckingoffsetisgreaterthanlimiti.e.wearenotonfirstpage)
                //reasonforaddinglogicafterreloadtomakesurethereisnorecordsafteroperation
                if(parent&&parent.type==='list'&&!parent.data.length&&parent.offset>0){
                    parent.offset=Math.max(parent.offset-parent.limit,0);
                    returnself.reload(parentID);
                }
                returndatapoint;
            });
    },
    /**
     *Toggle(open/close)agroupinagroupedlist,thenfetchesrelevant
     *data
     *
     *@param{string}groupId
     *@returns{Promise<string>}resolvestothegroupid
     */
    toggleGroup:function(groupId){
        varself=this;
        vargroup=this.localData[groupId];
        if(group.isOpen){
            group.isOpen=false;
            group.data=[];
            group.res_ids=[];
            group.offset=0;
            this._updateParentResIDs(group);
            returnPromise.resolve(groupId);
        }
        if(!group.isOpen){
            group.isOpen=true;
            vardef;
            if(group.count>0){
                def=this._load(group).then(function(){
                    self._updateParentResIDs(group);
                });
            }
            returnPromise.resolve(def).then(function(){
                returngroupId;
            });
        }
    },
    /**
     *Foralistdatapoint,unfreezesthecurrentrecordsorderandsortsit.
     *Forarecorddatapoint,unfreezesthex2manylistdatapoints.
     *
     *@param{string}elementIDavalidelementID
     */
    unfreezeOrder:function(elementID){
        varlist=this.localData[elementID];
        if(list.type==='record'){
            vardata=_.extend({},list.data,list._changes);
            for(varfieldNameindata){
                varfield=list.fields[fieldName];
                if(!field||!data[fieldName]){
                    continue;
                }
                if(field.type==='one2many'||field.type==='many2many'){
                    varrecordlist=this.localData[data[fieldName]];
                    recordlist.orderedResIDs=null;
                    for(varindexinrecordlist.data){
                        this.unfreezeOrder(recordlist.data[index]);
                    }
                }
            }
            return;
        }
        list.orderedResIDs=null;
        this._sortList(list);
    },

    //--------------------------------------------------------------------------
    //Private
    //--------------------------------------------------------------------------

    /**
     *Addadefaultrecordtoalistobject.Thismethodactuallymakesanew
     *recordwiththe_makeDefaultRecordmethod,thenaddsittothelistobject
     *asa'ADD'commandinits_changes.Thisismeanttobeusedx2manylists,
     *notbylistorkanbancontrollers.
     *
     *@private
     *@param{Object}listavalidlistobject
     *@param{Object}[options]
     *@param{string}[options.position=top]ifthenewrecordshouldbeadded
     *  ontoporonbottomofthelist
     *@param{Array}[options.[context]]additionalcontexttobemergedbefore
     *  callingthedefault_get(eg.tosetdefaultvalues).
     *  Ifseveralcontextsarefound,multiplerecordsareadded
     *@param{boolean}[options.allowWarning=false]iftrue,thedefaultrecord
     *  operationcancomplete,evenifawarningisraised
     *@returns{Promise<[string]>}resolvestothenewrecordsids
     */
    _addX2ManyDefaultRecord:function(list,options){
        varself=this;
        varposition=options&&options.position||'top';
        varparams={
            fields:list.fields,
            fieldsInfo:list.fieldsInfo,
            parentID:list.id,
            position:position,
            viewType:options.viewType||list.viewType,
            allowWarning:options&&options.allowWarning
        };

        varadditionalContexts=options&&options.context;
        varmakeDefaultRecords=[];
        if(additionalContexts){
            _.each(additionalContexts,function(context){
                params.context=self._getContext(list,{additionalContext:context,sanitize_default_values:true});
                makeDefaultRecords.push(self._makeDefaultRecord(list.model,params));
            });
        }else{
            params.context=self._getContext(list,{sanitize_default_values:true});
            makeDefaultRecords.push(self._makeDefaultRecord(list.model,params));
        }

        returnPromise.all(makeDefaultRecords).then(function(resultIds){
            varids=[];
            _.each(resultIds,function(id){
                ids.push(id);

                list._changes.push({operation:'ADD',id:id,position:position,isNew:true});
                varrecord=self.localData[id];
                list._cache[record.res_id]=id;
                if(list.orderedResIDs){
                    varindex=list.offset+(position!=='top'?list.limit:0);
                    list.orderedResIDs.splice(index,0,record.res_id);
                    //listcouldbeacopyoftheoriginalone
                    self.localData[list.id].orderedResIDs=list.orderedResIDs;
                }
            });

            returnids;
        });
    },
    /**
     *ThismethodistheprivateversionofnotifyChanges. Unlike
     *notifyChanges,itisnotprotectedbyamutex. Everychangesfromthe
     *usertothemodelgothroughthismethod.
     *
     *@param{string}recordID
     *@param{Object}changes
     *@param{Object}[options]
     *@param{boolean}[options.doNotSetDirty=false]ifthisflagissetto
     *  true,thenwewillnottagtherecordasdirty. Thisshouldbeavoided
     *  formostsituations.
     *@param{boolean}[options.notifyChange=true]ifthisflagissetto
     *  false,thenwewillnotnotifyandnottriggertheonchange,eventhough
     *  itwaschanged.
     *@param{string}[options.viewType]currentviewType.Ifnotset,wewillassume
     *  mainviewTypefromtherecord
     *@param{boolean}[options.allowWarning=false]iftrue,change
     *  operationcancomplete,evenifawarningisraised
     *  (onlysupportedbyX2ManyChange)
     *@returns{Promise}listofchangedfields
     */
    _applyChange:function(recordID,changes,options){
        varself=this;
        varrecord=this.localData[recordID];
        varfield;
        vardefs=[];
        options=options||{};
        record._changes=record._changes||{};
        if(!options.doNotSetDirty){
            record._isDirty=true;
        }
        varinitialData={};
        this._visitChildren(record,function(elem){
            initialData[elem.id]=$.extend(true,{},_.pick(elem,'data','_changes'));
        });

        //applychangestolocaldata
        for(varfieldNameinchanges){
            field=record.fields[fieldName];
            if(field&&(field.type==='one2many'||field.type==='many2many')){
                defs.push(this._applyX2ManyChange(record,fieldName,changes[fieldName],options));
            }elseif(field&&(field.type==='many2one'||field.type==='reference')){
                defs.push(this._applyX2OneChange(record,fieldName,changes[fieldName],options));
            }else{
                record._changes[fieldName]=changes[fieldName];
            }
        }

        if(options.notifyChange===false){
            returnPromise.all(defs).then(function(){
                returnPromise.resolve(_.keys(changes));
            });
        }

        returnPromise.all(defs).then(function(){
            varonChangeFields=[];//thefieldsthathavechangedandthathaveanon_change
            for(varfieldNameinchanges){
                field=record.fields[fieldName];
                if(field&&field.onChange){
                    varisX2Many=field.type==='one2many'||field.type==='many2many';
                    if(!isX2Many||(self._isX2ManyValid(record._changes[fieldName]||record.data[fieldName]))){
                        onChangeFields.push(fieldName);
                    }
                }
            }
            returnnewPromise(function(resolve,reject){
                if(onChangeFields.length){
                    self._performOnChange(record,onChangeFields,{viewType:options.viewType})
                    .then(function(result){
                        deleterecord._warning;
                        resolve(_.keys(changes).concat(Object.keys(result&&result.value||{})));
                    }).guardedCatch(function(){
                        self._visitChildren(record,function(elem){
                            _.extend(elem,initialData[elem.id]);
                        });
                        reject();
                    });
                }else{
                    resolve(_.keys(changes));
                }
            }).then(function(fieldNames){
                returnself._fetchSpecialData(record).then(function(fieldNames2){
                    //Returnthenamesofthefieldsthatchanged(onchangeor
                    //associatedspecialdatachange)
                    return_.union(fieldNames,fieldNames2);
                });
            });
        });
    },
    /**
     *Applyanx2one(eitheramany2oneorareferencefield)change.Thereis
     *aneedforthisfunctionbecausetheserveronlygivesanidwhena
     *onchangemodifiesamany2onefield.Forthisreason,weneed(sometimes)
     *todoa/name_gettofetchadisplay_name.
     *
     *Moreover,forthemany2onecase,anewvaluecansometimesbeset(i.e.
     *adisplay_nameisgiven,butnoid).Whenthishappens,wefirstdoa
     *name_create.
     *
     *@param{Object}record
     *@param{string}fieldName
     *@param{Object}[data]
     *@param{Object}[options]
     *@param{string}[options.viewType]currentviewType.Ifnotset,wewill
     *  assumemainviewTypefromtherecord
     *@returns{Promise}
     */
    _applyX2OneChange:asyncfunction(record,fieldName,data,options){
        options=options||{};
        varself=this;
        if(!data||(!data.id&&!data.display_name)){
            record._changes[fieldName]=false;
            returnPromise.resolve();
        }

        constfield=record.fields[fieldName];
        constcoModel=field.type==='reference'?data.model:field.relation;
        constallowedTypes=['many2one','reference'];
        if(allowedTypes.includes(field.type)&&!data.id&&data.display_name){
            //onlydisplay_namegiven->doaname_create
            constresult=awaitthis._rpc({
                model:coModel,
                method:'name_create',
                args:[data.display_name],
                context:this._getContext(record,{fieldName:fieldName,viewType:options.viewType}),
            });
            //Checkifarecordisreallycreated.Modelswithoutdefined
            //_rec_namecannotcreaterecordbasedonname_create.
            if(!result){
                record._changes[fieldName]=false;
                returnPromise.resolve();
            }
            data={id:result[0],display_name:result[1]};
        }

        //here,wecheckthatthemany2onereallychanged.Iftheres_idisthe
        //same,wedonotneedtodoanyextrawork.Itcanhappenwhenthe
        //usereditedamanyone(withthesmallformviewbutton)withan
        //onchange. Inthatcase,theonchangeistriggered,buttheactual
        //valuedidnotchange.
        varrelatedID;
        if(record._changes&&fieldNameinrecord._changes){
            relatedID=record._changes[fieldName];
        }else{
            relatedID=record.data[fieldName];
        }
        varrelatedRecord=this.localData[relatedID];
        if(relatedRecord&&(data.id===this.localData[relatedID].res_id)){
            returnPromise.resolve();
        }
        varrel_data=_.pick(data,'id','display_name');

        //thereferencefielddoesn'tstoreitsco-modelinitsfieldmetadata
        //butdirectlyinthedata(astheco-modelisn'tfixed)
        vardef;
        if(rel_data.display_name===undefined){
            //TODO:refactorthistouse_fetchNameGet
            def=this._rpc({
                    model:coModel,
                    method:'name_get',
                    args:[data.id],
                    context:record.context,
                })
                .then(function(result){
                    rel_data.display_name=result[0][1];
                });
        }
        returnPromise.resolve(def).then(function(){
            varrec=self._makeDataPoint({
                context:record.context,
                data:rel_data,
                fields:{},
                fieldsInfo:{},
                modelName:coModel,
                parentID:record.id,
            });
            record._changes[fieldName]=rec.id;
        });
    },
    /**
     *AppliestheresultofanonchangeRPConarecord.
     *
     *@private
     *@param{Object}valuestheresultoftheonchangeRPC(amappingof
     *  fieldnamestotheirvalue)
     *@param{Object}record
     *@param{Object}[options={}]
     *@param{string}[options.viewType]currentviewType.Ifnotset,wewillassume
     *  mainviewTypefromtherecord
     *@param{string}[options.firstOnChange]settotrueifthisisthefirst
     *  onchange(ifso,someinitializationwillneedtobedone)
     *@returns{Promise}
     */
    _applyOnChange:function(values,record,options={}){
        varself=this;
        vardefs=[];
        varrec;
        constviewType=options.viewType||record.viewType;
        record._changes=record._changes||{};

        for(letnamein(values||{})){
            constval=values[name];
            varfield=record.fields[name];
            if(!field){
                //thisfieldisunknownsowecan'tprocessitfornow(itisnot
                //inthecurrentviewanyway,otherwiseitwouldn'tbeunknown.
                //westoreitsvaluewithoutprocessingit,sothatifwelater
                //onswitchtoanotherviewinwhichthisfieldisdisplayed,
                //wecouldprocessitaswewouldknowitstypethen.
                //usecase:anonchangesendsacreatecommandforaone2many,
                //inthedictofvalues,thereisavalueforafieldthatis
                //notintheone2manylist,butthatisintheone2manyform.
                record._rawChanges[name]=val;
                //LPETODO1taskid-2261084:removethisentirecommentincludingcodesnippet
                //whenthechangeinbehaviorhasbeenthoroughlytested.
                //Itisimpossibletodistinguishbetweenvaluesreturnedbythedefault_get
                //andthosereturnedbytheonchange.Sincethosearenotin_changes,theywon'tbesaved.
                //if(options.firstOnChange){
                //    record._changes[name]=val;
                //}
                continue;
            }
            if(record._rawChanges[name]){
                //ifprevious_rawChangesexists,clearthemsincethefieldisnowknwon
                //andrestoringoutdatedonchangeoverposteriouschangeiswrong
                deleterecord._rawChanges[name];
            }
            varoldValue=nameinrecord._changes?record._changes[name]:record.data[name];
            varid;
            if(field.type==='many2one'){
                id=false;
                //insomecase,thevaluereturnedbytheonchangecan
                //befalse(novalue),soweneedtoavoidcreatinga
                //localrecordforthat.
                if(val){
                    //whenthevalueisn'tfalse,itcanbeeither
                    //anarray[id,display_name]orjustanid.
                    vardata=_.isArray(val)?
                        {id:val[0],display_name:val[1]}:
                        {id:val};
                    if(!oldValue||(self.localData[oldValue].res_id!==data.id)){
                        //onlyregisterachangeifthevaluehaschanged
                        rec=self._makeDataPoint({
                            context:record.context,
                            data:data,
                            modelName:field.relation,
                            parentID:record.id,
                        });
                        id=rec.id;
                        record._changes[name]=id;
                    }
                }else{
                    record._changes[name]=false;
                }
            }elseif(field.type==='reference'){
                id=false;
                if(val){
                    varref=val.split(',');
                    varmodelName=ref[0];
                    varresID=parseInt(ref[1]);
                    if(!oldValue||self.localData[oldValue].res_id!==resID||
                        self.localData[oldValue].model!==modelName){
                        //onlyregisterachangeifthevaluehaschanged
                        rec=self._makeDataPoint({
                            context:record.context,
                            data:{id:parseInt(ref[1])},
                            modelName:modelName,
                            parentID:record.id,
                        });
                        defs.push(self._fetchNameGet(rec));
                        id=rec.id;
                        record._changes[name]=id;
                    }
                }else{
                    record._changes[name]=id;
                }
            }elseif(field.type==='one2many'||field.type==='many2many'){
                varlistId=record._changes[name]||record.data[name];
                varlist;
                if(listId){
                    list=self.localData[listId];
                }else{
                    varfieldInfo=record.fieldsInfo[viewType][name];
                    if(!fieldInfo){
                        //ignorechangesofx2manynotinview
                        continue;
                    }
                    varview=fieldInfo.views&&fieldInfo.views[fieldInfo.mode];
                    list=self._makeDataPoint({
                        fields:view?view.fields:fieldInfo.relatedFields,
                        fieldsInfo:view?view.fieldsInfo:fieldInfo.fieldsInfo,
                        limit:fieldInfo.limit,
                        modelName:field.relation,
                        parentID:record.id,
                        static:true,
                        type:'list',
                        viewType:view?view.type:fieldInfo.viewType,
                    });
                }
                //TODO:beforeregisteringthechanges,verifythatthex2many
                //valuehaschanged
                record._changes[name]=list.id;
                list._changes=list._changes||[];

                //saveitincaseofa[5]whichwillremovethe_changes
                varoldChanges=list._changes;
                _.each(val,function(command){
                    varrec,recID;
                    if(command[0]===0||command[0]===1){
                        //CREATEorUPDATE
                        if(command[0]===0&&command[1]){
                            //updatinganexisting(virtual)record
                            varpreviousChange=_.find(oldChanges,function(operation){
                                varchild=self.localData[operation.id];
                                returnchild&&(child.ref===command[1]);
                            });
                            recID=previousChange&&previousChange.id;
                            rec=self.localData[recID];
                        }
                        if(command[0]===1&&command[1]){
                            //updatinganexistingrecord
                            rec=self.localData[list._cache[command[1]]];
                        }
                        if(!rec){
                            varparams={
                                context:list.context,
                                fields:list.fields,
                                fieldsInfo:list.fieldsInfo,
                                modelName:list.model,
                                parentID:list.id,
                                viewType:list.viewType,
                                ref:command[1],
                            };
                            if(command[0]===1){
                                params.res_id=command[1];
                            }
                            rec=self._makeDataPoint(params);
                            list._cache[rec.res_id]=rec.id;
                            if(options.firstOnChange){
                                //thisisnecessarysothefieldsareinitialized
                                rec.getFieldNames().forEach(fieldName=>{
                                    if(!(fieldNameinrec.data)){
                                        rec.data[fieldName]=null;
                                    }
                                });
                            }
                        }
                        //Donotabandontherecordifithasbeencreated
                        //from`default_get`.Thelisthasasavepointonly
                        //afterhavingfullyexecuted`default_get`.
                        rec._noAbandon=!list._savePoint;
                        list._changes.push({operation:'ADD',id:rec.id});
                        if(command[0]===1){
                            list._changes.push({operation:'UPDATE',id:rec.id});
                        }
                        defs.push(self._applyOnChange(command[2],rec,{
                            firstOnChange:options.firstOnChange,
                        }));
                    }elseif(command[0]===4){
                        //LINKTO
                        linkRecord(list,command[1]);
                    }elseif(command[0]===5){
                        //DELETEALL
                        list._changes=[{operation:'REMOVE_ALL'}];
                    }elseif(command[0]===6){
                        list._changes=[{operation:'REMOVE_ALL'}];
                        _.each(command[2],function(resID){
                            linkRecord(list,resID);
                        });
                    }
                });
                vardef=self._readUngroupedList(list).then(function(list){
                    varx2ManysDef=self._fetchX2ManysBatched(list);
                    varreferencesDef=self._fetchReferencesBatched(list);
                    returnPromise.all([x2ManysDef,referencesDef]);
                });
                defs.push(def);
            }else{
                varnewValue=self._parseServerValue(field,val);
                if(newValue!==oldValue){
                    record._changes[name]=newValue;
                }
            }
        }
        returnPromise.all(defs);

        //innerfunctionthataddsarecord(basedonitsres_id)toalist
        //dataPoint(usedforonchangesthatreturncommands4(LINKTO)or
        //commands6(REPLACEWITH))
        functionlinkRecord(list,resID){
            rec=self.localData[list._cache[resID]];
            if(rec){
                //modificationsdoneonarecordarediscardediftheonchange
                //usesaLINKTOoraREPLACEWITH
                self.discardChanges(rec.id);
            }
            //thedataPointidwillbesetwhentherecordwillbefetched(for
            //now,thisdataPointmaynotexistyet)
            list._changes.push({
                operation:'ADD',
                id:rec?rec.id:null,
                resID:resID,
            });
        }
    },
    /**
     *Whenanoperationisappliedtoax2manyfield,thefieldwidgets
     *generateone(ormore)command,whichdescribestheexactoperation.
     *Thismethodtriestointerpretthesecommandsandapplythemtothe
     *localData.
     *
     *@param{Object}record
     *@param{string}fieldName
     *@param{Object}commandAcommandobject. Itshouldhavea'operation'
     *  key. Forexample,itlookslike{operation:ADD,id:'partner_1'}
     *@param{Object}[options]
     *@param{string}[options.viewType]currentviewType.Ifnotset,wewillassume
     *  mainviewTypefromtherecord
     *@param{boolean}[options.allowWarning=false]iftrue,change
     *  operationcancomplete,evenifawarningisraised
     *  (onlysupportedbythe'CREATE'command.operation)
     *@returns{Promise}
     */
    _applyX2ManyChange:asyncfunction(record,fieldName,command,options){
        if(command.operation==='TRIGGER_ONCHANGE'){
            //thepurposeofthisoperationistotriggeranonchangeRPC,so
            //thereisnoneedtoapplyanychangeontherecord(thechanges
            //haveprobablybeenalreadyappliedandsaved,usecase:many2many
            //editioninadialog)
            returnPromise.resolve();
        }

        varself=this;
        varlocalID=(record._changes&&record._changes[fieldName])||record.data[fieldName];
        varlist=this.localData[localID];
        varfield=record.fields[fieldName];
        varviewType=(options&&options.viewType)||record.viewType;
        varfieldInfo=record.fieldsInfo[viewType][fieldName];
        varview=fieldInfo.views&&fieldInfo.views[fieldInfo.mode];
        vardef,rec;
        vardefs=[];
        list._changes=list._changes||[];

        switch(command.operation){
            case'ADD':
                //fornow,weareinthecontextofaone2manyfield
                //thecommandshouldlooklikethis:
                //{operation:'ADD',id:localID}
                //Thecorrespondingrecordmaycontainvalueforfieldsthat
                //areunknowninthelist(e.g.fieldsthatareinthe
                //subrecordformviewbutnotinthekanbanorlistview),so
                //toensurethatonchangesarecorrectlyhandled,weextendthe
                //list'sfieldswiththoseinthecreatedrecord
                varnewRecord=this.localData[command.id];
                _.defaults(list.fields,newRecord.fields);
                _.defaults(list.fieldsInfo,newRecord.fieldsInfo);
                newRecord.fields=list.fields;
                newRecord.fieldsInfo=list.fieldsInfo;
                newRecord.viewType=list.viewType;
                list._cache[newRecord.res_id]=newRecord.id;
                list._changes.push(command);
                break;
            case'ADD_M2M':
                //forcetouselinkcommandinsteadofcreatecommand
                list._forceM2MLink=true;
                //handlemultipleadd:command[2]maybeadictofvalues(1
                //recordadded)oranarrayofdictofvalues
                vardata=_.isArray(command.ids)?command.ids:[command.ids];

                //name_createrecordsforwhichthereisnoid(typically,could
                //bethecaseofaquick_createinamany2many_tags,sodata.length
                //is1)
                for(constrofdata){
                    if(!r.id&&r.display_name){
                        constprom=this._rpc({
                            model:field.relation,
                            method:'name_create',
                            args:[r.display_name],
                            context:this._getContext(record,{fieldName:fieldName,viewType:options.viewType}),
                        }).then(result=>{
                            r.id=result[0];
                            r.display_name=result[1];
                        });
                        defs.push(prom);
                    }
                }
                awaitPromise.all(defs);

                //Ensurethelocaldatarepository(list)boundariescanhandleincomingrecords(data)
                if(data.length+list.res_ids.length>list.limit){
                    list.limit=data.length+list.res_ids.length;
                }

                varlist_records={};
                _.each(data,function(d){
                    rec=self._makeDataPoint({
                        context:record.context,
                        modelName:field.relation,
                        fields:view?view.fields:fieldInfo.relatedFields,
                        fieldsInfo:view?view.fieldsInfo:fieldInfo.fieldsInfo,
                        res_id:d.id,
                        data:d,
                        viewType:view?view.type:fieldInfo.viewType,
                        parentID:list.id,
                    });
                    list_records[d.id]=rec;
                    list._cache[rec.res_id]=rec.id;
                    list._changes.push({operation:'ADD',id:rec.id});
                });
                //readlist'srecordsasweonlyhavetheiridsandoptionallytheirdisplay_name
                //(wecan'tusefunctionreadUngroupedListbecausethoserecordsareonlyinthe
                //_changessothisisaveryspecificcase)
                //thiscouldbeoptimizedbyregisteringthefetchedrecordsinthelist's_cache
                //sothatifarecordisremovedandthenre-added,itwon'tbefetchedtwice
                varfieldNames=list.getFieldNames();
                if(fieldNames.length){
                    def=this._rpc({
                        model:list.model,
                        method:'read',
                        args:[_.pluck(data,'id'),fieldNames],
                        context:_.extend({},record.context,field.context),
                    }).then(function(records){
                        _.each(records,function(record){
                            list_records[record.id].data=record;
                            self._parseServerData(fieldNames,list,record);
                        });
                        returnPromise.all([
                            self._fetchX2ManysBatched(list),
                            self._fetchReferencesBatched(list)
                        ]);
                    });
                    defs.push(def);
                }
                break;
            case'CREATE':
                varcreateOptions=_.extend({
                    context:command.context,
                    position:command.position
                },options||{});
                createOptions.viewType=fieldInfo.mode;

                def=this._addX2ManyDefaultRecord(list,createOptions).then(function(ids){
                    _.each(ids,function(id){
                        if(command.position==='bottom'&&list.orderedResIDs&&list.orderedResIDs.length>=list.limit){
                            list.tempLimitIncrement=(list.tempLimitIncrement||0)+1;
                            list.limit+=1;
                        }
                        //FIXME:hackforlunchwidget,whichdoesuselessdefault_getandonchange
                        if(command.data){
                            returnself._applyChange(id,command.data);
                        }
                    });
                });
                defs.push(def);
                break;
            case'UPDATE':
                list._changes.push({operation:'UPDATE',id:command.id});
                if(command.data){
                    defs.push(this._applyChange(command.id,command.data,{
                        viewType:view&&view.type,
                    }));
                }
                break;
            case'FORGET':
                //Unlinktherecordoflist.
                list._forceM2MUnlink=true;
            case'DELETE':
                //filteroutexistingoperationsinvolvingthecurrent
                //dataPoint,andadda'DELETE'or'FORGET'operationonlyifthereis
                //no'ADD'operationforthatdataPoint,asitwouldmean
                //thattherecordwasn'tintherelationyet
                varidsToRemove=command.ids;
                list._changes=_.reject(list._changes,function(change,index){
                    varidInCommands=_.contains(command.ids,change.id);
                    if(idInCommands&&change.operation==='ADD'){
                        idsToRemove=_.without(idsToRemove,change.id);
                    }
                    returnidInCommands;
                });
                _.each(idsToRemove,function(id){
                    varoperation=list._forceM2MUnlink?'FORGET':'DELETE';
                    list._changes.push({operation:operation,id:id});
                });
                break;
            case'DELETE_ALL':
                //firstremoveallpending'ADD'operations
                list._changes=_.reject(list._changes,function(change){
                    returnchange.operation==='ADD';
                });

                //thenapply'DELETE'onexistingrecords
                returnthis._applyX2ManyChange(record,fieldName,{
                    operation:'DELETE',
                    ids:list.res_ids
                },options);
            case'REPLACE_WITH':
                //thisiscertainlynotoptimal...andnotsurethatitis
                //correctifsomeidsareaddedandsomeotherareremoved
                list._changes=[];
                varnewIds=_.difference(command.ids,list.res_ids);
                varremovedIds=_.difference(list.res_ids,command.ids);
                varaddDef,removedDef,values;
                if(newIds.length){
                    values=_.map(newIds,function(id){
                        return{id:id};
                    });
                    addDef=this._applyX2ManyChange(record,fieldName,{
                        operation:'ADD_M2M',
                        ids:values
                    },options);
                }
                if(removedIds.length){
                    varlistData=_.map(list.data,function(localId){
                        returnself.localData[localId];
                    });
                    removedDef=this._applyX2ManyChange(record,fieldName,{
                        operation:'DELETE',
                        ids:_.map(removedIds,function(resID){
                            if(resIDinlist._cache){
                                returnlist._cache[resID];
                            }
                            return_.findWhere(listData,{res_id:resID}).id;
                        }),
                    },options);
                }
                returnPromise.all([addDef,removedDef]);
            case'MULTI':
                //allowsbatchingmultipleoperations
                _.each(command.commands,function(innerCommand){
                    defs.push(self._applyX2ManyChange(
                        record,
                        fieldName,
                        innerCommand,
                        options
                    ));
                });
                break;
        }

        returnPromise.all(defs).then(function(){
            //ensuretofetchupto'limit'records(maybeusefulifrecordsof
            //thecurrentpagehavebeenremoved)
            returnself._readUngroupedList(list).then(function(){
                returnself._fetchX2ManysBatched(list);
            });
        });
    },
    /**
     *IndataPointsoftypelistforx2manys,thechangesarestoredasalist
     *ofoperations(beingoftype'ADD','DELETE','FORGET',UPDATE'or'REMOVE_ALL').
     *ThisfunctionappliestheoperationofsuchadataPointwithoutaltering
     *theoriginaldataPoint.ItreturnsacopyofthedataPointinwhichthe
     *'count','data'and'res_ids'keyshavebeenupdated.
     *
     *@private
     *@param{Object}dataPointoftypelist
     *@param{Object}[options]mostlycontainstherangeofoperationstoapply
     *@param{Object}[options.from=0]theindexofthefirstoperationtoapply
     *@param{Object}[options.to=length]theindexofthelastoperationtoapply
     *@param{Object}[options.position]ifset,eachnewoperationwillbeset
     *  accordinglyatthetoporthebottomofthelist
     *@returns{Object}elementoftypelistinwhichthecommandshavebeen
     *  applied
     */
    _applyX2ManyOperations:function(list,options){
        if(!list.static){
            //thisfunctiononlyappliesonx2manylists
            returnlist;
        }
        varself=this;
        list=_.extend({},list);
        list.res_ids=list.res_ids.slice(0);
        varchanges=list._changes||[];
        if(options){
            varto=options.to===0?0:(options.to||changes.length);
            changes=changes.slice(options.from||0,to);
        }
        _.each(changes,function(change){
            varrelRecord;
            if(change.id){
                relRecord=self.localData[change.id];
            }
            switch(change.operation){
                case'ADD':
                    list.count++;
                    varresID=relRecord?relRecord.res_id:change.resID;
                    if(change.position==='top'&&(options?options.position!=='bottom':true)){
                        list.res_ids.unshift(resID);
                    }else{
                        list.res_ids.push(resID);
                    }
                    break;
                case'FORGET':
                case'DELETE':
                    list.count--;
                    //FIXMEawa:thereisno"relRecord"foro2mfield
                    //seemslikeusingchange.iddoesthetrick->checkwithframeworkJS
                    vardeletedResID=relRecord?relRecord.res_id:change.id;
                    list.res_ids=_.without(list.res_ids,deletedResID);
                    break;
                case'REMOVE_ALL':
                    list.count=0;
                    list.res_ids=[];
                    break;
                case'UPDATE':
                    //nothingtodoforUPDATEcommands
                    break;
            }
        });
        this._setDataInRange(list);
        returnlist;
    },
    /**
     *Helpermethodtobuilda'spec',thatisadescriptionofallfieldsin
     *theviewthathaveaonchangedefinedonthem.
     *
     *Anonchangespecisnecessaryasanargumenttothe/onchangeroute.It
     *lookslikethis:{field:"1",anotherField:"",relation.subField:"1"}
     *
     *Thefirstonchangecallwillfilluptherecordwithdefaultvalues,so
     *weneedtosendeveryfieldnameknowntousinthiscase.
     *
     *@see_performOnChange
     *
     *@param{Object}recordresourceobjectoftype'record'
     *@param{string}[viewType]currentviewType.Ifnotset,wewillassume
     *  mainviewTypefromtherecord
     *@returns{Object}withtwokeys
     *  -'hasOnchange':trueiffthereisatleastafieldwithonchange
     *  -'onchangeSpec':theonchangespec
     */
    _buildOnchangeSpecs:function(record,viewType){
        lethasOnchange=false;
        constonchangeSpec={};
        varfieldsInfo=record.fieldsInfo[viewType||record.viewType];
        generateSpecs(fieldsInfo,record.fields);

        //recursivelygeneratestheonchangespecsforfieldsinfieldsInfo,
        //andtheirsubviews
        functiongenerateSpecs(fieldsInfo,fields,prefix){
            prefix=prefix||'';
            _.each(Object.keys(fieldsInfo),function(name){
                varfield=fields[name];
                varfieldInfo=fieldsInfo[name];
                varkey=prefix+name;
                onchangeSpec[key]=(field.onChange)||"";
                if(field.onChange){
                    hasOnchange=true;
                }
                if(field.type==='one2many'||field.type==='many2many'){
                    _.each(fieldInfo.views,function(view){
                        generateSpecs(view.fieldsInfo[view.type],view.fields,key+'.');
                    });
                }
            });
        }
        return{hasOnchange,onchangeSpec};
    },
    /**
     *EnsuresthatdataPointidsarealwayssynchronizedbetweenthemainand
     *samplemodelswhenbeinginsamplemode.Here,wenowthat__idinthe
     *samplemodelisalwaysgreaterthan__idinthemainmodel(asit
     *containsstrictlymoredatapoints).
     *
     *@override
     */
    async_callSampleModel(){
        awaitthis._super(...arguments);
        if(this._isInSampleMode){
            this.__id=this.sampleModel.__id;
        }
    },
    /**
     *Computethedefaultvaluethatthehandlefieldshouldtake.
     *Weneedtocomputethisinorderfornewlinestobeaddedatthecorrectposition.
     *
     *@private
     *@param{Object}listID
     *@param{string}position
     *@return{Object}emptyobjectifnooverriehastobedone,or:
     * field:thenameofthefieldtooverride,
     * value:thevaluetouseforthatfield
     */
    _computeOverrideDefaultFields:function(listID,position){
        varlist=this.localData[listID];
        varhandleField;

        //HerelistIDisactuallyjustparentID,it'snotyetconfirmed
        //tobealist.
        //Ifwearenotinthecasethatinterestsus,
        //listIDwillbeundefinedandthischeckwillwork.
        if(!list){
            return{};
        }

        position=position||'bottom';

        //Let'sfindifthereisafieldwithhandle.
        if(!list.fieldsInfo){
            return{};
        }
        for(varfieldinlist.fieldsInfo.list){
            if(list.fieldsInfo.list[field].widget==='handle'){
                handleField=field;
                break;
                //Ifthereare2handlefieldsonthesamelist,
                //wetakethefirstonewefind.
                //Andthatwillbealphabeticallyonthefieldname...
            }
        }

        if(!handleField){
            return{};
        }

        //Wedon'twanttooverridethedefaultvalue
        //ifthelistisnotorderedbythehandlefield.
        varisOrderedByHandle=list.orderedBy
            &&list.orderedBy.length
            &&list.orderedBy[0].asc===true
            &&list.orderedBy[0].name===handleField;

        if(!isOrderedByHandle){
            return{};
        }

        //Wecomputethelist(get)toapplythependingchangesbeforedoingourwork,
        //otherwisenewlinesmightnotbetakenintoaccount.
        //Weuseraw:truebecauseweonlyneedtoloadthefirstlevelofrelation.
        varcomputedList=this.get(list.id,{raw:true});

        //Wedon'tneedtoworryaboutthepositionofanewlineifthelistisempty.
        if(!computedList||!computedList.data||!computedList.data.length){
            return{};
        }

        //Iftherearelesselementsinthelistthanthelimitof
        //thepagethentaketheindexofthelastexistingline.

        //Ifthebuttonisatthetop,wewantthenewelementon
        //thefirstlineofthepage.

        //Ifthebuttonisatthebottom,wewantthenewelement
        //afterthelastlineofthepage
        //(=theoricallyitwillbethefirstelementofthenextpage).

        //Weignorelist.offsetbecausecomputedList.data
        //willonlyhavethecurrentpageelements.

        varindex=Math.min(
            computedList.data.length-1,
            position!=='top'?list.limit-1:0
        );

        //Thispositioningwillalmostbecorrect.Theremightjustbe
        //anissueifseveralotherlineshavethesamehandleFieldValue.

        //TODOideally:ifthereisanelementwiththesamehandleFieldValue,
        //thatoneandallthefollowingelementsmustbeincremented
        //by1(atleastuntilthereisagapinthenumbering).

        //Wedon'tdoitnowbecauseit'snotanimportantcase.
        //However,wecanforsureincrementby1ifweareonthelastpage.
        varhandleFieldValue=computedList.data[index].data[handleField];
        if(position==='top'){
            handleFieldValue--;
        }elseif(list.count<=list.offset+list.limit-(list.tempLimitIncrement||0)){
            handleFieldValue++;
        }
        return{
            field:handleField,
            value:handleFieldValue,
        };
    },
    /**
     *Evaluatemodifiers
     *
     *@private
     *@param{Object}elementavalidelementobject,whichwillserveaseval
     *  context.
     *@param{Object}modifiers
     *@returns{Object}
     *@throws{Error}ifoneofthemodifierdomainsisinvalid
     */
    _evalModifiers:function(element,modifiers){
        letevalContext=null;
        constevaluated={};
        for(constkof['invisible','column_invisible','readonly','required']){
            constmod=modifiers[k];
            if(mod===undefined||mod===false||mod===true){
                if(kinmodifiers){
                    evaluated[k]=!!mod;
                }
                continue;
            }
            try{
                evalContext=evalContext||this._getEvalContext(element);
                evaluated[k]=newDomain(mod,evalContext).compute(evalContext);
            }catch(e){
                thrownewError(_.str.sprintf('formodifier"%s":%s',k,e.message));
            }
        }
        returnevaluated;
    },
    /**
     *Fetchname_getforarecorddatapoint.
     *
     *@param{Object}dataPoint
     *@returns{Promise}
     */
    _fetchNameGet:function(dataPoint){
        returnthis._rpc({
            model:dataPoint.model,
            method:'name_get',
            args:[dataPoint.res_id],
            context:dataPoint.getContext(),
        }).then(function(result){
            dataPoint.data.display_name=result[0][1];
        });
    },
    /**
     *Fetchname_getforafieldoftypeMany2oneorReference
     *
     *@private
     *@params{Object}list:mustbeadatapointoftypelist
     *  (forexample:adatapointrepresentingax2many)
     *@params{string}fieldName:thenameofafieldoftypeMany2oneorReference
     *@returns{Promise}
     */
    _fetchNameGets:function(list,fieldName){
        varself=this;
        //Wefirstgetthemodelthiswaybecauseiflist.dataisempty
        //the_.eachbelowwillnotmakeit.
        varmodel=list.fields[fieldName].relation;
        varrecords=[];
        varids=[];
        list=this._applyX2ManyOperations(list);

        _.each(list.data,function(localId){
            varrecord=self.localData[localId];
            vardata=record._changes||record.data;
            varmany2oneId=data[fieldName];
            if(!many2oneId){return;}
            varmany2oneRecord=self.localData[many2oneId];
            records.push(many2oneRecord);
            ids.push(many2oneRecord.res_id);
            //Weneedtocalculatethemodelthiswaytoobecause
            //field.relationisnotsetforareferencefield.
            model=many2oneRecord.model;
        });

        if(!ids.length){
            returnPromise.resolve();
        }
        returnthis._rpc({
                model:model,
                method:'name_get',
                args:[_.uniq(ids)],
                context:list.context,
            })
            .then(function(name_gets){
                _.each(records,function(record){
                    varnameGet=_.find(name_gets,function(nameGet){
                        returnnameGet[0]===record.data.id;
                    });
                    record.data.display_name=nameGet[1];
                });
            });
    },
    /**
     *Foragivenresourceoftype'record',fetchalldata.
     *
     *@param{Object}recordlocalresource
     *@param{Object}[options]
     *@param{string[]}[options.fieldNames]thelistoffieldstofetch.If
     *  notgiven,fetchallthefieldsinrecord.fieldNames(+display_name)
     *@param{string}[options.viewType]thetypeofviewforwhichtherecord
     *  isfetched(usefulltoloadtheadequatefields),bydefaults,uses
     *  record.viewType
     *@returns{Promise<Object>}resolvestotherecordorisrejectedin
     *  casenoidgivenwerevalidids
     */
    _fetchRecord:function(record,options){
        varself=this;
        options=options||{};
        varfieldNames=options.fieldNames||record.getFieldNames(options);
        fieldNames=_.uniq(fieldNames.concat(['display_name']));
        returnthis._rpc({
                model:record.model,
                method:'read',
                args:[[record.res_id],fieldNames],
                context:_.extend({bin_size:true},record.getContext()),
            })
            .then(function(result){
                if(result.length===0){
                    returnPromise.reject();
                }
                result=result[0];
                record.data=_.extend({},record.data,result);
            })
            .then(function(){
                self._parseServerData(fieldNames,record,record.data);
            })
            .then(function(){
                returnPromise.all([
                    self._fetchX2Manys(record,options),
                    self._fetchReferences(record,options)
                ]).then(function(){
                    returnself._postprocess(record,options);
                });
            });
    },
    /**
     *Fetchthe`name_get`forareferencefield.
     *
     *@private
     *@param{Object}record
     *@param{string}fieldName
     *@returns{Promise}
     */
    _fetchReference:function(record,fieldName){
        varself=this;
        vardef;
        varvalue=record._changes&&record._changes[fieldName]||record.data[fieldName];
        varmodel=value&&value.split(',')[0];
        varresID=value&&parseInt(value.split(',')[1]);
        if(model&&model!=='False'&&resID){
            def=self._rpc({
                model:model,
                method:'name_get',
                args:[resID],
                context:record.getContext({fieldName:fieldName}),
            }).then(function(result){
                returnself._makeDataPoint({
                    data:{
                        id:result[0][0],
                        display_name:result[0][1],
                    },
                    modelName:model,
                    parentID:record.id,
                });
            });
        }
        returnPromise.resolve(def);
    },
    /**
     *Fetchesdataforreferencefieldsandassignsthesedatatonewly
     *createddatapoint.
     *Thenplacesdatapointreferenceintoparentrecord.
     *
     *@param{Object}datapointsacollectionofidsclassedbymodel,
     *  @see_getDataToFetchByModel
     *@param{string}model
     *@param{string}fieldName
     *@returns{Promise}
     */
    _fetchReferenceData:function(datapoints,model,fieldName){
        varself=this;
        varids=_.map(Object.keys(datapoints),function(id){returnparseInt(id);});
        //weneedoneparentforthecontext(theyallhavethesame)
        varparent=datapoints[ids[0]][0];
        vardef=self._rpc({
            model:model,
            method:'name_get',
            args:[ids],
            context:self.localData[parent].getContext({fieldName:fieldName}),
        }).then(function(result){
            _.each(result,function(el){
                varparentIDs=datapoints[el[0]];
                _.each(parentIDs,function(parentID){
                    varparent=self.localData[parentID];
                    varreferenceDp=self._makeDataPoint({
                        data:{
                            id:el[0],
                            display_name:el[1],
                        },
                        modelName:model,
                        parentID:parent.id,
                    });
                    parent.data[fieldName]=referenceDp.id;
                });
            });
        });
        returndef;
    },
    /**
     *Fetchtheextradata(`name_get`)forthereferencefieldsoftherecord
     *model.
     *
     *@private
     *@param{Object}record
     *@returns{Promise}
     */
    _fetchReferences:function(record,options){
        varself=this;
        vardefs=[];
        varfieldNames=options&&options.fieldNames||record.getFieldNames();
        _.each(fieldNames,function(fieldName){
            varfield=record.fields[fieldName];
            if(field.type==='reference'){
                vardef=self._fetchReference(record,fieldName).then(function(dataPoint){
                    if(dataPoint){
                        record.data[fieldName]=dataPoint.id;
                    }
                });
                defs.push(def);
            }
        });
        returnPromise.all(defs);
    },
    /**
     *Batchrequestsforonereferencefieldinlist(onerequestbydifferent
     *modelinthefieldvalues).
     *
     *@see_fetchReferencesBatched
     *@param{Object}list
     *@param{string}fieldName
     *@returns{Promise}
     */
    _fetchReferenceBatched:function(list,fieldName){
        varself=this;
        list=this._applyX2ManyOperations(list);
        this._sortList(list);

        vartoFetch=this._getDataToFetchByModel(list,fieldName);
        vardefs=[];
        //onename_getbymodel
        _.each(toFetch,function(datapoints,model){
            defs.push(self._fetchReferenceData(datapoints,model,fieldName));
        });

        returnPromise.all(defs);
    },
    /**
     *Batchrequestsforreferencesfordatapointoftypelist.
     *
     *@param{Object}list
     *@returns{Promise}
     */
    _fetchReferencesBatched:function(list){
        vardefs=[];
        varfieldNames=list.getFieldNames();
        for(vari=0;i<fieldNames.length;i++){
            varfield=list.fields[fieldNames[i]];
            if(field.type==='reference'){
                defs.push(this._fetchReferenceBatched(list,fieldNames[i]));
            }
        }
        returnPromise.all(defs);
    },
    /**
     *Batchreferencerequestsforallrecordsinlist.
     *
     *@see_fetchReferencesSingleBatch
     *@param{Object}listavalidresourceobject
     *@param{string}fieldName
     *@returns{Promise}
     */
    _fetchReferenceSingleBatch:function(list,fieldName){
        varself=this;

        //collectidsbymodel
        vartoFetch={};
        _.each(list.data,function(groupIndex){
            vargroup=self.localData[groupIndex];
            self._getDataToFetchByModel(group,fieldName,toFetch);
        });

        vardefs=[];
        //onename_getbymodel
        _.each(toFetch,function(datapoints,model){
            defs.push(self._fetchReferenceData(datapoints,model,fieldName));
        });

        returnPromise.all(defs);
    },
    /**
     *Batchrequestsforallreferencefieldinlist'schildren.
     *Calledby_readGrouptomakeonlyone'name_get'rpcbyfieldName.
     *
     *@param{Object}listavalidresourceobject
     *@returns{Promise}
     */
    _fetchReferencesSingleBatch:function(list){
        vardefs=[];
        varfieldNames=list.getFieldNames();
        for(varfIndexinfieldNames){
            varfield=list.fields[fieldNames[fIndex]];
            if(field.type==='reference'){
                defs.push(this._fetchReferenceSingleBatch(list,fieldNames[fIndex]));
            }
        }
        returnPromise.all(defs);
    },
    /**
     *Fetchmodeldatafromserver,relationallytofieldNameandresulted
     *fieldrelation.Forexample,iffieldNameis"tag_ids"andreferredto
     *project.tags,itwillfetchproject.tags'relatedfieldswhereitsidis
     *containedintoFetch.idsarray.
     *
     *@param{Object}listavalidresourceobject
     *@param{Object}toFetchalistofrecordsandres_ids,
     *  @see_getDataToFetch
     *@param{string}fieldName
     *@returns{Promise}
     */
    _fetchRelatedData:function(list,toFetch,fieldName){
        varself=this;
        varids=_.keys(toFetch);
        for(vari=0;i<ids.length;i++){
            ids[i]=Number(ids[i]);
        }
        varfieldInfo=list.fieldsInfo[list.viewType][fieldName];

        if(!ids.length||fieldInfo.__no_fetch){
            returnPromise.resolve();
        }

        vardef;
        varfieldNames=_.keys(fieldInfo.relatedFields);
        if(fieldNames.length){
            varfield=list.fields[fieldName];
            def=this._rpc({
                model:field.relation,
                method:'read',
                args:[ids,fieldNames],
                context:list.getContext()||{},
            });
        }else{
            def=Promise.resolve(_.map(ids,function(id){
                return{id:id};
            }));
        }
        returndef.then(function(result){
            varrecords=_.uniq(_.flatten(_.values(toFetch)));
            self._updateRecordsData(records,fieldName,result);
        });
    },
    /**
     *ChecktheAbstractFieldspecializationsthatare(willbe)usedbythe
     *givenrecordandfetchthespecialdatatheywillneed.Specialdataare
     *datathattherenderingoftherecordwon'tneedifitwasnotusing
     *particularwidgets(exampleofthesecanbefoundatthemethodswhich
     *startwith_fetchSpecial).
     *
     *@param{Object}record-anelementfromthelocalData
     *@param{Object}options
     *@returns{Promise<Array>}
     *         Thepromiseisresolvedwithanarraycontainingthenamesof
     *         thefieldwhosespecialdatahasbeenchanged.
     */
    _fetchSpecialData:function(record,options){
        varself=this;
        varspecialFieldNames=[];
        varfieldNames=(options&&options.fieldNames)||record.getFieldNames();
        returnPromise.all(_.map(fieldNames,function(name){
            varviewType=(options&&options.viewType)||record.viewType;
            varfieldInfo=record.fieldsInfo[viewType][name]||{};
            varWidget=fieldInfo.Widget;
            if(Widget&&Widget.prototype.specialData){
                returnself[Widget.prototype.specialData](record,name,fieldInfo).then(function(data){
                    if(data===undefined){
                        return;
                    }
                    record.specialData[name]=data;
                    specialFieldNames.push(name);
                });
            }
        })).then(function(){
            returnspecialFieldNames;
        });
    },
    /**
     *Fetchesallthem2orecordsassociatedtothegivenfieldName.Ifthe
     *givenfieldNameisnotam2ofield,nothingisdone.
     *
     *@param{Object}record-anelementfromthelocalData
     *@param{Object}fieldName-thenameofthefield
     *@param{Object}fieldInfo
     *@param{string[]}[fieldsToRead]-them2osfieldstoread(idand
     *                                 display_nameareautomatic).
     *@returns{Promise<any>}
     *         Thepromiseisresolvedwiththefetchedspecialdata.Ifthis
     *         dataisthesameasthepreviouslyfetchedone(forthegiven
     *         parameters),noRPCisdoneandthepromiseisresolvedwith
     *         theundefinedvalue.
     */
    _fetchSpecialMany2ones:function(record,fieldName,fieldInfo,fieldsToRead){
        varfield=record.fields[fieldName];
        if(field.type!=="many2one"){
            returnPromise.resolve();
        }

        varcontext=record.getContext({fieldName:fieldName});
        vardomain=record.getDomain({fieldName:fieldName});
        if(domain.length){
            varlocalID=(record._changes&&fieldNameinrecord._changes)?
                            record._changes[fieldName]:
                            record.data[fieldName];
            if(localID){
                varelement=this.localData[localID];
                domain=["|",["id","=",element.data.id]].concat(domain);
            }
        }

        //avoidrpcifnotnecessary
        varhasChanged=this._saveSpecialDataCache(record,fieldName,{
            context:context,
            domain:domain,
        });
        if(!hasChanged){
            returnPromise.resolve();
        }

        varself=this;
        returnthis._rpc({
                model:field.relation,
                method:'search_read',
                fields:["id"].concat(fieldsToRead||[]),
                context:context,
                domain:domain,
            })
            .then(function(records){
                varids=_.pluck(records,'id');
                returnself._rpc({
                        model:field.relation,
                        method:'name_get',
                        args:[ids],
                        context:context,
                    })
                    .then(function(name_gets){
                        _.each(records,function(rec){
                            varname_get=_.find(name_gets,function(n){
                                returnn[0]===rec.id;
                            });
                            rec.display_name=name_get[1];
                        });
                        returnrecords;
                    });
            });
    },
    /**
     *FetchesalltherelationrecordsassociatedtothegivenfieldName.If
     *thegivenfieldNameisnotarelationalfield,nothingisdone.
     *
     *@param{Object}record-anelementfromthelocalData
     *@param{Object}fieldName-thenameofthefield
     *@returns{Promise<any>}
     *         Thepromiseisresolvedwiththefetchedspecialdata.Ifthis
     *         dataisthesameasthepreviouslyfetchedone(forthegiven
     *         parameters),noRPCisdoneandthepromiseisresolvedwith
     *         theundefinedvalue.
     */
    _fetchSpecialRelation:function(record,fieldName){
        varfield=record.fields[fieldName];
        if(!_.contains(["many2one","many2many","one2many"],field.type)){
            returnPromise.resolve();
        }

        varcontext=record.getContext({fieldName:fieldName});
        vardomain=record.getDomain({fieldName:fieldName});

        //avoidrpcifnotnecessary
        varhasChanged=this._saveSpecialDataCache(record,fieldName,{
            context:context,
            domain:domain,
        });
        if(!hasChanged){
            returnPromise.resolve();
        }

        returnthis._rpc({
                model:field.relation,
                method:'name_search',
                args:["",domain],
                context:context
            });
    },
    /**
     *Fetchesthe`name_get`associatedtothereferencewidgetifthefieldis
     *a`char`(whichisasupportedcase).
     *
     *@private
     *@param{Object}record-anelementfromthelocalData
     *@param{Object}fieldName-thenameofthefield
     *@returns{Promise}
     */
    _fetchSpecialReference:function(record,fieldName){
        vardef;
        varfield=record.fields[fieldName];
        if(field.type==='char'){
            //ifthewidgetreferenceissetonacharfield,thename_get
            //needstobefetchedaposteriori
            def=this._fetchReference(record,fieldName);
        }
        returnPromise.resolve(def);
    },
    /**
     *Fetchesallthem2orecordsassociatedtothegivenfieldName.Ifthe
     *givenfieldNameisnotam2ofield,nothingisdone.Thedifferencewith
     *_fetchSpecialMany2onesisthatthefieldgivenbyoptions.fold_fieldis
     *alsofetched.
     *
     *@param{Object}record-anelementfromthelocalData
     *@param{Object}fieldName-thenameofthefield
     *@param{Object}fieldInfo
     *@returns{Promise<any>}
     *         Thepromiseisresolvedwiththefetchedspecialdata.Ifthis
     *         dataisthesameasthepreviouslyfetchedone(forthegiven
     *         parameters),noRPCisdoneandthepromiseisresolvedwith
     *         theundefinedvalue.
     */
    _fetchSpecialStatus:function(record,fieldName,fieldInfo){
        varfoldField=fieldInfo.options.fold_field;
        varfieldsToRead=foldField?[foldField]:[];
        returnthis._fetchSpecialMany2ones(record,fieldName,fieldInfo,fieldsToRead).then(function(m2os){
            _.each(m2os,function(m2o){
                m2o.fold=foldField?m2o[foldField]:false;
            });
            returnm2os;
        });
    },
    /**
     *Fetchesthenumberofrecordsassociatedtothedomainthevalueofthe
     *givenfieldrepresents.
     *
     *@param{Object}record-anelementfromthelocalData
     *@param{Object}fieldName-thenameofthefield
     *@param{Object}fieldInfo
     *@returns{Promise<any>}
     *         Thepromiseisresolvedwiththefetchedspecialdata.Ifthis
     *         dataisthesameasthepreviouslyfetchedone(forthegiven
     *         parameters),noRPCisdoneandthepromiseisresolvedwith
     *         theundefinedvalue.
     */
    _fetchSpecialDomain:function(record,fieldName,fieldInfo){
        varself=this;
        varcontext=record.getContext({fieldName:fieldName});

        vardomainModel=fieldInfo.options.model;
        if(record.data.hasOwnProperty(domainModel)){
            domainModel=record._changes&&record._changes[domainModel]||record.data[domainModel];
        }
        vardomainValue=record._changes&&record._changes[fieldName]||record.data[fieldName]||[];

        //avoidrpcifnotnecessary
        varhasChanged=this._saveSpecialDataCache(record,fieldName,{
            context:context,
            domainModel:domainModel,
            domainValue:domainValue,
        });
        if(!hasChanged){
            returnPromise.resolve();
        }elseif(!domainModel){
            returnPromise.resolve({
                model:domainModel,
                nbRecords:0,
            });
        }

        returnnewPromise(function(resolve){
            varevalContext=self._getEvalContext(record);
            self._rpc({
                model:domainModel,
                method:'search_count',
                args:[Domain.prototype.stringToArray(domainValue,evalContext)],
                context:context
            })
            .then(function(nbRecords){
                resolve({
                    model:domainModel,
                    nbRecords:nbRecords,
                });
            })
            .guardedCatch(function(reason){
                vare=reason.event;
                e.preventDefault();//preventtraceback(thesearch_countmightbeintendedtobreak)
                resolve({
                    model:domainModel,
                    nbRecords:0,
                });
            });
        });
    },
    /**
     *Fetchalldatainaungroupedlist
     *
     *@param{Object}listavalidresourceobject
     *@param{Object}[options]
     *@param{boolean}[options.enableRelationalFetch=true]iffalse,willnot
     *  fetchx2mandrelationaldata(thatwillbedoneby_readGroupinthis
     *  case).
     *@returns{Promise<Object>}resolvestothefecthedlist
     */
    _fetchUngroupedList:function(list,options){
        options=_.defaults(options||{},{enableRelationalFetch:true});
        varself=this;
        vardef;
        if(list.static){
            def=this._readUngroupedList(list).then(function(){
                if(list.parentID&&self.isNew(list.parentID)){
                    //listfromadefault_get,sofetchdisplay_nameformany2onefields
                    varmany2ones=self._getMany2OneFieldNames(list);
                    vardefs=_.map(many2ones,function(name){
                        returnself._fetchNameGets(list,name);
                    });
                    returnPromise.all(defs);
                }
            });
        }else{
            def=this._searchReadUngroupedList(list);
        }
        returndef.then(function(){
            if(options.enableRelationalFetch){
                returnPromise.all([
                    self._fetchX2ManysBatched(list),
                    self._fetchReferencesBatched(list)
                ]);
            }
        }).then(function(){
            returnlist;
        });
    },
    /**
     *batchrequestsfor1x2minlist
     *
     *@see_fetchX2ManysBatched
     *@param{Object}list
     *@param{string}fieldName
     *@returns{Promise}
     */
    _fetchX2ManyBatched:function(list,fieldName){
        list=this._applyX2ManyOperations(list);
        this._sortList(list);

        vartoFetch=this._getDataToFetch(list,fieldName);
        returnthis._fetchRelatedData(list,toFetch,fieldName);
    },
    /**
     *X2Manyshavetobefetchedbyseparaterpcs(theirdataarestoredon
     *differentmodels).Thismethodtakesarecord,lookatitsx2manyfields,
     *then,ifnecessary,createalocalresourceandfetchthecorresponding
     *data.
     *
     *Italsotriestoreusedata,ifitcanfindanexistinglist,toprevent
     *uselessrpcs.
     *
     *@param{Object}recordlocalresource
     *@param{Object}[options]
     *@param{string[]}[options.fieldNames]thelistoffieldstofetch.
     *  Ifnotgiven,fetchallthefieldsinrecord.fieldNames
     *@param{string}[options.viewType]thetypeofviewforwhichthemain
     *  recordisfetched(usefultoloadtheadequatefields),bydefaults,
     *  usesrecord.viewType
     *@returns{Promise}
     */
    _fetchX2Manys:function(record,options){
        varself=this;
        vardefs=[];
        options=options||{};
        varfieldNames=options.fieldNames||record.getFieldNames(options);
        varviewType=options.viewType||record.viewType;
        _.each(fieldNames,function(fieldName){
            varfield=record.fields[fieldName];
            if(field.type==='one2many'||field.type==='many2many'){
                varfieldInfo=record.fieldsInfo[viewType][fieldName];
                varrawContext=fieldInfo&&fieldInfo.context;
                varview=fieldInfo.views&&fieldInfo.views[fieldInfo.mode];
                varfieldsInfo=view?view.fieldsInfo:(fieldInfo.fieldsInfo||{});
                varids=record.data[fieldName]||[];
                varlist=self._makeDataPoint({
                    count:ids.length,
                    context:_.extend({},record.context,field.context),
                    fieldsInfo:fieldsInfo,
                    fields:view?view.fields:fieldInfo.relatedFields,
                    limit:fieldInfo.limit,
                    modelName:field.relation,
                    res_ids:ids,
                    static:true,
                    type:'list',
                    orderedBy:fieldInfo.orderedBy,
                    parentID:record.id,
                    rawContext:rawContext,
                    relationField:field.relation_field,
                    viewType:view?view.type:fieldInfo.viewType,
                });
                record.data[fieldName]=list.id;
                if(!fieldInfo.__no_fetch){
                    vardef=self._readUngroupedList(list).then(function(){
                        returnPromise.all([
                            self._fetchX2ManysBatched(list),
                            self._fetchReferencesBatched(list)
                        ]);
                    });
                    defs.push(def);
                }
            }
        });
        returnPromise.all(defs);
    },
    /**
     *batchrequestforx2msfordatapointoftypelist
     *
     *@param{Object}list
     *@returns{Promise}
     */
    _fetchX2ManysBatched:function(list){
        vardefs=[];
        varfieldNames=list.getFieldNames();
        for(vari=0;i<fieldNames.length;i++){
            varfield=list.fields[fieldNames[i]];
            if(field.type==='many2many'||field.type==='one2many'){
                defs.push(this._fetchX2ManyBatched(list,fieldNames[i]));
            }
        }
        returnPromise.all(defs);
    },
    /**
     *Foranon-staticlist,batchesrequestsforallitssublists'records.
     *Makeonlyonerpcforallrecordsontheconcernedfield.
     *
     *@see_fetchX2ManysSingleBatch
     *@param{Object}listavalidresourceobject,itsdatamustbeanother
     *  listcontainingrecords
     *@param{string}fieldName
     *@returns{Promise}
     */
    _fetchX2ManySingleBatch:function(list,fieldName){
        varself=this;
        vartoFetch={};
        _.each(list.data,function(groupIndex){
            vargroup=self.localData[groupIndex];
            varnextDataToFetch=self._getDataToFetch(group,fieldName);
            _.each(_.keys(nextDataToFetch),function(id){
                if(toFetch[id]){
                    toFetch[id]=toFetch[id].concat(nextDataToFetch[id]);
                }else{
                    toFetch[id]=nextDataToFetch[id];
                }
            });
        });
        returnself._fetchRelatedData(list,toFetch,fieldName);
    },
    /**
     *Batchrequestsforallx2minlist'schildren.
     *Calledby_readGrouptomakeonlyone'read'rpcbyfieldName.
     *
     *@param{Object}listavalidresourceobject
     *@returns{Promise}
     */
    _fetchX2ManysSingleBatch:function(list){
        vardefs=[];
        varfieldNames=list.getFieldNames();
        for(vari=0;i<fieldNames.length;i++){
            varfield=list.fields[fieldNames[i]];
            if(field.type==='many2many'||field.type==='one2many'){
                defs.push(this._fetchX2ManySingleBatch(list,fieldNames[i]));
            }
        }
        returnPromise.all(defs);
    },
    /**
     *Generatesanobjectmappingfieldnamestotheirchangedvalueinagiven
     *record(i.e.mapstothenewvalueforbasicfields,totheres_idfor
     *many2onesandtocommandsforx2manys).
     *
     *@private
     *@param{Object}record
     *@param{Object}[options]
     *@param{boolean}[options.changesOnly=true]iftrue,onlygenerates
     *  commandsforfieldsthathavechanged(concernsx2manyfieldsonly)
     *@param{boolean}[options.withReadonly=false]iffalse,doesn'tgenerate
     *  changesforreadonlyfields
     *@param{string}[options.viewType]currentviewType.Ifnotset,wewill
     *  assumemainviewTypefromtherecord.NotethatifaneditionViewTypeis
     *  specifiedforafield,itwilltakethepriorityovertheviewTypearg.
     *@returns{Object}amapfromchangedfieldstotheirnewvalue
     */
    _generateChanges:function(record,options){
        options=options||{};
        varviewType=options.viewType||record.viewType;
        varchanges;
        constchangesOnly='changesOnly'inoptions?!!options.changesOnly:true;
        if(!changesOnly){
            changes=_.extend({},record.data,record._changes);
        }else{
            changes=_.extend({},record._changes);
        }
        varwithReadonly=options.withReadonly||false;
        varcommands=this._generateX2ManyCommands(record,{
            changesOnly:changesOnly,
            withReadonly:withReadonly,
        });
        for(varfieldNameinrecord.fields){
            //removereadonlyfieldsfromthelistofchanges
            if(!withReadonly&&fieldNameinchanges||fieldNameincommands){
                vareditionViewType=record._editionViewType[fieldName]||viewType;
                if(this._isFieldProtected(record,fieldName,editionViewType)){
                    deletechanges[fieldName];
                    continue;
                }
            }

            //processrelationalfieldsandhandlethenullcase
            vartype=record.fields[fieldName].type;
            varvalue;
            if(type==='one2many'||type==='many2many'){
                if(!changesOnly||(commands[fieldName]&&commands[fieldName].length)){//replacelocalIdbycommands
                    changes[fieldName]=commands[fieldName];
                }else{//nocommand->nochangeforthatfield
                    deletechanges[fieldName];
                }
            }elseif(type==='many2one'&&fieldNameinchanges){
                value=changes[fieldName];
                changes[fieldName]=value?this.localData[value].res_id:false;
            }elseif(type==='reference'&&fieldNameinchanges){
                value=changes[fieldName];
                changes[fieldName]=value?
                    this.localData[value].model+','+this.localData[value].res_id:
                    false;
            }elseif(type==='char'&&changes[fieldName]===''){
                changes[fieldName]=false;
            }elseif(changes[fieldName]===null){
                changes[fieldName]=false;
            }
        }
        returnchanges;
    },
    /**
     *Generatesanobjectmappingfieldnamestotheircurrentvalueinagiven
     *record.Iftherecordisinsideaone2many,thereturnedobjectcontains
     *anadditionalkey(thecorrespondingmany2onefieldname)mappingtothe
     *currentvalueoftheparentrecord.
     *
     *@param{Object}record
     *@param{Object}[options]Thisoptionobjectwillbegiventotheprivate
     *  method_generateX2ManyCommands. Inparticular,itisusefultobeable
     *  tosendchangesOnly:truetogetalldata,notonlythecurrentchanges.
     *@returns{Object}thedata
     */
    _generateOnChangeData:function(record,options){
        options=_.extend({},options||{},{withReadonly:true});
        vardata={};
        if(!options.firstOnChange){
            varcommands=this._generateX2ManyCommands(record,options);
            data=_.extend(this.get(record.id,{raw:true}).data,commands);
            //'display_name'isautomaticallyaddedtothelistoffieldstofetch,
            //whenfetchingarecord,evenifitdoesn'tappearintheview.However,
            //onlythefieldsintheviewmustbepassedtotheonchangeRPC,sowe
            //removeitfromthedatasentbyRPCifitisn'tintheview.
            varhasDisplayName=_.some(record.fieldsInfo,function(fieldsInfo){
                return'display_name'infieldsInfo;
            });
            if(!hasDisplayName){
                deletedata.display_name;
            }
        }

        //one2manyrecordshaveaparentID
        if(record.parentID){
            varparent=this.localData[record.parentID];
            //parentisthelistelementcontainingalltherecordsinthe
            //one2manyandparent.parentIDistheIDofthemainrecord
            //ifthereisarelationfield,thismeansthatrecordisanelem
            //inaone2many.Therelationfieldisthecorrespondingmany2one
            if(parent.parentID&&parent.relationField){
                varparentRecord=this.localData[parent.parentID];
                data[parent.relationField]=this._generateOnChangeData(parentRecord);
            }
        }

        returndata;
    },
    /**
     *Readallx2manyfieldsandgeneratethecommandsfortheservertocreate
     *orwritethem...
     *
     *@param{Object}record
     *@param{Object}[options]
     *@param{string}[options.fieldNames]ifgiven,generatesthecommandsfor
     *  thesefieldsonly
     *@param{boolean}[changesOnly=false]iftrue,onlygeneratescommandsfor
     *  fieldsthathavechanged
     *@param{boolean}[options.withReadonly=false]iffalse,doesn'tgenerate
     *  changesforreadonlyfieldsincommands
     *@returns{Object}amapfromsomefieldnamestocommands
     */
    _generateX2ManyCommands:function(record,options){
        varself=this;
        options=options||{};
        constchangesOnly=options.changesOnly;
        varfields=record.fields;
        if(options.fieldNames){
            fields=_.pick(fields,options.fieldNames);
        }
        varcommands={};
        vardata=_.extend({},record.data,record._changes);
        vartype;
        for(varfieldNameinfields){
            type=fields[fieldName].type;

            if(type==='many2many'||type==='one2many'){
                if(!data[fieldName]){
                    //skipifthisfieldisempty
                    continue;
                }
                commands[fieldName]=[];
                varlist=this.localData[data[fieldName]];
                if(options.changesOnly&&(!list._changes||!list._changes.length)){
                    //ifonlychangesarerequested,skipifthereisnochange
                    continue;
                }
                varoldResIDs=list.res_ids.slice(0);
                varrelRecordAdded=[];
                varrelRecordUpdated=[];
                _.each(list._changes,function(change){
                    if(change.operation==='ADD'&&change.id){
                        relRecordAdded.push(self.localData[change.id]);
                    }elseif(change.operation==='UPDATE'&&!self.isNew(change.id)){
                        //ignorenewrecordsthatwouldhavebeenupdated
                        //afterwards,asalltheirchangeswouldalready
                        //beaggregatedintheCREATEcommand
                        relRecordUpdated.push(self.localData[change.id]);
                    }
                });
                list=this._applyX2ManyOperations(list);
                this._sortList(list);
                if(type==='many2many'||list._forceM2MLink){
                    varrelRecordCreated=_.filter(relRecordAdded,function(rec){
                        returntypeofrec.res_id==='string';
                    });
                    varrealIDs=_.difference(list.res_ids,_.pluck(relRecordCreated,'res_id'));
                    //deliberatelygenerateasingle'replace'commandinstead
                    //ofa'delete'anda'link'commandswiththeexactdiff
                    //because1)performance-wiseitdoesn'tchangeanything
                    //and2)toguardagainstconcurrentupdates(policy:force
                    //acompleteoverrideoftheactualvalueofthem2m)
                    commands[fieldName].push(x2ManyCommands.replace_with(realIDs));
                    _.each(relRecordCreated,function(relRecord){
                        varchanges=self._generateChanges(relRecord,options);
                        commands[fieldName].push(x2ManyCommands.create(relRecord.ref,changes));
                    });
                    //generateupdatecommandsforrecordsthathavebeen
                    //updated(itmayhappenwitheditablelists)
                    _.each(relRecordUpdated,function(relRecord){
                        varchanges=self._generateChanges(relRecord,options);
                        if(!_.isEmpty(changes)){
                            varcommand=x2ManyCommands.update(relRecord.res_id,changes);
                            commands[fieldName].push(command);
                        }
                    });
                }elseif(type==='one2many'){
                    varremovedIds=_.difference(oldResIDs,list.res_ids);
                    varaddedIds=_.difference(list.res_ids,oldResIDs);
                    varkeptIds=_.intersection(oldResIDs,list.res_ids);

                    //thedidChangevariablekeepstrackofthefactthatat
                    //leastoneidwasupdated
                    vardidChange=false;
                    varchanges,command,relRecord;
                    for(vari=0;i<list.res_ids.length;i++){
                        if(_.contains(keptIds,list.res_ids[i])){
                            //thisisanidthatalreadyexisted
                            relRecord=_.findWhere(relRecordUpdated,{res_id:list.res_ids[i]});
                            changes=relRecord?this._generateChanges(relRecord,options):{};
                            if(!_.isEmpty(changes)){
                                command=x2ManyCommands.update(relRecord.res_id,changes);
                                didChange=true;
                            }else{
                                command=x2ManyCommands.link_to(list.res_ids[i]);
                            }
                            commands[fieldName].push(command);
                        }elseif(_.contains(addedIds,list.res_ids[i])){
                            //thisisanewid(maybeexistinginDB,butnewinJS)
                            relRecord=_.findWhere(relRecordAdded,{res_id:list.res_ids[i]});
                            if(!relRecord){
                                commands[fieldName].push(x2ManyCommands.link_to(list.res_ids[i]));
                                continue;
                            }
                            changes=this._generateChanges(relRecord,options);
                            if(!this.isNew(relRecord.id)){
                                //thesubrecordalreadyexistsindb
                                commands[fieldName].push(x2ManyCommands.link_to(relRecord.res_id));
                                if(changesOnly?Object.keys(changes).length:this.isDirty(relRecord.id)){
                                    deletechanges.id;
                                    commands[fieldName].push(x2ManyCommands.update(relRecord.res_id,changes));
                                }
                            }else{
                                //thesubrecordisnew,socreateit

                                //wemayhavereceivedvaluesfromanonchangeforfieldsthatare
                                //notintheview,andthatwedon'tevenknow,aswedon'thavethe
                                //fields_getofmodelsofrelatedfields.Wesavethosevalues
                                //anyway,butformany2ones,wehavetoextracttheidfromthepair
                                //[id,display_name]
                                constrawChangesEntries=Object.entries(relRecord._rawChanges);
                                for(const[fieldName,value]ofrawChangesEntries){
                                    constisMany2OneValue=Array.isArray(value)&&
                                                            value.length===2&&
                                                            Number.isInteger(value[0])&&
                                                            typeofvalue[1]==='string';
                                    changes[fieldName]=isMany2OneValue?value[0]:value;
                                }

                                commands[fieldName].push(x2ManyCommands.create(relRecord.ref,changes));
                            }
                        }
                    }
                    if(options.changesOnly&&!didChange&&addedIds.length===0&&removedIds.length===0){
                        //inthissituation,wehavenochangedids,noadded
                        //idsandnoremovedids,sowecansafelyignorethe
                        //lastchanges
                        commands[fieldName]=[];
                    }
                    //adddeletecommands
                    for(i=0;i<removedIds.length;i++){
                        if(list._forceM2MUnlink){
                            commands[fieldName].push(x2ManyCommands.forget(removedIds[i]));
                        }else{
                            commands[fieldName].push(x2ManyCommands.delete(removedIds[i]));
                        }
                    }
                }
            }
        }
        returncommands;
    },
    /**
     *EveryRPCdonebythemodelneedtoaddsomecontext,whichisa
     *combinationofthecontextofthesession,oftherecord/list,and/orof
     *theconcernedfield.Thismethodcombinesallthesecontextsandevaluate
     *themwiththeproperevalcontext.
     *
     *@param{Object}elementanelementfromthelocalData
     *@param{Object}[options]
     *@param{string|Object}[options.additionalContext]
     *       anothercontexttoevaluateandmergetothereturnedcontext
     *@param{string}[options.fieldName]
     *       ifgiven,thisfield'scontextisaddedtothecontext,insteadof
     *       theelement'scontext(exceptifoptions.fullistrue)
     *@param{boolean}[options.full=false]
     *       iftrueornorfieldNameoradditionalContextgiveninoptions,
     *       theelement'scontextisaddedtothecontext
     *@returns{Object}theevaluatedcontext
     */
    _getContext:function(element,options){
        options=options||{};
        varcontext=newContext(session.user_context);
        context.set_eval_context(this._getEvalContext(element));

        if(options.full||!(options.fieldName||options.additionalContext)){
            varcontext_to_add=options.sanitize_default_values?
                _.omit(element.context,function(val,key){
                    return_.str.startsWith(key,'default_');
                })
                :element.context;
            context.add(context_to_add);
        }
        if(options.fieldName){
            varviewType=options.viewType||element.viewType;
            varfieldInfo=element.fieldsInfo[viewType][options.fieldName];
            if(fieldInfo&&fieldInfo.context){
                context.add(fieldInfo.context);
            }else{
                varfieldParams=element.fields[options.fieldName];
                if(fieldParams.context){
                    context.add(fieldParams.context);
                }
            }
        }
        if(options.additionalContext){
            context.add(options.additionalContext);
        }
        if(element.rawContext){
            varrawContext=newContext(element.rawContext);
            varevalContext=this._getEvalContext(this.localData[element.parentID]);
            evalContext.id=evalContext.id||false;
            rawContext.set_eval_context(evalContext);
            context.add(rawContext);
        }

        returncontext.eval();
    },
    /**
     *Collectsfromarecordalistofidstofetch,accordingtofieldName,
     *andalistofrecordswheretosettheresultofthefetch.
     *
     *@param{Object}listalistcontainingrecordswewanttogettheids,
     *  itassumes_applyX2ManyOperationsand_sorthavebeenalreadycalledon
     *  thislist
     *@param{string}fieldName
     *@return{Object}alistofrecordsandres_ids
     */
    _getDataToFetch:function(list,fieldName){
        varself=this;
        varfield=list.fields[fieldName];
        varfieldInfo=list.fieldsInfo[list.viewType][fieldName];
        varview=fieldInfo.views&&fieldInfo.views[fieldInfo.mode];
        varfieldsInfo=view?view.fieldsInfo:fieldInfo.fieldsInfo;
        varfields=view?view.fields:fieldInfo.relatedFields;
        varviewType=view?view.type:fieldInfo.viewType;

        vartoFetch={};

        //flattensthelist.dataidsinagroupedcase
        letdataPointIds=list.data;
        for(leti=0;i<list.groupedBy.length;i++){
            dataPointIds=dataPointIds.reduce((acc,groupId)=>
                acc.concat(this.localData[groupId].data),[]);
        }

        dataPointIds.forEach(function(dataPoint){
            varrecord=self.localData[dataPoint];
            if(typeofrecord.data[fieldName]==='string'){
                //inthiscase,thevalueisalocalID,whichmeansthatthe
                //recordhasalreadybeenprocessed.Itcanhappenforexample
                //whenauseraddsarecordinam2mrelation,orloadsmore
                //recordsinakanbancolumn
                return;
            }

            _.each(record.data[fieldName],function(id){
                toFetch[id]=toFetch[id]||[];
                toFetch[id].push(record);
            });

            varm2mList=self._makeDataPoint({
                fieldsInfo:fieldsInfo,
                fields:fields,
                modelName:field.relation,
                parentID:record.id,
                res_ids:record.data[fieldName],
                static:true,
                type:'list',
                viewType:viewType,
            });
            record.data[fieldName]=m2mList.id;
        });

        returntoFetch;
    },
    /**
     *Determinesandreturnsfromalistacollectionofidsclassedby
     *theirmodel.
     *
     *@param{Object}listavalidresourceobject
     *@param{string}fieldName
     *@param{Object}[toFetchAcc]anobjecttostorefetchingdata.Usedwhen
     * batchingreferenceacrossmultiplegroups.
     *   [modelName:string]:{
     *       [recordId:number]:datapointId[]
     *   }
     *@returns{Object}eachkeyrepresentamodelandcontainasub-object
     *whereeachkeyrepresentanid(res_id)containinganarrayof
     *webclientid(referredtoadatapoint,sonotares_id).
     */
    _getDataToFetchByModel:function(list,fieldName,toFetchAcc){
        varself=this;
        vartoFetch=toFetchAcc||{};
        _.each(list.data,function(dataPoint){
            varrecord=self.localData[dataPoint];
            varvalue=record.data[fieldName];
            //ifthereferencefieldhasalreadybeenfetched,thevalueisa
            //datapointID,andinthiscasethere'snothingtodo
            if(value&&!self.localData[value]){
                varmodel=value.split(',')[0];
                varresID=value.split(',')[1];
                if(!(modelintoFetch)){
                    toFetch[model]={};
                }
                //therecouldbemultipledatapointswiththesamemodel/resID
                if(toFetch[model][resID]){
                    toFetch[model][resID].push(dataPoint);
                }else{
                    toFetch[model][resID]=[dataPoint];
                }
            }
        });
        returntoFetch;
    },
    /**
     *GivenadataPointoftypelist(thatmaybeagroup),returnsanobject
     *with'default_'keystobeusedtocreatenewrecordsinthatgroup.
     *
     *@private
     *@param{Object}dataPoint
     *@returns{Object}
     */
    _getDefaultContext:function(dataPoint){
        vardefaultContext={};
        while(dataPoint.parentID){
            varparent=this.localData[dataPoint.parentID];
            vargroupByField=parent.groupedBy[0].split(':')[0];
            varvalue=viewUtils.getGroupValue(dataPoint,groupByField);
            if(value){
                defaultContext['default_'+groupByField]=value;
            }
            dataPoint=parent;
        }
        returndefaultContext;
    },
    /**
     *Somerecordsareassociatedtoa/somedomain(s).Thismethodallowsto
     *retrievethem,evaluated.
     *
     *@param{Object}elementanelementfromthelocalData
     *@param{Object}[options]
     *@param{string}[options.fieldName]
     *       thenameofthefieldwhosedomainneedstobereturned
     *@returns{Array}theevaluateddomain
     */
    _getDomain:function(element,options){
        if(options&&options.fieldName){
            if(element._domains[options.fieldName]){
                returnDomain.prototype.stringToArray(
                    element._domains[options.fieldName],
                    this._getEvalContext(element,true)
                );
            }
            varviewType=options.viewType||element.viewType;
            varfieldInfo=element.fieldsInfo[viewType][options.fieldName];
            if(fieldInfo&&fieldInfo.domain){
                returnDomain.prototype.stringToArray(
                    fieldInfo.domain,
                    this._getEvalContext(element,true)
                );
            }
            varfieldParams=element.fields[options.fieldName];
            if(fieldParams.domain){
                returnDomain.prototype.stringToArray(
                    fieldParams.domain,
                    this._getEvalContext(element,true)
                );
            }
            return[];
        }

        returnDomain.prototype.stringToArray(
            element.domain,
            this._getEvalContext(element,true)
        );
    },
    /**
     *Returnstheevaluationcontextthatshouldbeusedwhenevaluatingthe
     *context/domainassociatedtoagivenelementfromthelocalData.
     *
     *Itisactuallyquitesubtle. Weneedtoaddsomemagickeys:active_id
     *andactive_ids. Also,thesessionusercontextisaddedinthemixtobe
     *sure. Thisallowssomedomainstousetheuidkeyforexample
     *
     *@param{Object}element-anelementfromthelocalData
     *@param{boolean}[forDomain=false]iftrue,evaluatesx2manysasalistof
     *  idsinsteadofalistofcommands
     *@returns{Object}
     */
    _getEvalContext:function(element,forDomain){
        varevalContext=element.type==='record'?this._getRecordEvalContext(element,forDomain):{};

        if(element.parentID){
            varparent=this.localData[element.parentID];
            if(parent.type==='list'&&parent.parentID){
                parent=this.localData[parent.parentID];
            }
            if(parent.type==='record'){
                evalContext.parent=this._getRecordEvalContext(parent,forDomain);
            }
        }
        //Uses"current_company_id"because"company_id"wouldconflictwithallthecompany_idfields
        //ingeneral,theactual"company_id"fieldoftheformshouldbeusedform2odomains,notthisfallback
        letcurrent_company_id;
        if(session.user_context.allowed_company_ids){
            current_company_id=session.user_context.allowed_company_ids[0];
        }else{
            current_company_id=session.user_companies?
                session.user_companies.current_company[0]:
                false;
        }
        returnObject.assign(
            {
                active_id:evalContext.id||false,
                active_ids:evalContext.id?[evalContext.id]:[],
                active_model:element.model,
                current_company_id,
                id:evalContext.id||false,
            },
            pyUtils.context(),
            session.user_context,
            element.context,
            evalContext,
        );
    },
    /**
     *Returnsthelistoffieldnamesofthegivenelementaccordingtoits
     *defaultviewtype.
     *
     *@param{Object}elementanelementfromthelocalData
     *@param{Object}[options]
     *@param{Object}[options.viewType]currentviewType.Ifnotset,wewill
     *  assumemainviewTypefromtherecord
     *@returns{string[]}thelistoffieldnames
     */
    _getFieldNames:function(element,options){
        varfieldsInfo=element.fieldsInfo;
        varviewType=options&&options.viewType||element.viewType;
        returnObject.keys(fieldsInfo&&fieldsInfo[viewType]||{});
    },
    /**
     *Getmany2onefieldsnamesinadatapoint.Thisisusefulinorderto
     *fetchtheirnamesinthecaseofadefault_get.
     *
     *@private
     *@param{Object}datapointavalidresourceobject
     *@returns{string[]}listoffieldnamesthataremany2one
     */
    _getMany2OneFieldNames:function(datapoint){
        varmany2ones=[];
        _.each(datapoint.fields,function(field,name){
            if(field.type==='many2one'){
                many2ones.push(name);
            }
        });
        returnmany2ones;
    },
    /**
     *Evaluatetherecordevaluationcontext. Thismethodissupposedtobe
     *calledby_getEvalContext. Itbasicallyonlygeneratesadictionaryof
     *currentvaluesfortherecord,withcommandsforx2manysfields.
     *
     *@param{Object}recordanelementoftype'record'
     *@param{boolean}[forDomain=false]iftrue,x2manyvaluesarealistof
     *  idsinsteadofalistofcommands
     *@returnsObject
     */
    _getRecordEvalContext:function(record,forDomain){
        varself=this;
        varrelDataPoint;
        varcontext=_.extend({},record.data,record._changes);

        //calls_generateX2ManyCommandsforagivenfield,andreturnsthearrayofcommands
        function_generateX2ManyCommands(fieldName){
            varcommands=self._generateX2ManyCommands(record,{fieldNames:[fieldName]});
            returncommands[fieldName];
        }

        for(varfieldNameincontext){
            varfield=record.fields[fieldName];
            if(context[fieldName]===null){
                context[fieldName]=false;
            }
            if(!field||field.name==='id'){
                continue;
            }
            if(field.type==='date'||field.type==='datetime'){
                if(context[fieldName]){
                    context[fieldName]=JSON.parse(JSON.stringify(context[fieldName]));
                }
                continue;
            }
            if(field.type==='many2one'){
                relDataPoint=this.localData[context[fieldName]];
                context[fieldName]=relDataPoint?relDataPoint.res_id:false;
                continue;
            }
            if(field.type==='one2many'||field.type==='many2many'){
                varids;
                if(!context[fieldName]||_.isArray(context[fieldName])){//nodataPointcreatedyet
                    ids=context[fieldName]?context[fieldName].slice(0):[];
                }else{
                    relDataPoint=this._applyX2ManyOperations(this.localData[context[fieldName]]);
                    ids=relDataPoint.res_ids.slice(0);
                }
                if(!forDomain){
                    //whensenttotheserver,thex2manysvaluesmustbealist
                    //ofcommandsinacontext,butthelistofidsinadomain
                    ids.toJSON=_generateX2ManyCommands.bind(null,fieldName);
                }elseif(field.type==='one2many'){//Idsareevaluatedasalistofids
                    /*Filteringoutvirtualidsfromtheidslist
                     *Theserverwillcrashiftherearevirtualidsinthere
                     *ThewebClientdoesn'tdoliteralidlistcomparisonlikeids==list
                     *Onlyrelevantino2m:m2mdoescreateactualrecordsindb
                     */
                    ids=_.filter(ids,function(id){
                        returntypeofid!=='string';
                    });
                }
                context[fieldName]=ids;
            }

        }
        returncontext;
    },
    /**
     *InvalidatestheDataManager'scacheifthemainmodel(i.e.themodelof
     *itsrootparent)ofthegivendataPointisamodelin'noCacheModels'.
     *
     *Reloadsthecurrenciesifthemainmodelis'res.currency'.
     *Reloadsthewebclientifwemodifyares.company,to(un)activatethe
     *multi-companyenvironmentifwearenotinatourtest.
     *
     *@private
     *@param{Object}dataPoint
     */
    _invalidateCache:function(dataPoint){
        while(dataPoint.parentID){
            dataPoint=this.localData[dataPoint.parentID];
        }
        if(dataPoint.model==='res.currency'){
            session.reloadCurrencies();
        }
        if(dataPoint.model==='res.company'&&!localStorage.getItem('running_tour')){
            this.do_action('reload_context');
        }
        if(_.contains(this.noCacheModels,dataPoint.model)){
            core.bus.trigger('clear_cache');
        }
    },
    /**
     *Returnstrueifthefieldisprotectedagainstchanges,lookingfora
     *readonlymodifierunlessthereisaforce_savemodifier(checkingfirst
     *inthemodifiers,andifthereisnoreadonlymodifier,checkingthe
     *readonlyattributeofthefield).
     *
     *@private
     *@param{Object}recordanelementfromthelocalData
     *@param{string}fieldName
     *@param{string}[viewType]currentviewType.Ifnotset,wewillassume
     *  mainviewTypefromtherecord
     *@returns{boolean}
     */
    _isFieldProtected:function(record,fieldName,viewType){
        viewType=viewType||record.viewType;
        varfieldInfo=viewType&&record.fieldsInfo&&record.fieldsInfo[viewType][fieldName];
        if(fieldInfo){
            varrawModifiers=fieldInfo.modifiers||{};
            varmodifiers=this._evalModifiers(record,_.pick(rawModifiers,'readonly'));
            returnmodifiers.readonly&&!fieldInfo.force_save;
        }else{
            returnfalse;
        }
    },
    /**
     *Returnstrueiffvalueisconsideredtobesetforthegivenfield'stype.
     *
     *@private
     *@param{any}valueavalueforthefield
     *@param{string}fieldTypeatypeoffield
     *@returns{boolean}
     */
    _isFieldSet:function(value,fieldType){
        switch(fieldType){
            case'boolean':
                returntrue;
            case'one2many':
            case'many2many':
                returnvalue.length>0;
            default:
                returnvalue!==false;
        }
    },
    /**
     *returntrueifalistelementis'valid'.Suchanelementisvalidifit
     *hasnosubrecordwithanunsetrequiredfield.
     *
     *Thismethodismeanttobeusedtocheckifax2manychangewilltrigger
     *anonchange.
     *
     *@param{string}ididforalocalresourceoftype'list'.Thisis
     *  assumedtobealistelementforanx2many
     *@returns{boolean}
     */
    _isX2ManyValid:function(id){
        varself=this;
        varisValid=true;
        varelement=this.localData[id];
        _.each(element._changes,function(command){
            if(command.operation==='DELETE'||
                    command.operation==='FORGET'||
                    (command.operation==='ADD'&& !command.isNew)||
                    command.operation==='REMOVE_ALL'){
                return;
            }
            varrecordData=self.get(command.id,{raw:true}).data;
            varrecord=self.localData[command.id];
            _.each(element.getFieldNames(),function(fieldName){
                varfield=element.fields[fieldName];
                varfieldInfo=element.fieldsInfo[element.viewType][fieldName];
                varrawModifiers=fieldInfo.modifiers||{};
                varmodifiers=self._evalModifiers(record,_.pick(rawModifiers,'required'));
                if(modifiers.required&&!self._isFieldSet(recordData[fieldName],field.type)){
                    isValid=false;
                }
            });
        });
        returnisValid;
    },
    /**
     *Helpermethodfortheloadentrypoint.
     *
     *@seeload
     *
     *@param{Object}dataPointsomelocalresource
     *@param{Object}[options]
     *@param{string[]}[options.fieldNames]thefieldstofetchforarecord
     *@param{boolean}[options.onlyGroups=false]
     *@param{boolean}[options.keepEmptyGroups=false]ifset,thegroupsnot
     *  presentintheread_groupanymore(emptygroups)willstayinthe
     *  datapoint(usedtomimicthekanbanrendererbehaviourforexample)
     *@returns{Promise}
     */
    _load:function(dataPoint,options){
        if(options&&options.onlyGroups&&
          !(dataPoint.type==='list'&&dataPoint.groupedBy.length)){
            returnPromise.resolve(dataPoint);
        }

        if(dataPoint.type==='record'){
            returnthis._fetchRecord(dataPoint,options);
        }
        if(dataPoint.type==='list'&&dataPoint.groupedBy.length){
            returnthis._readGroup(dataPoint,options);
        }
        if(dataPoint.type==='list'&&!dataPoint.groupedBy.length){
            returnthis._fetchUngroupedList(dataPoint,options);
        }
    },
    /**
     *Turnsabagofpropertiesintoavalidlocalresource. Also,register
     *theresourceinthelocalDataobject.
     *
     *@param{Object}params
     *@param{Object}[params.aggregateValues={}]
     *@param{Object}[params.context={}]contextoftheaction
     *@param{integer}[params.count=0]numberofrecordbeingmanipulated
     *@param{Object|Object[]}[params.data={}|[]]dataoftherecord
     *@param{*[]}[params.domain=[]]
     *@param{Object}params.fieldscontainsthedescriptionofeachfield
     *@param{Object}[params.fieldsInfo={}]containsthefieldInfoofeachfield
     *@param{Object[]}[params.fieldNames]thenameoffieldstoload,thelist
     *  ofallfieldsbydefault
     *@param{string[]}[params.groupedBy=[]]
     *@param{boolean}[params.isOpen]
     *@param{integer}params.limitmaxnumberofrecordsshownonscreen(pagersize)
     *@param{string}params.modelName
     *@param{integer}[params.offset]
     *@param{boolean}[params.openGroupByDefault]
     *@param{Object[]}[params.orderedBy=[]]
     *@param{integer[]}[params.orderedResIDs]
     *@param{string}[params.parentID]modelnameIDoftheparentmodel
     *@param{Object}[params.rawContext]
     *@param{[type]}[params.ref]
     *@param{string}[params.relationField]
     *@param{integer|null}[params.res_id]actualidofrecordintheserver
     *@param{integer[]}[params.res_ids]contextinwhichthedatapointisused,fromalistofres_id
     *@param{boolean}[params.static=false]
     *@param{string}[params.type='record'|'list']
     *@param{[type]}[params.value]
     *@param{string}[params.viewType]thetypeoftheview,e.g.'list'or'form'
     *@returns{Object}theresourcecreated
     */
    _makeDataPoint:function(params){
        vartype=params.type||('domain'inparams&&'list')||'record';
        varres_id,value;
        varres_ids=params.res_ids||[];
        vardata=params.data||(type==='record'?{}:[]);
        varcontext=params.context;
        if(type==='record'){
            res_id=params.res_id||(params.data&&params.data.id);
            if(res_id){
                data.id=res_id;
            }else{
                res_id=_.uniqueId('virtual_');
            }
            //itdoesn'tmakesenseforarecorddatapointtohavethosekeys
            //besides,itwillmessupx2mandactionsdowntheline
            context=_.omit(context,['orderedBy','group_by']);
        }else{
            varisValueArray=params.valueinstanceofArray;
            res_id=isValueArray?params.value[0]:undefined;
            value=isValueArray?params.value[1]:params.value;
        }

        varfields=_.extend({
            display_name:{type:'char'},
            id:{type:'integer'},
        },params.fields);

        vardataPoint={
            _cache:type==='list'?{}:undefined,
            _changes:null,
            _domains:{},
            _rawChanges:{},
            aggregateValues:params.aggregateValues||{},
            context:context,
            count:params.count||res_ids.length,
            data:data,
            domain:params.domain||[],
            fields:fields,
            fieldsInfo:params.fieldsInfo,
            groupedBy:params.groupedBy||[],
            groupsCount:0,
            groupsLimit:type==='list'&&params.groupsLimit||null,
            groupsOffset:0,
            id:`${params.modelName}_${++this.__id}`,
            isOpen:params.isOpen,
            limit:type==='record'?1:(params.limit||Number.MAX_SAFE_INTEGER),
            loadMoreOffset:0,
            model:params.modelName,
            offset:params.offset||(type==='record'?_.indexOf(res_ids,res_id):0),
            openGroupByDefault:params.openGroupByDefault,
            orderedBy:params.orderedBy||[],
            orderedResIDs:params.orderedResIDs,
            parentID:params.parentID,
            rawContext:params.rawContext,
            ref:params.ref||res_id,
            relationField:params.relationField,
            res_id:res_id,
            res_ids:res_ids,
            specialData:{},
            _specialDataCache:{},
            static:params.static||false,
            type:type, //'record'|'list'
            value:value,
            viewType:params.viewType,
        };

        //_editionViewTypeisadictwhosekeysarefieldnamesandwhichispopulatedwhenafield
        //iseditedwiththeviewTypeasvalue.Thisisusefulforone2manystodeterminewhether
        //ornotafieldisreadonly(usingthereadonlymodifiersoftheviewinwhichthefield
        //hasbeenedited)
        dataPoint._editionViewType={};

        dataPoint.evalModifiers=this._evalModifiers.bind(this,dataPoint);
        dataPoint.getContext=this._getContext.bind(this,dataPoint);
        dataPoint.getDomain=this._getDomain.bind(this,dataPoint);
        dataPoint.getFieldNames=this._getFieldNames.bind(this,dataPoint);
        dataPoint.isDirty=this.isDirty.bind(this,dataPoint.id);

        this.localData[dataPoint.id]=dataPoint;

        returndataPoint;
    },
    /**
     *Whenoneneedstocreatearecordfromscratch,anotsosimpleprocess
     *needstobedone:
     *-callthe/default_getroutetogetdefaultvalues
     *-fetchallrelationaldata
     *-applyallonchangesifnecessary
     *-fetchallrelationaldata
     *
     *Thismethodtriestooptimizetheprocessasmuchaspossible. Also,
     *itisquitehorribleandshouldberefactoredatsomepoint.
     *
     *@private
     *@param{any}params
     *@param{string}modelNamemodelname
     *@param{boolean}[params.allowWarning=false]iftrue,thedefaultrecord
     *  operationcancomplete,evenifawarningisraised
     *@param{Object}params.contextthecontextforthenewrecord
     *@param{Object}params.fieldsInfocontainsthefieldInfoofeachview,
     *  foreachfield
     *@param{Object}params.fieldscontainsthedescriptionofeachfield
     *@param{Object}params.contextthecontextforthenewrecord
     *@param{string}params.viewTypethekeyinfieldsInfoofthefieldstoload
     *@returns{Promise<string>}resolvestotheidforthecreatedresource
     */
    async_makeDefaultRecord(modelName,params){
        vartargetView=params.viewType;
        varfields=params.fields;
        varfieldsInfo=params.fieldsInfo;
        varfieldNames=Object.keys(fieldsInfo[targetView]);

        //Fieldsthatarepresentintheoriginatingview,thatneedtobeinitialized
        //Hencepreventingtheirvaluetocrashwhengettingbacktotheoriginatingview
        varparentRecord=params.parentID&&this.localData[params.parentID].type==='list'?this.localData[params.parentID]:null;

        if(parentRecord&&parentRecord.viewTypeinparentRecord.fieldsInfo){
            varoriginView=parentRecord.viewType;
            fieldNames=_.union(fieldNames,Object.keys(parentRecord.fieldsInfo[originView]));
            fieldsInfo[targetView]=_.defaults({},fieldsInfo[targetView],parentRecord.fieldsInfo[originView]);
            fields=_.defaults({},fields,parentRecord.fields);
        }

        varrecord=this._makeDataPoint({
            modelName:modelName,
            fields:fields,
            fieldsInfo:fieldsInfo,
            context:params.context,
            parentID:params.parentID,
            res_ids:params.res_ids,
            viewType:targetView,
        });

        awaitthis.generateDefaultValues(record.id,{},{fieldNames});
        try{
            awaitthis._performOnChange(record,[],{firstOnChange:true});
        }finally{
            if(record._warning&&params.allowWarning){
                deleterecord._warning;
            }
        }
        if(record._warning){
            returnPromise.reject();
        }

        //Wewanttooverwritethedefaultvalueofthehandlefield(ifany),
        //inorderfornewlinestobeaddedatthecorrectposition.
        //->Thisisararecasewherethedefaul_getfromtheserver
        //   willbeignoredbytheviewforacertainfield(usually"sequence").
        varoverrideDefaultFields=this._computeOverrideDefaultFields(params.parentID,params.position);
        if(overrideDefaultFields.field){
            record._changes[overrideDefaultFields.field]=overrideDefaultFields.value;
        }

        //fetchadditionaldata(specialdataandmany2onenamegetsfor"always_reload"fields)
        awaitthis._postprocess(record);
        //saveinitialchanges,sotheycanberestoredlater,ifweneedtodiscard
        this.save(record.id,{savePoint:true});
        returnrecord.id;
    },
    /**
     *parsetheservervaluestojavascriptframwork
     *
     *@param{[string]}fieldNames
     *@param{Object}elementthedataPointusedasparentforthecreated
     *  dataPoints
     *@param{Object}datatheserverdatatoparse
     */
    _parseServerData:function(fieldNames,element,data){
        varself=this;
        _.each(fieldNames,function(fieldName){
            varfield=element.fields[fieldName];
            varval=data[fieldName];
            if(field.type==='many2one'){
                //processmany2one:split[id,nameget]andcreatecorrespondingrecord
                if(val!==false){
                    //themany2onevalueisoftheform[id,display_name]
                    varr=self._makeDataPoint({
                        modelName:field.relation,
                        fields:{
                            display_name:{type:'char'},
                            id:{type:'integer'},
                        },
                        data:{
                            display_name:val[1],
                            id:val[0],
                        },
                        parentID:element.id,
                    });
                    data[fieldName]=r.id;
                }else{
                    //novalueforthemany2one
                    data[fieldName]=false;
                }
            }else{
                data[fieldName]=self._parseServerValue(field,val);
            }
        });
    },
    /**
     *Thismethodisquiteimportant:itissupposedtoperformthe/onchange
     *rpcandapplytheresult.
     *
     *Thechangesthattriggeredtheonchangeareassumedtohavealreadybeen
     *appliedtotherecord.
     *
     *@param{Object}record
     *@param{string[]}fieldschangedfields(emptylistinthecaseoffirst
     *  onchange)
     *@param{Object}[options={}]
     *@param{string}[options.viewType]currentviewType.Ifnotset,wewillassume
     *  mainviewTypefromtherecord
     *@param{boolean}[options.firstOnChange=false]settotrueifthisisthe
     *  firstonchange
     *@returns{Promise}
     */
    async_performOnChange(record,fields,options={}){
        constfirstOnChange=options.firstOnChange;
        let{hasOnchange,onchangeSpec}=this._buildOnchangeSpecs(record,options.viewType);
        if(!firstOnChange&&!hasOnchange){
            return;
        }
        varidList=record.data.id?[record.data.id]:[];
        constctxOptions={
            full:true,
        };
        if(fields.length===1){
            fields=fields[0];
            //ifonlyonefieldchanged,additscontexttotheRPCcontext
            ctxOptions.fieldName=fields;
        }
        varcontext=this._getContext(record,ctxOptions);
        varcurrentData=this._generateOnChangeData(record,{
            changesOnly:false,
            firstOnChange,
        });

        constresult=awaitthis._rpc({
            model:record.model,
            method:'onchange',
            args:[idList,currentData,fields,onchangeSpec],
            context:context,
        });
        if(!record._changes){
            //ifthe_changeskeydoesnotexistanymore,itmeansthat
            //itwasremovedbydiscardingthechangesaftertherpc
            //toonchange.So,inthatcase,theproperresponseisto
            //ignoretheonchange.
            return;
        }
        if(result.warning){
            this.trigger_up('warning',result.warning);
            record._warning=true;
        }
        if(result.domain){
            record._domains=Object.assign(record._domains,result.domain);
        }
        awaitthis._applyOnChange(result.value,record,{firstOnChange});
        returnresult;
    },
    /**
     *ThisfunctionaccumulatesRPCrequestsdoneinthesamecallstack,and
     *performstheminthenextmicrotaskticksothatsimilarrequestscanbe
     *batchedinasingleRPC.
     *
     *Fornow,only'read'callsaresupported.
     *
     *@private
     *@param{Object}params
     *@returns{Promise}
     */
    _performRPC:function(params){
        varself=this;

        //savetheRPCrequest
        varrequest=_.extend({},params);
        varprom=newPromise(function(resolve,reject){
            request.resolve=resolve;
            request.reject=reject;
        });
        this.batchedRPCsRequests.push(request);

        //emptythepoolofRPCrequestsinthenextmicrotick
        Promise.resolve().then(function(){
            if(!self.batchedRPCsRequests.length){
                //poolhasalreadybeenprocessed
                return;
            }

            //resetpoolofRPCrequests
            varbatchedRPCsRequests=self.batchedRPCsRequests;
            self.batchedRPCsRequests=[];

            //batchsimilarrequests
            varbatches={};
            varkey;
            for(vari=0;i<batchedRPCsRequests.length;i++){
                varrequest=batchedRPCsRequests[i];
                key=request.model+','+JSON.stringify(request.context);
                if(!batches[key]){
                    batches[key]=_.extend({},request,{requests:[request]});
                }else{
                    batches[key].ids=_.uniq(batches[key].ids.concat(request.ids));
                    batches[key].fieldNames=_.uniq(batches[key].fieldNames.concat(request.fieldNames));
                    batches[key].requests.push(request);
                }
            }

            //performbatchedRPCs
            functiononSuccess(batch,results){
                for(vari=0;i<batch.requests.length;i++){
                    varrequest=batch.requests[i];
                    varfieldNames=request.fieldNames.concat(['id']);
                    varfilteredResults=results.filter(function(record){
                        returnrequest.ids.indexOf(record.id)>=0;
                    }).map(function(record){
                        return_.pick(record,fieldNames);
                    });
                    request.resolve(filteredResults);
                }
            }
            functiononFailure(batch,error){
                for(vari=0;i<batch.requests.length;i++){
                    varrequest=batch.requests[i];
                    request.reject(error);
                }
            }
            for(keyinbatches){
                varbatch=batches[key];
                self._rpc({
                    model:batch.model,
                    method:'read',
                    args:[batch.ids,batch.fieldNames],
                    context:batch.context,
                }).then(onSuccess.bind(null,batch)).guardedCatch(onFailure.bind(null,batch));
            }
        });

        returnprom;
    },
    /**
     *Oncearecordiscreatedandsomedatahasbeenfetched,weneedtodo
     *quitealotofcomputationstodeterminewhatneedstobefetched.This
     *methodisdoingthat.
     *
     *@see_fetchRecord@see_makeDefaultRecord
     *
     *@param{Object}record
     *@param{Object}[options]
     *@param{Object}[options.viewType]currentviewType.Ifnotset,wewill
     *  assumemainviewTypefromtherecord
     *@returns{Promise<Object>}resolvestothefinishedresource
     */
    _postprocess:function(record,options){
        varself=this;
        varviewType=options&&options.viewType||record.viewType;
        vardefs=[];

        _.each(record.getFieldNames(options),function(name){
            varfield=record.fields[name];
            varfieldInfo=record.fieldsInfo[viewType][name]||{};
            varoptions=fieldInfo.options||{};
            if(options.always_reload){
                if(record.fields[name].type==='many2one'){
                    const_changes=record._changes||{};
                    constrelRecordId=_changes[name]||record.data[name];
                    if(!relRecordId){
                        return;//fieldisunset,noneedtodothename_get
                    }
                    varrelRecord=self.localData[relRecordId];
                    defs.push(self._rpc({
                            model:field.relation,
                            method:'name_get',
                            args:[relRecord.data.id],
                            context:self._getContext(record,{fieldName:name,viewType:viewType}),
                        })
                        .then(function(result){
                            relRecord.data.display_name=result[0][1];
                        }));
                }
            }
        });

        defs.push(this._fetchSpecialData(record,options));

        returnPromise.all(defs).then(function(){
            returnrecord;
        });
    },
    /**
     *Processx2manycommandsinadefaultrecordbytransformingthelistof
     *commandsinoperations(pushedin_changes)andfetchtherelated
     *recordsfields.
     *
     *Notethatthismethodcanbecalledrecursively.
     *
     *@todoinmaster:factorizethiscodewiththepostprocessingofx2manyin
     * _applyOnChange
     *
     *@private
     *@param{Object}record
     *@param{string}fieldName
     *@param{Array[Array]}commands
     *@param{Object}[options]
     *@param{string}[options.viewType]currentviewType.Ifnotset,wewill
     *  assumemainviewTypefromtherecord
     *@returns{Promise}
     */
    _processX2ManyCommands:function(record,fieldName,commands,options){
        varself=this;
        options=options||{};
        vardefs=[];
        varfield=record.fields[fieldName];
        varfieldInfo=record.fieldsInfo[options.viewType||record.viewType][fieldName]||{};
        varview=fieldInfo.views&&fieldInfo.views[fieldInfo.mode];
        varfieldsInfo=view?view.fieldsInfo:fieldInfo.fieldsInfo;
        varfields=view?view.fields:fieldInfo.relatedFields;
        varviewType=view?view.type:fieldInfo.viewType;

        //removedefault_*keysfromparentcontexttoavoidissueofsamefieldnameinx2m
        varparentContext=_.omit(record.context,function(val,key){
            return_.str.startsWith(key,'default_');
        });
        varx2manyList=self._makeDataPoint({
            context:parentContext,
            fieldsInfo:fieldsInfo,
            fields:fields,
            limit:fieldInfo.limit,
            modelName:field.relation,
            parentID:record.id,
            rawContext:fieldInfo&&fieldInfo.context,
            relationField:field.relation_field,
            res_ids:[],
            static:true,
            type:'list',
            viewType:viewType,
        });
        record._changes[fieldName]=x2manyList.id;
        x2manyList._changes=[];
        varmany2ones={};
        varr;
        commands=commands||[];//handlefalsevalue
        varisCommandList=commands.length&&_.isArray(commands[0]);
        if(!isCommandList){
            commands=[[6,false,commands]];
        }
        _.each(commands,function(value){
            //valueisacommand
            if(value[0]===0){
                //CREATE
                r=self._makeDataPoint({
                    modelName:x2manyList.model,
                    context:x2manyList.context,
                    fieldsInfo:fieldsInfo,
                    fields:fields,
                    parentID:x2manyList.id,
                    viewType:viewType,
                });
                r._noAbandon=true;
                x2manyList._changes.push({operation:'ADD',id:r.id});
                x2manyList._cache[r.res_id]=r.id;

                //thisisnecessarysothefieldsareinitialized
                _.each(r.getFieldNames(),function(fieldName){
                    r.data[fieldName]=null;
                });

                r._changes=_.defaults(value[2],r.data);
                for(varfieldNameinr._changes){
                    if(!r._changes[fieldName]){
                        continue;
                    }
                    varisFieldInView=fieldNameinr.fields;
                    if(isFieldInView){
                        varfield=r.fields[fieldName];
                        varfieldType=field.type;
                        varrec;
                        if(fieldType==='many2one'){
                            rec=self._makeDataPoint({
                                context:r.context,
                                modelName:field.relation,
                                data:{id:r._changes[fieldName]},
                                parentID:r.id,
                            });
                            r._changes[fieldName]=rec.id;
                            many2ones[fieldName]=true;
                        }elseif(fieldType==='reference'){
                            varreference=r._changes[fieldName].split(',');
                            rec=self._makeDataPoint({
                                context:r.context,
                                modelName:reference[0],
                                data:{id:parseInt(reference[1])},
                                parentID:r.id,
                            });
                            r._changes[fieldName]=rec.id;
                            many2ones[fieldName]=true;
                        }elseif(_.contains(['one2many','many2many'],fieldType)){
                            varx2mCommands=value[2][fieldName];
                            defs.push(self._processX2ManyCommands(r,fieldName,x2mCommands));
                        }else{
                            r._changes[fieldName]=self._parseServerValue(field,r._changes[fieldName]);
                        }
                    }
                }
            }
            if(value[0]===6){
                //REPLACE_WITH
                _.each(value[2],function(res_id){
                    x2manyList._changes.push({operation:'ADD',resID:res_id});
                });
                vardef=self._readUngroupedList(x2manyList).then(function(){
                    returnPromise.all([
                        self._fetchX2ManysBatched(x2manyList),
                        self._fetchReferencesBatched(x2manyList)
                    ]);
                });
                defs.push(def);
            }
        });

        //fetchmany2onesdisplay_name
        _.each(_.keys(many2ones),function(name){
            defs.push(self._fetchNameGets(x2manyList,name));
        });

        returnPromise.all(defs);
    },
    /**
     *Readsdatafromserverforallmissingfields.
     *
     *@private
     *@param{Object}listavalidresourceobject
     *@param{interger[]}resIDs
     *@param{string[]}fieldNamestocheckandreadifmissing
     *@returns{Promise<Object>}
     */
    _readMissingFields:function(list,resIDs,fieldNames){
        varself=this;

        varmissingIDs=[];
        for(vari=0,len=resIDs.length;i<len;i++){
            varresId=resIDs[i];
            vardataPointID=list._cache[resId];
            if(!dataPointID){
                missingIDs.push(resId);
                continue;
            }
            varrecord=self.localData[dataPointID];
            vardata=_.extend({},record.data,record._changes);
            if(_.difference(fieldNames,_.keys(data)).length){
                missingIDs.push(resId);
            }
        }

        vardef;
        if(missingIDs.length&&fieldNames.length){
            def=self._performRPC({
                context:list.getContext(),
                fieldNames:fieldNames,
                ids:missingIDs,
                method:'read',
                model:list.model,
            });
        }else{
            def=Promise.resolve(_.map(missingIDs,function(id){
                return{id:id};
            }));
        }
        returndef.then(function(records){
            _.each(resIDs,function(id){
                vardataPoint;
                vardata=_.findWhere(records,{id:id});
                if(idinlist._cache){
                    dataPoint=self.localData[list._cache[id]];
                    if(data){
                        self._parseServerData(fieldNames,dataPoint,data);
                        _.extend(dataPoint.data,data);
                    }
                }else{
                    dataPoint=self._makeDataPoint({
                        context:list.getContext(),
                        data:data,
                        fieldsInfo:list.fieldsInfo,
                        fields:list.fields,
                        modelName:list.model,
                        parentID:list.id,
                        viewType:list.viewType,
                    });
                    self._parseServerData(fieldNames,dataPoint,dataPoint.data);

                    //addmany2onerecords
                    list._cache[id]=dataPoint.id;
                }
                //setthedataPointidinpotential'ADD'operationaddingthecurrentrecord
                _.each(list._changes,function(change){
                    if(change.operation==='ADD'&&!change.id&&change.resID===id){
                        change.id=dataPoint.id;
                    }
                });
            });
            returnlist;
        });
    },
    /**
     *Foragroupedlistresource,thismethodfetchesallgroupdataby
     *performinga/read_group.Italsotriestoreadopensubgroupsifthey
     *wereopenbefore.
     *
     *@param{Object}listvalidresourceobject
     *@param{Object}[options]@see_load
     *@returns{Promise<Object>}resolvestothefetchedgroupobject
     */
    _readGroup:function(list,options){
        varself=this;
        options=options||{};
        vargroupByField=list.groupedBy[0];
        varrawGroupBy=groupByField.split(':')[0];
        varfields=_.uniq(list.getFieldNames().concat(rawGroupBy));
        varorderedBy=_.filter(list.orderedBy,function(order){
            returnorder.name===rawGroupBy||list.fields[order.name].group_operator!==undefined;
        });
        varopenGroupsLimit=list.groupsLimit||self.OPEN_GROUP_LIMIT;
        varexpand=list.openGroupByDefault&&options.fetchRecordsWithGroups;
        returnthis._rpc({
                model:list.model,
                method:'web_read_group',
                fields:fields,
                domain:list.domain,
                context:list.context,
                groupBy:list.groupedBy,
                limit:list.groupsLimit,
                offset:list.groupsOffset,
                orderBy:orderedBy,
                lazy:true,
                expand:expand,
                expand_limit:expand?list.limit:null,
                expand_orderby:expand?list.orderedBy:null,
            })
            .then(function(result){
                vargroups=result.groups;
                list.groupsCount=result.length;
                varpreviousGroups=_.map(list.data,function(groupID){
                    returnself.localData[groupID];
                });
                list.data=[];
                list.count=0;
                vardefs=[];
                varopenGroupCount=0;

                _.each(groups,function(group){
                    varaggregateValues={};
                    _.each(group,function(value,key){
                        if(_.contains(fields,key)&&key!==groupByField&&
                            AGGREGATABLE_TYPES.includes(list.fields[key].type)){
                                aggregateValues[key]=value;
                        }
                    });
                    //Whenaviewisgrouped,weneedtodisplaythenameofeachgroupin
                    //the'title'.
                    varvalue=group[groupByField];
                    if(list.fields[rawGroupBy].type==="selection"){
                        varchoice=_.find(list.fields[rawGroupBy].selection,function(c){
                            returnc[0]===value;
                        });
                        value=choice?choice[1]:false;
                    }
                    //Whengroup_by_no_leafkeyispresentFIELD_ID_countdoesn'texist
                    //wehavetogetthecountfrom`__count`instead
                    //see_read_group_rawinmodels.py
                    constcountKey=rawGroupBy+'_count';
                    varnewGroup=self._makeDataPoint({
                        modelName:list.model,
                        count:countKeyingroup?group[countKey]:group.__count,
                        domain:group.__domain,
                        context:list.context,
                        fields:list.fields,
                        fieldsInfo:list.fieldsInfo,
                        value:value,
                        aggregateValues:aggregateValues,
                        groupedBy:list.groupedBy.slice(1),
                        orderedBy:list.orderedBy,
                        orderedResIDs:list.orderedResIDs,
                        limit:list.limit,
                        openGroupByDefault:list.openGroupByDefault,
                        parentID:list.id,
                        type:'list',
                        viewType:list.viewType,
                    });
                    varoldGroup=_.find(previousGroups,function(g){
                        returng.res_id===newGroup.res_id&&g.value===newGroup.value;
                    });
                    if(oldGroup){
                        deleteself.localData[newGroup.id];
                        //restoretheinternalstateofthegroup
                        varupdatedProps=_.pick(oldGroup,'isOpen','offset','id');
                        if(options.onlyGroups||oldGroup.isOpen&&newGroup.groupedBy.length){
                            //Ifthegroupisopenedandcontainssubgroups,
                            //alsokeepitsdatatokeepinternalstateof
                            //sub-groups
                            //Alsokeepdataifweonlyreloadgroups'owndata
                            updatedProps.data=oldGroup.data;
                            if(options.onlyGroups){
                                //keepcountandres_idsasinthiscasethegroup
                                //won'tbesearch_readagain.Thissituationhappens
                                //whenusingkanbanquick_createwheretherecordismanually
                                //addedtothedatapointbeforegettinghere.
                                updatedProps.res_ids=oldGroup.res_ids;
                                updatedProps.count=oldGroup.count;
                            }
                        }
                        _.extend(newGroup,updatedProps);
                        //setthelimitsuchthatallpreviouslyloadedrecords
                        //(e.g.ifwearecomingbacktothekanbanviewfroma
                        //formview)arereloaded
                        newGroup.limit=oldGroup.limit+oldGroup.loadMoreOffset;
                        self.localData[newGroup.id]=newGroup;
                    }elseif(!newGroup.openGroupByDefault||openGroupCount>=openGroupsLimit){
                        newGroup.isOpen=false;
                    }elseif('__fold'ingroup){
                        newGroup.isOpen=!group.__fold;
                    }else{
                        //openthegroupiffitisafirstlevelgroup
                        newGroup.isOpen=!self.localData[newGroup.parentID].parentID;
                    }
                    list.data.push(newGroup.id);
                    list.count+=newGroup.count;
                    if(newGroup.isOpen&&newGroup.count>0){
                        openGroupCount++;
                        if(group.__data){
                            //bypassthesearch_readwhenthegroup'srecordshavebeenobtained
                            //bythecallto'web_read_group'(see@_searchReadUngroupedList)
                            newGroup.__data=group.__data;
                        }
                        options=_.defaults({enableRelationalFetch:false},options);
                        defs.push(self._load(newGroup,options));
                    }
                });
                if(options.keepEmptyGroups){
                    //Findthegroupsthatwereavailableinaprevious
                    //readGroupbutarenotthereanymore.
                    //Notethatthesegroupsareputafterexistinggroupsso
                    //theorderisnotconserved.Asort*might*beuseful.
                    varemptyGroupsIDs=_.difference(_.pluck(previousGroups,'id'),list.data);
                    _.each(emptyGroupsIDs,function(groupID){
                        list.data.push(groupID);
                        varemptyGroup=self.localData[groupID];
                        //thisattributehasn'tbeenupdatedintheprevious
                        //loopforemptygroups
                        emptyGroup.aggregateValues={};
                    });
                }

                returnPromise.all(defs).then(function(groups){
                    if(!options.onlyGroups){
                        //generatetheres_idsofthemainlist,beingtheconcatenation
                        //ofthefetchedres_idsineachgroup
                        list.res_ids=_.flatten(_.map(groups,function(group){
                            returngroup?group.res_ids:[];
                        }));
                    }
                    returnlist;
                }).then(function(){
                    returnPromise.all([
                        self._fetchX2ManysSingleBatch(list),
                        self._fetchReferencesSingleBatch(list)
                    ]).then(function(){
                        returnlist;
                    });
                });
            });
    },
    /**
     *For'static'list,suchasone2manysinaformview,wecandoa/read
     *insteadofa/search_read.
     *
     *@param{Object}listavalidresourceobject
     *@returns{Promise<Object>}resolvestothefetchedlistobject
     */
    _readUngroupedList:function(list){
        varself=this;
        vardef=Promise.resolve();

        //generatethecurrentcountandres_idslistbyapplyingthechanges
        list=this._applyX2ManyOperations(list);

        //formulti-pageslistdatapoints,wemightneedtoreadthe
        //orderfieldfirsttoapplytheorderonallpages
        if(list.res_ids.length>list.limit&&list.orderedBy.length){
            if(!list.orderedResIDs){
                varfieldNames=_.pluck(list.orderedBy,'name');
                def=this._readMissingFields(list,_.filter(list.res_ids,_.isNumber),fieldNames);
            }
            def.then(function(){
                self._sortList(list);
            });
        }
        returndef.then(function(){
            varresIDs=[];
            varcurrentResIDs=list.res_ids;
            //ifnewrecordshavebeenaddedtothelist,theirvirtualidshave
            //beenpushedattheendofres_ids(oratthebeginning,depending
            //ontheeditableproperty),ignoringcompletelythecurrentpage
            //wheretherecordshaveactuallybeencreated;forthatreason,
            //weuseorderedResIDswhichisafreezedorderwiththevirtualids
            //atthecorrectpositionwheretheywereactuallyinserted;however,
            //whenweuseorderedResIDs,wemustfilteroutidsthatarenotin
            //res_ids,whichcorrespondtorecordsthathavebeenremovedfrom
            //therelation(thisinformationbeingtakenintoaccountinres_ids
            //butnotinorderedResIDs)
            if(list.orderedResIDs){
                currentResIDs=list.orderedResIDs.filter(function(resID){
                    returnlist.res_ids.indexOf(resID)>=0;
                });
            }
            varcurrentCount=currentResIDs.length;
            varupperBound=list.limit?Math.min(list.offset+list.limit,currentCount):currentCount;
            varfieldNames=list.getFieldNames();
            for(vari=list.offset;i<upperBound;i++){
                varresId=currentResIDs[i];
                if(_.isNumber(resId)){
                    resIDs.push(resId);
                }
            }
            returnself._readMissingFields(list,resIDs,fieldNames).then(function(){
                if(list.res_ids.length<=list.limit){
                    self._sortList(list);
                }else{
                    //sortListhasalreadybeenappliedafterfirsttheread
                    self._setDataInRange(list);
                }
                returnlist;
            });
        });
    },
    /**
     *Reloadalldataforagivenresource
     *
     *@private
     *@param{string}idlocalidforaresource
     *@param{Object}[options]
     *@param{boolean}[options.keepChanges=false]iftrue,doesn'tdiscardthe
     *  changesontherecordbeforereloadingit
     *@returns{Promise<string>}resolvestotheidoftheresource
     */
    _reload:function(id,options){
        options=options||{};
        varelement=this.localData[id];

        if(element.type==='record'){
            if(!options.currentId&&(('currentId'inoptions)||this.isNew(id))){
                varparams={
                    context:element.context,
                    fieldsInfo:element.fieldsInfo,
                    fields:element.fields,
                    viewType:element.viewType,
                    allowWarning:true,
                };
                returnthis._makeDefaultRecord(element.model,params);
            }
            if(!options.keepChanges){
                this.discardChanges(id,{rollback:false});
            }
        }elseif(element._changes){
            deleteelement.tempLimitIncrement;
            _.each(element._changes,function(change){
                deletechange.isNew;
            });
        }

        if(options.context!==undefined){
            element.context=options.context;
        }
        if(options.orderedBy!==undefined){
            element.orderedBy=(options.orderedBy.length&&options.orderedBy)||element.orderedBy;
        }
        if(options.domain!==undefined){
            element.domain=options.domain;
        }
        if(options.groupBy!==undefined){
            element.groupedBy=options.groupBy;
        }
        if(options.limit!==undefined){
            element.limit=options.limit;
        }
        if(options.offset!==undefined){
            this._setOffset(element.id,options.offset);
        }
        if(options.groupsLimit!==undefined){
            element.groupsLimit=options.groupsLimit;
        }
        if(options.groupsOffset!==undefined){
            element.groupsOffset=options.groupsOffset;
        }
        if(options.loadMoreOffset!==undefined){
            element.loadMoreOffset=options.loadMoreOffset;
        }else{
            //resetifnotspecified
            element.loadMoreOffset=0;
        }
        if(options.currentId!==undefined){
            element.res_id=options.currentId;
        }
        if(options.ids!==undefined){
            element.res_ids=options.ids;
            element.count=element.res_ids.length;
        }
        if(element.type==='record'){
            element.offset=_.indexOf(element.res_ids,element.res_id);
        }
        varloadOptions=_.pick(options,'fieldNames','viewType');
        returnthis._load(element,loadOptions).then(function(result){
            returnresult.id;
        });
    },
    /**
     *Overridetohandlethecasewherewewantsampledata,andweareina
     *groupedkanbanorlistviewwithrealgroups,butallgroupsareempty.
     *Inthiscase,weusetheresultoftheweb_read_grouprpctotweakthe
     *dataintheSampleServerinstanceofthesampleModel(sothatcallsto
     *thatserverwillreturnthesamegroups).
     *
     *@override
     */
    async_rpc(params){
        constresult=awaitthis._super(...arguments);
        if(this.sampleModel&&params.method==='web_read_group'&&result.length){
            constsampleServer=this.sampleModel.sampleServer;
            sampleServer.setExistingGroups(result.groups);
        }
        returnresult;
    },
    /**
     *AllowstosaveavalueinthespecialDatacacheassociatedtoagiven
     *recordandfieldName.Ifthevalueinthecachewasalreadythegiven
     *one,nothingisdoneandthemethodindicatesitbyreturningfalse
     *insteadoftrue.
     *
     *@private
     *@param{Object}record-anelementfromthelocalData
     *@param{string}fieldName-thenameofthefield
     *@param{*}value-thecachevaluetosave
     *@returns{boolean}falseifthevaluewasalreadythegivenone
     */
    _saveSpecialDataCache:function(record,fieldName,value){
        if(_.isEqual(record._specialDataCache[fieldName],value)){
            returnfalse;
        }
        record._specialDataCache[fieldName]=value;
        returntrue;
    },
    /**
     *Doa/search_readtogetdataforalistresource. Thisdoesa
     */search_readbecausethedatamaynotbestatic(forex,alistview).
     *
     *@param{Object}list
     *@returns{Promise}
     */
    _searchReadUngroupedList:function(list){
        varself=this;
        varfieldNames=list.getFieldNames();
        varprom;
        if(list.__data){
            //thedatahavealreadybeenfetched(alongsidethegroupsbythe
            //callto'web_read_group'),sowecanbypassthesearch_read
            //Buttheweb_read_groupreturnstherawGroupByfield'svalue,whichmaynotbepresent
            //intheview.Sowefilteritout.
            constfieldNameSet=newSet(fieldNames);
            fieldNameSet.add("id");//don'tfilterouttheid
            list.__data.records.forEach(record=>
                Object.keys(record)
                    .filter(fieldName=>!fieldNameSet.has(fieldName))
                    .forEach(fieldName=>deleterecord[fieldName]));
            prom=Promise.resolve(list.__data);
        }else{
            prom=this._rpc({
                route:'/web/dataset/search_read',
                model:list.model,
                fields:fieldNames,
                context:_.extend({},list.getContext(),{bin_size:true}),
                domain:list.domain||[],
                limit:list.limit,
                offset:list.loadMoreOffset+list.offset,
                orderBy:list.orderedBy,
            });
        }
        returnprom.then(function(result){
            deletelist.__data;
            list.count=result.length;
            varids=_.pluck(result.records,'id');
            vardata=_.map(result.records,function(record){
                vardataPoint=self._makeDataPoint({
                    context:list.context,
                    data:record,
                    fields:list.fields,
                    fieldsInfo:list.fieldsInfo,
                    modelName:list.model,
                    parentID:list.id,
                    viewType:list.viewType,
                });

                //addmany2onerecords
                self._parseServerData(fieldNames,dataPoint,dataPoint.data);
                returndataPoint.id;
            });
            if(list.loadMoreOffset){
                list.data=list.data.concat(data);
                list.res_ids=list.res_ids.concat(ids);
            }else{
                list.data=data;
                list.res_ids=ids;
            }
            self._updateParentResIDs(list);
            returnlist;
        });
    },
    /**
     *Setdatainrange,i.e.accordingtothelistoffsetandlimit.
     *
     *@param{Object}list
     */
    _setDataInRange:function(list){
        varidsInRange;
        if(list.limit){
            idsInRange=list.res_ids.slice(list.offset,list.offset+list.limit);
        }else{
            idsInRange=list.res_ids;
        }
        list.data=[];
        _.each(idsInRange,function(id){
            if(list._cache[id]){
                list.data.push(list._cache[id]);
            }
        });

        //displaynewlycreatedrecordinadditiontothedisplayedrecords
        if(list.limit){
            for(vari=list.offset+list.limit;i<list.res_ids.length;i++){
                varid=list.res_ids[i];
                vardataPointID=list._cache[id];
                if(_.findWhere(list._changes,{isNew:true,id:dataPointID})){
                    list.data.push(dataPointID);
                }else{
                    break;
                }
            }
        }
    },
    /**
     *Changetheoffsetofarecord.Notethatthisdoesnotreloadthedata.
     *Theoffsetisusedtoloadadifferentrecordinalistofrecord(for
     *example,aformviewwithapager. Clickingonnext/previousactually
     *changestheoffsetthroughthismethod).
     *
     *@param{string}elementIdlocalidfortheresource
     *@param{number}offset
     */
    _setOffset:function(elementId,offset){
        varelement=this.localData[elementId];
        element.offset=offset;
        if(element.type==='record'&&element.res_ids.length){
            element.res_id=element.res_ids[offset];
        }
    },
    /**
     *Doain-memorysortofalistresourcedatapoints.Thismethodassumes
     *thatthelistdatahasalreadybeenfetched,andthatthechangesthat
     *needtobesortedhavealreadybeenapplied.Itsintendeduseisfor
     *staticdatasets,suchasaone2manyinaformview.
     *
     *@param{Object}listlistdataPointonwhich(some)changesmighthave
     *  beenapplied;itisacopyofaninternaldataPoint,nottheresultof
     *  get
     */
    _sortList:function(list){
        if(!list.static){
            //onlysortx2manylists
            return;
        }
        varself=this;

        if(list.orderedResIDs){
            varorderedResIDs={};
            for(vark=0;k<list.orderedResIDs.length;k++){
                orderedResIDs[list.orderedResIDs[k]]=k;
            }
            utils.stableSort(list.res_ids,functioncompareResIdIndexes(resId1,resId2){
                if(!(resId1inorderedResIDs)&&!(resId2inorderedResIDs)){
                    return0;
                }
                if(!(resId1inorderedResIDs)){
                    returnInfinity;
                }
                if(!(resId2inorderedResIDs)){
                    return-Infinity;
                }
                returnorderedResIDs[resId1]-orderedResIDs[resId2];
            });
        }elseif(list.orderedBy.length){
            //sortrecordsaccordingtoordered_by[0]
            varcompareRecords=function(resId1,resId2,level){
                if(!level){
                    level=0;
                }
                if(list.orderedBy.length<level+1){
                    return0;
                }
                varorder=list.orderedBy[level];
                varrecord1ID=list._cache[resId1];
                varrecord2ID=list._cache[resId2];
                if(!record1ID&&!record2ID){
                    return0;
                }
                if(!record1ID){
                    returnInfinity;
                }
                if(!record2ID){
                    return-Infinity;
                }
                varr1=self.localData[record1ID];
                varr2=self.localData[record2ID];
                vardata1=_.extend({},r1.data,r1._changes);
                vardata2=_.extend({},r2.data,r2._changes);

                //Defaultvaluetosortagainst:thevalueofthefield
                varorderData1=data1[order.name];
                varorderData2=data2[order.name];

                //Ifthefieldisarelation,sortonthedisplay_nameofthoserecords
                if(list.fields[order.name].type==='many2one'){
                    orderData1=orderData1?self.localData[orderData1].data.display_name:"";
                    orderData2=orderData2?self.localData[orderData2].data.display_name:"";
                }
                if(orderData1<orderData2){
                    returnorder.asc?-1:1;
                }
                if(orderData1>orderData2){
                    returnorder.asc?1:-1;
                }
                returncompareRecords(resId1,resId2,level+1);
            };
            utils.stableSort(list.res_ids,compareRecords);
        }
        this._setDataInRange(list);
    },
    /**
     *Updatestheres_idsoftheparentofagivenelementoftypelist.
     *
     *Aftersomeoperations(e.g.loadingmorerecords,folding/unfoldinga
     *group),theres_idslistofanelementmaybeupdated.Whenthishappens,
     *theres_idsofitsancestorsneedtobeupdatedaswell.Thisisthe
     *purposeofthisfunction.
     *
     *@param{Object}element
     */
    _updateParentResIDs:function(element){
        varself=this;
        if(element.parentID){
            varparent=this.localData[element.parentID];
            parent.res_ids= _.flatten(_.map(parent.data,function(dataPointID){
                returnself.localData[dataPointID].res_ids;
            }));
            this._updateParentResIDs(parent);
        }
    },
    /**
     *Helpermethodtocreatedatapointsandassignthemvalues,thenlink
     *thosedatapointsintorecords'data.
     *
     *@param{Object[]}recordsalistofrecordwheredatapointswillbe
     *  assigned,itassumes_applyX2ManyOperationsand_sorthavebeen
     *  alreadycalledonthislist
     *@param{string}fieldNameconcernedfieldinrecords
     *@param{Object[]}valuestypicallyalistofvaluesgotfromarpc
     */
    _updateRecordsData:function(records,fieldName,values){
        if(!records.length||!values){
            return;
        }
        varself=this;
        varfield=records[0].fields[fieldName];
        varfieldInfo=records[0].fieldsInfo[records[0].viewType][fieldName];
        varview=fieldInfo.views&&fieldInfo.views[fieldInfo.mode];
        varfieldsInfo=view?view.fieldsInfo:fieldInfo.fieldsInfo;
        varfields=view?view.fields:fieldInfo.relatedFields;
        varviewType=view?view.type:fieldInfo.viewType;
        varid2Values=newMap(values.map((value)=>[value.id,value]))

        _.each(records,function(record){
            varx2mList=self.localData[record.data[fieldName]];
            x2mList.data=[];
            _.each(x2mList.res_ids,function(res_id){
                vardataPoint=self._makeDataPoint({
                    modelName:field.relation,
                    data:id2Values.get(res_id),
                    fields:fields,
                    fieldsInfo:fieldsInfo,
                    parentID:x2mList.id,
                    viewType:viewType,
                });
                x2mList.data.push(dataPoint.id);
                x2mList._cache[res_id]=dataPoint.id;
            });
        });
    },
    /**
     *Helpermethod. Recursivelytraversesthedata,startingfromtheelement
     *record(orlist),thenfollowingallrelations. Thisisusefulwhenone
     *wanttodetermineapropertyforthecurrentrecord.
     *
     *Forexample,isDirtyneedtocheckallrelationstofindoutifsomething
     *hasbeenmodified,ornot.
     *
     *Notethatthismethodfollowsallthechanges,soifarecordhas
     *relationalsubdata,itwillvisitthenewsubrecordsandnottheold
     *ones.
     *
     *@param{Object}elementavalidlocalresource
     *@param{callback}fnafunctiontobecalledoneachvisitedelement
     */
    _visitChildren:function(element,fn){
        varself=this;
        fn(element);
        if(element.type==='record'){
            for(varfieldNameinelement.data){
                varfield=element.fields[fieldName];
                if(!field){
                    continue;
                }
                if(_.contains(['one2many','many2one','many2many'],field.type)){
                    varhasChange=element._changes&&fieldNameinelement._changes;
                    varvalue= hasChange?element._changes[fieldName]:element.data[fieldName];
                    varrelationalElement=this.localData[value];
                    //relationalElementcouldbeemptyinthecaseofamany2one
                    if(relationalElement){
                        self._visitChildren(relationalElement,fn);
                    }
                }
            }
        }
        if(element.type==='list'){
            element=this._applyX2ManyOperations(element);
            _.each(element.data,function(elemId){
                varelem=self.localData[elemId];
                self._visitChildren(elem,fn);
            });
        }
    },
});

returnBasicModel;
});

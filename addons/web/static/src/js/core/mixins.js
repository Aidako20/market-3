flectra.define('web.mixins',function(require){
"usestrict";

varClass=require('web.Class');
varutils=require('web.utils');

/**
 *Mixintostructureobjects'life-cyclesfolowingaparent-children
 *relationship.Eachobjectcanahaveaparentandmultiplechildren.
 *Whenanobjectisdestroyed,allitschildrenaredestroyedtooreleasing
 *anyresourcetheycouldhavereservedbefore.
 *
 *@nameParentedMixin
 *@mixin
 */
varParentedMixin={
    __parentedMixin:true,
    init:function(){
        this.__parentedDestroyed=false;
        this.__parentedChildren=[];
        this.__parentedParent=null;
    },
    /**
     *Settheparentofthecurrentobject.Whencallingthismethod,the
     *parentwillalsobeinformedandwillreturnthecurrentobject
     *whenitsgetChildren()methodiscalled.Ifthecurrentobjectdid
     *alreadyhaveaparent,itisunregisteredbefore,whichmeansthe
     *previousparentwillnotreturnthecurrentobjectanymorewhenits
     *getChildren()methodiscalled.
     */
    setParent:function(parent){
        if(this.getParent()){
            if(this.getParent().__parentedMixin){
                this.getParent().__parentedChildren=_.without(this
                        .getParent().getChildren(),this);
            }
        }
        this.__parentedParent=parent;
        if(parent&&parent.__parentedMixin){
            parent.__parentedChildren.push(this);
        }
    },
    /**
     *Returnthecurrentparentoftheobject(ornull).
     */
    getParent:function(){
        returnthis.__parentedParent;
    },
    /**
     *Returnalistofthechildrenofthecurrentobject.
     */
    getChildren:function(){
        return_.clone(this.__parentedChildren);
    },
    /**
     *Returnstrueifdestroy()wascalledonthecurrentobject.
     */
    isDestroyed:function(){
        returnthis.__parentedDestroyed;
    },
    /**
     *Utilitymethodtoonlyexecuteasynchronousactionsifthecurrent
     *objecthasnotbeendestroyed.
     *
     *@param{Promise}promiseThepromiserepresentingtheasynchronous
     *                            action.
     *@param{bool}[shouldReject=false]Iftrue,thereturnedpromisewillbe
     *                             rejectedwithnoargumentsifthecurrent
     *                             objectisdestroyed.Iffalse,the
     *                             returnedpromisewillneverberesolved
     *                             orrejected.
     *@returns{Promise}Apromisethatwillmirrorthegivenpromiseif
     *                      everythinggoesfinebutwilleitherberejected
     *                      withnoargumentsorneverresolvedifthe
     *                      currentobjectisdestroyed.
     */
    alive:function(promise,shouldReject){
        varself=this;

        returnnewPromise(function(resolve,reject){
            promise.then(function(result){
                if(!self.isDestroyed()){
                    resolve(result);
                }elseif(shouldReject){
                    reject();
                }
            }).guardedCatch(function(reason){
                if(!self.isDestroyed()){
                    reject(reason);
                }elseif(shouldReject){
                    reject();
                }
            });
        });
    },
    /**
     *Informtheobjectitshoulddestroyitself,releasingany
     *resourceitcouldhavereserved.
     */
    destroy:function(){
        this.getChildren().forEach(function(child){
            child.destroy();
        });
        this.setParent(undefined);
        this.__parentedDestroyed=true;
    },
    /**
     *Findtheclosestancestormatchingpredicate
     */
    findAncestor:function(predicate){
        varancestor=this;
        while(ancestor&&!(predicate(ancestor))&&ancestor.getParent){
            ancestor=ancestor.getParent();
        }
        returnancestor;
    },
};

functionFlectraEvent(target,name,data){
    this.target=target;
    this.name=name;
    this.data=Object.create(null);
    _.extend(this.data,data);
    this.stopped=false;
}

FlectraEvent.prototype.stopPropagation=function(){
    this.stopped=true;
};

FlectraEvent.prototype.is_stopped=function(){
    returnthis.stopped;
};

/**
 *Backbone'sevents.Donoteveruseitdirectly,useEventDispatcherMixininstead.
 *
 *Thisclassjusthandlethedispatchingofevents,itisnotmeanttobeextended,
 *noruseddirectly.Allintegrationwithparentingandautomaticunregistrationof
 *eventsisdoneinEventDispatcherMixin.
 *
 *CopyrightnoticeforthefollowingClass:
 *
 *(c)2010-2012JeremyAshkenas,DocumentCloudInc.
 *BackbonemaybefreelydistributedundertheMITlicense.
 *Foralldetailsanddocumentation:
 *http://backbonejs.org
 *
 */
varEvents=Class.extend({
    on:function(events,callback,context){
        varev;
        events=events.split(/\s+/);
        varcalls=this._callbacks||(this._callbacks={});
        while((ev=events.shift())){
            varlist=calls[ev]||(calls[ev]={});
            vartail=list.tail||(list.tail=list.next={});
            tail.callback=callback;
            tail.context=context;
            list.tail=tail.next={};
        }
        returnthis;
    },

    off:function(events,callback,context){
        varev,calls,node;
        if(!events){
            deletethis._callbacks;
        }elseif((calls=this._callbacks)){
            events=events.split(/\s+/);
            while((ev=events.shift())){
                node=calls[ev];
                deletecalls[ev];
                if(!callback||!node)
                    continue;
                while((node=node.next)&&node.next){
                    if(node.callback===callback
                            &&(!context||node.context===context))
                        continue;
                    this.on(ev,node.callback,node.context);
                }
            }
        }
        returnthis;
    },

    callbackList:function(){
        varlst=[];
        _.each(this._callbacks||{},function(el,eventName){
            varnode=el;
            while((node=node.next)&&node.next){
                lst.push([eventName,node.callback,node.context]);
            }
        });
        returnlst;
    },

    trigger:function(events){
        varevent,node,calls,tail,args,all,rest;
        if(!(calls=this._callbacks))
            returnthis;
        all=calls.all;
        (events=events.split(/\s+/)).push(null);
        //Savereferencestothecurrentheads&tails.
        while((event=events.shift())){
            if(all)
                events.push({
                    next:all.next,
                    tail:all.tail,
                    event:event
                });
            if(!(node=calls[event]))
                continue;
            events.push({
                next:node.next,
                tail:node.tail
            });
        }
        rest=Array.prototype.slice.call(arguments,1);
        while((node=events.pop())){
            tail=node.tail;
            args=node.event?[node.event].concat(rest):rest;
            while((node=node.next)!==tail){
                node.callback.apply(node.context||this,args);
            }
        }
        returnthis;
    }
});

/**
 *Mixincontaininganeventsystem.Eventsarealsoregisteredbyspecifyingthetargetobject
 *(theobjectwhichwillreceivetheeventwhenitisraised).Boththeevent-emittingobject
 *andthetargetobjectstoreorreferencetoeachother.Thisisusedtocorrectlyremoveall
 *referencetotheeventhandlerwhenanyoftheobjectisdestroyed(whenthedestroy()method
 *fromParentedMixiniscalled).Removingthosereferencesisnecessarytoavoidmemoryleak
 *andphantomevents(eventswhichareraisedandsenttoapreviouslydestroyedobject).
 *
 *@nameEventDispatcherMixin
 *@mixin
 */
varEventDispatcherMixin=_.extend({},ParentedMixin,{
    __eventDispatcherMixin:true,
    custom_events:{},
    init:function(){
        ParentedMixin.init.call(this);
        this.__edispatcherEvents=newEvents();
        this.__edispatcherRegisteredEvents=[];
        this._delegateCustomEvents();
    },
    /**
     *Proxiesamethodoftheobject,inordertokeeptheright``this``on
     *methodinvocations.
     *
     *Thismethodissimilarto``Function.prototype.bind``or``_.bind``,and
     *evenmoresoto``jQuery.proxy``withafundamentaldifference:its
     *resolutionofthemethodbeingcalledislazy,meaningitwillusethe
     *methodasitiswhentheproxyiscalled,notwhentheproxyiscreated.
     *
     *Othermethodswillfixtheboundmethodtowhatitiswhencreatingthe
     *binding/proxy,whichisfineinmostjavascriptcodebutproblematicin
     *OpenERPWebwheredevelopersmaywanttoreplaceexistingcallbackswith
     *theirs.
     *
     *Thesemanticsofthispreciselyreplaceclosingoverthemethodcall.
     *
     *@param{String|Function}methodfunctionornameofthemethodtoinvoke
     *@returns{Function}proxiedmethod
     */
    proxy:function(method){
        varself=this;
        returnfunction(){
            varfn=(typeofmethod==='string')?self[method]:method;
            if(fn===void0){
                thrownewError("Couldn'tfindmethod'"+method+"'inwidget"+self);
            }
            returnfn.apply(self,arguments);
        };
    },
    _delegateCustomEvents:function(){
        if(_.isEmpty(this.custom_events)){return;}
        for(varkeyinthis.custom_events){
            if(!this.custom_events.hasOwnProperty(key)){continue;}

            varmethod=this.proxy(this.custom_events[key]);
            this.on(key,this,method);
        }
    },
    on:function(events,dest,func){
        varself=this;
        if(typeoffunc!=="function"){
            thrownewError("Eventhandlermustbeafunction.");
        }
        events=events.split(/\s+/);
        _.each(events,function(eventName){
            self.__edispatcherEvents.on(eventName,func,dest);
            if(dest&&dest.__eventDispatcherMixin){
                dest.__edispatcherRegisteredEvents.push({name:eventName,func:func,source:self});
            }
        });
        returnthis;
    },
    off:function(events,dest,func){
        varself=this;
        events=events.split(/\s+/);
        _.each(events,function(eventName){
            self.__edispatcherEvents.off(eventName,func,dest);
            if(dest&&dest.__eventDispatcherMixin){
                dest.__edispatcherRegisteredEvents=_.filter(dest.__edispatcherRegisteredEvents,function(el){
                    return!(el.name===eventName&&el.func===func&&el.source===self);
                });
            }
        });
        returnthis;
    },
    once:function(events,dest,func){
        //similartothis.on(),butfuncisexecutedonlyonce
        varself=this;
        if(typeoffunc!=="function"){
            thrownewError("Eventhandlermustbeafunction.");
        }
        self.on(events,dest,functionwhat(){
            func.apply(this,arguments);
            self.off(events,dest,what);
        });
    },
    trigger:function(){
        this.__edispatcherEvents.trigger.apply(this.__edispatcherEvents,arguments);
        returnthis;
    },
    trigger_up:function(name,info){
        varevent=newFlectraEvent(this,name,info);
        //console.info('event:',name,info);
        this._trigger_up(event);
        returnevent;
    },
    _trigger_up:function(event){
        varparent;
        this.__edispatcherEvents.trigger(event.name,event);
        if(!event.is_stopped()&&(parent=this.getParent())){
            parent._trigger_up(event);
        }
    },
    destroy:function(){
        varself=this;
        _.each(this.__edispatcherRegisteredEvents,function(event){
            event.source.__edispatcherEvents.off(event.name,event.func,self);
        });
        this.__edispatcherRegisteredEvents=[];
        _.each(this.__edispatcherEvents.callbackList(),function(cal){
            this.off(cal[0],cal[2],cal[1]);
        },this);
        this.__edispatcherEvents.off();
        ParentedMixin.destroy.call(this);
    }
});

/**
 *@namePropertiesMixin
 *@mixin
 */
varPropertiesMixin=_.extend({},EventDispatcherMixin,{
    init:function(){
        EventDispatcherMixin.init.call(this);
        this.__getterSetterInternalMap={};
    },
    set:function(arg1,arg2,arg3){
        varmap;
        varoptions;
        if(typeofarg1==="string"){
            map={};
            map[arg1]=arg2;
            options=arg3||{};
        }else{
            map=arg1;
            options=arg2||{};
        }
        varself=this;
        varchanged=false;
        _.each(map,function(val,key){
            vartmp=self.__getterSetterInternalMap[key];
            if(tmp===val)
                return;
            //seriously,whyareyoudoingthis?itisobviouslyastupiddesign.
            //thepropertiesmixinshouldnotbeconcernedwithhandlingfieldsdetails.
            //thisalsohasthesideeffectofintroducingadependencyonutils. Todo:
            //removethis,ormoveitelsewhere. Also,learnOOprogramming.
            if(key==='value'&&self.field&&self.field.type==='float'&&tmp&&val){
                vardigits=self.field.digits;
                if(_.isArray(digits)){
                    if(utils.float_is_zero(tmp-val,digits[1])){
                        return;
                    }
                }
            }
            changed=true;
            self.__getterSetterInternalMap[key]=val;
            if(!options.silent)
                self.trigger("change:"+key,self,{
                    oldValue:tmp,
                    newValue:val
                });
        });
        if(changed)
            self.trigger("change",self);
    },
    get:function(key){
        returnthis.__getterSetterInternalMap[key];
    }
});

return{
    ParentedMixin:ParentedMixin,
    EventDispatcherMixin:EventDispatcherMixin,
    PropertiesMixin:PropertiesMixin,
};

});

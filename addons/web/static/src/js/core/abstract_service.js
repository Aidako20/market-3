flectra.define('web.AbstractService',function(require){
"usestrict";

varClass=require('web.Class');
const{serviceRegistry}=require("web.core");
varMixins=require('web.mixins');
varServicesMixin=require('web.ServicesMixin');

varAbstractService=Class.extend(Mixins.EventDispatcherMixin,ServicesMixin,{
    dependencies:[],
    init:function(env){
        Mixins.EventDispatcherMixin.init.call(this,arguments);
        this.env=env;
    },
    /**
     *@abstract
     */
    start:function(){},
    /**
     *Directlycallstherequestedservice,insteadoftriggeringa
     *'call_service'eventup,whichwouldn'tworkasserviceshavenoparent
     *
     *@param{FlectraEvent}ev
     */
    _trigger_up:function(ev){
        Mixins.EventDispatcherMixin._trigger_up.apply(this,arguments);
        if(ev.is_stopped()){
            return;
        }
        constpayload=ev.data;
        if(ev.name==='call_service'){
            letargs=payload.args||[];
            if(payload.service==='ajax'&&payload.method==='rpc'){
                //ajaxserviceusesanextra'target'argumentforrpc
                args=args.concat(ev.target);
            }
            constservice=this.env.services[payload.service];
            constresult=service[payload.method].apply(service,args);
            payload.callback(result);
        }elseif(ev.name==='do_action'){
            this.env.bus.trigger('do-action',payload);
        }
    },

    //--------------------------------------------------------------------------
    //Static
    //--------------------------------------------------------------------------

    /**
     *Deployservicesintheenv(specializationsofAbstractServiceregistered
     *intotheserviceRegistry).
     *
     *@static
     *@param{Object}env
     */
    deployServices(env){
        constUndeployedServices=Object.assign({},serviceRegistry.map);
        function_deployServices(){
            letdone=false;
            while(!done){
                //findaservicewithnomissingdependency
                constserviceName=Object.keys(UndeployedServices).find(serviceName=>{
                    constService=UndeployedServices[serviceName];
                    returnService.prototype.dependencies.every(depName=>{
                        returnenv.services[depName];
                    });
                });
                if(serviceName){
                    constService=UndeployedServices[serviceName];
                    constservice=newService(env);
                    env.services[serviceName]=service;
                    deleteUndeployedServices[serviceName];
                    service.start();
                }else{
                    done=true;
                }
            }
        }
        serviceRegistry.onAdd((serviceName,Service)=>{
            if(serviceNameinenv.services||serviceNameinUndeployedServices){
                thrownewError(`Service${serviceName}isalreadyloaded.`);
            }
            UndeployedServices[serviceName]=Service;
            _deployServices();
        });
        _deployServices();
    }
});

returnAbstractService;
});

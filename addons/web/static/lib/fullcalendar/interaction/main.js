/*!
FullCalendarInteractionPluginv4.4.0
Docs&License:https://fullcalendar.io/
(c)2019AdamShaw
*/

(function(global,factory){
    typeofexports==='object'&&typeofmodule!=='undefined'?factory(exports,require('@fullcalendar/core')):
    typeofdefine==='function'&&define.amd?define(['exports','@fullcalendar/core'],factory):
    (global=global||self,factory(global.FullCalendarInteraction={},global.FullCalendar));
}(this,function(exports,core){'usestrict';

    /*!*****************************************************************************
    Copyright(c)MicrosoftCorporation.Allrightsreserved.
    LicensedundertheApacheLicense,Version2.0(the"License");youmaynotuse
    thisfileexceptincompliancewiththeLicense.Youmayobtainacopyofthe
    Licenseathttp://www.apache.org/licenses/LICENSE-2.0

    THISCODEISPROVIDEDONAN*ASIS*BASIS,WITHOUTWARRANTIESORCONDITIONSOFANY
    KIND,EITHEREXPRESSORIMPLIED,INCLUDINGWITHOUTLIMITATIONANYIMPLIED
    WARRANTIESORCONDITIONSOFTITLE,FITNESSFORAPARTICULARPURPOSE,
    MERCHANTABLITYORNON-INFRINGEMENT.

    SeetheApacheVersion2.0Licenseforspecificlanguagegoverningpermissions
    andlimitationsundertheLicense.
    ******************************************************************************/
    /*globalReflect,Promise*/

    varextendStatics=function(d,b){
        extendStatics=Object.setPrototypeOf||
            ({__proto__:[]}instanceofArray&&function(d,b){d.__proto__=b;})||
            function(d,b){for(varpinb)if(b.hasOwnProperty(p))d[p]=b[p];};
        returnextendStatics(d,b);
    };

    function__extends(d,b){
        extendStatics(d,b);
        function__(){this.constructor=d;}
        d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new__());
    }

    var__assign=function(){
        __assign=Object.assign||function__assign(t){
            for(vars,i=1,n=arguments.length;i<n;i++){
                s=arguments[i];
                for(varpins)if(Object.prototype.hasOwnProperty.call(s,p))t[p]=s[p];
            }
            returnt;
        };
        return__assign.apply(this,arguments);
    };

    core.config.touchMouseIgnoreWait=500;
    varignoreMouseDepth=0;
    varlistenerCnt=0;
    varisWindowTouchMoveCancelled=false;
    /*
    Usesa"pointer"abstraction,whichmonitorsUIeventsforbothmouseandtouch.
    Trackswhenthepointer"drags"onacertainelement,meaningdown+move+up.

    Also,tracksiftherewastouch-scrolling.
    Also,canpreventtouch-scrollingfromhappening.
    Also,canfirepointermoveeventswhenscrollinghappensunderneath,evenwhennorealpointermovement.

    emits:
    -pointerdown
    -pointermove
    -pointerup
    */
    varPointerDragging=/**@class*/(function(){
        functionPointerDragging(containerEl){
            var_this=this;
            this.subjectEl=null;
            this.downEl=null;
            //optionsthatcanbedirectlyassignedbycaller
            this.selector='';//willcausesubjectElinallemittedeventstobethiselement
            this.handleSelector='';
            this.shouldIgnoreMove=false;
            this.shouldWatchScroll=true;//forsimulatingpointermoveonscroll
            //internalstates
            this.isDragging=false;
            this.isTouchDragging=false;
            this.wasTouchScroll=false;
            //Mouse
            //----------------------------------------------------------------------------------------------------
            this.handleMouseDown=function(ev){
                if(!_this.shouldIgnoreMouse()&&
                    isPrimaryMouseButton(ev)&&
                    _this.tryStart(ev)){
                    varpev=_this.createEventFromMouse(ev,true);
                    _this.emitter.trigger('pointerdown',pev);
                    _this.initScrollWatch(pev);
                    if(!_this.shouldIgnoreMove){
                        document.addEventListener('mousemove',_this.handleMouseMove);
                    }
                    document.addEventListener('mouseup',_this.handleMouseUp);
                }
            };
            this.handleMouseMove=function(ev){
                varpev=_this.createEventFromMouse(ev);
                _this.recordCoords(pev);
                _this.emitter.trigger('pointermove',pev);
            };
            this.handleMouseUp=function(ev){
                document.removeEventListener('mousemove',_this.handleMouseMove);
                document.removeEventListener('mouseup',_this.handleMouseUp);
                _this.emitter.trigger('pointerup',_this.createEventFromMouse(ev));
                _this.cleanup();//calllastsothatpointeruphasaccesstoprops
            };
            //Touch
            //----------------------------------------------------------------------------------------------------
            this.handleTouchStart=function(ev){
                if(_this.tryStart(ev)){
                    _this.isTouchDragging=true;
                    varpev=_this.createEventFromTouch(ev,true);
                    _this.emitter.trigger('pointerdown',pev);
                    _this.initScrollWatch(pev);
                    //unlikemouse,needtoattachtotarget,notdocument
                    //https://stackoverflow.com/a/45760014
                    vartarget=ev.target;
                    if(!_this.shouldIgnoreMove){
                        target.addEventListener('touchmove',_this.handleTouchMove);
                    }
                    target.addEventListener('touchend',_this.handleTouchEnd);
                    target.addEventListener('touchcancel',_this.handleTouchEnd);//treatitasatouchend
                    //attachahandlertogetcalledwhenANYscrollactionhappensonthepage.
                    //thiswasimpossibletodowithnormalon/offbecause'scroll'doesn'tbubble.
                    //http://stackoverflow.com/a/32954565/96342
                    window.addEventListener('scroll',_this.handleTouchScroll,true//useCapture
                    );
                }
            };
            this.handleTouchMove=function(ev){
                varpev=_this.createEventFromTouch(ev);
                _this.recordCoords(pev);
                _this.emitter.trigger('pointermove',pev);
            };
            this.handleTouchEnd=function(ev){
                if(_this.isDragging){//donetoguardagainsttouchendfollowedbytouchcancel
                    vartarget=ev.target;
                    target.removeEventListener('touchmove',_this.handleTouchMove);
                    target.removeEventListener('touchend',_this.handleTouchEnd);
                    target.removeEventListener('touchcancel',_this.handleTouchEnd);
                    window.removeEventListener('scroll',_this.handleTouchScroll,true);//useCaptured=true
                    _this.emitter.trigger('pointerup',_this.createEventFromTouch(ev));
                    _this.cleanup();//calllastsothatpointeruphasaccesstoprops
                    _this.isTouchDragging=false;
                    startIgnoringMouse();
                }
            };
            this.handleTouchScroll=function(){
                _this.wasTouchScroll=true;
            };
            this.handleScroll=function(ev){
                if(!_this.shouldIgnoreMove){
                    varpageX=(window.pageXOffset-_this.prevScrollX)+_this.prevPageX;
                    varpageY=(window.pageYOffset-_this.prevScrollY)+_this.prevPageY;
                    _this.emitter.trigger('pointermove',{
                        origEvent:ev,
                        isTouch:_this.isTouchDragging,
                        subjectEl:_this.subjectEl,
                        pageX:pageX,
                        pageY:pageY,
                        deltaX:pageX-_this.origPageX,
                        deltaY:pageY-_this.origPageY
                    });
                }
            };
            this.containerEl=containerEl;
            this.emitter=newcore.EmitterMixin();
            containerEl.addEventListener('mousedown',this.handleMouseDown);
            containerEl.addEventListener('touchstart',this.handleTouchStart,{passive:true});
            listenerCreated();
        }
        PointerDragging.prototype.destroy=function(){
            this.containerEl.removeEventListener('mousedown',this.handleMouseDown);
            this.containerEl.removeEventListener('touchstart',this.handleTouchStart,{passive:true});
            listenerDestroyed();
        };
        PointerDragging.prototype.tryStart=function(ev){
            varsubjectEl=this.querySubjectEl(ev);
            vardownEl=ev.target;
            if(subjectEl&&
                (!this.handleSelector||core.elementClosest(downEl,this.handleSelector))){
                this.subjectEl=subjectEl;
                this.downEl=downEl;
                this.isDragging=true;//dothisfirstsocancelTouchScrollwillwork
                this.wasTouchScroll=false;
                returntrue;
            }
            returnfalse;
        };
        PointerDragging.prototype.cleanup=function(){
            isWindowTouchMoveCancelled=false;
            this.isDragging=false;
            this.subjectEl=null;
            this.downEl=null;
            //keepwasTouchScrollaroundforlateraccess
            this.destroyScrollWatch();
        };
        PointerDragging.prototype.querySubjectEl=function(ev){
            if(this.selector){
                returncore.elementClosest(ev.target,this.selector);
            }
            else{
                returnthis.containerEl;
            }
        };
        PointerDragging.prototype.shouldIgnoreMouse=function(){
            returnignoreMouseDepth||this.isTouchDragging;
        };
        //canbecalledbyuserofthisclass,tocanceltouch-basedscrollingforthecurrentdrag
        PointerDragging.prototype.cancelTouchScroll=function(){
            if(this.isDragging){
                isWindowTouchMoveCancelled=true;
            }
        };
        //Scrollingthatsimulatespointermoves
        //----------------------------------------------------------------------------------------------------
        PointerDragging.prototype.initScrollWatch=function(ev){
            if(this.shouldWatchScroll){
                this.recordCoords(ev);
                window.addEventListener('scroll',this.handleScroll,true);//useCapture=true
            }
        };
        PointerDragging.prototype.recordCoords=function(ev){
            if(this.shouldWatchScroll){
                this.prevPageX=ev.pageX;
                this.prevPageY=ev.pageY;
                this.prevScrollX=window.pageXOffset;
                this.prevScrollY=window.pageYOffset;
            }
        };
        PointerDragging.prototype.destroyScrollWatch=function(){
            if(this.shouldWatchScroll){
                window.removeEventListener('scroll',this.handleScroll,true);//useCaptured=true
            }
        };
        //EventNormalization
        //----------------------------------------------------------------------------------------------------
        PointerDragging.prototype.createEventFromMouse=function(ev,isFirst){
            vardeltaX=0;
            vardeltaY=0;
            //TODO:repeatcode
            if(isFirst){
                this.origPageX=ev.pageX;
                this.origPageY=ev.pageY;
            }
            else{
                deltaX=ev.pageX-this.origPageX;
                deltaY=ev.pageY-this.origPageY;
            }
            return{
                origEvent:ev,
                isTouch:false,
                subjectEl:this.subjectEl,
                pageX:ev.pageX,
                pageY:ev.pageY,
                deltaX:deltaX,
                deltaY:deltaY
            };
        };
        PointerDragging.prototype.createEventFromTouch=function(ev,isFirst){
            vartouches=ev.touches;
            varpageX;
            varpageY;
            vardeltaX=0;
            vardeltaY=0;
            //iftouchcoordsavailable,prefer,
            //becauseFFwouldgivebadev.pageXev.pageY
            if(touches&&touches.length){
                pageX=touches[0].pageX;
                pageY=touches[0].pageY;
            }
            else{
                pageX=ev.pageX;
                pageY=ev.pageY;
            }
            //TODO:repeatcode
            if(isFirst){
                this.origPageX=pageX;
                this.origPageY=pageY;
            }
            else{
                deltaX=pageX-this.origPageX;
                deltaY=pageY-this.origPageY;
            }
            return{
                origEvent:ev,
                isTouch:true,
                subjectEl:this.subjectEl,
                pageX:pageX,
                pageY:pageY,
                deltaX:deltaX,
                deltaY:deltaY
            };
        };
        returnPointerDragging;
    }());
    //Returnsabooleanwhetherthiswasaleftmouseclickandnoctrlkey(whichmeansrightclickonMac)
    functionisPrimaryMouseButton(ev){
        returnev.button===0&&!ev.ctrlKey;
    }
    //Ignoringfakemouseeventsgeneratedbytouch
    //----------------------------------------------------------------------------------------------------
    functionstartIgnoringMouse(){
        ignoreMouseDepth++;
        setTimeout(function(){
            ignoreMouseDepth--;
        },core.config.touchMouseIgnoreWait);
    }
    //WewanttoattachtouchmoveasearlyaspossibleforSafari
    //----------------------------------------------------------------------------------------------------
    functionlistenerCreated(){
        if(!(listenerCnt++)){
            window.addEventListener('touchmove',onWindowTouchMove,{passive:false});
        }
    }
    functionlistenerDestroyed(){
        if(!(--listenerCnt)){
            window.removeEventListener('touchmove',onWindowTouchMove,{passive:false});
        }
    }
    functiononWindowTouchMove(ev){
        if(isWindowTouchMoveCancelled){
            ev.preventDefault();
        }
    }

    /*
    Aneffectinwhichanelementfollowsthemovementofapointeracrossthescreen.
    Themovingelementisacloneofsomeotherelement.
    Mustcallstart+handleMove+stop.
    */
    varElementMirror=/**@class*/(function(){
        functionElementMirror(){
            this.isVisible=false;//mustbeexplicitlyenabled
            this.sourceEl=null;
            this.mirrorEl=null;
            this.sourceElRect=null;//screencoordsrelativetoviewport
            //optionsthatcanbesetdirectlybycaller
            this.parentNode=document.body;
            this.zIndex=9999;
            this.revertDuration=0;
        }
        ElementMirror.prototype.start=function(sourceEl,pageX,pageY){
            this.sourceEl=sourceEl;
            this.sourceElRect=this.sourceEl.getBoundingClientRect();
            this.origScreenX=pageX-window.pageXOffset;
            this.origScreenY=pageY-window.pageYOffset;
            this.deltaX=0;
            this.deltaY=0;
            this.updateElPosition();
        };
        ElementMirror.prototype.handleMove=function(pageX,pageY){
            this.deltaX=(pageX-window.pageXOffset)-this.origScreenX;
            this.deltaY=(pageY-window.pageYOffset)-this.origScreenY;
            this.updateElPosition();
        };
        //canbecalledbeforestart
        ElementMirror.prototype.setIsVisible=function(bool){
            if(bool){
                if(!this.isVisible){
                    if(this.mirrorEl){
                        this.mirrorEl.style.display='';
                    }
                    this.isVisible=bool;//needstohappenbeforeupdateElPosition
                    this.updateElPosition();//becausewasnotupdatingthepositionwhileinvisible
                }
            }
            else{
                if(this.isVisible){
                    if(this.mirrorEl){
                        this.mirrorEl.style.display='none';
                    }
                    this.isVisible=bool;
                }
            }
        };
        //alwaysasync
        ElementMirror.prototype.stop=function(needsRevertAnimation,callback){
            var_this=this;
            vardone=function(){
                _this.cleanup();
                callback();
            };
            if(needsRevertAnimation&&
                this.mirrorEl&&
                this.isVisible&&
                this.revertDuration&&//if0,transitionwon'twork
                (this.deltaX||this.deltaY)//ifsamecoords,transitionwon'twork
            ){
                this.doRevertAnimation(done,this.revertDuration);
            }
            else{
                setTimeout(done,0);
            }
        };
        ElementMirror.prototype.doRevertAnimation=function(callback,revertDuration){
            varmirrorEl=this.mirrorEl;
            varfinalSourceElRect=this.sourceEl.getBoundingClientRect();//becauseautoscrollingmighthavehappened
            mirrorEl.style.transition=
                'top'+revertDuration+'ms,'+
                    'left'+revertDuration+'ms';
            core.applyStyle(mirrorEl,{
                left:finalSourceElRect.left,
                top:finalSourceElRect.top
            });
            core.whenTransitionDone(mirrorEl,function(){
                mirrorEl.style.transition='';
                callback();
            });
        };
        ElementMirror.prototype.cleanup=function(){
            if(this.mirrorEl){
                core.removeElement(this.mirrorEl);
                this.mirrorEl=null;
            }
            this.sourceEl=null;
        };
        ElementMirror.prototype.updateElPosition=function(){
            if(this.sourceEl&&this.isVisible){
                core.applyStyle(this.getMirrorEl(),{
                    left:this.sourceElRect.left+this.deltaX,
                    top:this.sourceElRect.top+this.deltaY
                });
            }
        };
        ElementMirror.prototype.getMirrorEl=function(){
            varsourceElRect=this.sourceElRect;
            varmirrorEl=this.mirrorEl;
            if(!mirrorEl){
                mirrorEl=this.mirrorEl=this.sourceEl.cloneNode(true);//cloneChildren=true
                //wedon'twantlongtapsoranymouseinteractioncausingselection/menus.
                //wouldusepreventSelection(),butthatpreventsselectstart,causingproblems.
                mirrorEl.classList.add('fc-unselectable');
                mirrorEl.classList.add('fc-dragging');
                core.applyStyle(mirrorEl,{
                    position:'fixed',
                    zIndex:this.zIndex,
                    visibility:'',
                    boxSizing:'border-box',
                    width:sourceElRect.right-sourceElRect.left,
                    height:sourceElRect.bottom-sourceElRect.top,
                    right:'auto',
                    bottom:'auto',
                    margin:0
                });
                this.parentNode.appendChild(mirrorEl);
            }
            returnmirrorEl;
        };
        returnElementMirror;
    }());

    /*
    Isacacheforagivenelement'sscrollinformation(alltheinfothatScrollControllerstores)
    inadditionthe"clientrectangle"oftheelement..theareawithinthescrollbars.

    Thecachecanbeinoneoftwomodes:
    -doesListening:false-ignoreswhenthecontainerisscrolledbysomeoneelse
    -doesListening:true-watchforscrollingandupdatethecache
    */
    varScrollGeomCache=/**@class*/(function(_super){
        __extends(ScrollGeomCache,_super);
        functionScrollGeomCache(scrollController,doesListening){
            var_this=_super.call(this)||this;
            _this.handleScroll=function(){
                _this.scrollTop=_this.scrollController.getScrollTop();
                _this.scrollLeft=_this.scrollController.getScrollLeft();
                _this.handleScrollChange();
            };
            _this.scrollController=scrollController;
            _this.doesListening=doesListening;
            _this.scrollTop=_this.origScrollTop=scrollController.getScrollTop();
            _this.scrollLeft=_this.origScrollLeft=scrollController.getScrollLeft();
            _this.scrollWidth=scrollController.getScrollWidth();
            _this.scrollHeight=scrollController.getScrollHeight();
            _this.clientWidth=scrollController.getClientWidth();
            _this.clientHeight=scrollController.getClientHeight();
            _this.clientRect=_this.computeClientRect();//dolastincaseitneedscachedvalues
            if(_this.doesListening){
                _this.getEventTarget().addEventListener('scroll',_this.handleScroll);
            }
            return_this;
        }
        ScrollGeomCache.prototype.destroy=function(){
            if(this.doesListening){
                this.getEventTarget().removeEventListener('scroll',this.handleScroll);
            }
        };
        ScrollGeomCache.prototype.getScrollTop=function(){
            returnthis.scrollTop;
        };
        ScrollGeomCache.prototype.getScrollLeft=function(){
            returnthis.scrollLeft;
        };
        ScrollGeomCache.prototype.setScrollTop=function(top){
            this.scrollController.setScrollTop(top);
            if(!this.doesListening){
                //wearenotrelyingontheelementtonormalizeout-of-boundsscrollvalues
                //soweneedtosanitizeourselves
                this.scrollTop=Math.max(Math.min(top,this.getMaxScrollTop()),0);
                this.handleScrollChange();
            }
        };
        ScrollGeomCache.prototype.setScrollLeft=function(top){
            this.scrollController.setScrollLeft(top);
            if(!this.doesListening){
                //wearenotrelyingontheelementtonormalizeout-of-boundsscrollvalues
                //soweneedtosanitizeourselves
                this.scrollLeft=Math.max(Math.min(top,this.getMaxScrollLeft()),0);
                this.handleScrollChange();
            }
        };
        ScrollGeomCache.prototype.getClientWidth=function(){
            returnthis.clientWidth;
        };
        ScrollGeomCache.prototype.getClientHeight=function(){
            returnthis.clientHeight;
        };
        ScrollGeomCache.prototype.getScrollWidth=function(){
            returnthis.scrollWidth;
        };
        ScrollGeomCache.prototype.getScrollHeight=function(){
            returnthis.scrollHeight;
        };
        ScrollGeomCache.prototype.handleScrollChange=function(){
        };
        returnScrollGeomCache;
    }(core.ScrollController));
    varElementScrollGeomCache=/**@class*/(function(_super){
        __extends(ElementScrollGeomCache,_super);
        functionElementScrollGeomCache(el,doesListening){
            return_super.call(this,newcore.ElementScrollController(el),doesListening)||this;
        }
        ElementScrollGeomCache.prototype.getEventTarget=function(){
            returnthis.scrollController.el;
        };
        ElementScrollGeomCache.prototype.computeClientRect=function(){
            returncore.computeInnerRect(this.scrollController.el);
        };
        returnElementScrollGeomCache;
    }(ScrollGeomCache));
    varWindowScrollGeomCache=/**@class*/(function(_super){
        __extends(WindowScrollGeomCache,_super);
        functionWindowScrollGeomCache(doesListening){
            return_super.call(this,newcore.WindowScrollController(),doesListening)||this;
        }
        WindowScrollGeomCache.prototype.getEventTarget=function(){
            returnwindow;
        };
        WindowScrollGeomCache.prototype.computeClientRect=function(){
            return{
                left:this.scrollLeft,
                right:this.scrollLeft+this.clientWidth,
                top:this.scrollTop,
                bottom:this.scrollTop+this.clientHeight
            };
        };
        //thewindowistheonlyscrollobjectthatchangesit'srectanglerelative
        //tothedocument'stopleftasitscrolls
        WindowScrollGeomCache.prototype.handleScrollChange=function(){
            this.clientRect=this.computeClientRect();
        };
        returnWindowScrollGeomCache;
    }(ScrollGeomCache));

    //Ifavailableweareusingnative"performance"APIinsteadof"Date"
    //ReadmoreaboutitonMDN:
    //https://developer.mozilla.org/en-US/docs/Web/API/Performance
    vargetTime=typeofperformance==='function'?performance.now:Date.now;
    /*
    Forapointerinteraction,automaticallyscrollscertainscrollcontainerswhenthepointer
    approachestheedge.

    Thecallermustcallstart+handleMove+stop.
    */
    varAutoScroller=/**@class*/(function(){
        functionAutoScroller(){
            var_this=this;
            //optionsthatcanbesetbycaller
            this.isEnabled=true;
            this.scrollQuery=[window,'.fc-scroller'];
            this.edgeThreshold=50;//pixels
            this.maxVelocity=300;//pixelspersecond
            //internalstate
            this.pointerScreenX=null;
            this.pointerScreenY=null;
            this.isAnimating=false;
            this.scrollCaches=null;
            //protectagainsttheinitialpointerdownbeingtooclosetoanedgeandstartingthescroll
            this.everMovedUp=false;
            this.everMovedDown=false;
            this.everMovedLeft=false;
            this.everMovedRight=false;
            this.animate=function(){
                if(_this.isAnimating){//wasn'tcancelledbetweenanimationcalls
                    varedge=_this.computeBestEdge(_this.pointerScreenX+window.pageXOffset,_this.pointerScreenY+window.pageYOffset);
                    if(edge){
                        varnow=getTime();
                        _this.handleSide(edge,(now-_this.msSinceRequest)/1000);
                        _this.requestAnimation(now);
                    }
                    else{
                        _this.isAnimating=false;//willstopanimation
                    }
                }
            };
        }
        AutoScroller.prototype.start=function(pageX,pageY){
            if(this.isEnabled){
                this.scrollCaches=this.buildCaches();
                this.pointerScreenX=null;
                this.pointerScreenY=null;
                this.everMovedUp=false;
                this.everMovedDown=false;
                this.everMovedLeft=false;
                this.everMovedRight=false;
                this.handleMove(pageX,pageY);
            }
        };
        AutoScroller.prototype.handleMove=function(pageX,pageY){
            if(this.isEnabled){
                varpointerScreenX=pageX-window.pageXOffset;
                varpointerScreenY=pageY-window.pageYOffset;
                varyDelta=this.pointerScreenY===null?0:pointerScreenY-this.pointerScreenY;
                varxDelta=this.pointerScreenX===null?0:pointerScreenX-this.pointerScreenX;
                if(yDelta<0){
                    this.everMovedUp=true;
                }
                elseif(yDelta>0){
                    this.everMovedDown=true;
                }
                if(xDelta<0){
                    this.everMovedLeft=true;
                }
                elseif(xDelta>0){
                    this.everMovedRight=true;
                }
                this.pointerScreenX=pointerScreenX;
                this.pointerScreenY=pointerScreenY;
                if(!this.isAnimating){
                    this.isAnimating=true;
                    this.requestAnimation(getTime());
                }
            }
        };
        AutoScroller.prototype.stop=function(){
            if(this.isEnabled){
                this.isAnimating=false;//willstopanimation
                for(var_i=0,_a=this.scrollCaches;_i<_a.length;_i++){
                    varscrollCache=_a[_i];
                    scrollCache.destroy();
                }
                this.scrollCaches=null;
            }
        };
        AutoScroller.prototype.requestAnimation=function(now){
            this.msSinceRequest=now;
            requestAnimationFrame(this.animate);
        };
        AutoScroller.prototype.handleSide=function(edge,seconds){
            varscrollCache=edge.scrollCache;
            varedgeThreshold=this.edgeThreshold;
            varinvDistance=edgeThreshold-edge.distance;
            varvelocity=//theclosertotheedge,thefasterwescroll
             (invDistance*invDistance)/(edgeThreshold*edgeThreshold)*//quadratic
                this.maxVelocity*seconds;
            varsign=1;
            switch(edge.name){
                case'left':
                    sign=-1;
                //fallsthrough
                case'right':
                    scrollCache.setScrollLeft(scrollCache.getScrollLeft()+velocity*sign);
                    break;
                case'top':
                    sign=-1;
                //fallsthrough
                case'bottom':
                    scrollCache.setScrollTop(scrollCache.getScrollTop()+velocity*sign);
                    break;
            }
        };
        //left/toparerelativetodocumenttopleft
        AutoScroller.prototype.computeBestEdge=function(left,top){
            varedgeThreshold=this.edgeThreshold;
            varbestSide=null;
            for(var_i=0,_a=this.scrollCaches;_i<_a.length;_i++){
                varscrollCache=_a[_i];
                varrect=scrollCache.clientRect;
                varleftDist=left-rect.left;
                varrightDist=rect.right-left;
                vartopDist=top-rect.top;
                varbottomDist=rect.bottom-top;
                //completelywithintherect?
                if(leftDist>=0&&rightDist>=0&&topDist>=0&&bottomDist>=0){
                    if(topDist<=edgeThreshold&&this.everMovedUp&&scrollCache.canScrollUp()&&
                        (!bestSide||bestSide.distance>topDist)){
                        bestSide={scrollCache:scrollCache,name:'top',distance:topDist};
                    }
                    if(bottomDist<=edgeThreshold&&this.everMovedDown&&scrollCache.canScrollDown()&&
                        (!bestSide||bestSide.distance>bottomDist)){
                        bestSide={scrollCache:scrollCache,name:'bottom',distance:bottomDist};
                    }
                    if(leftDist<=edgeThreshold&&this.everMovedLeft&&scrollCache.canScrollLeft()&&
                        (!bestSide||bestSide.distance>leftDist)){
                        bestSide={scrollCache:scrollCache,name:'left',distance:leftDist};
                    }
                    if(rightDist<=edgeThreshold&&this.everMovedRight&&scrollCache.canScrollRight()&&
                        (!bestSide||bestSide.distance>rightDist)){
                        bestSide={scrollCache:scrollCache,name:'right',distance:rightDist};
                    }
                }
            }
            returnbestSide;
        };
        AutoScroller.prototype.buildCaches=function(){
            returnthis.queryScrollEls().map(function(el){
                if(el===window){
                    returnnewWindowScrollGeomCache(false);//false=don'tlistentouser-generatedscrolls
                }
                else{
                    returnnewElementScrollGeomCache(el,false);//false=don'tlistentouser-generatedscrolls
                }
            });
        };
        AutoScroller.prototype.queryScrollEls=function(){
            varels=[];
            for(var_i=0,_a=this.scrollQuery;_i<_a.length;_i++){
                varquery=_a[_i];
                if(typeofquery==='object'){
                    els.push(query);
                }
                else{
                    els.push.apply(els,Array.prototype.slice.call(document.querySelectorAll(query)));
                }
            }
            returnels;
        };
        returnAutoScroller;
    }());

    /*
    Monitorsdraggingonanelement.Hasanumberofhigh-levelfeatures:
    -minimumdistancerequiredbeforedragging
    -minimumwaittime("delay")beforedragging
    -amirrorelementthatfollowsthepointer
    */
    varFeaturefulElementDragging=/**@class*/(function(_super){
        __extends(FeaturefulElementDragging,_super);
        functionFeaturefulElementDragging(containerEl){
            var_this=_super.call(this,containerEl)||this;
            //optionsthatcanbedirectlysetbycaller
            //thecallercanalsosetthePointerDragging'soptionsaswell
            _this.delay=null;
            _this.minDistance=0;
            _this.touchScrollAllowed=true;//preventsdragfromstartingandblocksscrollingduringdrag
            _this.mirrorNeedsRevert=false;
            _this.isInteracting=false;//istheuservalidlymovingthepointer?lastsuntilpointerup
            _this.isDragging=false;//isitINTENTFULLYdragging?lastsuntilafterrevertanimation
            _this.isDelayEnded=false;
            _this.isDistanceSurpassed=false;
            _this.delayTimeoutId=null;
            _this.onPointerDown=function(ev){
                if(!_this.isDragging){//sonewdragdoesn'thappenwhilerevertanimationisgoing
                    _this.isInteracting=true;
                    _this.isDelayEnded=false;
                    _this.isDistanceSurpassed=false;
                    core.preventSelection(document.body);
                    core.preventContextMenu(document.body);
                    //preventlinksfrombeingvisitedifthere'saneventualdrag.
                    //alsopreventsselectioninolderbrowsers(maybe?).
                    //notnecessaryfortouch,besides,browserwouldcomplainaboutpassiveness.
                    if(!ev.isTouch){
                        ev.origEvent.preventDefault();
                    }
                    _this.emitter.trigger('pointerdown',ev);
                    if(!_this.pointer.shouldIgnoreMove){
                        //actionsrelatedtoinitiatingdragstart+dragmove+dragend...
                        _this.mirror.setIsVisible(false);//reset.callermustset-visible
                        _this.mirror.start(ev.subjectEl,ev.pageX,ev.pageY);//musthappenonfirstpointerdown
                        _this.startDelay(ev);
                        if(!_this.minDistance){
                            _this.handleDistanceSurpassed(ev);
                        }
                    }
                }
            };
            _this.onPointerMove=function(ev){
                if(_this.isInteracting){//iffalse,stillwaitingforpreviousdrag'srevert
                    _this.emitter.trigger('pointermove',ev);
                    if(!_this.isDistanceSurpassed){
                        varminDistance=_this.minDistance;
                        vardistanceSq=void0;//currentdistancefromtheorigin,squared
                        vardeltaX=ev.deltaX,deltaY=ev.deltaY;
                        distanceSq=deltaX*deltaX+deltaY*deltaY;
                        if(distanceSq>=minDistance*minDistance){//usepythagoreantheorem
                            _this.handleDistanceSurpassed(ev);
                        }
                    }
                    if(_this.isDragging){
                        //arealpointermove?(notonesimulatedbyscrolling)
                        if(ev.origEvent.type!=='scroll'){
                            _this.mirror.handleMove(ev.pageX,ev.pageY);
                            _this.autoScroller.handleMove(ev.pageX,ev.pageY);
                        }
                        _this.emitter.trigger('dragmove',ev);
                    }
                }
            };
            _this.onPointerUp=function(ev){
                if(_this.isInteracting){//iffalse,stillwaitingforpreviousdrag'srevert
                    _this.isInteracting=false;
                    core.allowSelection(document.body);
                    core.allowContextMenu(document.body);
                    _this.emitter.trigger('pointerup',ev);//canpotentiallysetmirrorNeedsRevert
                    if(_this.isDragging){
                        _this.autoScroller.stop();
                        _this.tryStopDrag(ev);//whichwillstopthemirror
                    }
                    if(_this.delayTimeoutId){
                        clearTimeout(_this.delayTimeoutId);
                        _this.delayTimeoutId=null;
                    }
                }
            };
            varpointer=_this.pointer=newPointerDragging(containerEl);
            pointer.emitter.on('pointerdown',_this.onPointerDown);
            pointer.emitter.on('pointermove',_this.onPointerMove);
            pointer.emitter.on('pointerup',_this.onPointerUp);
            _this.mirror=newElementMirror();
            _this.autoScroller=newAutoScroller();
            return_this;
        }
        FeaturefulElementDragging.prototype.destroy=function(){
            this.pointer.destroy();
        };
        FeaturefulElementDragging.prototype.startDelay=function(ev){
            var_this=this;
            if(typeofthis.delay==='number'){
                this.delayTimeoutId=setTimeout(function(){
                    _this.delayTimeoutId=null;
                    _this.handleDelayEnd(ev);
                },this.delay);//notassignabletonumber!
            }
            else{
                this.handleDelayEnd(ev);
            }
        };
        FeaturefulElementDragging.prototype.handleDelayEnd=function(ev){
            this.isDelayEnded=true;
            this.tryStartDrag(ev);
        };
        FeaturefulElementDragging.prototype.handleDistanceSurpassed=function(ev){
            this.isDistanceSurpassed=true;
            this.tryStartDrag(ev);
        };
        FeaturefulElementDragging.prototype.tryStartDrag=function(ev){
            if(this.isDelayEnded&&this.isDistanceSurpassed){
                if(!this.pointer.wasTouchScroll||this.touchScrollAllowed){
                    this.isDragging=true;
                    this.mirrorNeedsRevert=false;
                    this.autoScroller.start(ev.pageX,ev.pageY);
                    this.emitter.trigger('dragstart',ev);
                    if(this.touchScrollAllowed===false){
                        this.pointer.cancelTouchScroll();
                    }
                }
            }
        };
        FeaturefulElementDragging.prototype.tryStopDrag=function(ev){
            //.stop()isALWAYSasynchronous,whichweNEEDbecausewewantallpointerupevents
            //thatcomefromthedocumenttofirebeforehand.muchmoreconvenientthisway.
            this.mirror.stop(this.mirrorNeedsRevert,this.stopDrag.bind(this,ev)//boundwithargs
            );
        };
        FeaturefulElementDragging.prototype.stopDrag=function(ev){
            this.isDragging=false;
            this.emitter.trigger('dragend',ev);
        };
        //fillintheimplementations...
        FeaturefulElementDragging.prototype.setIgnoreMove=function(bool){
            this.pointer.shouldIgnoreMove=bool;
        };
        FeaturefulElementDragging.prototype.setMirrorIsVisible=function(bool){
            this.mirror.setIsVisible(bool);
        };
        FeaturefulElementDragging.prototype.setMirrorNeedsRevert=function(bool){
            this.mirrorNeedsRevert=bool;
        };
        FeaturefulElementDragging.prototype.setAutoScrollEnabled=function(bool){
            this.autoScroller.isEnabled=bool;
        };
        returnFeaturefulElementDragging;
    }(core.ElementDragging));

    /*
    Whenthisclassisinstantiated,itrecordstheoffsetofanelement(relativetothedocumenttopleft),
    andcontinuestomonitorscrolling,updatingthecachedcoordinatesifitneedsto.
    DoesnotaccesstheDOMafterinstantiation,sohighlyperformant.

    Alsokeepstrackofallscrolling/overflow:hiddencontainersthatareparentsofthegivenelement
    andandetermineifagivenpointisinsidethecombinedclippingrectangle.
    */
    varOffsetTracker=/**@class*/(function(){
        functionOffsetTracker(el){
            this.origRect=core.computeRect(el);
            //willworkfinefordivsthathaveoverflow:hidden
            this.scrollCaches=core.getClippingParents(el).map(function(el){
                returnnewElementScrollGeomCache(el,true);//listen=true
            });
        }
        OffsetTracker.prototype.destroy=function(){
            for(var_i=0,_a=this.scrollCaches;_i<_a.length;_i++){
                varscrollCache=_a[_i];
                scrollCache.destroy();
            }
        };
        OffsetTracker.prototype.computeLeft=function(){
            varleft=this.origRect.left;
            for(var_i=0,_a=this.scrollCaches;_i<_a.length;_i++){
                varscrollCache=_a[_i];
                left+=scrollCache.origScrollLeft-scrollCache.getScrollLeft();
            }
            returnleft;
        };
        OffsetTracker.prototype.computeTop=function(){
            vartop=this.origRect.top;
            for(var_i=0,_a=this.scrollCaches;_i<_a.length;_i++){
                varscrollCache=_a[_i];
                top+=scrollCache.origScrollTop-scrollCache.getScrollTop();
            }
            returntop;
        };
        OffsetTracker.prototype.isWithinClipping=function(pageX,pageY){
            varpoint={left:pageX,top:pageY};
            for(var_i=0,_a=this.scrollCaches;_i<_a.length;_i++){
                varscrollCache=_a[_i];
                if(!isIgnoredClipping(scrollCache.getEventTarget())&&
                    !core.pointInsideRect(point,scrollCache.clientRect)){
                    returnfalse;
                }
            }
            returntrue;
        };
        returnOffsetTracker;
    }());
    //certainclippingcontainersshouldneverconstraininteractions,like<html>and<body>
    //https://github.com/fullcalendar/fullcalendar/issues/3615
    functionisIgnoredClipping(node){
        vartagName=node.tagName;
        returntagName==='HTML'||tagName==='BODY';
    }

    /*
    Tracksmovementovermultipledroppableareas(aka"hits")
    thatexistinoneormoreDateComponents.
    Reliesonanexistingdraggable.

    emits:
    -pointerdown
    -dragstart
    -hitchange-firesinitially,evenifnotoverahit
    -pointerup
    -(hitchange-again,tonull,ifendedoverahit)
    -dragend
    */
    varHitDragging=/**@class*/(function(){
        functionHitDragging(dragging,droppableStore){
            var_this=this;
            //optionsthatcanbesetbycaller
            this.useSubjectCenter=false;
            this.requireInitial=true;//ifdoesn'tstartoutonahit,won'temitanyevents
            this.initialHit=null;
            this.movingHit=null;
            this.finalHit=null;//won'teverbepopulatedifshouldIgnoreMove
            this.handlePointerDown=function(ev){
                vardragging=_this.dragging;
                _this.initialHit=null;
                _this.movingHit=null;
                _this.finalHit=null;
                _this.prepareHits();
                _this.processFirstCoord(ev);
                if(_this.initialHit||!_this.requireInitial){
                    dragging.setIgnoreMove(false);
                    _this.emitter.trigger('pointerdown',ev);//TODO:firethisbeforecomputingprocessFirstCoord,solistenerscancancel.thisgetsfiredbyalmosteveryhandler:(
                }
                else{
                    dragging.setIgnoreMove(true);
                }
            };
            this.handleDragStart=function(ev){
                _this.emitter.trigger('dragstart',ev);
                _this.handleMove(ev,true);//force=fireevenifinitiallynull
            };
            this.handleDragMove=function(ev){
                _this.emitter.trigger('dragmove',ev);
                _this.handleMove(ev);
            };
            this.handlePointerUp=function(ev){
                _this.releaseHits();
                _this.emitter.trigger('pointerup',ev);
            };
            this.handleDragEnd=function(ev){
                if(_this.movingHit){
                    _this.emitter.trigger('hitupdate',null,true,ev);
                }
                _this.finalHit=_this.movingHit;
                _this.movingHit=null;
                _this.emitter.trigger('dragend',ev);
            };
            this.droppableStore=droppableStore;
            dragging.emitter.on('pointerdown',this.handlePointerDown);
            dragging.emitter.on('dragstart',this.handleDragStart);
            dragging.emitter.on('dragmove',this.handleDragMove);
            dragging.emitter.on('pointerup',this.handlePointerUp);
            dragging.emitter.on('dragend',this.handleDragEnd);
            this.dragging=dragging;
            this.emitter=newcore.EmitterMixin();
        }
        //setsinitialHit
        //setscoordAdjust
        HitDragging.prototype.processFirstCoord=function(ev){
            varorigPoint={left:ev.pageX,top:ev.pageY};
            varadjustedPoint=origPoint;
            varsubjectEl=ev.subjectEl;
            varsubjectRect;
            if(subjectEl!==document){
                subjectRect=core.computeRect(subjectEl);
                adjustedPoint=core.constrainPoint(adjustedPoint,subjectRect);
            }
            varinitialHit=this.initialHit=this.queryHitForOffset(adjustedPoint.left,adjustedPoint.top);
            if(initialHit){
                if(this.useSubjectCenter&&subjectRect){
                    varslicedSubjectRect=core.intersectRects(subjectRect,initialHit.rect);
                    if(slicedSubjectRect){
                        adjustedPoint=core.getRectCenter(slicedSubjectRect);
                    }
                }
                this.coordAdjust=core.diffPoints(adjustedPoint,origPoint);
            }
            else{
                this.coordAdjust={left:0,top:0};
            }
        };
        HitDragging.prototype.handleMove=function(ev,forceHandle){
            varhit=this.queryHitForOffset(ev.pageX+this.coordAdjust.left,ev.pageY+this.coordAdjust.top);
            if(forceHandle||!isHitsEqual(this.movingHit,hit)){
                this.movingHit=hit;
                this.emitter.trigger('hitupdate',hit,false,ev);
            }
        };
        HitDragging.prototype.prepareHits=function(){
            this.offsetTrackers=core.mapHash(this.droppableStore,function(interactionSettings){
                interactionSettings.component.buildPositionCaches();
                returnnewOffsetTracker(interactionSettings.el);
            });
        };
        HitDragging.prototype.releaseHits=function(){
            varoffsetTrackers=this.offsetTrackers;
            for(varidinoffsetTrackers){
                offsetTrackers[id].destroy();
            }
            this.offsetTrackers={};
        };
        HitDragging.prototype.queryHitForOffset=function(offsetLeft,offsetTop){
            var_a=this,droppableStore=_a.droppableStore,offsetTrackers=_a.offsetTrackers;
            varbestHit=null;
            for(varidindroppableStore){
                varcomponent=droppableStore[id].component;
                varoffsetTracker=offsetTrackers[id];
                if(offsetTracker.isWithinClipping(offsetLeft,offsetTop)){
                    varoriginLeft=offsetTracker.computeLeft();
                    varoriginTop=offsetTracker.computeTop();
                    varpositionLeft=offsetLeft-originLeft;
                    varpositionTop=offsetTop-originTop;
                    varorigRect=offsetTracker.origRect;
                    varwidth=origRect.right-origRect.left;
                    varheight=origRect.bottom-origRect.top;
                    if(
                    //mustbewithintheelement'sbounds
                    positionLeft>=0&&positionLeft<width&&
                        positionTop>=0&&positionTop<height){
                        varhit=component.queryHit(positionLeft,positionTop,width,height);
                        if(hit&&
                            (
                            //makesurethehitiswithinactiveRange,meaningit'snotadealcell
                            !component.props.dateProfile||//hackforDayTile
                                core.rangeContainsRange(component.props.dateProfile.activeRange,hit.dateSpan.range))&&
                            (!bestHit||hit.layer>bestHit.layer)){
                            //TODO:betterwaytore-orientrectangle
                            hit.rect.left+=originLeft;
                            hit.rect.right+=originLeft;
                            hit.rect.top+=originTop;
                            hit.rect.bottom+=originTop;
                            bestHit=hit;
                        }
                    }
                }
            }
            returnbestHit;
        };
        returnHitDragging;
    }());
    functionisHitsEqual(hit0,hit1){
        if(!hit0&&!hit1){
            returntrue;
        }
        if(Boolean(hit0)!==Boolean(hit1)){
            returnfalse;
        }
        returncore.isDateSpansEqual(hit0.dateSpan,hit1.dateSpan);
    }

    /*
    Monitorswhentheuserclicksonaspecificdate/timeofacomponent.
    Apointerdown+pointeruponthesame"hit"constitutesaclick.
    */
    varDateClicking=/**@class*/(function(_super){
        __extends(DateClicking,_super);
        functionDateClicking(settings){
            var_this=_super.call(this,settings)||this;
            _this.handlePointerDown=function(ev){
                vardragging=_this.dragging;
                //dothisinpointerdown(notdragend)becauseDOMmightbemutatedbythetimedragendisfired
                dragging.setIgnoreMove(!_this.component.isValidDateDownEl(dragging.pointer.downEl));
            };
            //won'tevenfireifmovingwasignored
            _this.handleDragEnd=function(ev){
                varcomponent=_this.component;
                var_a=component.context,calendar=_a.calendar,view=_a.view;
                varpointer=_this.dragging.pointer;
                if(!pointer.wasTouchScroll){
                    var_b=_this.hitDragging,initialHit=_b.initialHit,finalHit=_b.finalHit;
                    if(initialHit&&finalHit&&isHitsEqual(initialHit,finalHit)){
                        calendar.triggerDateClick(initialHit.dateSpan,initialHit.dayEl,view,ev.origEvent);
                    }
                }
            };
            varcomponent=settings.component;
            //weDOwanttowatchpointermovesbecauseotherwisefinalHitwon'tgetpopulated
            _this.dragging=newFeaturefulElementDragging(component.el);
            _this.dragging.autoScroller.isEnabled=false;
            varhitDragging=_this.hitDragging=newHitDragging(_this.dragging,core.interactionSettingsToStore(settings));
            hitDragging.emitter.on('pointerdown',_this.handlePointerDown);
            hitDragging.emitter.on('dragend',_this.handleDragEnd);
            return_this;
        }
        DateClicking.prototype.destroy=function(){
            this.dragging.destroy();
        };
        returnDateClicking;
    }(core.Interaction));

    /*
    Trackswhentheuserselectsaportionoftimeofacomponent,
    constitutedbyadragoverdatecells,withapossibledelayatthebeginningofthedrag.
    */
    varDateSelecting=/**@class*/(function(_super){
        __extends(DateSelecting,_super);
        functionDateSelecting(settings){
            var_this=_super.call(this,settings)||this;
            _this.dragSelection=null;
            _this.handlePointerDown=function(ev){
                var_a=_this,component=_a.component,dragging=_a.dragging;
                varoptions=component.context.options;
                varcanSelect=options.selectable&&
                    component.isValidDateDownEl(ev.origEvent.target);
                //don'tbothertowatchexpensivemovesifcomponentwon'tdoselection
                dragging.setIgnoreMove(!canSelect);
                //iftouch,requireusertoholddown
                dragging.delay=ev.isTouch?getComponentTouchDelay(component):null;
            };
            _this.handleDragStart=function(ev){
                _this.component.context.calendar.unselect(ev);//unselectpreviousselections
            };
            _this.handleHitUpdate=function(hit,isFinal){
                varcalendar=_this.component.context.calendar;
                vardragSelection=null;
                varisInvalid=false;
                if(hit){
                    dragSelection=joinHitsIntoSelection(_this.hitDragging.initialHit,hit,calendar.pluginSystem.hooks.dateSelectionTransformers);
                    if(!dragSelection||!_this.component.isDateSelectionValid(dragSelection)){
                        isInvalid=true;
                        dragSelection=null;
                    }
                }
                if(dragSelection){
                    calendar.dispatch({type:'SELECT_DATES',selection:dragSelection});
                }
                elseif(!isFinal){//onlyunselectifmovedawaywhiledragging
                    calendar.dispatch({type:'UNSELECT_DATES'});
                }
                if(!isInvalid){
                    core.enableCursor();
                }
                else{
                    core.disableCursor();
                }
                if(!isFinal){
                    _this.dragSelection=dragSelection;//onlyclearifmovedawayfromallhitswhiledragging
                }
            };
            _this.handlePointerUp=function(pev){
                if(_this.dragSelection){
                    //selectionisalreadyrendered,sojustneedtoreportselection
                    _this.component.context.calendar.triggerDateSelect(_this.dragSelection,pev);
                    _this.dragSelection=null;
                }
            };
            varcomponent=settings.component;
            varoptions=component.context.options;
            vardragging=_this.dragging=newFeaturefulElementDragging(component.el);
            dragging.touchScrollAllowed=false;
            dragging.minDistance=options.selectMinDistance||0;
            dragging.autoScroller.isEnabled=options.dragScroll;
            varhitDragging=_this.hitDragging=newHitDragging(_this.dragging,core.interactionSettingsToStore(settings));
            hitDragging.emitter.on('pointerdown',_this.handlePointerDown);
            hitDragging.emitter.on('dragstart',_this.handleDragStart);
            hitDragging.emitter.on('hitupdate',_this.handleHitUpdate);
            hitDragging.emitter.on('pointerup',_this.handlePointerUp);
            return_this;
        }
        DateSelecting.prototype.destroy=function(){
            this.dragging.destroy();
        };
        returnDateSelecting;
    }(core.Interaction));
    functiongetComponentTouchDelay(component){
        varoptions=component.context.options;
        vardelay=options.selectLongPressDelay;
        if(delay==null){
            delay=options.longPressDelay;
        }
        returndelay;
    }
    functionjoinHitsIntoSelection(hit0,hit1,dateSelectionTransformers){
        vardateSpan0=hit0.dateSpan;
        vardateSpan1=hit1.dateSpan;
        varms=[
            dateSpan0.range.start,
            dateSpan0.range.end,
            dateSpan1.range.start,
            dateSpan1.range.end
        ];
        ms.sort(core.compareNumbers);
        varprops={};
        for(var_i=0,dateSelectionTransformers_1=dateSelectionTransformers;_i<dateSelectionTransformers_1.length;_i++){
            vartransformer=dateSelectionTransformers_1[_i];
            varres=transformer(hit0,hit1);
            if(res===false){
                returnnull;
            }
            elseif(res){
                __assign(props,res);
            }
        }
        props.range={start:ms[0],end:ms[3]};
        props.allDay=dateSpan0.allDay;
        returnprops;
    }

    varEventDragging=/**@class*/(function(_super){
        __extends(EventDragging,_super);
        functionEventDragging(settings){
            var_this=_super.call(this,settings)||this;
            //internalstate
            _this.subjectSeg=null;//thesegbeingselected/dragged
            _this.isDragging=false;
            _this.eventRange=null;
            _this.relevantEvents=null;//theeventsbeingdragged
            _this.receivingCalendar=null;
            _this.validMutation=null;
            _this.mutatedRelevantEvents=null;
            _this.handlePointerDown=function(ev){
                varorigTarget=ev.origEvent.target;
                var_a=_this,component=_a.component,dragging=_a.dragging;
                varmirror=dragging.mirror;
                varoptions=component.context.options;
                varinitialCalendar=component.context.calendar;
                varsubjectSeg=_this.subjectSeg=core.getElSeg(ev.subjectEl);
                vareventRange=_this.eventRange=subjectSeg.eventRange;
                vareventInstanceId=eventRange.instance.instanceId;
                _this.relevantEvents=core.getRelevantEvents(initialCalendar.state.eventStore,eventInstanceId);
                dragging.minDistance=ev.isTouch?0:options.eventDragMinDistance;
                dragging.delay=
                    //onlydoatouchdelayiftouchandthiseventhasn'tbeenselectedyet
                    (ev.isTouch&&eventInstanceId!==component.props.eventSelection)?
                        getComponentTouchDelay$1(component):
                        null;
                mirror.parentNode=initialCalendar.el;
                mirror.revertDuration=options.dragRevertDuration;
                varisValid=component.isValidSegDownEl(origTarget)&&
                    !core.elementClosest(origTarget,'.fc-resizer');//NOTonaresizer
                dragging.setIgnoreMove(!isValid);
                //disabledraggingforelementsthatareresizable(ie,selectable)
                //butarenotdraggable
                _this.isDragging=isValid&&
                    ev.subjectEl.classList.contains('fc-draggable');
            };
            _this.handleDragStart=function(ev){
                varcontext=_this.component.context;
                varinitialCalendar=context.calendar;
                vareventRange=_this.eventRange;
                vareventInstanceId=eventRange.instance.instanceId;
                if(ev.isTouch){
                    //needtoselectadifferentevent?
                    if(eventInstanceId!==_this.component.props.eventSelection){
                        initialCalendar.dispatch({type:'SELECT_EVENT',eventInstanceId:eventInstanceId});
                    }
                }
                else{
                    //ifnowusingmouse,butwasprevioustouchinteraction,clearselectedevent
                    initialCalendar.dispatch({type:'UNSELECT_EVENT'});
                }
                if(_this.isDragging){
                    initialCalendar.unselect(ev);//unselect*date*selection
                    initialCalendar.publiclyTrigger('eventDragStart',[
                        {
                            el:_this.subjectSeg.el,
                            event:newcore.EventApi(initialCalendar,eventRange.def,eventRange.instance),
                            jsEvent:ev.origEvent,
                            view:context.view
                        }
                    ]);
                }
            };
            _this.handleHitUpdate=function(hit,isFinal){
                if(!_this.isDragging){
                    return;
                }
                varrelevantEvents=_this.relevantEvents;
                varinitialHit=_this.hitDragging.initialHit;
                varinitialCalendar=_this.component.context.calendar;
                //statesbasedonnewhit
                varreceivingCalendar=null;
                varmutation=null;
                varmutatedRelevantEvents=null;
                varisInvalid=false;
                varinteraction={
                    affectedEvents:relevantEvents,
                    mutatedEvents:core.createEmptyEventStore(),
                    isEvent:true,
                    origSeg:_this.subjectSeg
                };
                if(hit){
                    varreceivingComponent=hit.component;
                    receivingCalendar=receivingComponent.context.calendar;
                    varreceivingOptions=receivingComponent.context.options;
                    if(initialCalendar===receivingCalendar||
                        receivingOptions.editable&&receivingOptions.droppable){
                        mutation=computeEventMutation(initialHit,hit,receivingCalendar.pluginSystem.hooks.eventDragMutationMassagers);
                        if(mutation){
                            mutatedRelevantEvents=core.applyMutationToEventStore(relevantEvents,receivingCalendar.eventUiBases,mutation,receivingCalendar);
                            interaction.mutatedEvents=mutatedRelevantEvents;
                            if(!receivingComponent.isInteractionValid(interaction)){
                                isInvalid=true;
                                mutation=null;
                                mutatedRelevantEvents=null;
                                interaction.mutatedEvents=core.createEmptyEventStore();
                            }
                        }
                    }
                    else{
                        receivingCalendar=null;
                    }
                }
                _this.displayDrag(receivingCalendar,interaction);
                if(!isInvalid){
                    core.enableCursor();
                }
                else{
                    core.disableCursor();
                }
                if(!isFinal){
                    if(initialCalendar===receivingCalendar&&//TODO:writetestforthis
                        isHitsEqual(initialHit,hit)){
                        mutation=null;
                    }
                    _this.dragging.setMirrorNeedsRevert(!mutation);
                    //renderthemirrorifnoalready-renderedmirror
                    //TODO:wishwecouldsomehowwaitfordispatchtoguaranteerender
                    _this.dragging.setMirrorIsVisible(!hit||!document.querySelector('.fc-mirror'));
                    //assignstatesbasedonnewhit
                    _this.receivingCalendar=receivingCalendar;
                    _this.validMutation=mutation;
                    _this.mutatedRelevantEvents=mutatedRelevantEvents;
                }
            };
            _this.handlePointerUp=function(){
                if(!_this.isDragging){
                    _this.cleanup();//becausehandleDragEndwon'tfire
                }
            };
            _this.handleDragEnd=function(ev){
                if(_this.isDragging){
                    varcontext=_this.component.context;
                    varinitialCalendar_1=context.calendar;
                    varinitialView=context.view;
                    var_a=_this,receivingCalendar=_a.receivingCalendar,validMutation=_a.validMutation;
                    vareventDef=_this.eventRange.def;
                    vareventInstance=_this.eventRange.instance;
                    vareventApi=newcore.EventApi(initialCalendar_1,eventDef,eventInstance);
                    varrelevantEvents_1=_this.relevantEvents;
                    varmutatedRelevantEvents=_this.mutatedRelevantEvents;
                    varfinalHit=_this.hitDragging.finalHit;
                    _this.clearDrag();//musthappenafterrevertanimation
                    initialCalendar_1.publiclyTrigger('eventDragStop',[
                        {
                            el:_this.subjectSeg.el,
                            event:eventApi,
                            jsEvent:ev.origEvent,
                            view:initialView
                        }
                    ]);
                    if(validMutation){
                        //droppedwithinsamecalendar
                        if(receivingCalendar===initialCalendar_1){
                            initialCalendar_1.dispatch({
                                type:'MERGE_EVENTS',
                                eventStore:mutatedRelevantEvents
                            });
                            vartransformed={};
                            for(var_i=0,_b=initialCalendar_1.pluginSystem.hooks.eventDropTransformers;_i<_b.length;_i++){
                                vartransformer=_b[_i];
                                __assign(transformed,transformer(validMutation,initialCalendar_1));
                            }
                            vareventDropArg=__assign({},transformed,{el:ev.subjectEl,delta:validMutation.datesDelta,oldEvent:eventApi,event:newcore.EventApi(//thedataAFTERthemutation
                                initialCalendar_1,mutatedRelevantEvents.defs[eventDef.defId],eventInstance?mutatedRelevantEvents.instances[eventInstance.instanceId]:null),revert:function(){
                                    initialCalendar_1.dispatch({
                                        type:'MERGE_EVENTS',
                                        eventStore:relevantEvents_1
                                    });
                                },jsEvent:ev.origEvent,view:initialView});
                            initialCalendar_1.publiclyTrigger('eventDrop',[eventDropArg]);
                            //droppedindifferentcalendar
                        }
                        elseif(receivingCalendar){
                            initialCalendar_1.publiclyTrigger('eventLeave',[
                                {
                                    draggedEl:ev.subjectEl,
                                    event:eventApi,
                                    view:initialView
                                }
                            ]);
                            initialCalendar_1.dispatch({
                                type:'REMOVE_EVENT_INSTANCES',
                                instances:_this.mutatedRelevantEvents.instances
                            });
                            receivingCalendar.dispatch({
                                type:'MERGE_EVENTS',
                                eventStore:_this.mutatedRelevantEvents
                            });
                            if(ev.isTouch){
                                receivingCalendar.dispatch({
                                    type:'SELECT_EVENT',
                                    eventInstanceId:eventInstance.instanceId
                                });
                            }
                            vardropArg=__assign({},receivingCalendar.buildDatePointApi(finalHit.dateSpan),{draggedEl:ev.subjectEl,jsEvent:ev.origEvent,view:finalHit.component//shouldthisbefinalHit.component.view?See#4644
                             });
                            receivingCalendar.publiclyTrigger('drop',[dropArg]);
                            receivingCalendar.publiclyTrigger('eventReceive',[
                                {
                                    draggedEl:ev.subjectEl,
                                    event:newcore.EventApi(//thedataAFTERthemutation
                                    receivingCalendar,mutatedRelevantEvents.defs[eventDef.defId],mutatedRelevantEvents.instances[eventInstance.instanceId]),
                                    view:finalHit.component//shouldthisbefinalHit.component.view?See#4644
                                }
                            ]);
                        }
                    }
                    else{
                        initialCalendar_1.publiclyTrigger('_noEventDrop');
                    }
                }
                _this.cleanup();
            };
            varcomponent=_this.component;
            varoptions=component.context.options;
            vardragging=_this.dragging=newFeaturefulElementDragging(component.el);
            dragging.pointer.selector=EventDragging.SELECTOR;
            dragging.touchScrollAllowed=false;
            dragging.autoScroller.isEnabled=options.dragScroll;
            varhitDragging=_this.hitDragging=newHitDragging(_this.dragging,core.interactionSettingsStore);
            hitDragging.useSubjectCenter=settings.useEventCenter;
            hitDragging.emitter.on('pointerdown',_this.handlePointerDown);
            hitDragging.emitter.on('dragstart',_this.handleDragStart);
            hitDragging.emitter.on('hitupdate',_this.handleHitUpdate);
            hitDragging.emitter.on('pointerup',_this.handlePointerUp);
            hitDragging.emitter.on('dragend',_this.handleDragEnd);
            return_this;
        }
        EventDragging.prototype.destroy=function(){
            this.dragging.destroy();
        };
        //renderadragstateonthenextreceivingCalendar
        EventDragging.prototype.displayDrag=function(nextCalendar,state){
            varinitialCalendar=this.component.context.calendar;
            varprevCalendar=this.receivingCalendar;
            //doesthepreviouscalendarneedtobecleared?
            if(prevCalendar&&prevCalendar!==nextCalendar){
                //doestheinitialcalendarneedtobecleared?
                //ifso,don'tclearalltheway.westillneedtotohidetheaffectedEvents
                if(prevCalendar===initialCalendar){
                    prevCalendar.dispatch({
                        type:'SET_EVENT_DRAG',
                        state:{
                            affectedEvents:state.affectedEvents,
                            mutatedEvents:core.createEmptyEventStore(),
                            isEvent:true,
                            origSeg:state.origSeg
                        }
                    });
                    //completelycleartheoldcalendarifitwasn'ttheinitial
                }
                else{
                    prevCalendar.dispatch({type:'UNSET_EVENT_DRAG'});
                }
            }
            if(nextCalendar){
                nextCalendar.dispatch({type:'SET_EVENT_DRAG',state:state});
            }
        };
        EventDragging.prototype.clearDrag=function(){
            varinitialCalendar=this.component.context.calendar;
            varreceivingCalendar=this.receivingCalendar;
            if(receivingCalendar){
                receivingCalendar.dispatch({type:'UNSET_EVENT_DRAG'});
            }
            //theinitialcalendarmighthaveandummydragstatefromdisplayDrag
            if(initialCalendar!==receivingCalendar){
                initialCalendar.dispatch({type:'UNSET_EVENT_DRAG'});
            }
        };
        EventDragging.prototype.cleanup=function(){
            this.subjectSeg=null;
            this.isDragging=false;
            this.eventRange=null;
            this.relevantEvents=null;
            this.receivingCalendar=null;
            this.validMutation=null;
            this.mutatedRelevantEvents=null;
        };
        EventDragging.SELECTOR='.fc-draggable,.fc-resizable';//TODO:testthisinIE11
        returnEventDragging;
    }(core.Interaction));
    functioncomputeEventMutation(hit0,hit1,massagers){
        vardateSpan0=hit0.dateSpan;
        vardateSpan1=hit1.dateSpan;
        vardate0=dateSpan0.range.start;
        vardate1=dateSpan1.range.start;
        varstandardProps={};
        if(dateSpan0.allDay!==dateSpan1.allDay){
            standardProps.allDay=dateSpan1.allDay;
            standardProps.hasEnd=hit1.component.context.options.allDayMaintainDuration;
            if(dateSpan1.allDay){
                //meansdate1isalreadystart-of-day,
                //butdate0needstobeconverted
                date0=core.startOfDay(date0);
            }
        }
        vardelta=core.diffDates(date0,date1,hit0.component.context.dateEnv,hit0.component===hit1.component?
            hit0.component.largeUnit:
            null);
        if(delta.milliseconds){//hashours/minutes/seconds
            standardProps.allDay=false;
        }
        varmutation={
            datesDelta:delta,
            standardProps:standardProps
        };
        for(var_i=0,massagers_1=massagers;_i<massagers_1.length;_i++){
            varmassager=massagers_1[_i];
            massager(mutation,hit0,hit1);
        }
        returnmutation;
    }
    functiongetComponentTouchDelay$1(component){
        varoptions=component.context.options;
        vardelay=options.eventLongPressDelay;
        if(delay==null){
            delay=options.longPressDelay;
        }
        returndelay;
    }

    varEventDragging$1=/**@class*/(function(_super){
        __extends(EventDragging,_super);
        functionEventDragging(settings){
            var_this=_super.call(this,settings)||this;
            //internalstate
            _this.draggingSeg=null;//TODO:renametoresizingSeg?subjectSeg?
            _this.eventRange=null;
            _this.relevantEvents=null;
            _this.validMutation=null;
            _this.mutatedRelevantEvents=null;
            _this.handlePointerDown=function(ev){
                varcomponent=_this.component;
                varseg=_this.querySeg(ev);
                vareventRange=_this.eventRange=seg.eventRange;
                _this.dragging.minDistance=component.context.options.eventDragMinDistance;
                //iftouch,needtobeworkingwithaselectedevent
                _this.dragging.setIgnoreMove(!_this.component.isValidSegDownEl(ev.origEvent.target)||
                    (ev.isTouch&&_this.component.props.eventSelection!==eventRange.instance.instanceId));
            };
            _this.handleDragStart=function(ev){
                var_a=_this.component.context,calendar=_a.calendar,view=_a.view;
                vareventRange=_this.eventRange;
                _this.relevantEvents=core.getRelevantEvents(calendar.state.eventStore,_this.eventRange.instance.instanceId);
                _this.draggingSeg=_this.querySeg(ev);
                calendar.unselect();
                calendar.publiclyTrigger('eventResizeStart',[
                    {
                        el:_this.draggingSeg.el,
                        event:newcore.EventApi(calendar,eventRange.def,eventRange.instance),
                        jsEvent:ev.origEvent,
                        view:view
                    }
                ]);
            };
            _this.handleHitUpdate=function(hit,isFinal,ev){
                varcalendar=_this.component.context.calendar;
                varrelevantEvents=_this.relevantEvents;
                varinitialHit=_this.hitDragging.initialHit;
                vareventInstance=_this.eventRange.instance;
                varmutation=null;
                varmutatedRelevantEvents=null;
                varisInvalid=false;
                varinteraction={
                    affectedEvents:relevantEvents,
                    mutatedEvents:core.createEmptyEventStore(),
                    isEvent:true,
                    origSeg:_this.draggingSeg
                };
                if(hit){
                    mutation=computeMutation(initialHit,hit,ev.subjectEl.classList.contains('fc-start-resizer'),eventInstance.range,calendar.pluginSystem.hooks.eventResizeJoinTransforms);
                }
                if(mutation){
                    mutatedRelevantEvents=core.applyMutationToEventStore(relevantEvents,calendar.eventUiBases,mutation,calendar);
                    interaction.mutatedEvents=mutatedRelevantEvents;
                    if(!_this.component.isInteractionValid(interaction)){
                        isInvalid=true;
                        mutation=null;
                        mutatedRelevantEvents=null;
                        interaction.mutatedEvents=null;
                    }
                }
                if(mutatedRelevantEvents){
                    calendar.dispatch({
                        type:'SET_EVENT_RESIZE',
                        state:interaction
                    });
                }
                else{
                    calendar.dispatch({type:'UNSET_EVENT_RESIZE'});
                }
                if(!isInvalid){
                    core.enableCursor();
                }
                else{
                    core.disableCursor();
                }
                if(!isFinal){
                    if(mutation&&isHitsEqual(initialHit,hit)){
                        mutation=null;
                    }
                    _this.validMutation=mutation;
                    _this.mutatedRelevantEvents=mutatedRelevantEvents;
                }
            };
            _this.handleDragEnd=function(ev){
                var_a=_this.component.context,calendar=_a.calendar,view=_a.view;
                vareventDef=_this.eventRange.def;
                vareventInstance=_this.eventRange.instance;
                vareventApi=newcore.EventApi(calendar,eventDef,eventInstance);
                varrelevantEvents=_this.relevantEvents;
                varmutatedRelevantEvents=_this.mutatedRelevantEvents;
                calendar.publiclyTrigger('eventResizeStop',[
                    {
                        el:_this.draggingSeg.el,
                        event:eventApi,
                        jsEvent:ev.origEvent,
                        view:view
                    }
                ]);
                if(_this.validMutation){
                    calendar.dispatch({
                        type:'MERGE_EVENTS',
                        eventStore:mutatedRelevantEvents
                    });
                    calendar.publiclyTrigger('eventResize',[
                        {
                            el:_this.draggingSeg.el,
                            startDelta:_this.validMutation.startDelta||core.createDuration(0),
                            endDelta:_this.validMutation.endDelta||core.createDuration(0),
                            prevEvent:eventApi,
                            event:newcore.EventApi(//thedataAFTERthemutation
                            calendar,mutatedRelevantEvents.defs[eventDef.defId],eventInstance?mutatedRelevantEvents.instances[eventInstance.instanceId]:null),
                            revert:function(){
                                calendar.dispatch({
                                    type:'MERGE_EVENTS',
                                    eventStore:relevantEvents
                                });
                            },
                            jsEvent:ev.origEvent,
                            view:view
                        }
                    ]);
                }
                else{
                    calendar.publiclyTrigger('_noEventResize');
                }
                //resetallinternalstate
                _this.draggingSeg=null;
                _this.relevantEvents=null;
                _this.validMutation=null;
                //okaytokeepeventInstancearound.usefultosetitinhandlePointerDown
            };
            varcomponent=settings.component;
            vardragging=_this.dragging=newFeaturefulElementDragging(component.el);
            dragging.pointer.selector='.fc-resizer';
            dragging.touchScrollAllowed=false;
            dragging.autoScroller.isEnabled=component.context.options.dragScroll;
            varhitDragging=_this.hitDragging=newHitDragging(_this.dragging,core.interactionSettingsToStore(settings));
            hitDragging.emitter.on('pointerdown',_this.handlePointerDown);
            hitDragging.emitter.on('dragstart',_this.handleDragStart);
            hitDragging.emitter.on('hitupdate',_this.handleHitUpdate);
            hitDragging.emitter.on('dragend',_this.handleDragEnd);
            return_this;
        }
        EventDragging.prototype.destroy=function(){
            this.dragging.destroy();
        };
        EventDragging.prototype.querySeg=function(ev){
            returncore.getElSeg(core.elementClosest(ev.subjectEl,this.component.fgSegSelector));
        };
        returnEventDragging;
    }(core.Interaction));
    functioncomputeMutation(hit0,hit1,isFromStart,instanceRange,transforms){
        vardateEnv=hit0.component.context.dateEnv;
        vardate0=hit0.dateSpan.range.start;
        vardate1=hit1.dateSpan.range.start;
        vardelta=core.diffDates(date0,date1,dateEnv,hit0.component.largeUnit);
        varprops={};
        for(var_i=0,transforms_1=transforms;_i<transforms_1.length;_i++){
            vartransform=transforms_1[_i];
            varres=transform(hit0,hit1);
            if(res===false){
                returnnull;
            }
            elseif(res){
                __assign(props,res);
            }
        }
        if(isFromStart){
            if(dateEnv.add(instanceRange.start,delta)<instanceRange.end){
                props.startDelta=delta;
                returnprops;
            }
        }
        else{
            if(dateEnv.add(instanceRange.end,delta)>instanceRange.start){
                props.endDelta=delta;
                returnprops;
            }
        }
        returnnull;
    }

    varUnselectAuto=/**@class*/(function(){
        functionUnselectAuto(calendar){
            var_this=this;
            this.isRecentPointerDateSelect=false;//wishwecoulduseaselectortodetectdateselection,butuseshitsystem
            this.onSelect=function(selectInfo){
                if(selectInfo.jsEvent){
                    _this.isRecentPointerDateSelect=true;
                }
            };
            this.onDocumentPointerUp=function(pev){
                var_a=_this,calendar=_a.calendar,documentPointer=_a.documentPointer;
                varstate=calendar.state;
                //touch-scrollingshouldneverunfocusanytypeofselection
                if(!documentPointer.wasTouchScroll){
                    if(state.dateSelection&&//anexistingdateselection?
                        !_this.isRecentPointerDateSelect//anewpointer-initiateddateselectionsincelastonDocumentPointerUp?
                    ){
                        varunselectAuto=calendar.viewOpt('unselectAuto');
                        varunselectCancel=calendar.viewOpt('unselectCancel');
                        if(unselectAuto&&(!unselectAuto||!core.elementClosest(documentPointer.downEl,unselectCancel))){
                            calendar.unselect(pev);
                        }
                    }
                    if(state.eventSelection&&//anexistingeventselected?
                        !core.elementClosest(documentPointer.downEl,EventDragging.SELECTOR)//interactionDIDN'Tstartonanevent
                    ){
                        calendar.dispatch({type:'UNSELECT_EVENT'});
                    }
                }
                _this.isRecentPointerDateSelect=false;
            };
            this.calendar=calendar;
            vardocumentPointer=this.documentPointer=newPointerDragging(document);
            documentPointer.shouldIgnoreMove=true;
            documentPointer.shouldWatchScroll=false;
            documentPointer.emitter.on('pointerup',this.onDocumentPointerUp);
            /*
            TODO:betterwaytoknowaboutwhethertherewasaselectionwiththepointer
            */
            calendar.on('select',this.onSelect);
        }
        UnselectAuto.prototype.destroy=function(){
            this.calendar.off('select',this.onSelect);
            this.documentPointer.destroy();
        };
        returnUnselectAuto;
    }());

    /*
    Givenanalreadyinstantiateddraggableobjectforone-or-moreelements,
    Interpretsanydraggingasanattempttodraganeventsthatlivesoutside
    ofacalendarontoacalendar.
    */
    varExternalElementDragging=/**@class*/(function(){
        functionExternalElementDragging(dragging,suppliedDragMeta){
            var_this=this;
            this.receivingCalendar=null;
            this.droppableEvent=null;//willexistforalldrags,evenifcreate:false
            this.suppliedDragMeta=null;
            this.dragMeta=null;
            this.handleDragStart=function(ev){
                _this.dragMeta=_this.buildDragMeta(ev.subjectEl);
            };
            this.handleHitUpdate=function(hit,isFinal,ev){
                vardragging=_this.hitDragging.dragging;
                varreceivingCalendar=null;
                vardroppableEvent=null;
                varisInvalid=false;
                varinteraction={
                    affectedEvents:core.createEmptyEventStore(),
                    mutatedEvents:core.createEmptyEventStore(),
                    isEvent:_this.dragMeta.create,
                    origSeg:null
                };
                if(hit){
                    receivingCalendar=hit.component.context.calendar;
                    if(_this.canDropElOnCalendar(ev.subjectEl,receivingCalendar)){
                        droppableEvent=computeEventForDateSpan(hit.dateSpan,_this.dragMeta,receivingCalendar);
                        interaction.mutatedEvents=core.eventTupleToStore(droppableEvent);
                        isInvalid=!core.isInteractionValid(interaction,receivingCalendar);
                        if(isInvalid){
                            interaction.mutatedEvents=core.createEmptyEventStore();
                            droppableEvent=null;
                        }
                    }
                }
                _this.displayDrag(receivingCalendar,interaction);
                //showmirrorifnoalready-renderedmirrorelementORifweareshuttingdownthemirror(?)
                //TODO:wishwecouldsomehowwaitfordispatchtoguaranteerender
                dragging.setMirrorIsVisible(isFinal||!droppableEvent||!document.querySelector('.fc-mirror'));
                if(!isInvalid){
                    core.enableCursor();
                }
                else{
                    core.disableCursor();
                }
                if(!isFinal){
                    dragging.setMirrorNeedsRevert(!droppableEvent);
                    _this.receivingCalendar=receivingCalendar;
                    _this.droppableEvent=droppableEvent;
                }
            };
            this.handleDragEnd=function(pev){
                var_a=_this,receivingCalendar=_a.receivingCalendar,droppableEvent=_a.droppableEvent;
                _this.clearDrag();
                if(receivingCalendar&&droppableEvent){
                    varfinalHit=_this.hitDragging.finalHit;
                    varfinalView=finalHit.component.context.view;
                    vardragMeta=_this.dragMeta;
                    vararg=__assign({},receivingCalendar.buildDatePointApi(finalHit.dateSpan),{draggedEl:pev.subjectEl,jsEvent:pev.origEvent,view:finalView});
                    receivingCalendar.publiclyTrigger('drop',[arg]);
                    if(dragMeta.create){
                        receivingCalendar.dispatch({
                            type:'MERGE_EVENTS',
                            eventStore:core.eventTupleToStore(droppableEvent)
                        });
                        if(pev.isTouch){
                            receivingCalendar.dispatch({
                                type:'SELECT_EVENT',
                                eventInstanceId:droppableEvent.instance.instanceId
                            });
                        }
                        //signalthatanexternaleventlanded
                        receivingCalendar.publiclyTrigger('eventReceive',[
                            {
                                draggedEl:pev.subjectEl,
                                event:newcore.EventApi(receivingCalendar,droppableEvent.def,droppableEvent.instance),
                                view:finalView
                            }
                        ]);
                    }
                }
                _this.receivingCalendar=null;
                _this.droppableEvent=null;
            };
            varhitDragging=this.hitDragging=newHitDragging(dragging,core.interactionSettingsStore);
            hitDragging.requireInitial=false;//willstartoutsideofacomponent
            hitDragging.emitter.on('dragstart',this.handleDragStart);
            hitDragging.emitter.on('hitupdate',this.handleHitUpdate);
            hitDragging.emitter.on('dragend',this.handleDragEnd);
            this.suppliedDragMeta=suppliedDragMeta;
        }
        ExternalElementDragging.prototype.buildDragMeta=function(subjectEl){
            if(typeofthis.suppliedDragMeta==='object'){
                returncore.parseDragMeta(this.suppliedDragMeta);
            }
            elseif(typeofthis.suppliedDragMeta==='function'){
                returncore.parseDragMeta(this.suppliedDragMeta(subjectEl));
            }
            else{
                returngetDragMetaFromEl(subjectEl);
            }
        };
        ExternalElementDragging.prototype.displayDrag=function(nextCalendar,state){
            varprevCalendar=this.receivingCalendar;
            if(prevCalendar&&prevCalendar!==nextCalendar){
                prevCalendar.dispatch({type:'UNSET_EVENT_DRAG'});
            }
            if(nextCalendar){
                nextCalendar.dispatch({type:'SET_EVENT_DRAG',state:state});
            }
        };
        ExternalElementDragging.prototype.clearDrag=function(){
            if(this.receivingCalendar){
                this.receivingCalendar.dispatch({type:'UNSET_EVENT_DRAG'});
            }
        };
        ExternalElementDragging.prototype.canDropElOnCalendar=function(el,receivingCalendar){
            vardropAccept=receivingCalendar.opt('dropAccept');
            if(typeofdropAccept==='function'){
                returndropAccept(el);
            }
            elseif(typeofdropAccept==='string'&&dropAccept){
                returnBoolean(core.elementMatches(el,dropAccept));
            }
            returntrue;
        };
        returnExternalElementDragging;
    }());
    //UtilsforcomputingeventstorefromtheDragMeta
    //----------------------------------------------------------------------------------------------------
    functioncomputeEventForDateSpan(dateSpan,dragMeta,calendar){
        vardefProps=__assign({},dragMeta.leftoverProps);
        for(var_i=0,_a=calendar.pluginSystem.hooks.externalDefTransforms;_i<_a.length;_i++){
            vartransform=_a[_i];
            __assign(defProps,transform(dateSpan,dragMeta));
        }
        vardef=core.parseEventDef(defProps,dragMeta.sourceId,dateSpan.allDay,calendar.opt('forceEventDuration')||Boolean(dragMeta.duration),//hasEnd
        calendar);
        varstart=dateSpan.range.start;
        //onlyrelyontimeinfoifdropzoneisall-day,
        //otherwise,wealreadyknowthetime
        if(dateSpan.allDay&&dragMeta.startTime){
            start=calendar.dateEnv.add(start,dragMeta.startTime);
        }
        varend=dragMeta.duration?
            calendar.dateEnv.add(start,dragMeta.duration):
            calendar.getDefaultEventEnd(dateSpan.allDay,start);
        varinstance=core.createEventInstance(def.defId,{start:start,end:end});
        return{def:def,instance:instance};
    }
    //Utilsforextractingdatafromelement
    //----------------------------------------------------------------------------------------------------
    functiongetDragMetaFromEl(el){
        varstr=getEmbeddedElData(el,'event');
        varobj=str?
            JSON.parse(str):
            {create:false};//ifnoembeddeddata,assumenoeventcreation
        returncore.parseDragMeta(obj);
    }
    core.config.dataAttrPrefix='';
    functiongetEmbeddedElData(el,name){
        varprefix=core.config.dataAttrPrefix;
        varprefixedName=(prefix?prefix+'-':'')+name;
        returnel.getAttribute('data-'+prefixedName)||'';
    }

    /*
    Makesanelement(thatis*external*toanycalendar)draggable.
    Canpassindatathatdetermineshowaneventwillbecreatedwhendroppedontoacalendar.
    LeveragesFullCalendar'sinternaldrag-n-dropfunctionalityWITHOUTathird-partydragsystem.
    */
    varExternalDraggable=/**@class*/(function(){
        functionExternalDraggable(el,settings){
            var_this=this;
            if(settings===void0){settings={};}
            this.handlePointerDown=function(ev){
                vardragging=_this.dragging;
                var_a=_this.settings,minDistance=_a.minDistance,longPressDelay=_a.longPressDelay;
                dragging.minDistance=
                    minDistance!=null?
                        minDistance:
                        (ev.isTouch?0:core.globalDefaults.eventDragMinDistance);
                dragging.delay=
                    ev.isTouch?//TODO:eventuallyreadeventLongPressDelayinsteadvvv
                        (longPressDelay!=null?longPressDelay:core.globalDefaults.longPressDelay):
                        0;
            };
            this.handleDragStart=function(ev){
                if(ev.isTouch&&
                    _this.dragging.delay&&
                    ev.subjectEl.classList.contains('fc-event')){
                    _this.dragging.mirror.getMirrorEl().classList.add('fc-selected');
                }
            };
            this.settings=settings;
            vardragging=this.dragging=newFeaturefulElementDragging(el);
            dragging.touchScrollAllowed=false;
            if(settings.itemSelector!=null){
                dragging.pointer.selector=settings.itemSelector;
            }
            if(settings.appendTo!=null){
                dragging.mirror.parentNode=settings.appendTo;//TODO:writetests
            }
            dragging.emitter.on('pointerdown',this.handlePointerDown);
            dragging.emitter.on('dragstart',this.handleDragStart);
            newExternalElementDragging(dragging,settings.eventData);
        }
        ExternalDraggable.prototype.destroy=function(){
            this.dragging.destroy();
        };
        returnExternalDraggable;
    }());

    /*
    Detectswhena*THIRD-PARTY*drag-n-dropsysteminteractswithelements.
    Thethird-partysystemisresponsiblefordrawingthevisualseffectsofthedrag.
    Thisclasssimplymonitorsforpointermovementsandfiresevents.
    Italsohastheabilitytohidethemovingelement(the"mirror")duringthedrag.
    */
    varInferredElementDragging=/**@class*/(function(_super){
        __extends(InferredElementDragging,_super);
        functionInferredElementDragging(containerEl){
            var_this=_super.call(this,containerEl)||this;
            _this.shouldIgnoreMove=false;
            _this.mirrorSelector='';
            _this.currentMirrorEl=null;
            _this.handlePointerDown=function(ev){
                _this.emitter.trigger('pointerdown',ev);
                if(!_this.shouldIgnoreMove){
                    //firedragstartrightaway.doesnotsupportdelayormin-distance
                    _this.emitter.trigger('dragstart',ev);
                }
            };
            _this.handlePointerMove=function(ev){
                if(!_this.shouldIgnoreMove){
                    _this.emitter.trigger('dragmove',ev);
                }
            };
            _this.handlePointerUp=function(ev){
                _this.emitter.trigger('pointerup',ev);
                if(!_this.shouldIgnoreMove){
                    //firedragendrightaway.doesnotsupportarevertanimation
                    _this.emitter.trigger('dragend',ev);
                }
            };
            varpointer=_this.pointer=newPointerDragging(containerEl);
            pointer.emitter.on('pointerdown',_this.handlePointerDown);
            pointer.emitter.on('pointermove',_this.handlePointerMove);
            pointer.emitter.on('pointerup',_this.handlePointerUp);
            return_this;
        }
        InferredElementDragging.prototype.destroy=function(){
            this.pointer.destroy();
        };
        InferredElementDragging.prototype.setIgnoreMove=function(bool){
            this.shouldIgnoreMove=bool;
        };
        InferredElementDragging.prototype.setMirrorIsVisible=function(bool){
            if(bool){
                //restoreapreviouslyhiddenelement.
                //usethereferenceincasetheselectorclasshasalreadybeenremoved.
                if(this.currentMirrorEl){
                    this.currentMirrorEl.style.visibility='';
                    this.currentMirrorEl=null;
                }
            }
            else{
                varmirrorEl=this.mirrorSelector?
                    document.querySelector(this.mirrorSelector):
                    null;
                if(mirrorEl){
                    this.currentMirrorEl=mirrorEl;
                    mirrorEl.style.visibility='hidden';
                }
            }
        };
        returnInferredElementDragging;
    }(core.ElementDragging));

    /*
    Bridgesthird-partydrag-n-dropsystemswithFullCalendar.
    Mustbeinstantiatedanddestroyedbycaller.
    */
    varThirdPartyDraggable=/**@class*/(function(){
        functionThirdPartyDraggable(containerOrSettings,settings){
            varcontainerEl=document;
            if(
            //wishwecouldjusttestinstanceofEventTarget,butdoesn'tworkinIE11
            containerOrSettings===document||
                containerOrSettingsinstanceofElement){
                containerEl=containerOrSettings;
                settings=settings||{};
            }
            else{
                settings=(containerOrSettings||{});
            }
            vardragging=this.dragging=newInferredElementDragging(containerEl);
            if(typeofsettings.itemSelector==='string'){
                dragging.pointer.selector=settings.itemSelector;
            }
            elseif(containerEl===document){
                dragging.pointer.selector='[data-event]';
            }
            if(typeofsettings.mirrorSelector==='string'){
                dragging.mirrorSelector=settings.mirrorSelector;
            }
            newExternalElementDragging(dragging,settings.eventData);
        }
        ThirdPartyDraggable.prototype.destroy=function(){
            this.dragging.destroy();
        };
        returnThirdPartyDraggable;
    }());

    varmain=core.createPlugin({
        componentInteractions:[DateClicking,DateSelecting,EventDragging,EventDragging$1],
        calendarInteractions:[UnselectAuto],
        elementDraggingImpl:FeaturefulElementDragging
    });

    exports.Draggable=ExternalDraggable;
    exports.FeaturefulElementDragging=FeaturefulElementDragging;
    exports.PointerDragging=PointerDragging;
    exports.ThirdPartyDraggable=ThirdPartyDraggable;
    exports.default=main;

    Object.defineProperty(exports,'__esModule',{value:true});

}));

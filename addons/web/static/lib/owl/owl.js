(function(exports){
    'usestrict';

    /**
     *Wedefinehereasimpleeventbus:itcan
     *-emitevents
     *-add/removelisteners.
     *
     *Thisisausefulpatternofcommunicationinmanycases. ForOWL,each
     *componentsandstoresareeventbuses.
     */
    //------------------------------------------------------------------------------
    //EventBus
    //------------------------------------------------------------------------------
    classEventBus{
        constructor(){
            this.subscriptions={};
        }
        /**
         *Addalistenerforthe'eventType'events.
         *
         *Notethatthe'owner'ofthiseventcanbeanything,butwillmorelikely
         *beacomponentoraclass.Theideaisthatthecallbackwillbecalledwith
         *theproperownerbound.
         *
         *Also,theownershouldbekindofunique.Thiswillbeusedtoremovethe
         *listener.
         */
        on(eventType,owner,callback){
            if(!callback){
                thrownewError("Missingcallback");
            }
            if(!this.subscriptions[eventType]){
                this.subscriptions[eventType]=[];
            }
            this.subscriptions[eventType].push({
                owner,
                callback,
            });
        }
        /**
         *Removealistener
         */
        off(eventType,owner){
            constsubs=this.subscriptions[eventType];
            if(subs){
                this.subscriptions[eventType]=subs.filter((s)=>s.owner!==owner);
            }
        }
        /**
         *Emitaneventoftype'eventType'. Anyextraargumentswillbepassedto
         *thelistenerscallback.
         */
        trigger(eventType,...args){
            constsubs=this.subscriptions[eventType]||[];
            for(leti=0,iLen=subs.length;i<iLen;i++){
                constsub=subs[i];
                sub.callback.call(sub.owner,...args);
            }
        }
        /**
         *Removeallsubscriptions.
         */
        clear(){
            this.subscriptions={};
        }
    }

    /**
     *OwlObserver
     *
     *ThiscodecontainsthelogicthatallowsOwltoobserveandreacttostate
     *changes.
     *
     *ThisisaObserverclassthatcanobserveanyJSvalues. Thewayitworks
     *canbesummarizedthusly:
     *-primitivevaluesarenotobservedatall
     *-ObjectsandarraysareobservedbyreplacingthemwithaProxy
     *-eachobject/arraymetadataaretrackedinaweakmap,andkeeparevision
     *  number
     *
     *NotethatthiscodeislooselyinspiredbyVue.
     */
    //------------------------------------------------------------------------------
    //Observer
    //------------------------------------------------------------------------------
    classObserver{
        constructor(){
            this.rev=1;
            this.allowMutations=true;
            this.weakMap=newWeakMap();
        }
        notifyCB(){}
        observe(value,parent){
            if(value===null||
                typeofvalue!=="object"||
                valueinstanceofDate||
                valueinstanceofPromise){
                //funfact:typeofnull==='object'
                returnvalue;
            }
            letmetadata=this.weakMap.get(value)||this._observe(value,parent);
            returnmetadata.proxy;
        }
        revNumber(value){
            constmetadata=this.weakMap.get(value);
            returnmetadata?metadata.rev:0;
        }
        _observe(value,parent){
            varself=this;
            constproxy=newProxy(value,{
                get(target,k){
                    consttargetValue=target[k];
                    returnself.observe(targetValue,value);
                },
                set(target,key,newVal){
                    constvalue=target[key];
                    if(newVal!==value){
                        if(!self.allowMutations){
                            thrownewError(`Observedstatecannotbechangedhere!(key:"${key}",val:"${newVal}")`);
                        }
                        self._updateRevNumber(target);
                        target[key]=newVal;
                        self.notifyCB();
                    }
                    returntrue;
                },
                deleteProperty(target,key){
                    if(keyintarget){
                        deletetarget[key];
                        self._updateRevNumber(target);
                        self.notifyCB();
                    }
                    returntrue;
                },
            });
            constmetadata={
                value,
                proxy,
                rev:this.rev,
                parent,
            };
            this.weakMap.set(value,metadata);
            this.weakMap.set(metadata.proxy,metadata);
            returnmetadata;
        }
        _updateRevNumber(target){
            this.rev++;
            letmetadata=this.weakMap.get(target);
            letparent=target;
            do{
                metadata=this.weakMap.get(parent);
                metadata.rev++;
            }while((parent=metadata.parent)&&parent!==target);
        }
    }

    /**
     *OwlQWebExpressionParser
     *
     *Owlneedsinvariouscontextstobeabletounderstandthestructureofa
     *stringrepresentingajavascriptexpression. Theusualgoalistobeable
     *torewritesomevariables. Forexample,ifatemplatehas
     *
     * ```xml
     * <tt-if="computeSomething({val:state.val})">...</t>
     *```
     *
     *thisneedstobetranslatedinsomethinglikethis:
     *
     *```js
     *  if(context["computeSomething"]({val:context["state"].val})){...}
     *```
     *
     *Thisfilecontainstheimplementationofanextremelynaivetokenizer/parser
     *andevaluatorforjavascriptexpressions. Thesupportedgrammarisbasically
     *onlyexpressiveenoughtounderstandtheshapeofobjects,ofarrays,and
     *variousoperators.
     */
    //------------------------------------------------------------------------------
    //Misctypes,constantsandhelpers
    //------------------------------------------------------------------------------
    constRESERVED_WORDS="true,false,NaN,null,undefined,debugger,console,window,in,instanceof,new,function,return,this,eval,void,Math,RegExp,Array,Object,Date".split(",");
    constWORD_REPLACEMENT=Object.assign(Object.create(null),{
        and:"&&",
        or:"||",
        gt:">",
        gte:">=",
        lt:"<",
        lte:"<=",
    });
    constSTATIC_TOKEN_MAP=Object.assign(Object.create(null),{
        "{":"LEFT_BRACE",
        "}":"RIGHT_BRACE",
        "[":"LEFT_BRACKET",
        "]":"RIGHT_BRACKET",
        ":":"COLON",
        ",":"COMMA",
        "(":"LEFT_PAREN",
        ")":"RIGHT_PAREN",
    });
    //notethatthespaceaftertypeofisrelevant.Itmakessurethattheformatted
    //expressionhasaspaceaftertypeof
    constOPERATORS="...,.,===,==,+,!==,!=,!,||,&&,>=,>,<=,<,?,-,*,/,%,typeof,=>,=,;,in".split(",");
    lettokenizeString=function(expr){
        lets=expr[0];
        letstart=s;
        if(s!=="'"&&s!=='"'&&s!=="`"){
            returnfalse;
        }
        leti=1;
        letcur;
        while(expr[i]&&expr[i]!==start){
            cur=expr[i];
            s+=cur;
            if(cur==="\\"){
                i++;
                cur=expr[i];
                if(!cur){
                    thrownewError("Invalidexpression");
                }
                s+=cur;
            }
            i++;
        }
        if(expr[i]!==start){
            thrownewError("Invalidexpression");
        }
        s+=start;
        if(start==="`"){
            return{
                type:"TEMPLATE_STRING",
                value:s,
                replace(replacer){
                    returns.replace(/\$\{(.*?)\}/g,(match,group)=>{
                        return"${"+replacer(group)+"}";
                    });
                },
            };
        }
        return{type:"VALUE",value:s};
    };
    lettokenizeNumber=function(expr){
        lets=expr[0];
        if(s&&s.match(/[0-9]/)){
            leti=1;
            while(expr[i]&&expr[i].match(/[0-9]|\./)){
                s+=expr[i];
                i++;
            }
            return{type:"VALUE",value:s};
        }
        else{
            returnfalse;
        }
    };
    lettokenizeSymbol=function(expr){
        lets=expr[0];
        if(s&&s.match(/[a-zA-Z_\$]/)){
            leti=1;
            while(expr[i]&&expr[i].match(/\w/)){
                s+=expr[i];
                i++;
            }
            if(sinWORD_REPLACEMENT){
                return{type:"OPERATOR",value:WORD_REPLACEMENT[s],size:s.length};
            }
            return{type:"SYMBOL",value:s};
        }
        else{
            returnfalse;
        }
    };
    consttokenizeStatic=function(expr){
        constchar=expr[0];
        if(char&&charinSTATIC_TOKEN_MAP){
            return{type:STATIC_TOKEN_MAP[char],value:char};
        }
        returnfalse;
    };
    consttokenizeOperator=function(expr){
        for(letopofOPERATORS){
            if(expr.startsWith(op)){
                return{type:"OPERATOR",value:op};
            }
        }
        returnfalse;
    };
    constTOKENIZERS=[
        tokenizeString,
        tokenizeNumber,
        tokenizeOperator,
        tokenizeSymbol,
        tokenizeStatic,
    ];
    /**
     *Convertajavascriptexpression(asastring)intoalistoftokens.For
     *example:`tokenize("1+b")`willreturn:
     *```js
     * [
     *  {type:"VALUE",value:"1"},
     *  {type:"OPERATOR",value:"+"},
     *  {type:"SYMBOL",value:"b"}
     *]
     *```
     */
    functiontokenize(expr){
        constresult=[];
        lettoken=true;
        while(token){
            expr=expr.trim();
            if(expr){
                for(lettokenizerofTOKENIZERS){
                    token=tokenizer(expr);
                    if(token){
                        result.push(token);
                        expr=expr.slice(token.size||token.value.length);
                        break;
                    }
                }
            }
            else{
                token=false;
            }
        }
        if(expr.length){
            thrownewError(`Tokenizererror:couldnottokenize"${expr}"`);
        }
        returnresult;
    }
    //------------------------------------------------------------------------------
    //Expression"evaluator"
    //------------------------------------------------------------------------------
    constisLeftSeparator=(token)=>token&&(token.type==="LEFT_BRACE"||token.type==="COMMA");
    constisRightSeparator=(token)=>token&&(token.type==="RIGHT_BRACE"||token.type==="COMMA");
    /**
     *Thisisthemainfunctionexportedbythisfile.Thisisthecodethatwill
     *processanexpression(givenasastring)andreturnsanotherexpressionwith
     *properlookupsinthecontext.
     *
     *Usually,thiskindofcodewouldbeverysimpletodoifwehadanAST(so,
     *ifwehadajavascriptparser),sincethen,wewouldonlyneedtofindthe
     *variablesandreplacethem. However,aparserismorecomplicated,andthere
     *arenostandardbuiltinparserAPI.
     *
     *Sincethismethodisappliedtosimplejavasriptexpressions,andtheworkto
     *bedoneisactuallyquitesimple,weactuallycangetawaywithnotusinga
     *parser,whichhelpswiththecodesize.
     *
     *Hereistheheuristicusedbythismethodtodetermineifatokenisa
     *variable:
     *-bydefault,allsymbolsareconsideredavariable
     *-unlesstheprevioustokenisadot(inthatcase,thisisaproperty:`a.b`)
     *-oriftheprevioustokenisaleftbraceoracomma,andthenexttokenis
     *  acolon(inthatcase,thisisanobjectkey:`{a:b}`)
     *
     *Somespecificcodeisalsorequiredtosupportarrowfunctions.Ifwedetect
     *thearrowoperator,thenweaddthecurrent(orsomeprevioustokens)tokento
     *thelistofvariablessoitdoesnotgetreplacedbyalookupinthecontext
     */
    functioncompileExprToArray(expr,scope){
        constlocalVars=newSet();
        scope=Object.create(scope);
        consttokens=tokenize(expr);
        leti=0;
        letstack=[];//totracklastopening[or{
        while(i<tokens.length){
            lettoken=tokens[i];
            letprevToken=tokens[i-1];
            letnextToken=tokens[i+1];
            letgroupType=stack[stack.length-1];
            switch(token.type){
                case"LEFT_BRACE":
                case"LEFT_BRACKET":
                    stack.push(token.type);
                    break;
                case"RIGHT_BRACE":
                case"RIGHT_BRACKET":
                    stack.pop();
            }
            letisVar=token.type==="SYMBOL"&&!RESERVED_WORDS.includes(token.value);
            if(token.type==="SYMBOL"&&!RESERVED_WORDS.includes(token.value)){
                if(prevToken){
                    //normalizemissingtokens:{a}shouldbeequivalentto{a:a}
                    if(groupType==="LEFT_BRACE"&&
                        isLeftSeparator(prevToken)&&
                        isRightSeparator(nextToken)){
                        tokens.splice(i+1,0,{type:"COLON",value:":"},Object.assign({},token));
                        nextToken=tokens[i+1];
                    }
                    if(prevToken.type==="OPERATOR"&&prevToken.value==="."){
                        isVar=false;
                    }
                    elseif(prevToken.type==="LEFT_BRACE"||prevToken.type==="COMMA"){
                        if(nextToken&&nextToken.type==="COLON"){
                            isVar=false;
                        }
                    }
                }
            }
            if(token.type==="TEMPLATE_STRING"){
                token.value=token.replace((expr)=>compileExpr(expr,scope));
            }
            if(nextToken&&nextToken.type==="OPERATOR"&&nextToken.value==="=>"){
                if(token.type==="RIGHT_PAREN"){
                    letj=i-1;
                    while(j>0&&tokens[j].type!=="LEFT_PAREN"){
                        if(tokens[j].type==="SYMBOL"&&tokens[j].originalValue){
                            tokens[j].value=tokens[j].originalValue;
                            scope[tokens[j].value]={id:tokens[j].value,expr:tokens[j].value};
                            localVars.add(tokens[j].value);
                        }
                        j--;
                    }
                }
                else{
                    scope[token.value]={id:token.value,expr:token.value};
                    localVars.add(token.value);
                }
            }
            if(isVar){
                token.varName=token.value;
                if(token.valueinscope&&"id"inscope[token.value]){
                    token.value=scope[token.value].expr;
                }
                else{
                    token.originalValue=token.value;
                    token.value=`scope['${token.value}']`;
                }
            }
            i++;
        }
        //Markallvariablesthathavebeenusedlocally.
        //Thisassumestheexpressionhasonlyonescope(incorrectbut"goodenoughfornow")
        for(consttokenoftokens){
            if(token.type==="SYMBOL"&&localVars.has(token.value)){
                token.isLocal=true;
            }
        }
        returntokens;
    }
    functioncompileExpr(expr,scope){
        returncompileExprToArray(expr,scope)
            .map((t)=>t.value)
            .join("");
    }

    constINTERP_REGEXP=/\{\{.*?\}\}/g;
    //------------------------------------------------------------------------------
    //CompilationContext
    //------------------------------------------------------------------------------
    classCompilationContext{
        constructor(name){
            this.code=[];
            this.variables={};
            this.escaping=false;
            this.parentNode=null;
            this.parentTextNode=null;
            this.rootNode=null;
            this.indentLevel=0;
            this.shouldDefineParent=false;
            this.shouldDefineScope=false;
            this.protectedScopeNumber=0;
            this.shouldDefineQWeb=false;
            this.shouldDefineUtils=false;
            this.shouldDefineRefs=false;
            this.shouldDefineResult=true;
            this.loopNumber=0;
            this.inPreTag=false;
            this.allowMultipleRoots=false;
            this.hasParentWidget=false;
            this.hasKey0=false;
            this.keyStack=[];
            this.rootContext=this;
            this.templateName=name||"noname";
            this.addLine("leth=this.h;");
        }
        generateID(){
            returnCompilationContext.nextID++;
        }
        /**
         *Thismethodgeneratesa"templatekey",whichisbasicallyauniquekey
         *whichdependsonthecurrentlysetkeys,andontheiterationnumbers(if
         *weareinaloop).
         *
         *Suchakeyisnecessarywhenweneedtoassociateanidtosomeelement
         *generatedbyatemplate(forexample,acomponent)
         */
        generateTemplateKey(prefix=""){
            constid=this.generateID();
            if(this.loopNumber===0&&!this.hasKey0){
                return`'${prefix}__${id}__'`;
            }
            letkey=`\`${prefix}__${id}__`;
            letstart=this.hasKey0?0:1;
            for(leti=start;i<this.loopNumber+1;i++){
                key+=`\${key${i}}__`;
            }
            this.addLine(`letk${id}=${key}\`;`);
            return`k${id}`;
        }
        generateCode(){
            if(this.shouldDefineResult){
                this.code.unshift("   letresult;");
            }
            if(this.shouldDefineScope){
                this.code.unshift("   letscope=Object.create(context);");
            }
            if(this.shouldDefineRefs){
                this.code.unshift("   context.__owl__.refs=context.__owl__.refs||{};");
            }
            if(this.shouldDefineParent){
                if(this.hasParentWidget){
                    this.code.unshift("   letparent=extra.parent;");
                }
                else{
                    this.code.unshift("   letparent=context;");
                }
            }
            if(this.shouldDefineQWeb){
                this.code.unshift("   letQWeb=this.constructor;");
            }
            if(this.shouldDefineUtils){
                this.code.unshift("   letutils=this.constructor.utils;");
            }
            returnthis.code;
        }
        withParent(node){
            if(!this.allowMultipleRoots&&
                this===this.rootContext&&
                (this.parentNode||this.parentTextNode)){
                thrownewError("Atemplateshouldnothavemorethanonerootnode");
            }
            if(!this.rootContext.rootNode){
                this.rootContext.rootNode=node;
            }
            if(!this.parentNode&&this.rootContext.shouldDefineResult){
                this.addLine(`result=vn${node};`);
            }
            returnthis.subContext("parentNode",node);
        }
        subContext(key,value){
            constnewContext=Object.create(this);
            newContext[key]=value;
            returnnewContext;
        }
        indent(){
            this.rootContext.indentLevel++;
        }
        dedent(){
            this.rootContext.indentLevel--;
        }
        addLine(line){
            constprefix=newArray(this.indentLevel+2).join("   ");
            this.code.push(prefix+line);
            returnthis.code.length-1;
        }
        addIf(condition){
            this.addLine(`if(${condition}){`);
            this.indent();
        }
        addElse(){
            this.dedent();
            this.addLine("}else{");
            this.indent();
        }
        closeIf(){
            this.dedent();
            this.addLine("}");
        }
        getValue(val){
            returnvalinthis.variables?this.getValue(this.variables[val]):val;
        }
        /**
         *Prepareanexpressionforbeingconsumedatrendertime. Itsmainjob
         *isto
         *-replaceunknownvariablesbyalookupinthecontext
         *-replacealreadydefinedvariablesbytheirinternalname
         */
        formatExpression(expr){
            this.rootContext.shouldDefineScope=true;
            returncompileExpr(expr,this.variables);
        }
        captureExpression(expr){
            this.rootContext.shouldDefineScope=true;
            constargId=this.generateID();
            consttokens=compileExprToArray(expr,this.variables);
            constdone=newSet();
            returntokens
                .map((tok,i)=>{
                //"this"incapturedexpressionsshouldbethecurrentcomponent
                if(tok.value==="this"){
                    if(!done.has("this")){
                        done.add("this");
                        this.addLine(`constthis_${argId}=utils.getComponent(context);`);
                    }
                    tok.value=`this_${argId}`;
                }
                //Variablesthatshouldbelookedupinthescope.isLocalisforarrow
                //functionargumentsthatshouldstayuntouched(eg"ev=>ev"should
                //notbecome"constev_1=scope['ev'];ev_1=>ev_1")
                if(tok.varName&&
                    !tok.isLocal&&
                    //HACK:forbackwardscompatibility,wedon'tcapturebaremethods
                    //thisallowsthemtobecalledwiththerenderingcontext/scope
                    //astheirthisvalue.
                    (!tokens[i+1]||tokens[i+1].type!=="LEFT_PAREN")){
                    if(!done.has(tok.varName)){
                        done.add(tok.varName);
                        this.addLine(`const${tok.varName}_${argId}=${tok.value};`);
                    }
                    tok.value=`${tok.varName}_${argId}`;
                }
                returntok.value;
            })
                .join("");
        }
        /**
         *Performstringinterpolationonthegivenstring.Notethatifthewhole
         *stringisanexpression,itsimplyreturnsit(formattedandenclosedin
         *parentheses).
         *Forinstance:
         *  'Hello{{x}}!'->`Hello${x}`
         *  '{{x?'a':'b'}}'->(x?'a':'b')
         */
        interpolate(s){
            letmatches=s.match(INTERP_REGEXP);
            if(matches&&matches[0].length===s.length){
                return`(${this.formatExpression(s.slice(2,-2))})`;
            }
            letr=s.replace(/\{\{.*?\}\}/g,(s)=>"${"+this.formatExpression(s.slice(2,-2))+"}");
            return"`"+r+"`";
        }
        startProtectScope(codeBlock){
            constprotectID=this.generateID();
            this.rootContext.protectedScopeNumber++;
            this.rootContext.shouldDefineScope=true;
            constscopeExpr=`Object.create(scope);`;
            this.addLine(`let_origScope${protectID}=scope;`);
            this.addLine(`scope=${scopeExpr}`);
            if(!codeBlock){
                this.addLine(`scope.__access_mode__='ro';`);
            }
            returnprotectID;
        }
        stopProtectScope(protectID){
            this.rootContext.protectedScopeNumber--;
            this.addLine(`scope=_origScope${protectID};`);
        }
    }
    CompilationContext.nextID=1;

    //------------------------------------------------------------------------------
    //module/props.ts
    //------------------------------------------------------------------------------
    functionupdateProps(oldVnode,vnode){
        varkey,cur,old,elm=vnode.elm,oldProps=oldVnode.data.props,props=vnode.data.props;
        if(!oldProps&&!props)
            return;
        if(oldProps===props)
            return;
        oldProps=oldProps||{};
        props=props||{};
        for(keyinoldProps){
            if(!props[key]){
                deleteelm[key];
            }
        }
        for(keyinprops){
            cur=props[key];
            old=oldProps[key];
            if(old!==cur&&(key!=="value"||elm[key]!==cur)){
                elm[key]=cur;
            }
        }
    }
    constpropsModule={
        create:updateProps,
        update:updateProps,
    };
    //------------------------------------------------------------------------------
    //module/eventlisteners.ts
    //------------------------------------------------------------------------------
    functioninvokeHandler(handler,vnode,event){
        if(typeofhandler==="function"){
            //callfunctionhandler
            handler.call(vnode,event,vnode);
        }
        elseif(typeofhandler==="object"){
            //callhandlerwitharguments
            if(typeofhandler[0]==="function"){
                //specialcaseforsingleargumentforperformance
                if(handler.length===2){
                    handler[0].call(vnode,handler[1],event,vnode);
                }
                else{
                    varargs=handler.slice(1);
                    args.push(event);
                    args.push(vnode);
                    handler[0].apply(vnode,args);
                }
            }
            else{
                //callmultiplehandlers
                for(leti=0,iLen=handler.length;i<iLen;i++){
                    invokeHandler(handler[i],vnode,event);
                }
            }
        }
    }
    functionhandleEvent(event,vnode){
        varname=event.type,on=vnode.data.on;
        //calleventhandler(s)ifexists
        if(on){
            if(on[name]){
                invokeHandler(on[name],vnode,event);
            }
            elseif(on["!"+name]){
                invokeHandler(on["!"+name],vnode,event);
            }
        }
    }
    functioncreateListener(){
        returnfunctionhandler(event){
            handleEvent(event,handler.vnode);
        };
    }
    functionupdateEventListeners(oldVnode,vnode){
        varoldOn=oldVnode.data.on,oldListener=oldVnode.listener,oldElm=oldVnode.elm,on=vnode&&vnode.data.on,elm=(vnode&&vnode.elm),name;
        //optimizationforreusedimmutablehandlers
        if(oldOn===on){
            return;
        }
        //removeexistinglistenerswhichnolongerused
        if(oldOn&&oldListener){
            //ifelementchangedordeletedweremoveallexistinglistenersunconditionally
            if(!on){
                for(nameinoldOn){
                    //removelistenerifelementwaschangedorexistinglistenersremoved
                    constcapture=name.charAt(0)==="!";
                    name=capture?name.slice(1):name;
                    oldElm.removeEventListener(name,oldListener,capture);
                }
            }
            else{
                for(nameinoldOn){
                    //removelistenerifexistinglistenerremoved
                    if(!on[name]){
                        constcapture=name.charAt(0)==="!";
                        name=capture?name.slice(1):name;
                        oldElm.removeEventListener(name,oldListener,capture);
                    }
                }
            }
        }
        //addnewlistenerswhichhasnotalreadyattached
        if(on){
            //reuseexistinglistenerorcreatenew
            varlistener=(vnode.listener=oldVnode.listener||createListener());
            //updatevnodeforlistener
            listener.vnode=vnode;
            //ifelementchangedoraddedweaddallneededlistenersunconditionally
            if(!oldOn){
                for(nameinon){
                    //addlistenerifelementwaschangedornewlistenersadded
                    constcapture=name.charAt(0)==="!";
                    name=capture?name.slice(1):name;
                    elm.addEventListener(name,listener,capture);
                }
            }
            else{
                for(nameinon){
                    //addlistenerifnewlisteneradded
                    if(!oldOn[name]){
                        constcapture=name.charAt(0)==="!";
                        name=capture?name.slice(1):name;
                        elm.addEventListener(name,listener,capture);
                    }
                }
            }
        }
    }
    consteventListenersModule={
        create:updateEventListeners,
        update:updateEventListeners,
        destroy:updateEventListeners,
    };
    //------------------------------------------------------------------------------
    //attributes.ts
    //------------------------------------------------------------------------------
    constxlinkNS="http://www.w3.org/1999/xlink";
    constxmlNS="http://www.w3.org/XML/1998/namespace";
    constcolonChar=58;
    constxChar=120;
    functionupdateAttrs(oldVnode,vnode){
        varkey,elm=vnode.elm,oldAttrs=oldVnode.data.attrs,attrs=vnode.data.attrs;
        if(!oldAttrs&&!attrs)
            return;
        if(oldAttrs===attrs)
            return;
        oldAttrs=oldAttrs||{};
        attrs=attrs||{};
        //updatemodifiedattributes,addnewattributes
        for(keyinattrs){
            constcur=attrs[key];
            constold=oldAttrs[key];
            if(old!==cur){
                if(cur===true){
                    elm.setAttribute(key,"");
                }
                elseif(cur===false){
                    elm.removeAttribute(key);
                }
                else{
                    if(key.charCodeAt(0)!==xChar){
                        elm.setAttribute(key,cur);
                    }
                    elseif(key.charCodeAt(3)===colonChar){
                        //Assumexmlnamespace
                        elm.setAttributeNS(xmlNS,key,cur);
                    }
                    elseif(key.charCodeAt(5)===colonChar){
                        //Assumexlinknamespace
                        elm.setAttributeNS(xlinkNS,key,cur);
                    }
                    else{
                        elm.setAttribute(key,cur);
                    }
                }
            }
        }
        //removeremovedattributes
        //use`in`operatorsincetheprevious`for`iterationusesit(.i.e.addevenattributeswithundefinedvalue)
        //theotheroptionistoremoveallattributeswithvalue==undefined
        for(keyinoldAttrs){
            if(!(keyinattrs)){
                elm.removeAttribute(key);
            }
        }
    }
    constattrsModule={
        create:updateAttrs,
        update:updateAttrs,
    };
    //------------------------------------------------------------------------------
    //class.ts
    //------------------------------------------------------------------------------
    functionupdateClass(oldVnode,vnode){
        varcur,name,elm,oldClass=oldVnode.data.class,klass=vnode.data.class;
        if(!oldClass&&!klass)
            return;
        if(oldClass===klass)
            return;
        oldClass=oldClass||{};
        klass=klass||{};
        elm=vnode.elm;
        for(nameinoldClass){
            if(name&&!klass[name]&&!Object.prototype.hasOwnProperty.call(klass,name)){
                //was`true`andnownotprovided
                elm.classList.remove(name);
            }
        }
        for(nameinklass){
            cur=klass[name];
            if(cur!==oldClass[name]){
                elm.classList[cur?"add":"remove"](name);
            }
        }
    }
    constclassModule={create:updateClass,update:updateClass};

    /**
     *OwlVDOM
     *
     *ThisfilecontainsanimplementationofavirtualDOM,whichisasystemthat
     *cangeneratein-memoryrepresentationsofaDOMtree,comparethem,and
     *eventuallychangeaconcreteDOMtreetomatchitsrepresentation,inan
     *hopefullyefficientway.
     *
     *NotethatthiscodeisaforkofSnabbdom,slightlytweaked/optimizedforour
     *needs(seehttps://github.com/snabbdom/snabbdom).
     *
     *Themainexportedvaluesare:
     *-interfaceVNode
     *-hfunction(ahelperfunctiontogenerateavnode)
     *-patchfunction(toapplyavnodetoanactualDOMnode)
     */
    functionvnode(sel,data,children,text,elm){
        letkey=data===undefined?undefined:data.key;
        return{sel,data,children,text,elm,key};
    }
    //------------------------------------------------------------------------------
    //snabbdom.ts
    //------------------------------------------------------------------------------
    functionisUndef(s){
        returns===undefined;
    }
    functionisDef(s){
        returns!==undefined;
    }
    constemptyNode=vnode("",{},[],undefined,undefined);
    functionsameVnode(vnode1,vnode2){
        returnvnode1.key===vnode2.key&&vnode1.sel===vnode2.sel;
    }
    functionisVnode(vnode){
        returnvnode.sel!==undefined;
    }
    functioncreateKeyToOldIdx(children,beginIdx,endIdx){
        leti,map={},key,ch;
        for(i=beginIdx;i<=endIdx;++i){
            ch=children[i];
            if(ch!=null){
                key=ch.key;
                if(key!==undefined)
                    map[key]=i;
            }
        }
        returnmap;
    }
    consthooks$1=["create","update","remove","destroy","pre","post"];
    functioninit(modules,domApi){
        leti,j,cbs={};
        constapi=domApi!==undefined?domApi:htmlDomApi;
        for(i=0;i<hooks$1.length;++i){
            cbs[hooks$1[i]]=[];
            for(j=0;j<modules.length;++j){
                consthook=modules[j][hooks$1[i]];
                if(hook!==undefined){
                    cbs[hooks$1[i]].push(hook);
                }
            }
        }
        functionemptyNodeAt(elm){
            constid=elm.id?"#"+elm.id:"";
            constc=elm.className?"."+elm.className.split("").join("."):"";
            returnvnode(api.tagName(elm).toLowerCase()+id+c,{},[],undefined,elm);
        }
        functioncreateRmCb(childElm,listeners){
            returnfunctionrmCb(){
                if(--listeners===0){
                    constparent=api.parentNode(childElm);
                    api.removeChild(parent,childElm);
                }
            };
        }
        functioncreateElm(vnode,insertedVnodeQueue){
            leti,iLen,data=vnode.data;
            if(data!==undefined){
                if(isDef((i=data.hook))&&isDef((i=i.init))){
                    i(vnode);
                    data=vnode.data;
                }
            }
            letchildren=vnode.children,sel=vnode.sel;
            if(sel==="!"){
                if(isUndef(vnode.text)){
                    vnode.text="";
                }
                vnode.elm=api.createComment(vnode.text);
            }
            elseif(sel!==undefined){
                constelm=vnode.elm||
                    (vnode.elm=
                        isDef(data)&&isDef((i=data.ns))
                            ?api.createElementNS(i,sel)
                            :api.createElement(sel));
                for(i=0,iLen=cbs.create.length;i<iLen;++i)
                    cbs.create[i](emptyNode,vnode);
                if(array(children)){
                    for(i=0,iLen=children.length;i<iLen;++i){
                        constch=children[i];
                        if(ch!=null){
                            api.appendChild(elm,createElm(ch,insertedVnodeQueue));
                        }
                    }
                }
                elseif(primitive(vnode.text)){
                    api.appendChild(elm,api.createTextNode(vnode.text));
                }
                i=vnode.data.hook;//Reusevariable
                if(isDef(i)){
                    if(i.create)
                        i.create(emptyNode,vnode);
                    if(i.insert)
                        insertedVnodeQueue.push(vnode);
                }
            }
            else{
                vnode.elm=api.createTextNode(vnode.text);
            }
            returnvnode.elm;
        }
        functionaddVnodes(parentElm,before,vnodes,startIdx,endIdx,insertedVnodeQueue){
            for(;startIdx<=endIdx;++startIdx){
                constch=vnodes[startIdx];
                if(ch!=null){
                    api.insertBefore(parentElm,createElm(ch,insertedVnodeQueue),before);
                }
            }
        }
        functioninvokeDestroyHook(vnode){
            leti,iLen,j,jLen,data=vnode.data;
            if(data!==undefined){
                if(isDef((i=data.hook))&&isDef((i=i.destroy)))
                    i(vnode);
                for(i=0,iLen=cbs.destroy.length;i<iLen;++i)
                    cbs.destroy[i](vnode);
                if(vnode.children!==undefined){
                    for(j=0,jLen=vnode.children.length;j<jLen;++j){
                        i=vnode.children[j];
                        if(i!=null&&typeofi!=="string"){
                            invokeDestroyHook(i);
                        }
                    }
                }
            }
        }
        functionremoveVnodes(parentElm,vnodes,startIdx,endIdx){
            for(;startIdx<=endIdx;++startIdx){
                leti,iLen,listeners,rm,ch=vnodes[startIdx];
                if(ch!=null){
                    if(isDef(ch.sel)){
                        invokeDestroyHook(ch);
                        listeners=cbs.remove.length+1;
                        rm=createRmCb(ch.elm,listeners);
                        for(i=0,iLen=cbs.remove.length;i<iLen;++i)
                            cbs.remove[i](ch,rm);
                        if(isDef((i=ch.data))&&isDef((i=i.hook))&&isDef((i=i.remove))){
                            i(ch,rm);
                        }
                        else{
                            rm();
                        }
                    }
                    else{
                        //Textnode
                        api.removeChild(parentElm,ch.elm);
                    }
                }
            }
        }
        functionupdateChildren(parentElm,oldCh,newCh,insertedVnodeQueue){
            letoldStartIdx=0,newStartIdx=0;
            letoldEndIdx=oldCh.length-1;
            letoldStartVnode=oldCh[0];
            letoldEndVnode=oldCh[oldEndIdx];
            letnewEndIdx=newCh.length-1;
            letnewStartVnode=newCh[0];
            letnewEndVnode=newCh[newEndIdx];
            letoldKeyToIdx;
            letidxInOld;
            letelmToMove;
            letbefore;
            while(oldStartIdx<=oldEndIdx&&newStartIdx<=newEndIdx){
                if(oldStartVnode==null){
                    oldStartVnode=oldCh[++oldStartIdx];//Vnodemighthavebeenmovedleft
                }
                elseif(oldEndVnode==null){
                    oldEndVnode=oldCh[--oldEndIdx];
                }
                elseif(newStartVnode==null){
                    newStartVnode=newCh[++newStartIdx];
                }
                elseif(newEndVnode==null){
                    newEndVnode=newCh[--newEndIdx];
                }
                elseif(sameVnode(oldStartVnode,newStartVnode)){
                    patchVnode(oldStartVnode,newStartVnode,insertedVnodeQueue);
                    oldStartVnode=oldCh[++oldStartIdx];
                    newStartVnode=newCh[++newStartIdx];
                }
                elseif(sameVnode(oldEndVnode,newEndVnode)){
                    patchVnode(oldEndVnode,newEndVnode,insertedVnodeQueue);
                    oldEndVnode=oldCh[--oldEndIdx];
                    newEndVnode=newCh[--newEndIdx];
                }
                elseif(sameVnode(oldStartVnode,newEndVnode)){
                    //Vnodemovedright
                    patchVnode(oldStartVnode,newEndVnode,insertedVnodeQueue);
                    api.insertBefore(parentElm,oldStartVnode.elm,api.nextSibling(oldEndVnode.elm));
                    oldStartVnode=oldCh[++oldStartIdx];
                    newEndVnode=newCh[--newEndIdx];
                }
                elseif(sameVnode(oldEndVnode,newStartVnode)){
                    //Vnodemovedleft
                    patchVnode(oldEndVnode,newStartVnode,insertedVnodeQueue);
                    api.insertBefore(parentElm,oldEndVnode.elm,oldStartVnode.elm);
                    oldEndVnode=oldCh[--oldEndIdx];
                    newStartVnode=newCh[++newStartIdx];
                }
                else{
                    if(oldKeyToIdx===undefined){
                        oldKeyToIdx=createKeyToOldIdx(oldCh,oldStartIdx,oldEndIdx);
                    }
                    idxInOld=oldKeyToIdx[newStartVnode.key];
                    if(isUndef(idxInOld)){
                        //Newelement
                        api.insertBefore(parentElm,createElm(newStartVnode,insertedVnodeQueue),oldStartVnode.elm);
                        newStartVnode=newCh[++newStartIdx];
                    }
                    else{
                        elmToMove=oldCh[idxInOld];
                        if(elmToMove.sel!==newStartVnode.sel){
                            api.insertBefore(parentElm,createElm(newStartVnode,insertedVnodeQueue),oldStartVnode.elm);
                        }
                        else{
                            patchVnode(elmToMove,newStartVnode,insertedVnodeQueue);
                            oldCh[idxInOld]=undefined;
                            api.insertBefore(parentElm,elmToMove.elm,oldStartVnode.elm);
                        }
                        newStartVnode=newCh[++newStartIdx];
                    }
                }
            }
            if(oldStartIdx<=oldEndIdx||newStartIdx<=newEndIdx){
                if(oldStartIdx>oldEndIdx){
                    before=newCh[newEndIdx+1]==null?null:newCh[newEndIdx+1].elm;
                    addVnodes(parentElm,before,newCh,newStartIdx,newEndIdx,insertedVnodeQueue);
                }
                else{
                    removeVnodes(parentElm,oldCh,oldStartIdx,oldEndIdx);
                }
            }
        }
        functionpatchVnode(oldVnode,vnode,insertedVnodeQueue){
            leti,iLen,hook;
            if(isDef((i=vnode.data))&&isDef((hook=i.hook))&&isDef((i=hook.prepatch))){
                i(oldVnode,vnode);
            }
            constelm=(vnode.elm=oldVnode.elm);
            letoldCh=oldVnode.children;
            letch=vnode.children;
            if(oldVnode===vnode)
                return;
            if(vnode.data!==undefined){
                for(i=0,iLen=cbs.update.length;i<iLen;++i)
                    cbs.update[i](oldVnode,vnode);
                i=vnode.data.hook;
                if(isDef(i)&&isDef((i=i.update)))
                    i(oldVnode,vnode);
            }
            if(isUndef(vnode.text)){
                if(isDef(oldCh)&&isDef(ch)){
                    if(oldCh!==ch)
                        updateChildren(elm,oldCh,ch,insertedVnodeQueue);
                }
                elseif(isDef(ch)){
                    if(isDef(oldVnode.text))
                        api.setTextContent(elm,"");
                    addVnodes(elm,null,ch,0,ch.length-1,insertedVnodeQueue);
                }
                elseif(isDef(oldCh)){
                    removeVnodes(elm,oldCh,0,oldCh.length-1);
                }
                elseif(isDef(oldVnode.text)){
                    api.setTextContent(elm,"");
                }
            }
            elseif(oldVnode.text!==vnode.text){
                if(isDef(oldCh)){
                    removeVnodes(elm,oldCh,0,oldCh.length-1);
                }
                api.setTextContent(elm,vnode.text);
            }
            if(isDef(hook)&&isDef((i=hook.postpatch))){
                i(oldVnode,vnode);
            }
        }
        returnfunctionpatch(oldVnode,vnode){
            leti,iLen,elm,parent;
            constinsertedVnodeQueue=[];
            for(i=0,iLen=cbs.pre.length;i<iLen;++i)
                cbs.pre[i]();
            if(!isVnode(oldVnode)){
                oldVnode=emptyNodeAt(oldVnode);
            }
            if(sameVnode(oldVnode,vnode)){
                patchVnode(oldVnode,vnode,insertedVnodeQueue);
            }
            else{
                elm=oldVnode.elm;
                parent=api.parentNode(elm);
                createElm(vnode,insertedVnodeQueue);
                if(parent!==null){
                    api.insertBefore(parent,vnode.elm,api.nextSibling(elm));
                    removeVnodes(parent,[oldVnode],0,0);
                }
            }
            for(i=0,iLen=insertedVnodeQueue.length;i<iLen;++i){
                insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
            }
            for(i=0,iLen=cbs.post.length;i<iLen;++i)
                cbs.post[i]();
            returnvnode;
        };
    }
    //------------------------------------------------------------------------------
    //is.ts
    //------------------------------------------------------------------------------
    constarray=Array.isArray;
    functionprimitive(s){
        returntypeofs==="string"||typeofs==="number";
    }
    functioncreateElement(tagName){
        returndocument.createElement(tagName);
    }
    functioncreateElementNS(namespaceURI,qualifiedName){
        returndocument.createElementNS(namespaceURI,qualifiedName);
    }
    functioncreateTextNode(text){
        returndocument.createTextNode(text);
    }
    functioncreateComment(text){
        returndocument.createComment(text);
    }
    functioninsertBefore(parentNode,newNode,referenceNode){
        parentNode.insertBefore(newNode,referenceNode);
    }
    functionremoveChild(node,child){
        node.removeChild(child);
    }
    functionappendChild(node,child){
        node.appendChild(child);
    }
    functionparentNode(node){
        returnnode.parentNode;
    }
    functionnextSibling(node){
        returnnode.nextSibling;
    }
    functiontagName(elm){
        returnelm.tagName;
    }
    functionsetTextContent(node,text){
        node.textContent=text;
    }
    consthtmlDomApi={
        createElement,
        createElementNS,
        createTextNode,
        createComment,
        insertBefore,
        removeChild,
        appendChild,
        parentNode,
        nextSibling,
        tagName,
        setTextContent,
    };
    functionaddNS(data,children,sel){
        if(sel==="dummy"){
            //wedonotneedtoaddthenamespaceondummyelements,theycomefroma
            //subcomponent,whichwillhandlethenamespaceitself
            return;
        }
        data.ns="http://www.w3.org/2000/svg";
        if(sel!=="foreignObject"&&children!==undefined){
            for(leti=0,iLen=children.length;i<iLen;++i){
                constchild=children[i];
                letchildData=child.data;
                if(childData!==undefined){
                    addNS(childData,child.children,child.sel);
                }
            }
        }
    }
    functionh(sel,b,c){
        vardata={},children,text,i,iLen;
        if(c!==undefined){
            data=b;
            if(array(c)){
                children=c;
            }
            elseif(primitive(c)){
                text=c;
            }
            elseif(c&&c.sel){
                children=[c];
            }
        }
        elseif(b!==undefined){
            if(array(b)){
                children=b;
            }
            elseif(primitive(b)){
                text=b;
            }
            elseif(b&&b.sel){
                children=[b];
            }
            else{
                data=b;
            }
        }
        if(children!==undefined){
            for(i=0,iLen=children.length;i<iLen;++i){
                if(primitive(children[i]))
                    children[i]=vnode(undefined,undefined,undefined,children[i],undefined);
            }
        }
        returnvnode(sel,data,children,text,undefined);
    }

    constpatch=init([eventListenersModule,attrsModule,propsModule,classModule]);

    letlocalStorage=null;
    constbrowser={
        setTimeout:window.setTimeout.bind(window),
        clearTimeout:window.clearTimeout.bind(window),
        setInterval:window.setInterval.bind(window),
        clearInterval:window.clearInterval.bind(window),
        requestAnimationFrame:window.requestAnimationFrame.bind(window),
        random:Math.random,
        Date:window.Date,
        fetch:(window.fetch||(()=>{})).bind(window),
        getlocalStorage(){
            returnlocalStorage||window.localStorage;
        },
        setlocalStorage(newLocalStorage){
            localStorage=newLocalStorage;
        },
    };

    /**
     *OwlUtils
     *
     *Wehavehereasmallcollectionofutilityfunctions:
     *
     *-whenReady
     *-loadJS
     *-loadFile
     *-escape
     *-debounce
     */
    functionwhenReady(fn){
        returnnewPromise(function(resolve){
            if(document.readyState!=="loading"){
                resolve();
            }
            else{
                document.addEventListener("DOMContentLoaded",resolve,false);
            }
        }).then(fn||function(){});
    }
    constloadedScripts={};
    functionloadJS(url){
        if(urlinloadedScripts){
            returnloadedScripts[url];
        }
        constpromise=newPromise(function(resolve,reject){
            constscript=document.createElement("script");
            script.type="text/javascript";
            script.src=url;
            script.onload=function(){
                resolve();
            };
            script.onerror=function(){
                reject(`Errorloadingfile'${url}'`);
            };
            consthead=document.head||document.getElementsByTagName("head")[0];
            head.appendChild(script);
        });
        loadedScripts[url]=promise;
        returnpromise;
    }
    asyncfunctionloadFile(url){
        constresult=awaitbrowser.fetch(url);
        if(!result.ok){
            thrownewError("Errorwhilefetchingxmltemplates");
        }
        returnawaitresult.text();
    }
    functionescape(str){
        if(str===undefined){
            return"";
        }
        if(typeofstr==="number"){
            returnString(str);
        }
        constp=document.createElement("p");
        p.textContent=str;
        returnp.innerHTML;
    }
    /**
     *Returnsafunction,that,aslongasitcontinuestobeinvoked,willnot
     *betriggered.Thefunctionwillbecalledafteritstopsbeingcalledfor
     *Nmilliseconds.If`immediate`ispassed,triggerthefunctiononthe
     *leadingedge,insteadofthetrailing.
     *
     *Inspiredbyhttps://davidwalsh.name/javascript-debounce-function
     */
    functiondebounce(func,wait,immediate){
        lettimeout;
        returnfunction(){
            constcontext=this;
            constargs=arguments;
            functionlater(){
                timeout=null;
                if(!immediate){
                    func.apply(context,args);
                }
            }
            constcallNow=immediate&&!timeout;
            browser.clearTimeout(timeout);
            timeout=browser.setTimeout(later,wait);
            if(callNow){
                func.apply(context,args);
            }
        };
    }
    functionshallowEqual(p1,p2){
        for(letkinp1){
            if(p1[k]!==p2[k]){
                returnfalse;
            }
        }
        returntrue;
    }

    var_utils=/*#__PURE__*/Object.freeze({
        __proto__:null,
        whenReady:whenReady,
        loadJS:loadJS,
        loadFile:loadFile,
        escape:escape,
        debounce:debounce,
        shallowEqual:shallowEqual
    });

    //------------------------------------------------------------------------------
    //Const/globalstuff/helpers
    //------------------------------------------------------------------------------
    constTRANSLATABLE_ATTRS=["label","title","placeholder","alt"];
    constlineBreakRE=/[\r\n]/;
    constwhitespaceRE=/\s+/g;
    consttranslationRE=/^(\s*)([\s\S]+?)(\s*)$/;
    constNODE_HOOKS_PARAMS={
        create:"(_,n)",
        insert:"vn",
        remove:"(vn,rm)",
        destroy:"()",
    };
    functionisComponent(obj){
        returnobj&&obj.hasOwnProperty("__owl__");
    }
    classVDomArrayextendsArray{
        toString(){
            returnvDomToString(this);
        }
    }
    functionvDomToString(vdom){
        returnvdom
            .map((vnode)=>{
            if(vnode.sel){
                constnode=document.createElement(vnode.sel);
                constresult=patch(node,vnode);
                returnresult.elm.outerHTML;
            }
            else{
                returnvnode.text;
            }
        })
            .join("");
    }
    constUTILS={
        zero:Symbol("zero"),
        toClassObj(expr){
            constresult={};
            if(typeofexpr==="string"){
                //wetransformherealistofclassesintoanobject:
                // 'heyyou'becomes{hey:true,you:true}
                expr=expr.trim();
                if(!expr){
                    return{};
                }
                letwords=expr.split(/\s+/);
                for(leti=0;i<words.length;i++){
                    result[words[i]]=true;
                }
                returnresult;
            }
            //thisisalreadyanobject,butwemayneedtosplitkeys:
            //{'ab':true,'ac':false}shouldbecome{a:true,b:true,c:false}
            for(letkeyinexpr){
                constvalue=expr[key];
                constwords=key.split(/\s+/);
                for(letwordofwords){
                    result[word]=result[word]||value;
                }
            }
            returnresult;
        },
        /**
         *Thismethodcombinesthecurrentcontextwiththevariablesdefinedina
         *scopeforuseinaslot.
         *
         *Theimplementationiskindoftrickybecausewewanttopreservethe
         *prototypechainstructureoftheclonedresult.Soweneedtotraversethe
         *prototypechain,cloningeachlevelrespectively.
         */
        combine(context,scope){
            letclone=context;
            constscopeStack=[];
            while(!isComponent(scope)){
                scopeStack.push(scope);
                scope=scope.__proto__;
            }
            while(scopeStack.length){
                letscope=scopeStack.pop();
                clone=Object.create(clone);
                Object.assign(clone,scope);
            }
            returnclone;
        },
        shallowEqual,
        addNameSpace(vnode){
            addNS(vnode.data,vnode.children,vnode.sel);
        },
        VDomArray,
        vDomToString,
        getComponent(obj){
            while(obj&&!isComponent(obj)){
                obj=obj.__proto__;
            }
            returnobj;
        },
        getScope(obj,property){
            constobj0=obj;
            while(obj&&
                !obj.hasOwnProperty(property)&&
                !(obj.hasOwnProperty("__access_mode__")&&obj.__access_mode__==="ro")){
                constnewObj=obj.__proto__;
                if(!newObj||isComponent(newObj)){
                    returnobj0;
                }
                obj=newObj;
            }
            returnobj;
        },
    };
    functionparseXML(xml){
        constparser=newDOMParser();
        constdoc=parser.parseFromString(xml,"text/xml");
        if(doc.getElementsByTagName("parsererror").length){
            letmsg="InvalidXMLintemplate.";
            constparsererrorText=doc.getElementsByTagName("parsererror")[0].textContent;
            if(parsererrorText){
                msg+="\nTheparserhasproducedthefollowingerrormessage:\n"+parsererrorText;
                constre=/\d+/g;
                constfirstMatch=re.exec(parsererrorText);
                if(firstMatch){
                    constlineNumber=Number(firstMatch[0]);
                    constline=xml.split("\n")[lineNumber-1];
                    constsecondMatch=re.exec(parsererrorText);
                    if(line&&secondMatch){
                        constcolumnIndex=Number(secondMatch[0])-1;
                        if(line[columnIndex]){
                            msg+=
                                `\nTheerrormightbelocatedatxmlline${lineNumber}column${columnIndex}\n`+
                                    `${line}\n${"-".repeat(columnIndex-1)}^`;
                        }
                    }
                }
            }
            thrownewError(msg);
        }
        returndoc;
    }
    functionescapeQuotes(str){
        returnstr.replace(/\'/g,"\\'");
    }
    //------------------------------------------------------------------------------
    //QWebrenderingengine
    //------------------------------------------------------------------------------
    classQWebextendsEventBus{
        constructor(config={}){
            super();
            this.h=h;
            //subTemplatesarestoredintwoobjects:a(local)mappingfromanametoan
            //id,anda(global)mappingfromanidtothecompiledfunction. Thisis
            //necessarytoensurethatglobaltemplatescanbecalledwithmorethanone
            //QWebinstance.
            this.subTemplates={};
            this.isUpdating=false;
            this.templates=Object.create(QWeb.TEMPLATES);
            if(config.templates){
                this.addTemplates(config.templates);
            }
            if(config.translateFn){
                this.translateFn=config.translateFn;
            }
        }
        staticaddDirective(directive){
            if(directive.nameinQWeb.DIRECTIVE_NAMES){
                thrownewError(`Directive"${directive.name}alreadyregistered`);
            }
            QWeb.DIRECTIVES.push(directive);
            QWeb.DIRECTIVE_NAMES[directive.name]=1;
            QWeb.DIRECTIVES.sort((d1,d2)=>d1.priority-d2.priority);
            if(directive.extraNames){
                directive.extraNames.forEach((n)=>(QWeb.DIRECTIVE_NAMES[n]=1));
            }
        }
        staticregisterComponent(name,Component){
            if(QWeb.components[name]){
                thrownewError(`Component'${name}'hasalreadybeenregistered`);
            }
            QWeb.components[name]=Component;
        }
        /**
         *Registergloballyatemplate. AllQWebinstanceswillobtaintheir
         *templatesfromtheirowntemplatemap,andthen,fromtheglobalstatic
         *TEMPLATESproperty.
         */
        staticregisterTemplate(name,template){
            if(QWeb.TEMPLATES[name]){
                thrownewError(`Template'${name}'hasalreadybeenregistered`);
            }
            constqweb=newQWeb();
            qweb.addTemplate(name,template);
            QWeb.TEMPLATES[name]=qweb.templates[name];
        }
        /**
         *Addatemplatetotheinternaltemplatemap. Notethatitisnot
         *immediatelycompiled.
         */
        addTemplate(name,xmlString,allowDuplicate){
            if(allowDuplicate&&nameinthis.templates){
                return;
            }
            constdoc=parseXML(xmlString);
            if(!doc.firstChild){
                thrownewError("Invalidtemplate(shouldnotbeempty)");
            }
            this._addTemplate(name,doc.firstChild);
        }
        /**
         *Loadtemplatesfromaxml(asastringorxmldocument). Thiswilllookup
         *forthefirst<templates>tag,andwillconsidereachchildofthisasa
         *template,withthenamegivenbythet-nameattribute.
         */
        addTemplates(xmlstr){
            if(!xmlstr){
                return;
            }
            constdoc=typeofxmlstr==="string"?parseXML(xmlstr):xmlstr;
            consttemplates=doc.getElementsByTagName("templates")[0];
            if(!templates){
                return;
            }
            for(letelemoftemplates.children){
                constname=elem.getAttribute("t-name");
                this._addTemplate(name,elem);
            }
        }
        _addTemplate(name,elem){
            if(nameinthis.templates){
                thrownewError(`Template${name}alreadydefined`);
            }
            this._processTemplate(elem);
            consttemplate={
                elem,
                fn:function(context,extra){
                    constcompiledFunction=this._compile(name);
                    template.fn=compiledFunction;
                    returncompiledFunction.call(this,context,extra);
                },
            };
            this.templates[name]=template;
        }
        _processTemplate(elem){
            lettbranch=elem.querySelectorAll("[t-elif],[t-else]");
            for(leti=0,ilen=tbranch.length;i<ilen;i++){
                letnode=tbranch[i];
                letprevElem=node.previousElementSibling;
                letpattr=function(name){
                    returnprevElem.getAttribute(name);
                };
                letnattr=function(name){
                    return+!!node.getAttribute(name);
                };
                if(prevElem&&(pattr("t-if")||pattr("t-elif"))){
                    if(pattr("t-foreach")){
                        thrownewError("t-ifcannotstayatthesamelevelast-foreachwhenusingt-elifort-else");
                    }
                    if(["t-if","t-elif","t-else"].map(nattr).reduce(function(a,b){
                        returna+b;
                    })>1){
                        thrownewError("Onlyoneconditionalbranchingdirectiveisallowedpernode");
                    }
                    //Alltext(withonlyspaces)andcommentnodes(nodeType8)between
                    //branchnodesareremoved
                    lettextNode;
                    while((textNode=node.previousSibling)!==prevElem){
                        if(textNode.nodeValue.trim().length&&textNode.nodeType!==8){
                            thrownewError("textisnotallowedbetweenbranchingdirectives");
                        }
                        textNode.remove();
                    }
                }
                else{
                    thrownewError("t-elifandt-elsedirectivesmustbeprecededbyat-ifort-elifdirective");
                }
            }
        }
        /**
         *Renderatemplate
         *
         *@param{string}namethetemplateshouldalreadyhavebeenadded
         */
        render(name,context={},extra=null){
            consttemplate=this.templates[name];
            if(!template){
                thrownewError(`Template${name}doesnotexist`);
            }
            returntemplate.fn.call(this,context,extra);
        }
        /**
         *Renderatemplatetoahtmlstring.
         *
         *Notethatthisismorelimitedthanthe`render`method:itisnotsuitable
         *torenderafullcomponenttree,sincethisisanasynchronousoperation.
         *Thismethodcanonlyrendertemplateswithoutcomponents.
         */
        renderToString(name,context={},extra){
            constvnode=this.render(name,context,extra);
            if(vnode.sel===undefined){
                returnvnode.text;
            }
            constnode=document.createElement(vnode.sel);
            constresult=patch(node,vnode);
            returnresult.elm.outerHTML;
        }
        /**
         *ForceallwidgetsconnectedtothisQWebinstancetorerenderthemselves.
         *
         *Thismethodismostlyusefulforexternalcodethatwanttomodifythe
         *applicationinsomecases. Forexample,arouterplugin.
         */
        forceUpdate(){
            this.isUpdating=true;
            Promise.resolve().then(()=>{
                if(this.isUpdating){
                    this.isUpdating=false;
                    this.trigger("update");
                }
            });
        }
        _compile(name,options={}){
            constelem=options.elem||this.templates[name].elem;
            constisDebug=elem.attributes.hasOwnProperty("t-debug");
            constctx=newCompilationContext(name);
            if(elem.tagName!=="t"){
                ctx.shouldDefineResult=false;
            }
            if(options.hasParent){
                ctx.variables=Object.create(null);
                ctx.parentNode=ctx.generateID();
                ctx.allowMultipleRoots=true;
                ctx.shouldDefineParent=true;
                ctx.hasParentWidget=true;
                ctx.shouldDefineResult=false;
                ctx.addLine(`letc${ctx.parentNode}=extra.parentNode;`);
                if(options.defineKey){
                    ctx.addLine(`letkey0=extra.key||"";`);
                    ctx.hasKey0=true;
                }
            }
            this._compileNode(elem,ctx);
            if(!options.hasParent){
                if(ctx.shouldDefineResult){
                    ctx.addLine(`returnresult;`);
                }
                else{
                    if(!ctx.rootNode){
                        thrownewError(`Atemplateshouldhaveonerootnode(${ctx.templateName})`);
                    }
                    ctx.addLine(`returnvn${ctx.rootNode};`);
                }
            }
            letcode=ctx.generateCode();
            consttemplateName=ctx.templateName.replace(/`/g,"'").slice(0,200);
            code.unshift(`   //Templatename:"${templateName}"`);
            lettemplate;
            try{
                template=newFunction("context,extra",code.join("\n"));
            }
            catch(e){
                console.groupCollapsed(`InvalidCodegeneratedby${templateName}`);
                console.warn(code.join("\n"));
                console.groupEnd();
                thrownewError(`Invalidgeneratedcodewhilecompilingtemplate'${templateName}':${e.message}`);
            }
            if(isDebug){
                consttpl=this.templates[name];
                if(tpl){
                    constmsg=`Template:${tpl.elem.outerHTML}\nCompiledcode:\n${template.toString()}`;
                    console.log(msg);
                }
            }
            returntemplate;
        }
        /**
         *Generatecodefromanxmlnode
         *
         */
        _compileNode(node,ctx){
            if(!(nodeinstanceofElement)){
                //thisisatextnode,therearenodirectivetoapply
                lettext=node.textContent;
                if(!ctx.inPreTag){
                    if(lineBreakRE.test(text)&&!text.trim()){
                        return;
                    }
                    text=text.replace(whitespaceRE,"");
                }
                if(this.translateFn){
                    if(node.parentNode.getAttribute("t-translation")!=="off"){
                        constmatch=translationRE.exec(text);
                        text=match[1]+this.translateFn(match[2])+match[3];
                    }
                }
                if(ctx.parentNode){
                    if(node.nodeType===3){
                        ctx.addLine(`c${ctx.parentNode}.push({text:\`${text}\`});`);
                    }
                    elseif(node.nodeType===8){
                        ctx.addLine(`c${ctx.parentNode}.push(h('!',\`${text}\`));`);
                    }
                }
                elseif(ctx.parentTextNode){
                    ctx.addLine(`vn${ctx.parentTextNode}.text+=\`${text}\`;`);
                }
                else{
                    //thisisanunusualsituation:thistextnodeistheresultofthe
                    //templaterendering.
                    letnodeID=ctx.generateID();
                    ctx.addLine(`letvn${nodeID}={text:\`${text}\`};`);
                    ctx.addLine(`result=vn${nodeID};`);
                    ctx.rootContext.rootNode=nodeID;
                    ctx.rootContext.parentTextNode=nodeID;
                }
                return;
            }
            if(node.tagName!=="t"&&node.hasAttribute("t-call")){
                consttCallNode=document.implementation.createDocument("http://www.w3.org/1999/xhtml","t",null).documentElement;
                tCallNode.setAttribute("t-call",node.getAttribute("t-call"));
                node.removeAttribute("t-call");
                node.prepend(tCallNode);
            }
            constfirstLetter=node.tagName[0];
            if(firstLetter===firstLetter.toUpperCase()){
                //thisisacomponent,wemodifyinplacethexmldocumenttochange
                //<SomeComponent.../>to<SomeComponentt-component="SomeComponent".../>
                node.setAttribute("t-component",node.tagName);
            }
            elseif(node.tagName!=="t"&&node.hasAttribute("t-component")){
                thrownewError(`Directive't-component'canonlybeusedon<t>nodes(usedona<${node.tagName}>)`);
            }
            constattributes=node.attributes;
            constvalidDirectives=[];
            constfinalizers=[];
            //maybethisisnotoptimal:weiterateonallattributeshere,andagain
            //justafterforeachdirective.
            for(leti=0;i<attributes.length;i++){
                letattrName=attributes[i].name;
                if(attrName.startsWith("t-")){
                    letdName=attrName.slice(2).split(/-|\./)[0];
                    if(!(dNameinQWeb.DIRECTIVE_NAMES)){
                        thrownewError(`UnknownQWebdirective:'${attrName}'`);
                    }
                    if(node.tagName!=="t"&&(attrName==="t-esc"||attrName==="t-raw")){
                        consttNode=document.implementation.createDocument("http://www.w3.org/1999/xhtml","t",null).documentElement;
                        tNode.setAttribute(attrName,node.getAttribute(attrName));
                        for(letchildofArray.from(node.childNodes)){
                            tNode.appendChild(child);
                        }
                        node.appendChild(tNode);
                        node.removeAttribute(attrName);
                    }
                }
            }
            constDIR_N=QWeb.DIRECTIVES.length;
            constATTR_N=attributes.length;
            letwithHandlers=false;
            for(leti=0;i<DIR_N;i++){
                letdirective=QWeb.DIRECTIVES[i];
                letfullName;
                letvalue;
                for(letj=0;j<ATTR_N;j++){
                    constname=attributes[j].name;
                    if(name==="t-"+directive.name||
                        name.startsWith("t-"+directive.name+"-")||
                        name.startsWith("t-"+directive.name+".")){
                        fullName=name;
                        value=attributes[j].textContent;
                        validDirectives.push({directive,value,fullName});
                        if(directive.name==="on"||directive.name==="model"){
                            withHandlers=true;
                        }
                    }
                }
            }
            for(let{directive,value,fullName}ofvalidDirectives){
                if(directive.finalize){
                    finalizers.push({directive,value,fullName});
                }
                if(directive.atNodeEncounter){
                    constisDone=directive.atNodeEncounter({
                        node,
                        qweb:this,
                        ctx,
                        fullName,
                        value,
                    });
                    if(isDone){
                        for(let{directive,value,fullName}offinalizers){
                            directive.finalize({node,qweb:this,ctx,fullName,value});
                        }
                        return;
                    }
                }
            }
            if(node.nodeName!=="t"||node.hasAttribute("t-tag")){
                letnodeHooks={};
                letaddNodeHook=function(hook,handler){
                    nodeHooks[hook]=nodeHooks[hook]||[];
                    nodeHooks[hook].push(handler);
                };
                if(node.tagName==="select"&&node.hasAttribute("t-att-value")){
                    constvalue=node.getAttribute("t-att-value");
                    letexprId=ctx.generateID();
                    ctx.addLine(`letexpr${exprId}=${ctx.formatExpression(value)};`);
                    letexpr=`expr${exprId}`;
                    node.setAttribute("t-att-value",expr);
                    addNodeHook("create",`n.elm.value=${expr};`);
                }
                letnodeID=this._compileGenericNode(node,ctx,withHandlers);
                ctx=ctx.withParent(nodeID);
                for(let{directive,value,fullName}ofvalidDirectives){
                    if(directive.atNodeCreation){
                        directive.atNodeCreation({
                            node,
                            qweb:this,
                            ctx,
                            fullName,
                            value,
                            nodeID,
                            addNodeHook,
                        });
                    }
                }
                if(Object.keys(nodeHooks).length){
                    ctx.addLine(`p${nodeID}.hook={`);
                    for(lethookinnodeHooks){
                        ctx.addLine(` ${hook}:${NODE_HOOKS_PARAMS[hook]}=>{`);
                        for(lethandlerofnodeHooks[hook]){
                            ctx.addLine(`   ${handler}`);
                        }
                        ctx.addLine(` },`);
                    }
                    ctx.addLine(`};`);
                }
            }
            if(node.nodeName==="pre"){
                ctx=ctx.subContext("inPreTag",true);
            }
            this._compileChildren(node,ctx);
            //svgsupport
            //wehaddsvgnamespaceifitisasvgorifitisag,butonlyifitis
            //therootnode. Thisistheeasiestwaytosupportsvgsubcomponents:
            //theyneedtohaveagtagasroot.Otherwise,wewouldneedacomplete
            //listofallowedsvgtags.
            constshouldAddNS=node.nodeName==="svg"||(node.nodeName==="g"&&ctx.rootNode===ctx.parentNode);
            if(shouldAddNS){
                ctx.rootContext.shouldDefineUtils=true;
                ctx.addLine(`utils.addNameSpace(vn${ctx.parentNode});`);
            }
            for(let{directive,value,fullName}offinalizers){
                directive.finalize({node,qweb:this,ctx,fullName,value});
            }
        }
        _compileGenericNode(node,ctx,withHandlers=true){
            //nodeType1isgenerictag
            if(node.nodeType!==1){
                thrownewError("unsupportednodetype");
            }
            constattributes=node.attributes;
            constattrs=[];
            constprops=[];
            consttattrs=[];
            functionhandleProperties(key,val){
                letisProp=false;
                switch(node.nodeName){
                    case"input":
                        lettype=node.getAttribute("type");
                        if(type==="checkbox"||type==="radio"){
                            if(key==="checked"||key==="indeterminate"){
                                isProp=true;
                            }
                        }
                        if(key==="value"||key==="readonly"||key==="disabled"){
                            isProp=true;
                        }
                        break;
                    case"option":
                        isProp=key==="selected"||key==="disabled";
                        break;
                    case"textarea":
                        isProp=key==="readonly"||key==="disabled"||key==="value";
                        break;
                    case"select":
                        isProp=key==="disabled"||key==="value";
                        break;
                    case"button":
                    case"optgroup":
                        isProp=key==="disabled";
                        break;
                }
                if(isProp){
                    props.push(`${key}:${val}`);
                }
            }
            letclassObj="";
            for(leti=0;i<attributes.length;i++){
                letname=attributes[i].name;
                letvalue=attributes[i].textContent;
                if(this.translateFn&&TRANSLATABLE_ATTRS.includes(name)){
                    value=this.translateFn(value);
                }
                //regularattributes
                if(!name.startsWith("t-")&&!node.getAttribute("t-attf-"+name)){
                    constattID=ctx.generateID();
                    if(name==="class"){
                        if((value=value.trim())){
                            letclassDef=value
                                .split(/\s+/)
                                .map((a)=>`'${escapeQuotes(a)}':true`)
                                .join(",");
                            if(classObj){
                                ctx.addLine(`Object.assign(${classObj},{${classDef}})`);
                            }
                            else{
                                classObj=`_${ctx.generateID()}`;
                                ctx.addLine(`let${classObj}={${classDef}};`);
                            }
                        }
                    }
                    else{
                        ctx.addLine(`let_${attID}='${escapeQuotes(value)}';`);
                        if(!name.match(/^[a-zA-Z]+$/)){
                            //attributecontains'nonletters'=>wewanttoquoteit
                            name='"'+name+'"';
                        }
                        attrs.push(`${name}:_${attID}`);
                        handleProperties(name,`_${attID}`);
                    }
                }
                //dynamicattributes
                if(name.startsWith("t-att-")){
                    letattName=name.slice(6);
                    constv=ctx.getValue(value);
                    letformattedValue=typeofv==="string"?ctx.formatExpression(v):`scope.${v.id}`;
                    if(attName==="class"){
                        ctx.rootContext.shouldDefineUtils=true;
                        formattedValue=`utils.toClassObj(${formattedValue})`;
                        if(classObj){
                            ctx.addLine(`Object.assign(${classObj},${formattedValue})`);
                        }
                        else{
                            classObj=`_${ctx.generateID()}`;
                            ctx.addLine(`let${classObj}=${formattedValue};`);
                        }
                    }
                    else{
                        constattID=ctx.generateID();
                        if(!attName.match(/^[a-zA-Z]+$/)){
                            //attributecontains'nonletters'=>wewanttoquoteit
                            attName='"'+attName+'"';
                        }
                        //weneedtocombinedynamicwithnondynamicattributes:
                        //class="a"t-att-class="'yop'"shouldberenderedasclass="ayop"
                        constattValue=node.getAttribute(attName);
                        if(attValue){
                            constattValueID=ctx.generateID();
                            ctx.addLine(`let_${attValueID}=${formattedValue};`);
                            formattedValue=`'${attValue}'+(_${attValueID}?''+_${attValueID}:'')`;
                            constattrIndex=attrs.findIndex((att)=>att.startsWith(attName+":"));
                            attrs.splice(attrIndex,1);
                        }
                        if(node.nodeName==="select"&&attName==="value"){
                            attrs.push(`${attName}:${v}`);
                            handleProperties(attName,v);
                        }
                        else{
                            ctx.addLine(`let_${attID}=${formattedValue};`);
                            attrs.push(`${attName}:_${attID}`);
                            handleProperties(attName,"_"+attID);
                        }
                    }
                }
                if(name.startsWith("t-attf-")){
                    letattName=name.slice(7);
                    if(!attName.match(/^[a-zA-Z]+$/)){
                        //attributecontains'nonletters'=>wewanttoquoteit
                        attName='"'+attName+'"';
                    }
                    constformattedExpr=ctx.interpolate(value);
                    constattID=ctx.generateID();
                    letstaticVal=node.getAttribute(attName);
                    if(staticVal){
                        ctx.addLine(`let_${attID}='${staticVal}'+${formattedExpr};`);
                    }
                    else{
                        ctx.addLine(`let_${attID}=${formattedExpr};`);
                    }
                    attrs.push(`${attName}:_${attID}`);
                }
                //t-att=attributes
                if(name==="t-att"){
                    letid=ctx.generateID();
                    ctx.addLine(`let_${id}=${ctx.formatExpression(value)};`);
                    tattrs.push(id);
                }
            }
            letnodeID=ctx.generateID();
            letkey=ctx.loopNumber||ctx.hasKey0?`\`\${key${ctx.loopNumber}}_${nodeID}\``:nodeID;
            constparts=[`key:${key}`];
            if(attrs.length+tattrs.length>0){
                parts.push(`attrs:{${attrs.join(",")}}`);
            }
            if(props.length>0){
                parts.push(`props:{${props.join(",")}}`);
            }
            if(classObj){
                parts.push(`class:${classObj}`);
            }
            if(withHandlers){
                parts.push(`on:{}`);
            }
            ctx.addLine(`letc${nodeID}=[],p${nodeID}={${parts.join(",")}};`);
            for(letidoftattrs){
                ctx.addIf(`_${id}instanceofArray`);
                ctx.addLine(`p${nodeID}.attrs[_${id}[0]]=_${id}[1];`);
                ctx.addElse();
                ctx.addLine(`for(letkeyin_${id}){`);
                ctx.indent();
                ctx.addLine(`p${nodeID}.attrs[key]=_${id}[key];`);
                ctx.dedent();
                ctx.addLine(`}`);
                ctx.closeIf();
            }
            letnodeName=`'${node.nodeName}'`;
            if(node.hasAttribute("t-tag")){
                consttagExpr=node.getAttribute("t-tag");
                node.removeAttribute("t-tag");
                nodeName=`tag${ctx.generateID()}`;
                ctx.addLine(`let${nodeName}=${ctx.formatExpression(tagExpr)};`);
            }
            ctx.addLine(`letvn${nodeID}=h(${nodeName},p${nodeID},c${nodeID});`);
            if(ctx.parentNode){
                ctx.addLine(`c${ctx.parentNode}.push(vn${nodeID});`);
            }
            elseif(ctx.loopNumber||ctx.hasKey0){
                ctx.rootContext.shouldDefineResult=true;
                ctx.addLine(`result=vn${nodeID};`);
            }
            returnnodeID;
        }
        _compileChildren(node,ctx){
            if(node.childNodes.length>0){
                for(letchildofArray.from(node.childNodes)){
                    this._compileNode(child,ctx);
                }
            }
        }
    }
    QWeb.utils=UTILS;
    QWeb.components=Object.create(null);
    QWeb.DIRECTIVE_NAMES={
        name:1,
        att:1,
        attf:1,
        translation:1,
        tag:1,
    };
    QWeb.DIRECTIVES=[];
    QWeb.TEMPLATES={};
    QWeb.nextId=1;
    //devmodeenablesbettererrormessagesormorecostlyvalidations
    QWeb.dev=false;
    QWeb.enableTransitions=true;
    //slotscontainssubtemplatesdefinedwitht-setinsidet-componentnodes,and
    //aremeanttobeusedbythet-slotdirective.
    QWeb.slots={};
    QWeb.nextSlotId=1;
    QWeb.subTemplates={};

    constparser=newDOMParser();
    functionhtmlToVDOM(html){
        constdoc=parser.parseFromString(html,"text/html");
        constresult=[];
        for(letchildofdoc.body.childNodes){
            result.push(htmlToVNode(child));
        }
        returnresult;
    }
    functionhtmlToVNode(node){
        if(!(nodeinstanceofElement)){
            if(nodeinstanceofComment){
                returnh("!",node.textContent);
            }
            return{text:node.textContent};
        }
        constattrs={};
        for(letattrofnode.attributes){
            attrs[attr.name]=attr.textContent;
        }
        constchildren=[];
        for(letcofnode.childNodes){
            children.push(htmlToVNode(c));
        }
        constvnode=h(node.tagName,{attrs},children);
        if(vnode.sel==="svg"){
            addNS(vnode.data,vnode.children,vnode.sel);
        }
        returnvnode;
    }

    /**
     *OwlQWebDirectives
     *
     *ThisfilecontainstheimplementationofmoststandardQWebdirectives:
     *-t-esc
     *-t-raw
     *-t-set/t-value
     *-t-if/t-elif/t-else
     *-t-call
     *-t-foreach/t-as
     *-t-debug
     *-t-log
     */
    //------------------------------------------------------------------------------
    //t-escandt-raw
    //------------------------------------------------------------------------------
    QWeb.utils.htmlToVDOM=htmlToVDOM;
    functioncompileValueNode(value,node,qweb,ctx){
        ctx.rootContext.shouldDefineScope=true;
        if(value==="0"){
            if(ctx.parentNode){
                //the'zero'magicalsymboliswherewecanfindtheresultoftherendering
                //of thebodyofthet-call.
                ctx.rootContext.shouldDefineUtils=true;
                constzeroArgs=ctx.escaping
                    ?`{text:utils.vDomToString(scope[utils.zero])}`
                    :`...scope[utils.zero]`;
                ctx.addLine(`c${ctx.parentNode}.push(${zeroArgs});`);
            }
            return;
        }
        letexprID;
        if(typeofvalue==="string"){
            exprID=`_${ctx.generateID()}`;
            ctx.addLine(`let${exprID}=${ctx.formatExpression(value)};`);
        }
        else{
            exprID=`scope.${value.id}`;
        }
        ctx.addIf(`${exprID}!=null`);
        if(ctx.escaping){
            letprotectID;
            if(value.hasBody){
                ctx.rootContext.shouldDefineUtils=true;
                protectID=ctx.startProtectScope();
                ctx.addLine(`${exprID}=${exprID}instanceofutils.VDomArray?utils.vDomToString(${exprID}):${exprID};`);
            }
            if(ctx.parentTextNode){
                ctx.addLine(`vn${ctx.parentTextNode}.text+=${exprID};`);
            }
            elseif(ctx.parentNode){
                ctx.addLine(`c${ctx.parentNode}.push({text:${exprID}});`);
            }
            else{
                letnodeID=ctx.generateID();
                ctx.rootContext.rootNode=nodeID;
                ctx.rootContext.parentTextNode=nodeID;
                ctx.addLine(`letvn${nodeID}={text:${exprID}};`);
                if(ctx.rootContext.shouldDefineResult){
                    ctx.addLine(`result=vn${nodeID}`);
                }
            }
            if(value.hasBody){
                ctx.stopProtectScope(protectID);
            }
        }
        else{
            ctx.rootContext.shouldDefineUtils=true;
            if(value.hasBody){
                ctx.addLine(`constvnodeArray=${exprID}instanceofutils.VDomArray?${exprID}:utils.htmlToVDOM(${exprID});`);
                ctx.addLine(`c${ctx.parentNode}.push(...vnodeArray);`);
            }
            else{
                ctx.addLine(`c${ctx.parentNode}.push(...utils.htmlToVDOM(${exprID}));`);
            }
        }
        if(node.childNodes.length){
            ctx.addElse();
            qweb._compileChildren(node,ctx);
        }
        ctx.closeIf();
    }
    QWeb.addDirective({
        name:"esc",
        priority:70,
        atNodeEncounter({node,qweb,ctx}){
            letvalue=ctx.getValue(node.getAttribute("t-esc"));
            compileValueNode(value,node,qweb,ctx.subContext("escaping",true));
            returntrue;
        },
    });
    QWeb.addDirective({
        name:"raw",
        priority:80,
        atNodeEncounter({node,qweb,ctx}){
            letvalue=ctx.getValue(node.getAttribute("t-raw"));
            compileValueNode(value,node,qweb,ctx);
            returntrue;
        },
    });
    //------------------------------------------------------------------------------
    //t-set
    //------------------------------------------------------------------------------
    QWeb.addDirective({
        name:"set",
        extraNames:["value"],
        priority:60,
        atNodeEncounter({node,qweb,ctx}){
            ctx.rootContext.shouldDefineScope=true;
            constvariable=node.getAttribute("t-set");
            letvalue=node.getAttribute("t-value");
            ctx.variables[variable]=ctx.variables[variable]||{};
            letqwebvar=ctx.variables[variable];
            consthasBody=node.hasChildNodes();
            qwebvar.id=variable;
            qwebvar.expr=`scope.${variable}`;
            if(value){
                constformattedValue=ctx.formatExpression(value);
                letscopeExpr=`scope`;
                if(ctx.protectedScopeNumber){
                    ctx.rootContext.shouldDefineUtils=true;
                    scopeExpr=`utils.getScope(scope,'${variable}')`;
                }
                ctx.addLine(`${scopeExpr}.${variable}=${formattedValue};`);
                qwebvar.value=formattedValue;
            }
            if(hasBody){
                ctx.rootContext.shouldDefineUtils=true;
                if(value){
                    ctx.addIf(`!(${qwebvar.expr})`);
                }
                consttempParentNodeID=ctx.generateID();
                const_parentNode=ctx.parentNode;
                ctx.parentNode=tempParentNodeID;
                ctx.addLine(`letc${tempParentNodeID}=newutils.VDomArray();`);
                constnodeCopy=node.cloneNode(true);
                for(letattrof["t-set","t-value","t-if","t-else","t-elif"]){
                    nodeCopy.removeAttribute(attr);
                }
                qweb._compileNode(nodeCopy,ctx);
                ctx.addLine(`${qwebvar.expr}=c${tempParentNodeID}`);
                qwebvar.value=`c${tempParentNodeID}`;
                qwebvar.hasBody=true;
                ctx.parentNode=_parentNode;
                if(value){
                    ctx.closeIf();
                }
            }
            returntrue;
        },
    });
    //------------------------------------------------------------------------------
    //t-if,t-elif,t-else
    //------------------------------------------------------------------------------
    QWeb.addDirective({
        name:"if",
        priority:20,
        atNodeEncounter({node,ctx}){
            letcond=ctx.getValue(node.getAttribute("t-if"));
            ctx.addIf(typeofcond==="string"?ctx.formatExpression(cond):`scope.${cond.id}`);
            returnfalse;
        },
        finalize({ctx}){
            ctx.closeIf();
        },
    });
    QWeb.addDirective({
        name:"elif",
        priority:30,
        atNodeEncounter({node,ctx}){
            letcond=ctx.getValue(node.getAttribute("t-elif"));
            ctx.addLine(`elseif(${typeofcond==="string"?ctx.formatExpression(cond):`scope.${cond.id}`}){`);
            ctx.indent();
            returnfalse;
        },
        finalize({ctx}){
            ctx.closeIf();
        },
    });
    QWeb.addDirective({
        name:"else",
        priority:40,
        atNodeEncounter({ctx}){
            ctx.addLine(`else{`);
            ctx.indent();
            returnfalse;
        },
        finalize({ctx}){
            ctx.closeIf();
        },
    });
    //------------------------------------------------------------------------------
    //t-call
    //------------------------------------------------------------------------------
    QWeb.addDirective({
        name:"call",
        priority:50,
        atNodeEncounter({node,qweb,ctx}){
            //Step1:sanitychecks
            //------------------------------------------------
            ctx.rootContext.shouldDefineScope=true;
            ctx.rootContext.shouldDefineUtils=true;
            constsubTemplate=node.getAttribute("t-call");
            constisDynamic=INTERP_REGEXP.test(subTemplate);
            constnodeTemplate=qweb.templates[subTemplate];
            if(!isDynamic&&!nodeTemplate){
                thrownewError(`Cannotfindtemplate"${subTemplate}"(t-call)`);
            }
            //Step2:compiletargettemplateinsubtemplates
            //------------------------------------------------
            letsubIdstr;
            if(isDynamic){
                const_id=ctx.generateID();
                ctx.addLine(`lettname${_id}=${ctx.interpolate(subTemplate)};`);
                ctx.addLine(`lettid${_id}=this.subTemplates[tname${_id}];`);
                ctx.addIf(`!tid${_id}`);
                ctx.addLine(`tid${_id}=this.constructor.nextId++;`);
                ctx.addLine(`this.subTemplates[tname${_id}]=tid${_id};`);
                ctx.addLine(`this.constructor.subTemplates[tid${_id}]=this._compile(tname${_id},{hasParent:true,defineKey:true});`);
                ctx.closeIf();
                subIdstr=`tid${_id}`;
            }
            else{
                letsubId=qweb.subTemplates[subTemplate];
                if(!subId){
                    subId=QWeb.nextId++;
                    qweb.subTemplates[subTemplate]=subId;
                    constsubTemplateFn=qweb._compile(subTemplate,{hasParent:true,defineKey:true});
                    QWeb.subTemplates[subId]=subTemplateFn;
                }
                subIdstr=`'${subId}'`;
            }
            //Step3:compilet-callbodyifnecessary
            //------------------------------------------------
            lethasBody=node.hasChildNodes();
            constprotectID=ctx.startProtectScope();
            if(hasBody){
                //weaddasubscopetoprotecttheambientscope
                ctx.addLine(`{`);
                ctx.indent();
                constnodeCopy=node.cloneNode(true);
                for(letattrof["t-if","t-else","t-elif","t-call"]){
                    nodeCopy.removeAttribute(attr);
                }
                //thislocalscopeisintendedtotrapc__0
                ctx.addLine(`{`);
                ctx.indent();
                ctx.addLine("letc__0=[];");
                qweb._compileNode(nodeCopy,ctx.subContext("parentNode","__0"));
                ctx.rootContext.shouldDefineUtils=true;
                ctx.addLine("scope[utils.zero]=c__0;");
                ctx.dedent();
                ctx.addLine(`}`);
            }
            //Step4:addtheappropriatefunctioncalltocurrentcomponent
            //------------------------------------------------
            constparentComponent=ctx.rootContext.shouldDefineParent
                ?`parent`
                :`utils.getComponent(context)`;
            constkey=ctx.generateTemplateKey();
            constparentNode=ctx.parentNode?`c${ctx.parentNode}`:"result";
            constextra=`Object.assign({},extra,{parentNode:${parentNode},parent:${parentComponent},key:${key}})`;
            if(ctx.parentNode){
                ctx.addLine(`this.constructor.subTemplates[${subIdstr}].call(this,scope,${extra});`);
            }
            else{
                //thisisat-callwithnoparentnode,weneedtoextracttheresult
                ctx.rootContext.shouldDefineResult=true;
                ctx.addLine(`result=[]`);
                ctx.addLine(`this.constructor.subTemplates[${subIdstr}].call(this,scope,${extra});`);
                ctx.addLine(`result=result[0]`);
            }
            //Step5:restorepreviousscope
            //------------------------------------------------
            if(hasBody){
                ctx.dedent();
                ctx.addLine(`}`);
            }
            ctx.stopProtectScope(protectID);
            returntrue;
        },
    });
    //------------------------------------------------------------------------------
    //t-foreach
    //------------------------------------------------------------------------------
    QWeb.addDirective({
        name:"foreach",
        extraNames:["as"],
        priority:10,
        atNodeEncounter({node,qweb,ctx}){
            ctx.rootContext.shouldDefineScope=true;
            ctx=ctx.subContext("loopNumber",ctx.loopNumber+1);
            constelems=node.getAttribute("t-foreach");
            constname=node.getAttribute("t-as");
            letarrayID=ctx.generateID();
            ctx.addLine(`let_${arrayID}=${ctx.formatExpression(elems)};`);
            ctx.addLine(`if(!_${arrayID}){thrownewError('QWeberror:Invalidloopexpression')}`);
            letkeysID=ctx.generateID();
            letvaluesID=ctx.generateID();
            ctx.addLine(`let_${keysID}=_${arrayID};`);
            ctx.addLine(`let_${valuesID}=_${arrayID};`);
            ctx.addIf(`!(_${arrayID}instanceofArray)`);
            ctx.addLine(`_${keysID}=Object.keys(_${arrayID});`);
            ctx.addLine(`_${valuesID}=Object.values(_${arrayID});`);
            ctx.closeIf();
            ctx.addLine(`let_length${keysID}=_${keysID}.length;`);
            letvarsID=ctx.startProtectScope(true);
            constloopVar=`i${ctx.loopNumber}`;
            ctx.addLine(`for(let${loopVar}=0;${loopVar}<_length${keysID};${loopVar}++){`);
            ctx.indent();
            ctx.addLine(`scope.${name}_first=${loopVar}===0`);
            ctx.addLine(`scope.${name}_last=${loopVar}===_length${keysID}-1`);
            ctx.addLine(`scope.${name}_index=${loopVar}`);
            ctx.addLine(`scope.${name}=_${keysID}[${loopVar}]`);
            ctx.addLine(`scope.${name}_value=_${valuesID}[${loopVar}]`);
            constnodeCopy=node.cloneNode(true);
            letshouldWarn=!nodeCopy.hasAttribute("t-key")&&
                node.children.length===1&&
                node.children[0].tagName!=="t"&&
                !node.children[0].hasAttribute("t-key");
            if(shouldWarn){
                console.warn(`Directivet-foreachshouldalwaysbeusedwithat-key!(intemplate:'${ctx.templateName}')`);
            }
            if(nodeCopy.hasAttribute("t-key")){
                constexpr=ctx.formatExpression(nodeCopy.getAttribute("t-key"));
                ctx.addLine(`letkey${ctx.loopNumber}=${expr};`);
                nodeCopy.removeAttribute("t-key");
            }
            else{
                ctx.addLine(`letkey${ctx.loopNumber}=i${ctx.loopNumber};`);
            }
            nodeCopy.removeAttribute("t-foreach");
            qweb._compileNode(nodeCopy,ctx);
            ctx.dedent();
            ctx.addLine("}");
            ctx.stopProtectScope(varsID);
            returntrue;
        },
    });
    //------------------------------------------------------------------------------
    //t-debug
    //------------------------------------------------------------------------------
    QWeb.addDirective({
        name:"debug",
        priority:1,
        atNodeEncounter({ctx}){
            ctx.addLine("debugger;");
        },
    });
    //------------------------------------------------------------------------------
    //t-log
    //------------------------------------------------------------------------------
    QWeb.addDirective({
        name:"log",
        priority:1,
        atNodeEncounter({ctx,value}){
            constexpr=ctx.formatExpression(value);
            ctx.addLine(`console.log(${expr})`);
        },
    });

    /**
     *OwlQWebExtensions
     *
     *ThisfilecontainstheimplementationofnonstandardQWebdirectives,added
     *byOwlandthatwillonlyworkonOwlprojects:
     *
     *-t-on
     *-t-ref
     *-t-transition
     *-t-mounted
     *-t-slot
     *-t-model
     */
    //------------------------------------------------------------------------------
    //t-on
    //------------------------------------------------------------------------------
    //thesearepiecesofcodethatwillbeinjectedintotheeventhandlerif
    //modifiersarespecified
    constMODS_CODE={
        prevent:"e.preventDefault();",
        self:"if(e.target!==this.elm){return}",
        stop:"e.stopPropagation();",
    };
    constFNAMEREGEXP=/^[$A-Z_][0-9A-Z_$]*$/i;
    functionmakeHandlerCode(ctx,fullName,value,putInCache,modcodes=MODS_CODE){
        let[event,...mods]=fullName.slice(5).split(".");
        if(mods.includes("capture")){
            event="!"+event;
        }
        if(!event){
            thrownewError("Missingeventnamewitht-ondirective");
        }
        letcode;
        //checkifitisamethodwithnoargs,amethodwithargsoranexpression
        letargs="";
        constname=value.replace(/\(.*\)/,function(_args){
            args=_args.slice(1,-1);
            return"";
        });
        constisMethodCall=name.match(FNAMEREGEXP);
        //thengeneratecode
        if(isMethodCall){
            ctx.rootContext.shouldDefineUtils=true;
            constcomp=`utils.getComponent(context)`;
            if(args){
                constargId=ctx.generateID();
                ctx.addLine(`letargs${argId}=[${ctx.formatExpression(args)}];`);
                code=`${comp}['${name}'](...args${argId},e);`;
                putInCache=false;
            }
            else{
                code=`${comp}['${name}'](e);`;
            }
        }
        else{
            //ifwegethere,thenitisanexpression
            //weneedtocaptureeveryvariableinit
            putInCache=false;
            code=ctx.captureExpression(value);
            code=`constres=(()=>{return${code}})();if(typeofres==='function'){res(e)}`;
        }
        constmodCode=mods.map((mod)=>modcodes[mod]).join("");
        lethandler=`function(e){if(context.__owl__.status===${5/*DESTROYED*/}){return}${modCode}${code}}`;
        if(putInCache){
            constkey=ctx.generateTemplateKey(event);
            ctx.addLine(`extra.handlers[${key}]=extra.handlers[${key}]||${handler};`);
            handler=`extra.handlers[${key}]`;
        }
        return{event,handler};
    }
    QWeb.addDirective({
        name:"on",
        priority:90,
        atNodeCreation({ctx,fullName,value,nodeID}){
            const{event,handler}=makeHandlerCode(ctx,fullName,value,true);
            ctx.addLine(`p${nodeID}.on['${event}']=${handler};`);
        },
    });
    //------------------------------------------------------------------------------
    //t-ref
    //------------------------------------------------------------------------------
    QWeb.addDirective({
        name:"ref",
        priority:95,
        atNodeCreation({ctx,value,addNodeHook}){
            ctx.rootContext.shouldDefineRefs=true;
            constrefKey=`ref${ctx.generateID()}`;
            ctx.addLine(`const${refKey}=${ctx.interpolate(value)};`);
            addNodeHook("create",`context.__owl__.refs[${refKey}]=n.elm;`);
            addNodeHook("destroy",`deletecontext.__owl__.refs[${refKey}];`);
        },
    });
    //------------------------------------------------------------------------------
    //t-transition
    //------------------------------------------------------------------------------
    QWeb.utils.nextFrame=function(cb){
        requestAnimationFrame(()=>requestAnimationFrame(cb));
    };
    QWeb.utils.transitionInsert=function(vn,name){
        constelm=vn.elm;
        //removepotentialduplicatedvnodethatiscurrentlybeingremoved,to
        //preventfromhavingtwicethesamenodeintheDOMduringananimation
        constdup=elm.parentElement&&elm.parentElement.querySelector(`*[data-owl-key='${vn.key}']`);
        if(dup){
            dup.remove();
        }
        elm.classList.add(name+"-enter");
        elm.classList.add(name+"-enter-active");
        elm.classList.remove(name+"-leave-active");
        elm.classList.remove(name+"-leave-to");
        constfinalize=()=>{
            elm.classList.remove(name+"-enter-active");
            elm.classList.remove(name+"-enter-to");
        };
        this.nextFrame(()=>{
            elm.classList.remove(name+"-enter");
            elm.classList.add(name+"-enter-to");
            whenTransitionEnd(elm,finalize);
        });
    };
    QWeb.utils.transitionRemove=function(vn,name,rm){
        constelm=vn.elm;
        elm.setAttribute("data-owl-key",vn.key);
        elm.classList.add(name+"-leave");
        elm.classList.add(name+"-leave-active");
        constfinalize=()=>{
            if(!elm.classList.contains(name+"-leave-active")){
                return;
            }
            elm.classList.remove(name+"-leave-active");
            elm.classList.remove(name+"-leave-to");
            rm();
        };
        this.nextFrame(()=>{
            elm.classList.remove(name+"-leave");
            elm.classList.add(name+"-leave-to");
            whenTransitionEnd(elm,finalize);
        });
    };
    functiongetTimeout(delays,durations){
        /*istanbulignorenext*/
        while(delays.length<durations.length){
            delays=delays.concat(delays);
        }
        returnMath.max.apply(null,durations.map((d,i)=>{
            returntoMs(d)+toMs(delays[i]);
        }));
    }
    //OldversionsofChromium(below61.0.3163.100)formatsfloatingpointernumbers
    //inalocale-dependentway,usingacommainsteadofadot.
    //Ifcommaisnotreplacedwithadot,theinputwillberoundeddown(i.e.acting
    //asafloorfunction)causingunexpectedbehaviors
    functiontoMs(s){
        returnNumber(s.slice(0,-1).replace(",","."))*1000;
    }
    functionwhenTransitionEnd(elm,cb){
        if(!elm.parentNode){
            //ifwegethere,thismeansthattheelementwasremovedforsomeother
            //reasons,andinthatcase,wedon'twanttoworkonanimationsincenothing
            //willbedisplayedanyway.
            return;
        }
        conststyles=window.getComputedStyle(elm);
        constdelays=(styles.transitionDelay||"").split(",");
        constdurations=(styles.transitionDuration||"").split(",");
        consttimeout=getTimeout(delays,durations);
        if(timeout>0){
            consttransitionEndCB=()=>{
                if(!elm.parentNode)
                    return;
                cb();
                browser.clearTimeout(fallbackTimeout);
                elm.removeEventListener("transitionend",transitionEndCB);
            };
            elm.addEventListener("transitionend",transitionEndCB,{once:true});
            constfallbackTimeout=browser.setTimeout(transitionEndCB,timeout+1);
        }
        else{
            cb();
        }
    }
    QWeb.addDirective({
        name:"transition",
        priority:96,
        atNodeCreation({ctx,value,addNodeHook}){
            if(!QWeb.enableTransitions){
                return;
            }
            ctx.rootContext.shouldDefineUtils=true;
            letname=value;
            consthooks={
                insert:`utils.transitionInsert(vn,'${name}');`,
                remove:`utils.transitionRemove(vn,'${name}',rm);`,
            };
            for(lethookNameinhooks){
                addNodeHook(hookName,hooks[hookName]);
            }
        },
    });
    //------------------------------------------------------------------------------
    //t-slot
    //------------------------------------------------------------------------------
    QWeb.addDirective({
        name:"slot",
        priority:80,
        atNodeEncounter({ctx,value,node,qweb}){
            constslotKey=ctx.generateID();
            constvalueExpr=value.match(INTERP_REGEXP)?ctx.interpolate(value):`'${value}'`;
            ctx.addLine(`constslot${slotKey}=this.constructor.slots[context.__owl__.slotId+'_'+${valueExpr}];`);
            ctx.addIf(`slot${slotKey}`);
            letparentNode=`c${ctx.parentNode}`;
            if(!ctx.parentNode){
                ctx.rootContext.shouldDefineResult=true;
                ctx.rootContext.shouldDefineUtils=true;
                parentNode=`children${ctx.generateID()}`;
                ctx.addLine(`let${parentNode}=[]`);
                ctx.addLine(`result={}`);
            }
            ctx.addLine(`slot${slotKey}.call(this,context.__owl__.scope,Object.assign({},extra,{parentNode:${parentNode},parent:extra.parent||context}));`);
            if(!ctx.parentNode){
                ctx.addLine(`utils.defineProxy(result,${parentNode}[0]);`);
            }
            if(node.hasChildNodes()){
                ctx.addElse();
                constnodeCopy=node.cloneNode(true);
                nodeCopy.removeAttribute("t-slot");
                qweb._compileNode(nodeCopy,ctx);
            }
            ctx.closeIf();
            returntrue;
        },
    });
    //------------------------------------------------------------------------------
    //t-model
    //------------------------------------------------------------------------------
    QWeb.utils.toNumber=function(val){
        constn=parseFloat(val);
        returnisNaN(n)?val:n;
    };
    consthasDotAtTheEnd=/\.[\w_]+\s*$/;
    consthasBracketsAtTheEnd=/\[[^\[]+\]\s*$/;
    QWeb.addDirective({
        name:"model",
        priority:42,
        atNodeCreation({ctx,nodeID,value,node,fullName,addNodeHook}){
            consttype=node.getAttribute("type");
            lethandler;
            letevent=fullName.includes(".lazy")?"change":"input";
            //Firststep:weneedtounderstandthestructureoftheexpression,and
            //fromit,extractabaseexpression(thatwecancapture,whichis
            //importantbecauseitwillbeusedinahandlerlater)andaformatted
            //expression(whichusesthecapturedbaseexpression)
            //
            //Also,wesupport2kindsofvalues:some.expr.valueorsome.expr[value]
            //Forthefirstone,wehave:
            //-baseexpression=scope[some].expr
            //-expression=exprX.value(whereexprXisthevarthatcapturesthebaseexpr)
            //andfortheexpressionwithbrackets:
            //-baseexpression=scope[some].expr
            //-expression=exprX[keyX](whereexprXisthevarthatcapturesthebaseexpr
            //       andkeyXcapturesscope[value])
            letexpr;
            letbaseExpr;
            if(hasDotAtTheEnd.test(value)){
                //wemanagethecasewheretheexprhasadot:some.expr.value
                constindex=value.lastIndexOf(".");
                baseExpr=value.slice(0,index);
                ctx.addLine(`letexpr${nodeID}=${ctx.formatExpression(baseExpr)};`);
                expr=`expr${nodeID}${value.slice(index)}`;
            }
            elseif(hasBracketsAtTheEnd.test(value)){
                //wemanageherethecasewheretheexprendsinabracketexpression:
                //   some.expr[value]
                constindex=value.lastIndexOf("[");
                baseExpr=value.slice(0,index);
                ctx.addLine(`letexpr${nodeID}=${ctx.formatExpression(baseExpr)};`);
                letexprKey=value.trimRight().slice(index+1,-1);
                ctx.addLine(`letexprKey${nodeID}=${ctx.formatExpression(exprKey)};`);
                expr=`expr${nodeID}[exprKey${nodeID}]`;
            }
            else{
                thrownewError(`Invalidt-modelexpression:"${value}"(itshouldbeassignable)`);
            }
            constkey=ctx.generateTemplateKey();
            if(node.tagName==="select"){
                ctx.addLine(`p${nodeID}.props={value:${expr}};`);
                addNodeHook("create",`n.elm.value=${expr};`);
                event="change";
                handler=`(ev)=>{${expr}=ev.target.value}`;
            }
            elseif(type==="checkbox"){
                ctx.addLine(`p${nodeID}.props={checked:${expr}};`);
                handler=`(ev)=>{${expr}=ev.target.checked}`;
            }
            elseif(type==="radio"){
                constnodeValue=node.getAttribute("value");
                ctx.addLine(`p${nodeID}.props={checked:${expr}==='${nodeValue}'};`);
                handler=`(ev)=>{${expr}=ev.target.value}`;
                event="click";
            }
            else{
                ctx.addLine(`p${nodeID}.props={value:${expr}};`);
                consttrimCode=fullName.includes(".trim")?".trim()":"";
                letvalueCode=`ev.target.value${trimCode}`;
                if(fullName.includes(".number")){
                    ctx.rootContext.shouldDefineUtils=true;
                    valueCode=`utils.toNumber(${valueCode})`;
                }
                handler=`(ev)=>{${expr}=${valueCode}}`;
            }
            ctx.addLine(`extra.handlers[${key}]=extra.handlers[${key}]||(${handler});`);
            ctx.addLine(`p${nodeID}.on['${event}']=extra.handlers[${key}];`);
        },
    });
    //------------------------------------------------------------------------------
    //t-key
    //------------------------------------------------------------------------------
    QWeb.addDirective({
        name:"key",
        priority:45,
        atNodeEncounter({ctx,value,node}){
            if(ctx.loopNumber===0){
                ctx.keyStack.push(ctx.rootContext.hasKey0);
                ctx.rootContext.hasKey0=true;
            }
            ctx.addLine("{");
            ctx.indent();
            ctx.addLine(`letkey${ctx.loopNumber}=${ctx.formatExpression(value)};`);
        },
        finalize({ctx}){
            ctx.dedent();
            ctx.addLine("}");
            if(ctx.loopNumber===0){
                ctx.rootContext.hasKey0=ctx.keyStack.pop();
            }
        },
    });

    constconfig={
        translatableAttributes:TRANSLATABLE_ATTRS,
    };
    Object.defineProperty(config,"mode",{
        get(){
            returnQWeb.dev?"dev":"prod";
        },
        set(mode){
            QWeb.dev=mode==="dev";
            if(QWeb.dev){
                console.info(`Owlisrunningin'dev'mode.

Thisisnotsuitableforproductionuse.
Seehttps://github.com/flectra/owl/blob/master/doc/reference/config.md#modeformoreinformation.`);
            }
        },
    });
    Object.defineProperty(config,"enableTransitions",{
        get(){
            returnQWeb.enableTransitions;
        },
        set(value){
            QWeb.enableTransitions=value;
        },
    });

    /**
     *WedefinehereOwlEvent,asubclassofCustomEvent,withanadditional
     *attribute:
     * -originalComponent:thecomponentthattriggeredtheevent
     */
    classOwlEventextendsCustomEvent{
        constructor(component,eventType,options){
            super(eventType,options);
            this.originalComponent=component;
        }
    }

    //------------------------------------------------------------------------------
    //t-component
    //------------------------------------------------------------------------------
    constT_COMPONENT_MODS_CODE=Object.assign({},MODS_CODE,{
        self:"if(e.target!==vn.elm){return}",
    });
    QWeb.utils.defineProxy=functiondefineProxy(target,source){
        for(letkinsource){
            Object.defineProperty(target,k,{
                get(){
                    returnsource[k];
                },
                set(val){
                    source[k]=val;
                },
            });
        }
    };
    QWeb.utils.assignHooks=functionassignHooks(dataObj,hooks){
        if("hook"indataObj){
            consthookObject=dataObj.hook;
            for(letnameinhooks){
                constcurrent=hookObject[name];
                constfn=hooks[name];
                if(current){
                    hookObject[name]=(...args)=>{
                        current(...args);
                        fn(...args);
                    };
                }
                else{
                    hookObject[name]=fn;
                }
            }
        }
        else{
            dataObj.hook=hooks;
        }
    };
    /**
     *Thet-componentdirectiveiscertainlyacomplicatedandhardtomaintainpiece
     *ofcode. Tohelpyou,fellowdeveloper,ifyouhavetomaintainit,Ioffer
     *youthisadvice:Goodluck...
     *
     *Sinceitisnot'direct'code,butrathercodethatgeneratesothercode,it
     *isnoteasytounderstand. Tohelpyou,here isadetailedandcommented
     *explanationofthecodegeneratedbythet-componentdirectiveforthefollowing
     *situation:
     *```xml
     *  <Child
     *     t-key="'somestring'"
     *     flag="state.flag"
     *     t-transition="fade"/>
     *```
     *
     *```js
     *//weassignutilsontopofthefunctionbecauseitwillbeusefulfor
     *//eachcomponents
     *letutils=this.utils;
     *
     *//thisisthevirtualnoderepresentingtheparentdiv
     *letc1=[],p1={key:1};
     *varvn1=h("div",p1,c1);
     *
     *//t-componentdirective:westartbyevaluatingtheexpressiongivenbyt-key:
     *letkey5="somestring";
     *
     *//def3isthepromisethatwillcontainlatereitherthenewcomponent
     *//creation,orthepropsupdate...
     *letdef3;
     *
     *//thisiskindoftricky:weneedheretofindifthecomponentwasalready
     *//createdbyapreviousrendering. Thisisdonebycheckingtheinternal
     *//`cmap`(childrenmap)oftheparentcomponent:itmapskeystocomponentids,
     *//and,then,ifthereisanid,welookintothechildrenlisttogetthe
     *//instance
     *letw4=
     *  key5incontext.__owl__.cmap
     *  ?context.__owl__.children[context.__owl__.cmap[key5]]
     *  :false;
     *
     *//Wekeeptheindexofthepositionofthecomponentintheclosure. Wepush
     *//nulltoreservetheslot,andwillreplaceitlaterbythecomponentvnode,
     *//whenitwillbeready(donotforgetthatpreparing/renderingacomponentis
     *//asynchronous)
     *let_2_index=c1.length;
     *c1.push(null);
     *
     *//weevaluateherethepropsgiventothecomponent.Itisdoneheretobe
     *//abletoeasilyreferenceitlater,andalso,itmightbeanexpensive
     *//computation,soitiscertainlybettertodoitonlyonce
     *letprops4={flag:context["state"].flag};
     *
     *//Ifwehaveacomponent,currentlyrendering,butnotreadyyet,wedonotwant
     *//towaitforittobereadyifwecanavoidit
     *if(w4&&w4.__owl__.renderPromise&&!w4.__owl__.vnode){
     *  //wecheckifthepropsarethesame. Inthatcase,wecansimplyreuse
     *  //thepreviousrenderingandskipalluselesswork
     *  if(utils.shallowEqual(props4,w4.__owl__.renderProps)){
     *    def3=w4.__owl__.renderPromise;
     *  }else{
     *    //ifthepropsarenotthesame,wedestroythecomponentandstartsanew.
     *    //thiswillbefasterthanwaitingforitsrendering,thenupdatingit
     *    w4.destroy();
     *    w4=false;
     *  }
     *}
     *
     *if(!w4){
     *  //inthissituation,weneedtocreateanewcomponent. Firststepis
     *  //togetareferencetotheclass,thencreateaninstancewith
     *  //currentcontextasparent,andtheprops.
     *  letW4=context.component&&context.components[componentKey4]||QWeb.component[componentKey4];

     *  if(!W4){
     *    thrownewError("Cannotfindthedefinitionofcomponent'child'");
     *  }
     *  w4=newW4(owner,props4);
     *
     *  //Wheneverwererendertheparentcomponent,weneedtobesurethatwe
     *  //areabletofindthecomponentinstance.Todothat,weregisteritto
     *  //theparentcmap(childrenmap). Notethatthe'template'keyis
     *  //usedhere,sincethisiswhatidentifythecomponentfromthetemplate
     *  //perspective.
     *  context.__owl__.cmap[key5]=w4.__owl__.id;
     *
     *  //__prepareiscalled,tobasicallycallwillStart,thenrenderthe
     *  //component
     *  def3=w4.__prepare();
     *
     *  def3=def3.then(vnode=>{
     *    //wecreatehereavirtualnodefortheparent(NOTthecomponent).This
     *    //meansthatthevdomoftheparentwillbestoppedhere,andfrom
     *    //theparent'sperspective,itsimplyisavnodewithnochildren.
     *    //However,itsharesthesamedomelementwiththecomponentroot
     *    //vnode.
     *    letpvnode=h(vnode.sel,{key:key5});
     *
     *    //weaddhookstotheparentvnodesowecaninteractwiththenew
     *    //componentatthepropertime
     *    pvnode.data.hook={
     *      insert(vn){
     *        //the__mountmethodwillpatchthecomponentvdomintotheelmvn.elm,
     *        //thencallthemountedhooks.However,suprisingly,thesnabbdom
     *        //patchmethodactuallyreplacetheelmbyanewelm,soweneed
     *        //tosynchronisethepvnodeelmwiththeresultingelm
     *        letnvn=w4.__mount(vnode,vn.elm);
     *        pvnode.elm=nvn.elm;
     *        //whatfollowsisonlypresentifthereareanimationsonthecomponent
     *        utils.transitionInsert(vn,"fade");
     *      },
     *      remove(){
     *        //overridewithemptyfunctiontopreventfromremovingthenode
     *        //directly.Itwillberemovedwhendestroyiscalledanyway,which
     *        //delaystheremovalifthereareanimations.
     *      },
     *      destroy(){
     *        //ifthereareanimations,wedelaythecalltodestroyonthe
     *        //component,ifnot,wecallitdirectly.
     *        letfinalize=()=>{
     *          w4.destroy();
     *        };
     *        utils.transitionRemove(vn,"fade",finalize);
     *      }
     *    };
     *    //thepvnodeisinsertedatthecorrectpositioninthediv'schildren
     *    c1[_2_index]=pvnode;
     *
     *    //wekeephereareferencetotheparentvnode(representingthe
     *    //component,sowecanreuseitlaterwheneverweupdatethecomponent
     *    w4.__owl__.pvnode=pvnode;
     *  });
     *}else{
     *  //thisisthe'update'pathofthedirective.
     *  //thecallto__updatePropsistheactualcomponentupdate
     *  //Notethatweonlyupdatethepropsifwecannotreusetheprevious
     *  //renderingwork(inthecaseitwasrenderedwiththesameprops)
     *  def3=def3||w4.__updateProps(props4,extra.forceUpdate,extra.patchQueue);
     *  def3=def3.then(()=>{
     *    //ifcomponentwasdestroyedinthemeantime,wedonothing(so,this
     *    //meansthattheparent'selementchildrenlistwillhaveanullin
     *    //thecomponent'sposition,whichwillcausethepvnodetoberemoved
     *    //whenitispatched.
     *    if(w4.__owl__.isDestroyed){
     *      return;
     *    }
     *    //likeabove,weregisterthepvnodetothechildrenlist,soit
     *    //willnotbepatchedoutofthedom.
     *    letpvnode=w4.__owl__.pvnode;
     *    c1[_2_index]=pvnode;
     *  });
     *}
     *
     *//weregisterthedeferredheresotheparentcancoordinateitspatchoperation
     *//withallthechildren.
     *extra.promises.push(def3);
     *returnvn1;
     *```
     */
    QWeb.addDirective({
        name:"component",
        extraNames:["props"],
        priority:100,
        atNodeEncounter({ctx,value,node,qweb}){
            ctx.addLine(`//Component'${value}'`);
            ctx.rootContext.shouldDefineQWeb=true;
            ctx.rootContext.shouldDefineParent=true;
            ctx.rootContext.shouldDefineUtils=true;
            ctx.rootContext.shouldDefineScope=true;
            lethasDynamicProps=node.getAttribute("t-props")?true:false;
            //t-on-eventsandt-transition
            constevents=[];
            lettransition="";
            constattributes=node.attributes;
            constprops={};
            for(leti=0;i<attributes.length;i++){
                constname=attributes[i].name;
                constvalue=attributes[i].textContent;
                if(name.startsWith("t-on-")){
                    events.push([name,value]);
                }
                elseif(name==="t-transition"){
                    if(QWeb.enableTransitions){
                        transition=value;
                    }
                }
                elseif(!name.startsWith("t-")){
                    if(name!=="class"&&name!=="style"){
                        //thisisaprop!
                        if(value.includes("=>")){
                            props[name]=ctx.captureExpression(value);
                        }
                        else{
                            props[name]=ctx.formatExpression(value)||"undefined";
                        }
                    }
                }
            }
            //computingthepropsstringrepresentingthepropsobject
            letpropStr=Object.keys(props)
                .map((k)=>k+":"+props[k])
                .join(",");
            letcomponentID=ctx.generateID();
            lethasDefinedKey=false;
            lettemplateKey;
            if(node.tagName==="t"&&!node.hasAttribute("t-key")&&value.match(INTERP_REGEXP)){
                defineComponentKey();
                constid=ctx.generateID();
                //the___istomakesurewehavenopossibleconflictwithnormal
                //templatekeys
                ctx.addLine(`letk${id}='___'+componentKey${componentID}`);
                templateKey=`k${id}`;
            }
            else{
                templateKey=ctx.generateTemplateKey();
            }
            letref=node.getAttribute("t-ref");
            letrefExpr="";
            letrefKey="";
            if(ref){
                ctx.rootContext.shouldDefineRefs=true;
                refKey=`ref${ctx.generateID()}`;
                ctx.addLine(`const${refKey}=${ctx.interpolate(ref)};`);
                refExpr=`context.__owl__.refs[${refKey}]=w${componentID};`;
            }
            letfinalizeComponentCode=`w${componentID}.destroy();`;
            if(ref){
                finalizeComponentCode+=`deletecontext.__owl__.refs[${refKey}];`;
            }
            if(transition){
                finalizeComponentCode=`letfinalize=()=>{
          ${finalizeComponentCode}
        };
        deletew${componentID}.__owl__.transitionInserted;
        utils.transitionRemove(vn,'${transition}',finalize);`;
            }
            letcreateHook="";
            letclassAttr=node.getAttribute("class");
            lettattClass=node.getAttribute("t-att-class");
            letstyleAttr=node.getAttribute("style");
            lettattStyle=node.getAttribute("t-att-style");
            if(tattStyle){
                constattVar=`_${ctx.generateID()}`;
                ctx.addLine(`const${attVar}=${ctx.formatExpression(tattStyle)};`);
                tattStyle=attVar;
            }
            letclassObj="";
            if(classAttr||tattClass||styleAttr||tattStyle||events.length){
                if(classAttr){
                    letclassDef=classAttr
                        .trim()
                        .split(/\s+/)
                        .map((a)=>`'${a}':true`)
                        .join(",");
                    classObj=`_${ctx.generateID()}`;
                    ctx.addLine(`let${classObj}={${classDef}};`);
                }
                if(tattClass){
                    lettattExpr=ctx.formatExpression(tattClass);
                    if(tattExpr[0]!=="{"||tattExpr[tattExpr.length-1]!=="}"){
                        tattExpr=`utils.toClassObj(${tattExpr})`;
                    }
                    if(classAttr){
                        ctx.addLine(`Object.assign(${classObj},${tattExpr})`);
                    }
                    else{
                        classObj=`_${ctx.generateID()}`;
                        ctx.addLine(`let${classObj}=${tattExpr};`);
                    }
                }
                leteventsCode=events
                    .map(function([name,value]){
                    constcapture=name.match(/\.capture/);
                    name=capture?name.replace(/\.capture/,""):name;
                    const{event,handler}=makeHandlerCode(ctx,name,value,false,T_COMPONENT_MODS_CODE);
                    if(capture){
                        return`vn.elm.addEventListener('${event}',${handler},true);`;
                    }
                    return`vn.elm.addEventListener('${event}',${handler});`;
                })
                    .join("");
                conststyleExpr=tattStyle||(styleAttr?`'${styleAttr}'`:false);
                conststyleCode=styleExpr?`vn.elm.style=${styleExpr};`:"";
                createHook=`utils.assignHooks(vnode.data,{create(_,vn){${styleCode}${eventsCode}}});`;
            }
            ctx.addLine(`letw${componentID}=${templateKey}inparent.__owl__.cmap?parent.__owl__.children[parent.__owl__.cmap[${templateKey}]]:false;`);
            letshouldProxy=!ctx.parentNode;
            if(shouldProxy){
                letid=ctx.generateID();
                ctx.rootContext.rootNode=id;
                shouldProxy=true;
                ctx.rootContext.shouldDefineResult=true;
                ctx.addLine(`letvn${id}={};`);
                ctx.addLine(`result=vn${id};`);
            }
            if(hasDynamicProps){
                constdynamicProp=ctx.formatExpression(node.getAttribute("t-props"));
                ctx.addLine(`letprops${componentID}=Object.assign({},${dynamicProp},{${propStr}});`);
            }
            else{
                ctx.addLine(`letprops${componentID}={${propStr}};`);
            }
            ctx.addIf(`w${componentID}&&w${componentID}.__owl__.currentFiber&&!w${componentID}.__owl__.vnode`);
            ctx.addLine(`w${componentID}.destroy();`);
            ctx.addLine(`w${componentID}=false;`);
            ctx.closeIf();
            letregisterCode="";
            if(shouldProxy){
                registerCode=`utils.defineProxy(vn${ctx.rootNode},pvnode);`;
            }
            //SLOTS
            consthasSlots=node.childNodes.length;
            letscope=hasSlots?`utils.combine(context,scope)`:"undefined";
            ctx.addIf(`w${componentID}`);
            //needtoupdatecomponent
            letstyleCode="";
            if(tattStyle){
                styleCode=`.then(()=>{if(w${componentID}.__owl__.status===${5/*DESTROYED*/}){return};w${componentID}.el.style=${tattStyle};});`;
            }
            ctx.addLine(`w${componentID}.__updateProps(props${componentID},extra.fiber,${scope})${styleCode};`);
            ctx.addLine(`letpvnode=w${componentID}.__owl__.pvnode;`);
            if(registerCode){
                ctx.addLine(registerCode);
            }
            if(ctx.parentNode){
                ctx.addLine(`c${ctx.parentNode}.push(pvnode);`);
            }
            ctx.addElse();
            //newcomponent
            functiondefineComponentKey(){
                if(!hasDefinedKey){
                    constinterpValue=ctx.interpolate(value);
                    ctx.addLine(`letcomponentKey${componentID}=${interpValue};`);
                    hasDefinedKey=true;
                }
            }
            defineComponentKey();
            constcontextualValue=value.match(INTERP_REGEXP)?"false":ctx.formatExpression(value);
            ctx.addLine(`letW${componentID}=${contextualValue}||context.constructor.components[componentKey${componentID}]||QWeb.components[componentKey${componentID}];`);
            //maybeonlydothisindevmode...
            ctx.addLine(`if(!W${componentID}){thrownewError('Cannotfindthedefinitionofcomponent"'+componentKey${componentID}+'"')}`);
            ctx.addLine(`w${componentID}=newW${componentID}(parent,props${componentID});`);
            if(transition){
                ctx.addLine(`const__patch${componentID}=w${componentID}.__patch;`);
                ctx.addLine(`w${componentID}.__patch=(t,vn)=>{__patch${componentID}.call(w${componentID},t,vn);if(!w${componentID}.__owl__.transitionInserted){w${componentID}.__owl__.transitionInserted=true;utils.transitionInsert(w${componentID}.__owl__.vnode,'${transition}');}};`);
            }
            ctx.addLine(`parent.__owl__.cmap[${templateKey}]=w${componentID}.__owl__.id;`);
            if(hasSlots){
                constclone=node.cloneNode(true);
                //Thenextcodeisafallbackforcompatibilityreason.Itacceptst-set
                //elementsthataredirectchildrenwithanonemptybodyasnodesdefining
                //thecontentofaslot.
                //
                //Thisiswrong,butisnecessarytopreventbreakingallexistingOwl
                //codeusingslots.Thiswillberemovedinv2.0someday.Meanwhile,
                //pleaseuset-set-sloteverywhereyouneedtosetthecontentofa
                //slot.
                for(letnodeofclone.children){
                    if(node.hasAttribute("t-set")&&node.hasChildNodes()){
                        node.setAttribute("t-set-slot",node.getAttribute("t-set"));
                        node.removeAttribute("t-set");
                    }
                }
                constslotNodes=Array.from(clone.querySelectorAll("[t-set-slot]"));
                constslotNames=newSet();
                constslotId=QWeb.nextSlotId++;
                ctx.addLine(`w${componentID}.__owl__.slotId=${slotId};`);
                if(slotNodes.length){
                    for(leti=0,length=slotNodes.length;i<length;i++){
                        constslotNode=slotNodes[i];
                        //checkifthisisdefinedinasubcomponent(inwhichcaseitshould
                        //beignored)
                        letel=slotNode.parentElement;
                        letisInSubComponent=false;
                        while(el!==clone){
                            if(el.hasAttribute("t-component")||
                                el.tagName[0]===el.tagName[0].toUpperCase()){
                                isInSubComponent=true;
                                break;
                            }
                            el=el.parentElement;
                        }
                        if(isInSubComponent){
                            continue;
                        }
                        letkey=slotNode.getAttribute("t-set-slot");
                        if(slotNames.has(key)){
                            continue;
                        }
                        slotNames.add(key);
                        slotNode.removeAttribute("t-set-slot");
                        slotNode.parentElement.removeChild(slotNode);
                        constslotFn=qweb._compile(`slot_${key}_template`,{elem:slotNode,hasParent:true});
                        QWeb.slots[`${slotId}_${key}`]=slotFn;
                    }
                }
                if(clone.childNodes.length){
                    lethasContent=false;
                    constt=clone.ownerDocument.createElement("t");
                    for(letchildofObject.values(clone.childNodes)){
                        hasContent=
                            hasContent||(childinstanceofText?Boolean(child.textContent.trim().length):true);
                        t.appendChild(child);
                    }
                    if(hasContent){
                        constslotFn=qweb._compile(`slot_default_template`,{elem:t,hasParent:true});
                        QWeb.slots[`${slotId}_default`]=slotFn;
                    }
                }
            }
            ctx.addLine(`letfiber=w${componentID}.__prepare(extra.fiber,${scope},()=>{constvnode=fiber.vnode;pvnode.sel=vnode.sel;${createHook}});`);
            //hack:specifyemptyremovehooktopreventthenodefrombeingremovedfromtheDOM
            constinsertHook=refExpr?`insert(vn){${refExpr}},`:"";
            ctx.addLine(`letpvnode=h('dummy',{key:${templateKey},hook:{${insertHook}remove(){},destroy(vn){${finalizeComponentCode}}}});`);
            if(registerCode){
                ctx.addLine(registerCode);
            }
            if(ctx.parentNode){
                ctx.addLine(`c${ctx.parentNode}.push(pvnode);`);
            }
            ctx.addLine(`w${componentID}.__owl__.pvnode=pvnode;`);
            ctx.closeIf();
            if(classObj){
                ctx.addLine(`w${componentID}.__owl__.classObj=${classObj};`);
            }
            ctx.addLine(`w${componentID}.__owl__.parentLastFiberId=extra.fiber.id;`);
            returntrue;
        },
    });

    classScheduler{
        constructor(requestAnimationFrame){
            this.tasks=[];
            this.isRunning=false;
            this.requestAnimationFrame=requestAnimationFrame;
        }
        start(){
            this.isRunning=true;
            this.scheduleTasks();
        }
        stop(){
            this.isRunning=false;
        }
        addFiber(fiber){
            //ifthefiberwasremappedintoalargerrenderingfiber,itmaynotbea
            //rootfiber. Butweonlywanttoregisterrootfibers
            fiber=fiber.root;
            returnnewPromise((resolve,reject)=>{
                if(fiber.error){
                    returnreject(fiber.error);
                }
                this.tasks.push({
                    fiber,
                    callback:()=>{
                        if(fiber.error){
                            returnreject(fiber.error);
                        }
                        resolve();
                    },
                });
                if(!this.isRunning){
                    this.start();
                }
            });
        }
        rejectFiber(fiber,reason){
            fiber=fiber.root;
            constindex=this.tasks.findIndex((t)=>t.fiber===fiber);
            if(index>=0){
                const[task]=this.tasks.splice(index,1);
                fiber.cancel();
                fiber.error=newError(reason);
                task.callback();
            }
        }
        /**
         *Processallcurrenttasks.Thisonlyappliestothefibersthatareready.
         *Othertasksareleftunchanged.
         */
        flush(){
            lettasks=this.tasks;
            this.tasks=[];
            tasks=tasks.filter((task)=>{
                if(task.fiber.isCompleted){
                    task.callback();
                    returnfalse;
                }
                if(task.fiber.counter===0){
                    if(!task.fiber.error){
                        try{
                            task.fiber.complete();
                        }
                        catch(e){
                            task.fiber.handleError(e);
                        }
                    }
                    task.callback();
                    returnfalse;
                }
                returntrue;
            });
            this.tasks=tasks.concat(this.tasks);
            if(this.tasks.length===0){
                this.stop();
            }
        }
        scheduleTasks(){
            this.requestAnimationFrame(()=>{
                this.flush();
                if(this.isRunning){
                    this.scheduleTasks();
                }
            });
        }
    }
    constscheduler=newScheduler(browser.requestAnimationFrame);

    /**
     *OwlFiberClass
     *
     *Fibersaresmallabstractionsdesignedtocontainalltheinternalstate
     *associatedwitha"renderingworkunit",relativetoaspecificcomponent.
     *
     *Arenderingwillcausethecreationofafiberforeachimpactedcomponents.
     *
     *Fiberscaptureallthatnecessaryinformation,whichiscriticaltoowl
     *asynchronousrenderingpipeline.Fiberscanbecancelled,canbeindifferent
     *statesandingeneraldeterminethestateoftherendering.
     */
    classFiber{
        constructor(parent,component,force,target,position){
            this.id=Fiber.nextId++;
            //isCompletedmeansthattherenderingcorrespondingtothisfiber'sworkis
            //done,eitherbecausethecomponenthasbeenmountedorpatched,orbecause
            //fiberhasbeencancelled.
            this.isCompleted=false;
            //thefiberscorrespondingtocomponentupdates(updateProps)needtocall
            //thewillPatchandpatchedhooksfromthecorrespondingcomponent.However,
            //fiberscorrespondingtoanewcomponentdonotneedtodothat.So,the
            //shouldPatchhookisthebooleanthatwecheckwheneverweneedtoapply
            //apatch.
            this.shouldPatch=true;
            //isRenderedisthelaststateofafiber.Iftrue,thismeansthatithas
            //beenrenderedandisinert(so,itshouldnotbetakenintoaccountwhen
            //countingthenumberofactivefibers).
            this.isRendered=false;
            //thecounternumberisacriticalinformation.Itisonlynecessaryfora
            //rootfiber. Forthatfiber,thisnumbercountsthenumberofactivesub
            //fibers. Whenthatnumberreaches0,thefibercanbeappliedbythe
            //scheduler.
            this.counter=0;
            this.vnode=null;
            this.child=null;
            this.sibling=null;
            this.lastChild=null;
            this.parent=null;
            this.component=component;
            this.force=force;
            this.target=target;
            this.position=position;
            const__owl__=component.__owl__;
            this.scope=__owl__.scope;
            this.root=parent?parent.root:this;
            this.parent=parent;
            letoldFiber=__owl__.currentFiber;
            if(oldFiber&&!oldFiber.isCompleted){
                this.force=true;
                if(oldFiber.root===oldFiber&&!parent){
                    //botholdFiberandthisfiberarerootfibers
                    this._reuseFiber(oldFiber);
                    returnoldFiber;
                }
                else{
                    this._remapFiber(oldFiber);
                }
            }
            this.root.counter++;
            __owl__.currentFiber=this;
        }
        /**
         *WhentheoldFiberisnotcompletedyet,andbotholdFiberandthisfiber
         *arerootfibers,wewanttoreusetheoldFiberinsteadofcreatinganew
         *one.Doingsowillguaranteethattheinitiator(s)ofthoserenderingswill
         *benotified(thepromisewillresolve)whenthelastrenderingwillbedone.
         *
         *ThisfunctionthusassumesthatoldFiberisarootfiber.
         */
        _reuseFiber(oldFiber){
            oldFiber.cancel();//cancelchildrenfibers
            oldFiber.target=this.target||oldFiber.target;
            oldFiber.position=this.position||oldFiber.position;
            oldFiber.isCompleted=false;//keeptherootfiberalive
            oldFiber.isRendered=false;//thefiberhastobere-rendered
            if(oldFiber.child){
                //removerelationtochildren
                oldFiber.child.parent=null;
                oldFiber.child=null;
                oldFiber.lastChild=null;
            }
            oldFiber.counter=1;//re-initializecounter
            oldFiber.id=Fiber.nextId++;
        }
        /**
         *Insomecases,arenderinginitiatedatsomecomponentcandetectthatit
         *shouldbepartofalargerrenderinginitiatedsomewhereupthecomponent
         *tree. Inthatcase,itneedstocancelthepreviousrenderingand
         *remapitselfasapartofthecurrentparentrendering.
         */
        _remapFiber(oldFiber){
            oldFiber.cancel();
            this.shouldPatch=oldFiber.shouldPatch;
            if(oldFiber===oldFiber.root){
                oldFiber.counter++;
            }
            if(oldFiber.parent&&!this.parent){
                //re-maplinks
                this.parent=oldFiber.parent;
                this.root=this.parent.root;
                this.sibling=oldFiber.sibling;
                if(this.parent.lastChild===oldFiber){
                    this.parent.lastChild=this;
                }
                if(this.parent.child===oldFiber){
                    this.parent.child=this;
                }
                else{
                    letcurrent=this.parent.child;
                    while(true){
                        if(current.sibling===oldFiber){
                            current.sibling=this;
                            break;
                        }
                        current=current.sibling;
                    }
                }
            }
        }
        /**
         *Thisfunctionhasbeentakenfrom
         *https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7
         */
        _walk(doWork){
            letroot=this;
            letcurrent=this;
            while(true){
                constchild=doWork(current);
                if(child){
                    current=child;
                    continue;
                }
                if(current===root){
                    return;
                }
                while(!current.sibling){
                    if(!current.parent||current.parent===root){
                        return;
                    }
                    current=current.parent;
                }
                current=current.sibling;
            }
        }
        /**
         *Successfullycompletetheworkofthefiber:callthemountorpatchhooks
         *andpatchtheDOM.Thisfunctioniscalledoncethefiberanditschildren
         *areready,andtheschedulerdecidestoprocessit.
         */
        complete(){
            letcomponent=this.component;
            this.isCompleted=true;
            conststatus=component.__owl__.status;
            if(status===5/*DESTROYED*/){
                return;
            }
            //buildpatchQueue
            constpatchQueue=[];
            constdoWork=function(f){
                f.component.__owl__.currentFiber=null;
                patchQueue.push(f);
                returnf.child;
            };
            this._walk(doWork);
            constpatchLen=patchQueue.length;
            //callwillPatchhookoneachfiberofpatchQueue
            if(status===3/*MOUNTED*/){
                for(leti=0;i<patchLen;i++){
                    constfiber=patchQueue[i];
                    if(fiber.shouldPatch){
                        component=fiber.component;
                        if(component.__owl__.willPatchCB){
                            component.__owl__.willPatchCB();
                        }
                        component.willPatch();
                    }
                }
            }
            //call__patchoneachfiberof(reversed)patchQueue
            for(leti=patchLen-1;i>=0;i--){
                constfiber=patchQueue[i];
                component=fiber.component;
                if(fiber.target&&i===0){
                    lettarget;
                    if(fiber.position==="self"){
                        target=fiber.target;
                        if(target.tagName.toLowerCase()!==fiber.vnode.sel){
                            thrownewError(`Cannotattach'${component.constructor.name}'totargetnode(notsametagname)`);
                        }
                        //Inselfmode,we*know*wearetotakepossessionofthetarget
                        //HencewemanuallycreatethecorrespondingVNodeandcopythe"key"indata
                        constselfVnodeData=fiber.vnode.data?{key:fiber.vnode.data.key}:{};
                        constselfVnode=h(fiber.vnode.sel,selfVnodeData);
                        selfVnode.elm=target;
                        target=selfVnode;
                    }
                    else{
                        target=component.__owl__.vnode||document.createElement(fiber.vnode.sel);
                    }
                    component.__patch(target,fiber.vnode);
                }
                else{
                    constvnode=component.__owl__.vnode;
                    if(fiber.shouldPatch&&vnode){
                        component.__patch(vnode,fiber.vnode);
                        //WhenupdatingaComponent'sprops(indirective),
                        //thecomponenthasapvnodeANDshouldbepatched.
                        //However,itspvnode.elmmayhavechangedifitisaHighOrderComponent
                        if(component.__owl__.pvnode){
                            component.__owl__.pvnode.elm=component.__owl__.vnode.elm;
                        }
                    }
                    else{
                        component.__patch(document.createElement(fiber.vnode.sel),fiber.vnode);
                        component.__owl__.pvnode.elm=component.__owl__.vnode.elm;
                    }
                }
            }
            //insertintotheDOM(mountcase)
            letinDOM=false;
            if(this.target){
                switch(this.position){
                    case"first-child":
                        this.target.prepend(this.component.el);
                        break;
                    case"last-child":
                        this.target.appendChild(this.component.el);
                        break;
                }
                inDOM=document.body.contains(this.component.el);
                this.component.env.qweb.trigger("dom-appended");
            }
            //callpatched/mountedhookoneachfiberof(reversed)patchQueue
            if(status===3/*MOUNTED*/||inDOM){
                for(leti=patchLen-1;i>=0;i--){
                    constfiber=patchQueue[i];
                    component=fiber.component;
                    if(fiber.shouldPatch&&!this.target){
                        component.patched();
                        if(component.__owl__.patchedCB){
                            component.__owl__.patchedCB();
                        }
                    }
                    else{
                        component.__callMounted();
                    }
                }
            }
            else{
                for(leti=patchLen-1;i>=0;i--){
                    constfiber=patchQueue[i];
                    component=fiber.component;
                    component.__owl__.status=4/*UNMOUNTED*/;
                }
            }
        }
        /**
         *Cancelafiberandallitschildren.
         */
        cancel(){
            this._walk((f)=>{
                if(!f.isRendered){
                    f.root.counter--;
                }
                f.isCompleted=true;
                returnf.child;
            });
        }
        /**
         *ThisistheglobalerrorhandlerforerrorsoccurringinOwlmainlifecycle
         *methods. CaughterrorsaretriggeredontheQWebinstance,andare
         *potentiallygiventosomeparentcomponentwhichimplements`catchError`.
         *
         *Iftherearenosuchcomponent,wedestroyeverything.Thisisbetterthan
         *beinginacorruptedstate.
         */
        handleError(error){
            letcomponent=this.component;
            this.vnode=component.__owl__.vnode||h("div");
            constqweb=component.env.qweb;
            letroot=component;
            functionhandle(error){
                letcanCatch=false;
                qweb.trigger("error",error);
                while(component&&!(canCatch=!!component.catchError)){
                    root=component;
                    component=component.__owl__.parent;
                }
                if(canCatch){
                    try{
                        component.catchError(error);
                    }
                    catch(e){
                        root=component;
                        component=component.__owl__.parent;
                        returnhandle(e);
                    }
                    returntrue;
                }
                returnfalse;
            }
            letisHandled=handle(error);
            if(!isHandled){
                //the3nextlinesaimtomarktherootfiberasbeinginerror,and
                //toforceittoend,withoutwaitingforitschildren
                this.root.counter=0;
                this.root.error=error;
                scheduler.flush();
                //atthispoint,thestateoftheapplicationiscorruptedandwecould
                //havealotofissuesorcrashes.Sowedestroytheapplicationinatry
                //catchandswallowtheseerrorsbecausethefiberisalreadyinerror,
                //andthisistheactualissuethatneedstobesolved,notthosefollowup
                //errors.
                try{
                    root.destroy();
                }
                catch(e){}
            }
        }
    }
    Fiber.nextId=1;

    //------------------------------------------------------------------------------
    //Propvalidationhelper
    //------------------------------------------------------------------------------
    /**
     *Validatethecomponentprops(ornextprops)againstthe(static)props
     *description. Thisispotentiallyanexpensiveoperation:itmayneedsto
     *visitrecursivelythepropsandallthechildrentocheckiftheyarevalid.
     *Thisiswhyitisonlydonein'dev'mode.
     */
    QWeb.utils.validateProps=function(Widget,props){
        constpropsDef=Widget.props;
        if(propsDefinstanceofArray){
            //listofstrings(propnames)
            for(leti=0,l=propsDef.length;i<l;i++){
                constpropName=propsDef[i];
                if(propName[propName.length-1]==="?"){
                    //optionalprop
                    break;
                }
                if(!(propNameinprops)){
                    thrownewError(`Missingprops'${propsDef[i]}'(component'${Widget.name}')`);
                }
            }
            for(letkeyinprops){
                if(!propsDef.includes(key)&&!propsDef.includes(key+"?")){
                    thrownewError(`Unknownprop'${key}'giventocomponent'${Widget.name}'`);
                }
            }
        }
        elseif(propsDef){
            //propsDefisanobjectnow
            for(letpropNameinpropsDef){
                if(props[propName]===undefined){
                    if(propsDef[propName]&&!propsDef[propName].optional){
                        thrownewError(`Missingprops'${propName}'(component'${Widget.name}')`);
                    }
                    else{
                        continue;
                    }
                }
                letwhyInvalid;
                try{
                    whyInvalid=whyInvalidProp(props[propName],propsDef[propName]);
                }
                catch(e){
                    e.message=`Invalidprop'${propName}'incomponent${Widget.name}(${e.message})`;
                    throwe;
                }
                if(whyInvalid!==null){
                    whyInvalid=whyInvalid.replace(/\${propName}/g,propName);
                    thrownewError(`InvalidProp'${propName}'incomponent'${Widget.name}':${whyInvalid}`);
                }
            }
            for(letpropNameinprops){
                if(!(propNameinpropsDef)){
                    thrownewError(`Unknownprop'${propName}'giventocomponent'${Widget.name}'`);
                }
            }
        }
    };
    /**
     *Checkwhyaninvidualpropvaluedoesn'tmatchits(static)propdefinition
     */
    functionwhyInvalidProp(prop,propDef){
        if(propDef===true){
            returnnull;
        }
        if(typeofpropDef==="function"){
            //CheckifavalueisconstructedbysomeConstructor. Notethatthereisa
            //slightabuseoflanguage:wewanttoconsiderprimitivevaluesaswell.
            //
            //So,eventhough1isnotaninstanceofNumber,wewanttoconsiderthat
            //itisvalid.
            if(typeofprop==="object"){
                if(propinstanceofpropDef){
                    returnnull;
                }
                return`\${propName}isnotaninstanceof${propDef.name}`;
            }
            if(typeofprop===propDef.name.toLowerCase()){
                returnnull;
            }
            return`typeof\${propName}isnot${propDef.name}`;
        }
        elseif(propDefinstanceofArray){
            //Ifthiscodeisexecuted,thismeansthatwewanttocheckifaprop
            //matchesatleastoneofitsdescriptor.
            letreasons=[];
            for(leti=0,iLen=propDef.length;i<iLen;i++){
                constwhy=whyInvalidProp(prop,propDef[i]);
                if(why===null){
                    returnnull;
                }
                reasons.push(why);
            }
            if(reasons.length>1){
                returnreasons.slice(0,-1).join(",")+"and"+reasons[reasons.length-1];
            }
            else{
                returnreasons[0];
            }
        }
        //propsDefisanobject
        if(propDef.optional&&prop===undefined){
            returnnull;
        }
        if(propDef.type){
            constwhy=whyInvalidProp(prop,propDef.type);
            if(why!==null){
                returnwhy;
            }
        }
        if(propDef.validate&&!propDef.validate(prop)){
            return"${propName}couldnotbevalidatedby`validate`function";
        }
        if(propDef.type===Array&&propDef.element){
            for(leti=0,iLen=prop.length;i<iLen;i++){
                constwhy=whyInvalidProp(prop[i],propDef.element);
                if(why!==null){
                    returnwhy.replace(/\${propName}/g,`\${propName}[${i}]`);
                }
            }
        }
        if(propDef.type===Object&&propDef.shape){
            constshape=propDef.shape;
            for(letkeyinshape){
                constwhy=whyInvalidProp(prop[key],shape[key]);
                if(why!==null){
                    returnwhy.replace(/\${propName}/g,`\${propName}['${key}']`);
                }
            }
            for(letpropNameinprop){
                if(!(propNameinshape)){
                    return`unknownprop\${propName}['${propName}']`;
                }
            }
        }
        returnnull;
    }

    /**
     *OwlStyleSystem
     *
     *ThisfilescontainstheOwlcoderelatedtoprocessing(extended)cssstrings
     *andcreating/adding<style>tagstothedocumenthead.
     */
    constSTYLESHEETS={};
    functionprocessSheet(str){
        consttokens=str.split(/(\{|\}|;)/).map((s)=>s.trim());
        constselectorStack=[];
        constparts=[];
        letrules=[];
        functiongenerateSelector(stackIndex,parentSelector){
            constparts=[];
            for(constselectorofselectorStack[stackIndex]){
                letpart=(parentSelector&&parentSelector+""+selector)||selector;
                if(part.includes("&")){
                    part=selector.replace(/&/g,parentSelector||"");
                }
                if(stackIndex<selectorStack.length-1){
                    part=generateSelector(stackIndex+1,part);
                }
                parts.push(part);
            }
            returnparts.join(",");
        }
        functiongenerateRules(){
            if(rules.length){
                parts.push(generateSelector(0)+"{");
                parts.push(...rules);
                parts.push("}");
                rules=[];
            }
        }
        while(tokens.length){
            lettoken=tokens.shift();
            if(token==="}"){
                generateRules();
                selectorStack.pop();
            }
            else{
                if(tokens[0]==="{"){
                    generateRules();
                    selectorStack.push(token.split(/\s*,\s*/));
                    tokens.shift();
                }
                if(tokens[0]===";"){
                    rules.push(" "+token+";");
                }
            }
        }
        returnparts.join("\n");
    }
    functionregisterSheet(id,css){
        constsheet=document.createElement("style");
        sheet.innerHTML=processSheet(css);
        STYLESHEETS[id]=sheet;
    }
    functionactivateSheet(id,name){
        constsheet=STYLESHEETS[id];
        if(!sheet){
            thrownewError(`Invalidcssstylesheetforcomponent'${name}'.Didyouforgettousethe'css'taghelper?`);
        }
        sheet.setAttribute("component",name);
        document.head.appendChild(sheet);
    }

    varSTATUS;
    (function(STATUS){
        STATUS[STATUS["CREATED"]=0]="CREATED";
        STATUS[STATUS["WILLSTARTED"]=1]="WILLSTARTED";
        STATUS[STATUS["RENDERED"]=2]="RENDERED";
        STATUS[STATUS["MOUNTED"]=3]="MOUNTED";
        STATUS[STATUS["UNMOUNTED"]=4]="UNMOUNTED";
        STATUS[STATUS["DESTROYED"]=5]="DESTROYED";
    })(STATUS||(STATUS={}));
    constportalSymbol=Symbol("portal");//FIXME
    //------------------------------------------------------------------------------
    //Component
    //------------------------------------------------------------------------------
    letnextId=1;
    classComponent{
        //--------------------------------------------------------------------------
        //Lifecycle
        //--------------------------------------------------------------------------
        /**
         *CreatesaninstanceofComponent.
         *
         *Notethatmostofthetime,onlytherootcomponentneedstobecreatedby
         *hand. Othercomponentsshouldbecreatedautomaticallybytheframework(with
         *thet-componentdirectiveinatemplate)
         */
        constructor(parent,props){
            Component.current=this;
            letconstr=this.constructor;
            constdefaultProps=constr.defaultProps;
            if(defaultProps){
                props=props||{};
                this.__applyDefaultProps(props,defaultProps);
            }
            this.props=props;
            if(QWeb.dev){
                QWeb.utils.validateProps(constr,this.props);
            }
            constid=nextId++;
            letdepth;
            if(parent){
                this.env=parent.env;
                const__powl__=parent.__owl__;
                __powl__.children[id]=this;
                depth=__powl__.depth+1;
            }
            else{
                //wearetherootcomponent
                this.env=this.constructor.env;
                if(!this.env.qweb){
                    this.env.qweb=newQWeb();
                }
                //TODO:removethisinowl2.0
                if(!this.env.browser){
                    this.env.browser=browser;
                }
                this.env.qweb.on("update",this,()=>{
                    switch(this.__owl__.status){
                        case3/*MOUNTED*/:
                            this.render(true);
                            break;
                        case5/*DESTROYED*/:
                            //thisisunlikelytohappen,butifarootwidgetisdestroyed,
                            //wewanttoremoveoursubscription. Theusualwaytodothat
                            //wouldbetoperformsomecheckinthedestroymethod,butsince
                            //itisveryperformancesensitive,andsincethisisarareevent,
                            //wesimplydoitlazily
                            this.env.qweb.off("update",this);
                            break;
                    }
                });
                depth=0;
            }
            constqweb=this.env.qweb;
            consttemplate=constr.template||this.__getTemplate(qweb);
            this.__owl__={
                id:id,
                depth:depth,
                vnode:null,
                pvnode:null,
                status:0/*CREATED*/,
                parent:parent||null,
                children:{},
                cmap:{},
                currentFiber:null,
                parentLastFiberId:0,
                boundHandlers:{},
                mountedCB:null,
                willUnmountCB:null,
                willPatchCB:null,
                patchedCB:null,
                willStartCB:null,
                willUpdatePropsCB:null,
                observer:null,
                renderFn:qweb.render.bind(qweb,template),
                classObj:null,
                refs:null,
                scope:null,
            };
            if(constr.style){
                this.__applyStyles(constr);
            }
            this.setup();
        }
        /**
         *The`el`istherootelementofthecomponent. Notethatitcouldbenull:
         *thisisthecaseifthecomponentisnotmountedyet,orisdestroyed.
         */
        getel(){
            returnthis.__owl__.vnode?this.__owl__.vnode.elm:null;
        }
        /**
         *setupisrunjustafterthecomponentisconstructed.Thisisthestandard
         *locationwherethecomponentcansetupitshooks.Ithassomeadvantages
         *overtheconstructor:
         * -itcanbepatched(usefulinflectraecosystem)
         * -itdoesnotneedtopropagatetheargumentstothesupercall
         *
         *Note:thismethodshouldnotbecalledmanually.
         */
        setup(){}
        /**
         *willStartisanasynchronoushookthatcanbeimplementedtoperformsome
         *actionbeforetheinitialrenderingofacomponent.
         *
         *Itwillbecalledexactlyoncebeforetheinitialrendering.Itisuseful
         *insomecases,forexample,toloadexternalassets(suchasaJSlibrary)
         *beforethecomponentisrendered.
         *
         *NotethataslowwillStartmethodwillslowdowntherenderingoftheuser
         *interface. Therefore,someeffortshouldbemadetomakethismethodas
         *fastaspossible.
         *
         *Note:thismethodshouldnotbecalledmanually.
         */
        asyncwillStart(){}
        /**
         *mountedisahookthatiscalledeachtimeacomponentisattachedtothe
         *DOM.Thisisagoodplacetoaddsomelisteners,ortointeractwiththe
         *DOM,ifthecomponentneedstoperformsomemeasureforexample.
         *
         *Note:thismethodshouldnotbecalledmanually.
         *
         *@seewillUnmount
         */
        mounted(){}
        /**
         *ThewillUpdatePropsisanasynchronoushook,calledjustbeforenewprops
         *areset.Thisisusefulifthecomponentneedssomeasynchronoustask
         *performed,dependingontheprops(forexample,assumingthatthepropsare
         *somerecordId,fetchingtherecorddata).
         *
         *Thishookisnotcalledduringthefirstrender(butwillStartiscalled
         *andperformsasimilarjob).
         */
        asyncwillUpdateProps(nextProps){}
        /**
         *ThewillPatchhookiscalledjustbeforetheDOMpatchingprocessstarts.
         *Itisnotcalledontheinitialrender. Thisisusefultogetsome
         *informationwhichareintheDOM. Forexample,thecurrentpositionofthe
         *scrollbar
         */
        willPatch(){}
        /**
         *Thishookiscalledwheneveracomponentdidactuallyupdateitsprops,
         *stateorenv.
         *
         *Thismethodisnotcalledontheinitialrender.Itisusefultointeract
         *withtheDOM(forexample,throughanexternallibrary)wheneverthe
         *componentwasupdated.
         *
         *Updatingthecomponentstateinthishookispossible,butnotencouraged.
         *Oneneedtobecareful,becauseupdatesherewillcausererender,whichin
         *turnwillcauseothercallstoupdated.So,weneedtobeparticularly
         *carefulatavoidingendlesscycles.
         */
        patched(){}
        /**
         *willUnmountisahookthatiscalledeachtimejustbeforeacomponentis
         *unmountedfromtheDOM.Thisisagoodplacetoremovesomelisteners,for
         *example.
         *
         *Note:thismethodshouldnotbecalledmanually.
         *
         *@seemounted
         */
        willUnmount(){}
        //--------------------------------------------------------------------------
        //Public
        //--------------------------------------------------------------------------
        /**
         *Mountthecomponenttoatargetelement.
         *
         *Thisshouldonlybedoneifthecomponentwascreatedmanually.Components
         *createddeclarativelyintemplatesaremanagedbytheOwlsystem.
         *
         *Notethatacomponentcanbemountedanunmountedseveraltimes
         */
        asyncmount(target,options={}){
            if(!(targetinstanceofHTMLElement||targetinstanceofDocumentFragment)){
                letmessage=`Component'${this.constructor.name}'cannotbemounted:thetargetisnotavalidDOMnode.`;
                message+=`\nMaybetheDOMisnotreadyyet?(inthatcase,youcanuseowl.utils.whenReady)`;
                thrownewError(message);
            }
            constposition=options.position||"last-child";
            const__owl__=this.__owl__;
            constcurrentFiber=__owl__.currentFiber;
            switch(__owl__.status){
                case0/*CREATED*/:{
                    constfiber=newFiber(null,this,true,target,position);
                    fiber.shouldPatch=false;
                    this.__prepareAndRender(fiber,()=>{});
                    returnscheduler.addFiber(fiber);
                }
                case1/*WILLSTARTED*/:
                case2/*RENDERED*/:
                    currentFiber.target=target;
                    currentFiber.position=position;
                    returnscheduler.addFiber(currentFiber);
                case4/*UNMOUNTED*/:{
                    constfiber=newFiber(null,this,true,target,position);
                    fiber.shouldPatch=false;
                    this.__render(fiber);
                    returnscheduler.addFiber(fiber);
                }
                case3/*MOUNTED*/:{
                    if(position!=="self"&&this.el.parentNode!==target){
                        constfiber=newFiber(null,this,true,target,position);
                        fiber.shouldPatch=false;
                        this.__render(fiber);
                        returnscheduler.addFiber(fiber);
                    }
                    else{
                        returnPromise.resolve();
                    }
                }
                case5/*DESTROYED*/:
                    thrownewError("Cannotmountadestroyedcomponent");
            }
        }
        /**
         *Theunmountmethodistheoppositeofthemountmethod. Itisuseful
         *tocallwillUnmountcallsandremovethecomponentfromtheDOM.
         */
        unmount(){
            if(this.__owl__.status===3/*MOUNTED*/){
                this.__callWillUnmount();
                this.el.remove();
            }
        }
        /**
         *Therendermethodisthemainentrypointtorenderacomponent(onceit
         *isready.Thismethodisnotinitiallycalledwhenthecomponentis
         *renderedthefirsttime).
         *
         *Thismethodwillcauseallitssubcomponentstopotentiallyrerender
         *themselves. Notethat`render`isnotcalledifacomponentisupdatedvia
         *itsprops.
         */
        asyncrender(force=false){
            const__owl__=this.__owl__;
            constcurrentFiber=__owl__.currentFiber;
            if(!__owl__.vnode&&!currentFiber){
                return;
            }
            if(currentFiber&&!currentFiber.isRendered&&!currentFiber.isCompleted){
                returnscheduler.addFiber(currentFiber.root);
            }
            //ifwearen'tmountedatthispoint,itimpliesthatthereisa
            //currentFiberthatisalreadyrendered(isRenderedistrue),soweare
            //abouttobemounted
            conststatus=__owl__.status;
            constfiber=newFiber(null,this,force,null,null);
            Promise.resolve().then(()=>{
                if(__owl__.status===3/*MOUNTED*/||status!==3/*MOUNTED*/){
                    if(fiber.isCompleted||fiber.isRendered){
                        return;
                    }
                    this.__render(fiber);
                }
                else{
                    //weweremountedwhenrenderwascalled,butwearen'tanymore,sowe
                    //wereactuallyabouttobeunmounted;wecanthusforgetaboutthis
                    //fiber
                    fiber.isCompleted=true;
                    __owl__.currentFiber=null;
                }
            });
            returnscheduler.addFiber(fiber);
        }
        /**
         *Destroythecomponent. Thisoperationisquitecomplex:
         * -itrecursivelydestroyallchildren
         * -callthewillUnmounthooksifnecessary
         * -removethedomnodefromthedom
         *
         *Thisshouldonlybecalledmanuallyifyoucreatedthecomponent. Most
         *componentswillbeautomaticallydestroyed.
         */
        destroy(){
            const__owl__=this.__owl__;
            if(__owl__.status!==5/*DESTROYED*/){
                constel=this.el;
                this.__destroy(__owl__.parent);
                if(el){
                    el.remove();
                }
            }
        }
        /**
         *Thismethodiscalledbythecomponentsystemwheneveritspropsare
         *updated.Ifitreturnstrue,thenthecomponentwillberendered.
         *Otherwise,itwillskiptherendering(also,itspropswillnotbeupdated)
         */
        shouldUpdate(nextProps){
            returntrue;
        }
        /**
         *Emitacustomeventoftype'eventType'withthegiven'payload'onthe
         *component'sel,ifitexists.However,notethattheeventwillonlybubble
         *uptotheparentDOMnodes.Thus,itmustbecalledbetweenmounted()and
         *willUnmount().
         */
        trigger(eventType,payload){
            this.__trigger(this,eventType,payload);
        }
        //--------------------------------------------------------------------------
        //Private
        //--------------------------------------------------------------------------
        /**
         *Privatehelpertoperformafulldestroy,fromthepointofviewofanOwl
         *component.Itdoesnotremovetheel(thisisdoneonlyonceonthetop
         *leveldestroyedcomponent,forperformancereasons).
         *
         *ThejobofthismethodismostlytocallwillUnmounthooks,andtoperform
         *allnecessaryinternalcleanup.
         *
         *Notethatitdoesnotcallthe__callWillUnmountmethodtoavoidvisiting
         *allchildrenmanytimes.
         */
        __destroy(parent){
            const__owl__=this.__owl__;
            if(__owl__.status===3/*MOUNTED*/){
                if(__owl__.willUnmountCB){
                    __owl__.willUnmountCB();
                }
                this.willUnmount();
                __owl__.status=4/*UNMOUNTED*/;
            }
            constchildren=__owl__.children;
            for(letkeyinchildren){
                children[key].__destroy(this);
            }
            if(parent){
                letid=__owl__.id;
                deleteparent.__owl__.children[id];
                __owl__.parent=null;
            }
            __owl__.status=5/*DESTROYED*/;
            delete__owl__.vnode;
            if(__owl__.currentFiber){
                __owl__.currentFiber.isCompleted=true;
            }
        }
        __callMounted(){
            const__owl__=this.__owl__;
            __owl__.status=3/*MOUNTED*/;
            this.mounted();
            if(__owl__.mountedCB){
                __owl__.mountedCB();
            }
        }
        __callWillUnmount(){
            const__owl__=this.__owl__;
            if(__owl__.willUnmountCB){
                __owl__.willUnmountCB();
            }
            this.willUnmount();
            __owl__.status=4/*UNMOUNTED*/;
            if(__owl__.currentFiber){
                __owl__.currentFiber.isCompleted=true;
                __owl__.currentFiber.root.counter=0;
            }
            constchildren=__owl__.children;
            for(letidinchildren){
                constcomp=children[id];
                if(comp.__owl__.status===3/*MOUNTED*/){
                    comp.__callWillUnmount();
                }
            }
        }
        /**
         *Privatetriggermethod,allowstochoosethecomponentwhichtriggered
         *theeventinthefirstplace
         */
        __trigger(component,eventType,payload){
            if(this.el){
                constev=newOwlEvent(component,eventType,{
                    bubbles:true,
                    cancelable:true,
                    detail:payload,
                });
                consttriggerHook=this.env[portalSymbol];
                if(triggerHook){
                    triggerHook(ev);
                }
                this.el.dispatchEvent(ev);
            }
        }
        /**
         *The__updatePropsmethodiscalledbythet-componentdirectivewhenever
         *itupdatesacomponent(so,whentheparenttemplateisrerendered).
         */
        async__updateProps(nextProps,parentFiber,scope){
            this.__owl__.scope=scope;
            constshouldUpdate=parentFiber.force||this.shouldUpdate(nextProps);
            if(shouldUpdate){
                const__owl__=this.__owl__;
                constfiber=newFiber(parentFiber,this,parentFiber.force,null,null);
                if(!parentFiber.child){
                    parentFiber.child=fiber;
                }
                else{
                    parentFiber.lastChild.sibling=fiber;
                }
                parentFiber.lastChild=fiber;
                constdefaultProps=this.constructor.defaultProps;
                if(defaultProps){
                    this.__applyDefaultProps(nextProps,defaultProps);
                }
                if(QWeb.dev){
                    QWeb.utils.validateProps(this.constructor,nextProps);
                }
                awaitPromise.all([
                    this.willUpdateProps(nextProps),
                    __owl__.willUpdatePropsCB&&__owl__.willUpdatePropsCB(nextProps),
                ]);
                if(fiber.isCompleted){
                    return;
                }
                this.props=nextProps;
                this.__render(fiber);
            }
        }
        /**
         *Mainpatchingmethod.Wecallthevirtualdompatchmethodheretoconvert
         *avirtualdomvnodeintosomeactualdom.
         */
        __patch(target,vnode){
            this.__owl__.vnode=patch(target,vnode);
        }
        /**
         *The__preparemethodisonlycalledbythet-componentdirective,whena
         *subcomponentiscreated.Itgetsitsscope,ifany,fromthe
         *parenttemplate.
         */
        __prepare(parentFiber,scope,cb){
            this.__owl__.scope=scope;
            constfiber=newFiber(parentFiber,this,parentFiber.force,null,null);
            fiber.shouldPatch=false;
            if(!parentFiber.child){
                parentFiber.child=fiber;
            }
            else{
                parentFiber.lastChild.sibling=fiber;
            }
            parentFiber.lastChild=fiber;
            this.__prepareAndRender(fiber,cb);
            returnfiber;
        }
        /**
         *Applythestylesheetsdefinedbythecomponent.Notethatweneedtomake
         *sureallinheritedstylesheetsareappliedaswell. Wethendeletethe
         *`style`keyfromtheconstructortomakesurewedonotapplyitagain.
         */
        __applyStyles(constr){
            while(constr&&constr.style){
                if(constr.hasOwnProperty("style")){
                    activateSheet(constr.style,constr.name);
                    deleteconstr.style;
                }
                constr=constr.__proto__;
            }
        }
        __getTemplate(qweb){
            letp=this.constructor;
            if(!p.hasOwnProperty("_template")){
                //here,thecomponentandnoneofitssuperclassesdefinesastatic`template`
                //key.Sowefallbackonlookingforatemplatematchingitsname(or
                //oneofitssubclass).
                lettemplate=p.name;
                while(!(templateinqweb.templates)&&p!==Component){
                    p=p.__proto__;
                    template=p.name;
                }
                if(p===Component){
                    thrownewError(`Couldnotfindtemplateforcomponent"${this.constructor.name}"`);
                }
                else{
                    p._template=template;
                }
            }
            returnp._template;
        }
        async__prepareAndRender(fiber,cb){
            try{
                constproms=Promise.all([
                    this.willStart(),
                    this.__owl__.willStartCB&&this.__owl__.willStartCB(),
                ]);
                this.__owl__.status=1/*WILLSTARTED*/;
                awaitproms;
                if(this.__owl__.status===5/*DESTROYED*/){
                    returnPromise.resolve();
                }
            }
            catch(e){
                fiber.handleError(e);
                returnPromise.resolve();
            }
            if(!fiber.isCompleted){
                this.__render(fiber);
                this.__owl__.status=2/*RENDERED*/;
                cb();
            }
        }
        __render(fiber){
            const__owl__=this.__owl__;
            if(__owl__.observer){
                __owl__.observer.allowMutations=false;
            }
            leterror;
            try{
                letvnode=__owl__.renderFn(this,{
                    handlers:__owl__.boundHandlers,
                    fiber:fiber,
                });
                //weiterateoverthechildrentodetectthosethatnolongerbelongtothe
                //currentrendering:thoseones,ifnotmountedyet,can(andhaveto)be
                //destroyedrightnow,becausetheyarenotintheDOM,andthuswewon't
                //benotifiedlateron(whenpatching),thattheyareremovedfromtheDOM
                for(letchildKeyin__owl__.children){
                    constchild=__owl__.children[childKey];
                    constchildOwl=child.__owl__;
                    if(childOwl.status!==3/*MOUNTED*/&&childOwl.parentLastFiberId<fiber.id){
                        //weonlydoherea"soft"destroy,meaningthatweleavethechild
                        //domnodealone,withoutremovingit. Mostofthetime,itdoesnot
                        //matter,becausethechildcomponentisalreadyunmounted. However,
                        //ifsomeofitsparenthavebeenunmounted,thechildcouldactually
                        //stillbeattachedtoitsparent,andthismaybeimportantifwe
                        //wanttoremounttheparent,becausethevdomneedtomatchthe
                        //actualDOM
                        child.__destroy(childOwl.parent);
                        if(childOwl.pvnode){
                            //weremovethekeyheretomakesurethatthepatchingalgorithm
                            //isabletomakethedifferencebetweenthispvnodeandaneventual
                            //otherinstanceofthesamecomponent
                            deletechildOwl.pvnode.key;
                            //Sincethecomponenthasbeenunmounted,wedonotwanttoactually
                            //callaremovehook. Thisisprettyimportant,sincethet-component
                            //directiveactuallydisabledit,sothevdomalgorithmwilljust
                            //notremovethechildelmifwedon'tremovethehook.
                            deletechildOwl.pvnode.data.hook.remove;
                        }
                    }
                }
                if(!vnode){
                    thrownewError(`Rendering'${this.constructor.name}'didnotreturnanything`);
                }
                fiber.vnode=vnode;
                //weapplyheretheclassinformationdescribedonthecomponentbythe
                //template(so,somethinglike<MyComponentclass="..."/>)totheactual
                //rootvnode
                if(__owl__.classObj){
                    constdata=vnode.data;
                    data.class=Object.assign(data.class||{},__owl__.classObj);
                }
            }
            catch(e){
                error=e;
            }
            if(__owl__.observer){
                __owl__.observer.allowMutations=true;
            }
            fiber.root.counter--;
            fiber.isRendered=true;
            if(error){
                fiber.handleError(error);
            }
        }
        /**
         *Applydefaultprops(onlytoplevel).
         *
         *Notethatthismethoddoesmodifyinplacetheprops
         */
        __applyDefaultProps(props,defaultProps){
            for(letpropNameindefaultProps){
                if(props[propName]===undefined){
                    props[propName]=defaultProps[propName];
                }
            }
        }
    }
    Component.template=null;
    Component._template=null;
    Component.current=null;
    Component.components={};
    Component.env={};
    //exposeschedulers.t.itcanbemockedfortestingpurposes
    Component.scheduler=scheduler;
    asyncfunctionmount(C,params){
        const{env,props,target}=params;
        letorigEnv=C.hasOwnProperty("env")?C.env:null;
        if(env){
            C.env=env;
        }
        constcomponent=newC(null,props);
        if(origEnv){
            C.env=origEnv;
        }
        else{
            deleteC.env;
        }
        constposition=params.position||"last-child";
        awaitcomponent.mount(target,{position});
        returncomponent;
    }

    /**
     *The`Context`objectprovidesawaytosharedatabetweenanarbitrarynumber
     *ofcomponent.Usually,dataispassedfromaparenttoitschildrencomponent,
     *butwhenwehavetodealwithsomemostlyglobalinformation,thiscanbe
     *annoying,sinceeachcomponentwillneedtopasstheinformationtoeach
     *children,eventhoughsomeormostofthemwillnotusetheinformation.
     *
     *Witha`Context`object,eachcomponentcansubscribe(withthe`useContext`
     *hook)toitsstate,andwillbeupdatedwheneverthecontextstateisupdated.
     */
    functionpartitionBy(arr,fn){
        letlastGroup=false;
        letlastValue;
        returnarr.reduce((acc,cur)=>{
            letcurVal=fn(cur);
            if(lastGroup){
                if(curVal===lastValue){
                    lastGroup.push(cur);
                }
                else{
                    lastGroup=false;
                }
            }
            if(!lastGroup){
                lastGroup=[cur];
                acc.push(lastGroup);
            }
            lastValue=curVal;
            returnacc;
        },[]);
    }
    classContext$1extendsEventBus{
        constructor(state={}){
            super();
            this.rev=1;
            //mappingfromcomponentidtolastobservedcontextid
            this.mapping={};
            this.observer=newObserver();
            this.observer.notifyCB=()=>{
                //notifycomponentsinthenextmicrotaskticktoensurethatsubscribers
                //arenotifiedonlyonceforallchangesthatoccurinthesamemicrotick
                letrev=this.rev;
                returnPromise.resolve().then(()=>{
                    if(rev===this.rev){
                        this.__notifyComponents();
                    }
                });
            };
            this.state=this.observer.observe(state);
            this.subscriptions.update=[];
        }
        /**
         *Insteadofusingtriggertoemitanupdateevent,weactuallyimplement
         *ourownfunctiontodothat. Thereasonisthatweneedtobesmarterthan
         *asimpletriggerfunction:weneedtowaitforparentcomponentstobe
         *donebeforedoingchildrencomponents. Moreprecisely,ifanupdate
         *asaneffectofdestroyingachildren,wedonotwanttocallanycode
         *fromthechild,andcertainlynotrenderit.
         *
         *Thismethodimplementsasimplegroupingalgorithmbydepth.Ifwehave
         *connectedcomponentsofdepths[2,4,4,4,4,3,8,8],theContextwillnotify
         *theminthefollowinggroups:[2],[4,4,4,4],[3],[8,8].Eachgroupwill
         *beupdatedsequentially,buteachcomponentsinagivengroupwillbedonein
         *parallel.
         *
         *Thisisaverysimplealgorithm,butitavoidscheckingifagiven
         *componentisachildofanother.
         */
        async__notifyComponents(){
            constrev=++this.rev;
            constsubscriptions=this.subscriptions.update;
            constgroups=partitionBy(subscriptions,(s)=>(s.owner?s.owner.__owl__.depth:-1));
            for(letgroupofgroups){
                constproms=group.map((sub)=>sub.callback.call(sub.owner,rev));
                //atthispoint,eachcomponentinthecurrentgrouphasregistereda
                //toplevelfiberinthescheduler.Itcouldhappenthatrenderingthese
                //componentsisdone(iftheyhavenochildren). Thisiswhywemanually
                //flushthescheduler. Thiswillforcetheschedulertocheck
                //immediatelyiftheyaredone,whichwillcausetheirrendering
                //promisetoresolveearlier,whichmeansthatthereisachanceof
                //processingthenextgroupinthesameframe.
                scheduler.flush();
                awaitPromise.all(proms);
            }
        }
    }
    /**
     *The`useContext`hookisthenormalwayforacomponenttoregisterthemselve
     *tocontextstatechanges.The`useContext`methodreturnsthecontextstate
     */
    functionuseContext(ctx){
        constcomponent=Component.current;
        returnuseContextWithCB(ctx,component,component.render.bind(component));
    }
    functionuseContextWithCB(ctx,component,method){
        const__owl__=component.__owl__;
        constid=__owl__.id;
        constmapping=ctx.mapping;
        if(idinmapping){
            returnctx.state;
        }
        if(!__owl__.observer){
            __owl__.observer=newObserver();
            __owl__.observer.notifyCB=component.render.bind(component);
        }
        mapping[id]=0;
        constrenderFn=__owl__.renderFn;
        __owl__.renderFn=function(comp,params){
            mapping[id]=ctx.rev;
            returnrenderFn(comp,params);
        };
        ctx.on("update",component,async(contextRev)=>{
            if(mapping[id]<contextRev){
                mapping[id]=contextRev;
                awaitmethod();
            }
        });
        const__destroy=component.__destroy;
        component.__destroy=(parent)=>{
            ctx.off("update",component);
            deletemapping[id];
            __destroy.call(component,parent);
        };
        returnctx.state;
    }

    /**
     *OwlHookSystem
     *
     *Thisfileintroducestheconceptofhooks,similartoReactorVuehooks.
     *Wehavecurrentlyanimplementationof:
     *-useState(reactivestate)
     *-onMounted
     *-onWillUnmount
     *-useRef
     */
    //-----------------------------------------------------------------------------
    //useState
    //-----------------------------------------------------------------------------
    /**
     *Thisisthemainwayacomponentcanbemadereactive. TheuseStatehook
     *willreturnanobservedobject(orarray). Changestothatvaluewillthen
     *triggerarerenderingofthecurrentcomponent.
     */
    functionuseState$1(state){
        constcomponent=Component.current;
        const__owl__=component.__owl__;
        if(!__owl__.observer){
            __owl__.observer=newObserver();
            __owl__.observer.notifyCB=component.render.bind(component);
        }
        return__owl__.observer.observe(state);
    }
    //-----------------------------------------------------------------------------
    //Lifecyclehooks
    //-----------------------------------------------------------------------------
    functionmakeLifecycleHook(method,reverse=false){
        if(reverse){
            returnfunction(cb){
                constcomponent=Component.current;
                if(component.__owl__[method]){
                    constcurrent=component.__owl__[method];
                    component.__owl__[method]=function(){
                        current.call(component);
                        cb.call(component);
                    };
                }
                else{
                    component.__owl__[method]=cb;
                }
            };
        }
        else{
            returnfunction(cb){
                constcomponent=Component.current;
                if(component.__owl__[method]){
                    constcurrent=component.__owl__[method];
                    component.__owl__[method]=function(){
                        cb.call(component);
                        current.call(component);
                    };
                }
                else{
                    component.__owl__[method]=cb;
                }
            };
        }
    }
    functionmakeAsyncHook(method){
        returnfunction(cb){
            constcomponent=Component.current;
            if(component.__owl__[method]){
                constcurrent=component.__owl__[method];
                component.__owl__[method]=function(...args){
                    returnPromise.all([current.call(component,...args),cb.call(component,...args)]);
                };
            }
            else{
                component.__owl__[method]=cb;
            }
        };
    }
    constonMounted=makeLifecycleHook("mountedCB",true);
    constonWillUnmount=makeLifecycleHook("willUnmountCB");
    constonWillPatch=makeLifecycleHook("willPatchCB");
    constonPatched=makeLifecycleHook("patchedCB",true);
    constonWillStart=makeAsyncHook("willStartCB");
    constonWillUpdateProps=makeAsyncHook("willUpdatePropsCB");
    functionuseRef(name){
        const__owl__=Component.current.__owl__;
        return{
            getel(){
                var_a,_b;
                constval=__owl__.refs&&__owl__.refs[name];
                if(valinstanceofComponent){
                    returnval.el;
                }
                if(valinstanceofHTMLElement){
                    returnval;
                }
                //Extracheckincasetheappwascreatedoutsideaniframebutmountedintoone
                //onFirefox109+,theprototypeoftheelementchangestousetheiframewindow'sHTMLElement
                //seehttps://bugzilla.mozilla.org/show_bug.cgi?id=1813499
                constownerWindow=(_b=(_a=val)===null||_a===void0?void0:_a.ownerDocument)===null||_b===void0?void0:_b.defaultView;
                if(ownerWindow&&valinstanceofownerWindow.HTMLElement){
                    returnval;
                }
                returnnull;
            },
            getcomp(){
                constval=__owl__.refs&&__owl__.refs[name];
                returnvalinstanceofComponent?val:null;
            },
        };
    }
    //-----------------------------------------------------------------------------
    //"Builder"hooks
    //-----------------------------------------------------------------------------
    /**
     *Thishookisusefulasabuildingblockforsomecustomizedhooks,thatmay
     *needareferencetothecomponentcallingthem.
     */
    functionuseComponent(){
        returnComponent.current;
    }
    /**
     *Thishookisusefulasabuildingblockforsomecustomizedhooks,thatmay
     *needareferencetotheenvofthecomponentcallingthem.
     */
    functionuseEnv(){
        returnComponent.current.env;
    }
    //-----------------------------------------------------------------------------
    //useSubEnv
    //-----------------------------------------------------------------------------
    /**
     *Thishookisasimplewaytoletcomponentsuseasubenvironment. Notethat
     *likeforallhooks,itisimportantthatthisisonlycalledinthe
     *constructormethod.
     */
    functionuseSubEnv(nextEnv){
        constcomponent=Component.current;
        component.env=Object.assign(Object.create(component.env),nextEnv);
    }
    //-----------------------------------------------------------------------------
    //useExternalListener
    //-----------------------------------------------------------------------------
    /**
     *WhenacomponentneedstolistentoDOMEventsonelement(s)thatarenot
     *partofhishierarchy,wecanusethe`useExternalListener`hook.
     *Itwillcorrectlyaddandremovetheeventlistener,wheneverthe
     *componentismountedandunmounted.
     *
     *Example:
     * amenuneedstolistentotheclickonwindowtobeclosedautomatically
     *
     *Usage:
     * intheconstructoroftheOWLcomponentthatneedstobenotified,
     * `useExternalListener(window,'click',this._doSomething);`
     **/
    functionuseExternalListener(target,eventName,handler,eventParams){
        constboundHandler=handler.bind(Component.current);
        onMounted(()=>target.addEventListener(eventName,boundHandler,eventParams));
        onWillUnmount(()=>target.removeEventListener(eventName,boundHandler,eventParams));
    }

    var_hooks=/*#__PURE__*/Object.freeze({
        __proto__:null,
        useState:useState$1,
        onMounted:onMounted,
        onWillUnmount:onWillUnmount,
        onWillPatch:onWillPatch,
        onPatched:onPatched,
        onWillStart:onWillStart,
        onWillUpdateProps:onWillUpdateProps,
        useRef:useRef,
        useComponent:useComponent,
        useEnv:useEnv,
        useSubEnv:useSubEnv,
        useExternalListener:useExternalListener
    });

    classStore$1extendsContext$1{
        constructor(config){
            super(config.state);
            this.actions=config.actions;
            this.env=config.env;
            this.getters={};
            this.updateFunctions=[];
            if(config.getters){
                constfirstArg={
                    state:this.state,
                    getters:this.getters,
                };
                for(letginconfig.getters){
                    this.getters[g]=config.getters[g].bind(this,firstArg);
                }
            }
        }
        dispatch(action,...payload){
            if(!this.actions[action]){
                thrownewError(`[Error]action${action}isundefined`);
            }
            constresult=this.actions[action]({
                dispatch:this.dispatch.bind(this),
                env:this.env,
                state:this.state,
                getters:this.getters,
            },...payload);
            returnresult;
        }
        __notifyComponents(){
            this.trigger("before-update");
            returnsuper.__notifyComponents();
        }
    }
    constisStrictEqual=(a,b)=>a===b;
    functionuseStore(selector,options={}){
        constcomponent=Component.current;
        constcomponentId=component.__owl__.id;
        conststore=options.store||component.env.store;
        if(!(storeinstanceofStore$1)){
            thrownewError(`Nostorefoundwhenconnecting'${component.constructor.name}'`);
        }
        letresult=selector(store.state,component.props);
        consthashFn=store.observer.revNumber.bind(store.observer);
        letrevNumber=hashFn(result);
        constisEqual=options.isEqual||isStrictEqual;
        if(!store.updateFunctions[componentId]){
            store.updateFunctions[componentId]=[];
        }
        functionselectCompareUpdate(state,props){
            constoldResult=result;
            result=selector(state,props);
            constnewRevNumber=hashFn(result);
            if((newRevNumber>0&&revNumber!==newRevNumber)||!isEqual(oldResult,result)){
                revNumber=newRevNumber;
                returntrue;
            }
            returnfalse;
        }
        if(options.onUpdate){
            store.on("before-update",component,()=>{
                constnewValue=selector(store.state,component.props);
                options.onUpdate(newValue);
            });
        }
        store.updateFunctions[componentId].push(function(){
            returnselectCompareUpdate(store.state,component.props);
        });
        useContextWithCB(store,component,function(){
            letshouldRender=false;
            for(letfnofstore.updateFunctions[componentId]){
                shouldRender=fn()||shouldRender;
            }
            if(shouldRender){
                returncomponent.render();
            }
        });
        onWillUpdateProps((props)=>{
            selectCompareUpdate(store.state,props);
        });
        const__destroy=component.__destroy;
        component.__destroy=(parent)=>{
            deletestore.updateFunctions[componentId];
            if(options.onUpdate){
                store.off("before-update",component);
            }
            __destroy.call(component,parent);
        };
        if(typeofresult!=="object"||result===null){
            returnresult;
        }
        returnnewProxy(result,{
            get(target,k){
                returnresult[k];
            },
            set(target,k,v){
                thrownewError("Storestateshouldonlybemodifiedthroughactions");
            },
            has(target,k){
                returnkinresult;
            },
        });
    }
    functionuseDispatch(store){
        store=store||Component.current.env.store;
        returnstore.dispatch.bind(store);
    }
    functionuseGetters(store){
        store=store||Component.current.env.store;
        returnstore.getters;
    }

    /**
     *OwlTags
     *
     *Wehaveherea(very)smallcollectionoftagfunctions:
     *
     *-xml
     *
     *Theplanistoaddafewothertagssuchascss,globalcss.
     */
    /**
     *XMLtaghelperfordefiningtemplates. Withthis,onecansimplydefine
     *aninlinetemplatewithjustthetemplatexml:
     *```js
     *  classAextendsComponent{
     *    statictemplate=xml`<div>sometemplate</div>`;
     *  }
     *```
     */
    functionxml(strings,...args){
        constname=`__template__${QWeb.nextId++}`;
        constvalue=String.raw(strings,...args);
        QWeb.registerTemplate(name,value);
        returnname;
    }
    /**
     *CSStaghelperfordefininginlinestylesheets. Withthis,onecansimplydefine
     *aninlinestylesheetwithjustthefollowingcode:
     *```js
     *  classAextendsComponent{
     *    staticstyle=css`.component-a{color:red;}`;
     *  }
     *```
     */
    functioncss(strings,...args){
        constname=`__sheet__${QWeb.nextId++}`;
        constvalue=String.raw(strings,...args);
        registerSheet(name,value);
        returnname;
    }

    var_tags=/*#__PURE__*/Object.freeze({
        __proto__:null,
        xml:xml,
        css:css
    });

    /**
     *AsyncRoot
     *
     *Owlisbydefaultasynchronous,andtheuserinterfacewillwaitforallits
     *subcomponentstoberenderedbeforeupdatingtheDOM.Thisismostofthe
     *timewhatwewant,butinsomecases,itmakessenseto"detach"acomponent
     *fromthiscoordination. ThisisthegoaloftheAsyncRootcomponent.
     */
    classAsyncRootextendsComponent{
        async__updateProps(nextProps,parentFiber){
            this.render(parentFiber.force);
        }
    }
    AsyncRoot.template=xml`<tt-slot="default"/>`;

    classPortalextendsComponent{
        constructor(parent,props){
            super(parent,props);
            //booleantoindicatewhetherornotwemustlistento'dom-appended'event
            //tohookonthemomentwhenthetargetisinsertedintotheDOM(becauseit
            //isnotwhentheportalisrendered)
            this.doTargetLookUp=true;
            //setofencounteredeventsthatneedtoberedirected
            this._handledEvents=newSet();
            //functionthatwillbetheevent'stunnel(needstobeanarrowfunctionto
            //avoidhavingtorebind`this`)
            this._handlerTunnel=(ev)=>{
                ev.stopPropagation();
                this.__trigger(ev.originalComponent,ev.type,ev.detail);
            };
            //Storingtheparent'senv
            this.parentEnv=null;
            //representstheelementthatismovedsomewhereelse
            this.portal=null;
            //thetargetwherewewillmove`portal`
            this.target=null;
            this.parentEnv=parent?parent.env:{};
            //putacallbackintheenvthatispropagatedtochildrens.t.portalcan
            //registeranhandlertothoseeventsjustbeforechildrenwilltriggerthem
            useSubEnv({
                [portalSymbol]:(ev)=>{
                    if(!this._handledEvents.has(ev.type)){
                        this.portal.elm.addEventListener(ev.type,this._handlerTunnel);
                        this._handledEvents.add(ev.type);
                    }
                },
            });
        }
        /**
         *OverridetorevertbacktoaclassicComponent'sstructure
         *
         *@override
         */
        __callWillUnmount(){
            super.__callWillUnmount();
            this.el.appendChild(this.portal.elm);
            this.doTargetLookUp=true;
        }
        /**
         *AteachDOMchange,wemustensurethattheportalcontainsexactlyone
         *child
         */
        __checkVNodeStructure(vnode){
            constchildren=vnode.children;
            letcountRealNodes=0;
            for(letchildofchildren){
                if(child.sel){
                    countRealNodes++;
                }
            }
            if(countRealNodes!==1){
                thrownewError(`Portalmusthaveexactlyonenon-textchild(has${countRealNodes})`);
            }
        }
        /**
         *Ensurethetargetisstillthereatwhichevertimewerender
         */
        __checkTargetPresence(){
            if(!this.target||!document.contains(this.target)){
                thrownewError(`Couldnotfindanymatchfor"${this.props.target}"`);
            }
        }
        /**
         *Movetheportal'selementtothetarget
         */
        __deployPortal(){
            this.__checkTargetPresence();
            this.target.appendChild(this.portal.elm);
        }
        /**
         *OverridetoremovefromtheDOMtheelementwehaveteleported
         *
         *@override
         */
        __destroy(parent){
            if(this.portal&&this.portal.elm){
                constdisplacedElm=this.portal.elm;
                constparent=displacedElm.parentNode;
                if(parent){
                    parent.removeChild(displacedElm);
                }
            }
            super.__destroy(parent);
        }
        /**
         *Overridetopatchtheelementthathasbeenteleported
         *
         *@override
         */
        __patch(target,vnode){
            if(this.doTargetLookUp){
                consttarget=document.querySelector(this.props.target);
                if(!target){
                    this.env.qweb.on("dom-appended",this,()=>{
                        this.doTargetLookUp=false;
                        this.env.qweb.off("dom-appended",this);
                        this.target=document.querySelector(this.props.target);
                        this.__deployPortal();
                    });
                }
                else{
                    this.doTargetLookUp=false;
                    this.target=target;
                }
            }
            this.__checkVNodeStructure(vnode);
            constshouldDeploy=(!this.portal||this.el.contains(this.portal.elm))&&!this.doTargetLookUp;
            if(!this.doTargetLookUp&&!shouldDeploy){
                //Onlyonpurepatching,providedthe
                //this.target'sparenthasnotbeenunmounted
                this.__checkTargetPresence();
            }
            constportalPatch=this.portal?this.portal:document.createElement(vnode.children[0].sel);
            this.portal=patch(portalPatch,vnode.children[0]);
            vnode.children=[];
            super.__patch(target,vnode);
            if(shouldDeploy){
                this.__deployPortal();
            }
        }
        /**
         *Overridetosettheenv
         */
        __trigger(component,eventType,payload){
            constenv=this.env;
            this.env=this.parentEnv;
            super.__trigger(component,eventType,payload);
            this.env=env;
        }
    }
    Portal.template=xml`<portal><tt-slot="default"/></portal>`;
    Portal.props={
        target:{
            type:String,
        },
    };

    classLinkextendsComponent{
        constructor(){
            super(...arguments);
            this.href=this.env.router.destToPath(this.props);
        }
        asyncwillUpdateProps(nextProps){
            this.href=this.env.router.destToPath(nextProps);
        }
        getisActive(){
            if(this.env.router.mode==="hash"){
                returndocument.location.hash===this.href;
            }
            returndocument.location.pathname===this.href;
        }
        navigate(ev){
            //don'tredirectwithcontrolkeys
            if(ev.metaKey||ev.altKey||ev.ctrlKey||ev.shiftKey){
                return;
            }
            //don'tredirectonrightclick
            if(ev.button!==undefined&&ev.button!==0){
                return;
            }
            //don'tredirectif`target="_blank"`
            if(ev.currentTarget&&ev.currentTarget.getAttribute){
                consttarget=ev.currentTarget.getAttribute("target");
                if(/\b_blank\b/i.test(target)){
                    return;
                }
            }
            ev.preventDefault();
            this.env.router.navigate(this.props);
        }
    }
    Link.template=xml`
    <a t-att-class="{'router-link-active':isActive}"
        t-att-href="href"
        t-on-click="navigate">
        <tt-slot="default"/>
    </a>
  `;

    classRouteComponentextendsComponent{
        getrouteComponent(){
            returnthis.env.router.currentRoute&&this.env.router.currentRoute.component;
        }
    }
    RouteComponent.template=xml`
    <t>
        <t
            t-if="routeComponent"
            t-component="routeComponent"
            t-key="env.router.currentRouteName"
            t-props="env.router.currentParams"/>
    </t>
  `;

    constparamRegexp=/\{\{(.*?)\}\}/;
    constglobalParamRegexp=newRegExp(paramRegexp.source,"g");
    classRouter{
        constructor(env,routes,options={mode:"history"}){
            this.currentRoute=null;
            this.currentParams=null;
            env.router=this;
            this.mode=options.mode;
            this.env=env;
            this.routes={};
            this.routeIds=[];
            letnextId=1;
            for(letpartialRouteofroutes){
                if(!partialRoute.name){
                    partialRoute.name="__route__"+nextId++;
                }
                if(partialRoute.component){
                    QWeb.registerComponent("__component__"+partialRoute.name,partialRoute.component);
                }
                if(partialRoute.redirect){
                    this.validateDestination(partialRoute.redirect);
                }
                partialRoute.params=partialRoute.path?findParams(partialRoute.path):[];
                partialRoute.extractionRegExp=makeExtractionRegExp(partialRoute.path);
                this.routes[partialRoute.name]=partialRoute;
                this.routeIds.push(partialRoute.name);
            }
        }
        //--------------------------------------------------------------------------
        //PublicAPI
        //--------------------------------------------------------------------------
        asyncstart(){
            this._listener=(ev)=>this._navigate(this.currentPath(),ev);
            window.addEventListener("popstate",this._listener);
            if(this.mode==="hash"){
                window.addEventListener("hashchange",this._listener);
            }
            constresult=awaitthis.matchAndApplyRules(this.currentPath());
            if(result.type==="match"){
                this.currentRoute=result.route;
                this.currentParams=result.params;
                constcurrentPath=this.routeToPath(result.route,result.params);
                if(currentPath!==this.currentPath()){
                    this.setUrlFromPath(currentPath);
                }
            }
        }
        asyncnavigate(to){
            constpath=this.destToPath(to);
            returnthis._navigate(path);
        }
        async_navigate(path,ev){
            constinitialName=this.currentRouteName;
            constinitialParams=this.currentParams;
            constresult=awaitthis.matchAndApplyRules(path);
            if(result.type==="match"){
                letfinalPath=this.routeToPath(result.route,result.params);
                if(path.indexOf("?")>-1){
                    finalPath+="?"+path.split("?")[1];
                }
                constisPopStateEvent=ev&&evinstanceofPopStateEvent;
                if(!isPopStateEvent){
                    this.setUrlFromPath(finalPath);
                }
                this.currentRoute=result.route;
                this.currentParams=result.params;
            }
            elseif(result.type==="nomatch"){
                this.currentRoute=null;
                this.currentParams=null;
            }
            constdidChange=this.currentRouteName!==initialName||!shallowEqual(this.currentParams,initialParams);
            if(didChange){
                this.env.qweb.forceUpdate();
                returntrue;
            }
            returnfalse;
        }
        destToPath(dest){
            this.validateDestination(dest);
            returndest.path||this.routeToPath(this.routes[dest.to],dest.params);
        }
        getcurrentRouteName(){
            returnthis.currentRoute&&this.currentRoute.name;
        }
        //--------------------------------------------------------------------------
        //Privatehelpers
        //--------------------------------------------------------------------------
        setUrlFromPath(path){
            constseparator=this.mode==="hash"?location.pathname:"";
            consturl=location.origin+separator+path;
            if(url!==window.location.href){
                window.history.pushState({},path,url);
            }
        }
        validateDestination(dest){
            if((!dest.path&&!dest.to)||(dest.path&&dest.to)){
                thrownewError(`Invaliddestination:${JSON.stringify(dest)}`);
            }
        }
        routeToPath(route,params){
            constprefix=this.mode==="hash"?"#":"";
            return(prefix+
                route.path.replace(globalParamRegexp,(match,param)=>{
                    const[key]=param.split(".");
                    returnparams[key];
                }));
        }
        currentPath(){
            letresult=this.mode==="history"?window.location.pathname:window.location.hash.slice(1);
            returnresult||"/";
        }
        match(path){
            for(letrouteIdofthis.routeIds){
                letroute=this.routes[routeId];
                letparams=this.getRouteParams(route,path);
                if(params){
                    return{
                        type:"match",
                        route:route,
                        params:params,
                    };
                }
            }
            return{type:"nomatch"};
        }
        asyncmatchAndApplyRules(path){
            constresult=this.match(path);
            if(result.type==="match"){
                returnthis.applyRules(result);
            }
            returnresult;
        }
        asyncapplyRules(matchResult){
            constroute=matchResult.route;
            if(route.redirect){
                constpath=this.destToPath(route.redirect);
                returnthis.matchAndApplyRules(path);
            }
            if(route.beforeRouteEnter){
                constresult=awaitroute.beforeRouteEnter({
                    env:this.env,
                    from:this.currentRoute,
                    to:route,
                });
                if(result===false){
                    return{type:"cancelled"};
                }
                elseif(result!==true){
                    //wewanttonavigatetoanotherdestination
                    constpath=this.destToPath(result);
                    returnthis.matchAndApplyRules(path);
                }
            }
            returnmatchResult;
        }
        getRouteParams(route,path){
            if(route.path==="*"){
                return{};
            }
            if(path.indexOf("?")>-1){
                path=path.split("?")[0];
            }
            if(path.startsWith("#")){
                path=path.slice(1);
            }
            constparamsMatch=path.match(route.extractionRegExp);
            if(!paramsMatch){
                returnfalse;
            }
            constresult={};
            route.params.forEach((param,index)=>{
                const[key,suffix]=param.split(".");
                constparamValue=paramsMatch[index+1];
                if(suffix==="number"){
                    return(result[key]=parseInt(paramValue,10));
                }
                return(result[key]=paramValue);
            });
            returnresult;
        }
    }
    functionfindParams(str){
        constresult=[];
        letm;
        do{
            m=globalParamRegexp.exec(str);
            if(m){
                result.push(m[1]);
            }
        }while(m);
        returnresult;
    }
    functionescapeRegExp(str){
        returnstr.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&");
    }
    functionmakeExtractionRegExp(path){
        //replaceparamstringswithcapturegroupssothatwecanbuildaregextomatchoverthepath
        constextractionString=path
            .split(paramRegexp)
            .map((part,index)=>{
            returnindex%2?"(.*)":escapeRegExp(part);
        })
            .join("");
        //Example:/home/{{param1}}/{{param2}}=>^\/home\/(.*)\/(.*)$
        returnnewRegExp(`^${extractionString}$`);
    }

    /**
     *Thisfileisthemainfilepackagedbyrollup(seerollup.config.js). From
     *thisfile,weexportallpublicowlelements.
     *
     *Notethatdynamicvalues,suchasadateoracommithashareaddedbyrollup
     */
    constContext=Context$1;
    constuseState=useState$1;
    constcore={EventBus,Observer};
    constrouter={Router,RouteComponent,Link};
    constStore=Store$1;
    constutils=_utils;
    consttags=_tags;
    constmisc={AsyncRoot,Portal};
    consthooks=Object.assign({},_hooks,{
        useContext:useContext,
        useDispatch:useDispatch,
        useGetters:useGetters,
        useStore:useStore,
    });
    const__info__={};

    exports.Component=Component;
    exports.Context=Context;
    exports.QWeb=QWeb;
    exports.Store=Store;
    exports.__info__=__info__;
    exports.browser=browser;
    exports.config=config;
    exports.core=core;
    exports.hooks=hooks;
    exports.misc=misc;
    exports.mount=mount;
    exports.router=router;
    exports.tags=tags;
    exports.useState=useState;
    exports.utils=utils;

    Object.defineProperty(exports,'__esModule',{value:true});


    __info__.version='1.4.11';
    __info__.date='2023-01-30T13:09:39.141Z';
    __info__.hash='a38c534';
    __info__.url='https://github.com/flectra/owl';


}(this.owl=this.owl||{}));

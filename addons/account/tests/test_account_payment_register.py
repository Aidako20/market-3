#-*-coding:utf-8-*-
fromflectra.addons.account.tests.commonimportAccountTestInvoicingCommon
fromflectra.exceptionsimportUserError
fromflectra.testsimporttagged,Form


@tagged('post_install','-at_install')
classTestAccountPaymentRegister(AccountTestInvoicingCommon):

    @classmethod
    defsetUpClass(cls,chart_template_ref=None):
        super().setUpClass(chart_template_ref=chart_template_ref)

        cls.currency_data_3=cls.setup_multi_currency_data({
            'name':"Umbrella",
            'symbol':'â˜‚',
            'currency_unit_label':"Umbrella",
            'currency_subunit_label':"BrokenUmbrella",
        },rate2017=0.01)

        cls.payment_debit_account_id=cls.company_data['default_journal_bank'].payment_debit_account_id.copy()
        cls.payment_credit_account_id=cls.company_data['default_journal_bank'].payment_credit_account_id.copy()

        cls.custom_payment_method_in=cls.env['account.payment.method'].sudo().create({
            'name':'custom_payment_method_in',
            'code':'CUSTOMIN',
            'payment_type':'inbound',
        })
        cls.manual_payment_method_in=cls.env.ref('account.account_payment_method_manual_in')

        cls.custom_payment_method_out=cls.env['account.payment.method'].sudo().create({
            'name':'custom_payment_method_out',
            'code':'CUSTOMOUT',
            'payment_type':'outbound',
        })
        cls.manual_payment_method_out=cls.env.ref('account.account_payment_method_manual_out')

        cls.bank_journal_1=cls.company_data['default_journal_bank']
        cls.bank_journal_2=cls.company_data['default_journal_bank'].copy()

        cls.bank_journal_1.write({
            'payment_debit_account_id':cls.payment_debit_account_id.id,
            'payment_credit_account_id':cls.payment_credit_account_id.id,
            'inbound_payment_method_ids':[(6,0,(
                cls.manual_payment_method_in.id,
                cls.custom_payment_method_in.id,
            ))],
            'outbound_payment_method_ids':[(6,0,(
                cls.env.ref('account.account_payment_method_manual_out').id,
                cls.custom_payment_method_out.id,
                cls.manual_payment_method_out.id,
            ))],
        })

        cls.partner_bank_account1=cls.env['res.partner.bank'].create({
            'acc_number':"0123456789",
            'partner_id':cls.partner_a.id,
            'acc_type':'bank',
        })
        cls.partner_bank_account2=cls.env['res.partner.bank'].create({
            'acc_number':"9876543210",
            'partner_id':cls.partner_a.id,
            'acc_type':'bank',
        })
        cls.comp_bank_account1=cls.env['res.partner.bank'].create({
            'acc_number':"985632147",
            'partner_id':cls.env.company.partner_id.id,
            'acc_type':'bank',
        })
        cls.comp_bank_account2=cls.env['res.partner.bank'].create({
            'acc_number':"741258963",
            'partner_id':cls.env.company.partner_id.id,
            'acc_type':'bank',
        })

        #Customerinvoicessharingthesamebatch.
        cls.out_invoice_1=cls.env['account.move'].create({
            'move_type':'out_invoice',
            'date':'2017-01-01',
            'invoice_date':'2017-01-01',
            'partner_id':cls.partner_a.id,
            'currency_id':cls.currency_data['currency'].id,
            'invoice_line_ids':[(0,0,{'product_id':cls.product_a.id,'price_unit':1000.0})],
        })
        cls.out_invoice_2=cls.env['account.move'].create({
            'move_type':'out_invoice',
            'date':'2017-01-01',
            'invoice_date':'2017-01-01',
            'partner_id':cls.partner_a.id,
            'currency_id':cls.currency_data['currency'].id,
            'invoice_line_ids':[(0,0,{'product_id':cls.product_a.id,'price_unit':2000.0})],
        })
        cls.out_invoice_3=cls.env['account.move'].create({
            'move_type':'out_invoice',
            'date':'2017-01-01',
            'invoice_date':'2017-01-01',
            'partner_id':cls.partner_a.id,
            'invoice_line_ids':[(0,0,{'product_id':cls.product_a.id,'price_unit':12.01})],
        })
        cls.out_invoice_4=cls.env['account.move'].create({
            'move_type':'out_invoice',
            'date':'2017-01-01',
            'invoice_date':'2017-01-01',
            'partner_id':cls.partner_a.id,
            'invoice_line_ids':[(0,0,{'product_id':cls.product_a.id,'price_unit':11.99})],
        })
        (cls.out_invoice_1+cls.out_invoice_2+cls.out_invoice_3+cls.out_invoice_4).action_post()

        #Vendorbills,in_invoice_1+in_invoice_2aresharingthesamebatchbutnotin_invoice_3.
        cls.in_invoice_1=cls.env['account.move'].create({
            'move_type':'in_invoice',
            'date':'2017-01-01',
            'invoice_date':'2017-01-01',
            'partner_id':cls.partner_a.id,
            'invoice_line_ids':[(0,0,{'product_id':cls.product_a.id,'price_unit':1000.0})],
        })
        cls.in_invoice_2=cls.env['account.move'].create({
            'move_type':'in_invoice',
            'date':'2017-01-01',
            'invoice_date':'2017-01-01',
            'partner_id':cls.partner_a.id,
            'invoice_line_ids':[(0,0,{'product_id':cls.product_a.id,'price_unit':2000.0})],
        })
        cls.in_invoice_3=cls.env['account.move'].create({
            'move_type':'in_invoice',
            'date':'2017-01-01',
            'invoice_date':'2017-01-01',
            'partner_id':cls.partner_b.id,
            'currency_id':cls.currency_data['currency'].id,
            'invoice_line_ids':[(0,0,{'product_id':cls.product_a.id,'price_unit':3000.0})],
        })
        (cls.in_invoice_1+cls.in_invoice_2+cls.in_invoice_3).action_post()

    deftest_register_payment_single_batch_grouped_keep_open_lower_amount(self):
        '''Pay800.0with'open'aspaymentdifferencehandlingontwocustomerinvoices(1000+2000).'''
        active_ids=(self.out_invoice_1+self.out_invoice_2).ids
        payments=self.env['account.payment.register'].with_context(active_model='account.move',active_ids=active_ids).create({
            'amount':800.0,
            'group_payment':True,
            'payment_difference_handling':'open',
            'currency_id':self.currency_data['currency'].id,
            'payment_method_id':self.custom_payment_method_in.id,
        })._create_payments()

        self.assertRecordValues(payments,[{
            'ref':'INV/2017/01/0001INV/2017/01/0002',
            'payment_method_id':self.custom_payment_method_in.id,
        }])
        self.assertRecordValues(payments.line_ids.sorted('balance'),[
            #Receivableline:
            {
                'debit':0.0,
                'credit':400.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':-800.0,
                'reconciled':True,
            },
            #Liquidityline:
            {
                'debit':400.0,
                'credit':0.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':800.0,
                'reconciled':False,
            },
        ])

    deftest_register_payment_single_batch_grouped_keep_open_higher_amount(self):
        '''Pay3100.0with'open'aspaymentdifferencehandlingontwocustomerinvoices(1000+2000).'''
        active_ids=(self.out_invoice_1+self.out_invoice_2).ids
        payments=self.env['account.payment.register'].with_context(active_model='account.move',active_ids=active_ids).create({
            'amount':3100.0,
            'group_payment':True,
            'payment_difference_handling':'open',
            'currency_id':self.currency_data['currency'].id,
            'payment_method_id':self.custom_payment_method_in.id,
        })._create_payments()

        self.assertRecordValues(payments,[{
            'ref':'INV/2017/01/0001INV/2017/01/0002',
            'payment_method_id':self.custom_payment_method_in.id,
        }])
        self.assertRecordValues(payments.line_ids.sorted('balance'),[
            #Receivableline:
            {
                'debit':0.0,
                'credit':1550.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':-3100.0,
                'reconciled':False,
            },
            #Liquidityline:
            {
                'debit':1550.0,
                'credit':0.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':3100.0,
                'reconciled':False,
            },
        ])

    deftest_register_payment_single_batch_grouped_writeoff_lower_amount_debit(self):
        '''Pay800.0with'reconcile'aspaymentdifferencehandlingontwocustomerinvoices(1000+2000).'''
        active_ids=(self.out_invoice_1+self.out_invoice_2).ids
        payments=self.env['account.payment.register'].with_context(active_model='account.move',active_ids=active_ids).create({
            'amount':800.0,
            'group_payment':True,
            'payment_difference_handling':'reconcile',
            'writeoff_account_id':self.company_data['default_account_revenue'].id,
            'writeoff_label':'writeoff',
            'payment_method_id':self.custom_payment_method_in.id,
        })._create_payments()

        self.assertRecordValues(payments,[{
            'ref':'INV/2017/01/0001INV/2017/01/0002',
            'payment_method_id':self.custom_payment_method_in.id,
        }])
        self.assertRecordValues(payments.line_ids.sorted('balance'),[
            #Receivableline:
            {
                'debit':0.0,
                'credit':1500.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':-3000.0,
                'reconciled':True,
            },
            #Liquidityline:
            {
                'debit':400.0,
                'credit':0.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':800.0,
                'reconciled':False,
            },
            #Writeoffline:
            {
                'debit':1100.0,
                'credit':0.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':2200.0,
                'reconciled':False,
            },
        ])

    deftest_register_payment_single_batch_grouped_writeoff_higher_amount_debit(self):
        '''Pay3100.0with'reconcile'aspaymentdifferencehandlingontwocustomerinvoices(1000+2000).'''
        active_ids=(self.out_invoice_1+self.out_invoice_2).ids
        payments=self.env['account.payment.register'].with_context(active_model='account.move',active_ids=active_ids).create({
            'amount':3100.0,
            'group_payment':True,
            'payment_difference_handling':'reconcile',
            'writeoff_account_id':self.company_data['default_account_revenue'].id,
            'writeoff_label':'writeoff',
            'payment_method_id':self.custom_payment_method_in.id,
        })._create_payments()

        self.assertRecordValues(payments,[{
            'ref':'INV/2017/01/0001INV/2017/01/0002',
            'payment_method_id':self.custom_payment_method_in.id,
        }])
        self.assertRecordValues(payments.line_ids.sorted('balance'),[
            #Receivableline:
            {
                'debit':0.0,
                'credit':1500.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':-3000.0,
                'reconciled':True,
            },
            #Writeoffline:
            {
                'debit':0.0,
                'credit':50.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':-100.0,
                'reconciled':False,
            },
            #Liquidityline:
            {
                'debit':1550.0,
                'credit':0.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':3100.0,
                'reconciled':False,
            },
        ])

    deftest_register_payment_single_batch_grouped_writeoff_lower_amount_credit(self):
        '''Pay800.0with'reconcile'aspaymentdifferencehandlingontwovendorbilles(1000+2000).'''
        active_ids=(self.in_invoice_1+self.in_invoice_2).ids
        payments=self.env['account.payment.register'].with_context(active_model='account.move',active_ids=active_ids).create({
            'amount':800.0,
            'group_payment':True,
            'payment_difference_handling':'reconcile',
            'writeoff_account_id':self.company_data['default_account_revenue'].id,
            'writeoff_label':'writeoff',
            'payment_method_id':self.custom_payment_method_in.id,
        })._create_payments()

        self.assertRecordValues(payments,[{
            'ref':'BILL/2017/01/0001BILL/2017/01/0002',
            'payment_method_id':self.custom_payment_method_in.id,
        }])
        self.assertRecordValues(payments.line_ids.sorted('balance'),[
            #Writeoffline:
            {
                'debit':0.0,
                'credit':2200.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':-2200.0,
                'reconciled':False,
            },
            #Liquidityline:
            {
                'debit':0.0,
                'credit':800.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':-800.0,
                'reconciled':False,
            },
            #Payableline:
            {
                'debit':3000.0,
                'credit':0.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':3000.0,
                'reconciled':True,
            },
        ])

    deftest_register_payment_single_batch_grouped_writeoff_higher_amount_credit(self):
        '''Pay3100.0with'reconcile'aspaymentdifferencehandlingontwovendorbilles(1000+2000).'''
        active_ids=(self.in_invoice_1+self.in_invoice_2).ids
        payments=self.env['account.payment.register'].with_context(active_model='account.move',active_ids=active_ids).create({
            'amount':3100.0,
            'group_payment':True,
            'payment_difference_handling':'reconcile',
            'writeoff_account_id':self.company_data['default_account_revenue'].id,
            'writeoff_label':'writeoff',
            'payment_method_id':self.custom_payment_method_in.id,
        })._create_payments()

        self.assertRecordValues(payments,[{
            'ref':'BILL/2017/01/0001BILL/2017/01/0002',
            'payment_method_id':self.custom_payment_method_in.id,
        }])
        self.assertRecordValues(payments.line_ids.sorted('balance'),[
            #Liquidityline:
            {
                'debit':0.0,
                'credit':3100.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':-3100.0,
                'reconciled':False,
            },
            #Writeoffline:
            {
                'debit':100.0,
                'credit':0.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':100.0,
                'reconciled':False,
            },
            #Payableline:
            {
                'debit':3000.0,
                'credit':0.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':3000.0,
                'reconciled':True,
            },
        ])

    deftest_register_payment_single_batch_not_grouped(self):
        '''Choosetopaytwocustomerinvoiceswithseparatedpayments(1000+2000).'''
        active_ids=(self.out_invoice_1+self.out_invoice_2).ids
        payments=self.env['account.payment.register'].with_context(active_model='account.move',active_ids=active_ids).create({
            'group_payment':False,
        })._create_payments()

        self.assertRecordValues(payments,[
            {
                'ref':'INV/2017/01/0001',
                'payment_method_id':self.manual_payment_method_in.id,
            },
            {
                'ref':'INV/2017/01/0002',
                'payment_method_id':self.manual_payment_method_in.id,
            },
        ])
        self.assertRecordValues(payments[0].line_ids.sorted('balance')+payments[1].line_ids.sorted('balance'),[
            #==Payment1:topayout_invoice_1==
            #Receivableline:
            {
                'debit':0.0,
                'credit':500.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':-1000.0,
                'reconciled':True,
            },
            #Liquidityline:
            {
                'debit':500.0,
                'credit':0.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':1000.0,
                'reconciled':False,
            },
            #==Payment2:topayout_invoice_2==
            #Receivableline:
            {
                'debit':0.0,
                'credit':1000.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':-2000.0,
                'reconciled':True,
            },
            #Liquidityline:
            {
                'debit':1000.0,
                'credit':0.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':2000.0,
                'reconciled':False,
            },
        ])

    deftest_register_payment_multi_batches_grouped(self):
        '''Choosetopaymultiplebatches,onewithtwocustomerinvoices(1000+2000)
         andonewithavendorbillof600,bygroupingpayments.
         '''
        active_ids=(self.in_invoice_1+self.in_invoice_2+self.in_invoice_3).ids
        payments=self.env['account.payment.register'].with_context(active_model='account.move',active_ids=active_ids).create({
            'group_payment':True,
        })._create_payments()

        self.assertRecordValues(payments,[
            {
                'ref':'BILL/2017/01/0001BILL/2017/01/0002',
                'payment_method_id':self.manual_payment_method_out.id,
            },
            {
                'ref':'BILL/2017/01/0003',
                'payment_method_id':self.manual_payment_method_out.id,
            },
        ])
        self.assertRecordValues(payments[0].line_ids.sorted('balance')+payments[1].line_ids.sorted('balance'),[
            #==Payment1:topayin_invoice_1&in_invoice_2==
            #Liquidityline:
            {
                'debit':0.0,
                'credit':3000.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':-3000.0,
                'reconciled':False,
            },
            #Payableline:
            {
                'debit':3000.0,
                'credit':0.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':3000.0,
                'reconciled':True,
            },
            #==Payment2:topayin_invoice_3==
            #Liquidityline:
            {
                'debit':0.0,
                'credit':1500.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':-3000.0,
                'reconciled':False,
            },
            #Payableline:
            {
                'debit':1500.0,
                'credit':0.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':3000.0,
                'reconciled':True,
            },
        ])

    deftest_register_payment_multi_batches_not_grouped(self):
        '''Choosetopaymultiplebatches,onewithtwocustomerinvoices(1000+2000)
         andonewithavendorbillof600,bysplittingpayments.
         '''
        self.in_invoice_1.partner_bank_id=self.partner_bank_account1
        self.in_invoice_2.partner_bank_id=self.partner_bank_account2

        active_ids=(self.in_invoice_1+self.in_invoice_2+self.in_invoice_3).ids
        payments=self.env['account.payment.register'].with_context(active_model='account.move',active_ids=active_ids).create({
            'group_payment':False,
        })._create_payments()

        self.assertRecordValues(payments,[
            {
                'journal_id':self.bank_journal_1.id,
                'ref':'BILL/2017/01/0001',
                'payment_method_id':self.manual_payment_method_out.id,
                'partner_bank_id':self.partner_bank_account1.id,
            },
            {
                'journal_id':self.bank_journal_1.id,
                'ref':'BILL/2017/01/0002',
                'payment_method_id':self.manual_payment_method_out.id,
                'partner_bank_id':self.partner_bank_account2.id,
            },
            {
                'journal_id':self.bank_journal_1.id,
                'ref':'BILL/2017/01/0003',
                'payment_method_id':self.manual_payment_method_out.id,
                'partner_bank_id':False,
            },
        ])
        self.assertRecordValues(payments[0].line_ids.sorted('balance')+payments[1].line_ids.sorted('balance')+payments[2].line_ids.sorted('balance'),[
            #==Payment1:topayin_invoice_1==
            #Liquidityline:
            {
                'debit':0.0,
                'credit':1000.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':-1000.0,
                'reconciled':False,
            },
            #Payableline:
            {
                'debit':1000.0,
                'credit':0.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':1000.0,
                'reconciled':True,
            },
            #==Payment2:topayin_invoice_2==
            #Liquidityline:
            {
                'debit':0.0,
                'credit':2000.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':-2000.0,
                'reconciled':False,
            },
            #Payableline:
            {
                'debit':2000.0,
                'credit':0.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':2000.0,
                'reconciled':True,
            },
            #==Payment3:topayin_invoice_3==
            #Liquidityline:
            {
                'debit':0.0,
                'credit':1500.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':-3000.0,
                'reconciled':False,
            },
            #Payableline:
            {
                'debit':1500.0,
                'credit':0.0,
                'currency_id':self.currency_data['currency'].id,
                'amount_currency':3000.0,
                'reconciled':True,
            },
        ])

    deftest_register_payment_constraints(self):
        #Testtoregisterapaymentforadraftjournalentry.
        self.out_invoice_1.button_draft()
        withself.assertRaises(UserError),self.cr.savepoint():
            self.env['account.payment.register']\
                .with_context(active_model='account.move',active_ids=self.out_invoice_1.ids)\
                .create({})

        #Testtoregisterapaymentforanalreadyfullyreconciledjournalentry.
        self.env['account.payment.register']\
            .with_context(active_model='account.move',active_ids=self.out_invoice_2.ids)\
            .create({})\
            ._create_payments()
        withself.assertRaises(UserError),self.cr.savepoint():
            self.env['account.payment.register']\
                .with_context(active_model='account.move',active_ids=self.out_invoice_2.ids)\
                .create({})

    deftest_register_payment_multi_currency_rounding_issue_positive_delta(self):
        '''Whenregisteringapaymentusingadifferentcurrencythantheinvoiceone,theinvoicemustbefullypaid
        attheendwhateverthecurrencyrate.
        '''
        payment=self.env['account.payment.register']\
            .with_context(active_model='account.move',active_ids=self.out_invoice_3.ids)\
            .create({
                'currency_id':self.currency_data_3['currency'].id,
                'amount':0.12,
            })\
            ._create_payments()

        self.assertRecordValues(payment.line_ids.sorted('balance'),[
            #Receivableline:
            {
                'debit':0.0,
                'credit':12.01,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':-0.12,
                'reconciled':True,
            },
            #Liquidityline:
            {
                'debit':12.01,
                'credit':0.0,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':0.12,
                'reconciled':False,
            },
        ])

    deftest_register_payment_multi_currency_rounding_issue_negative_delta(self):
        '''Whenregisteringapaymentusingadifferentcurrencythantheinvoiceone,theinvoicemustbefullypaid
        attheendwhateverthecurrencyrate.
        '''
        payment=self.env['account.payment.register']\
            .with_context(active_model='account.move',active_ids=self.out_invoice_4.ids)\
            .create({
                'currency_id':self.currency_data_3['currency'].id,
                'amount':0.12,
            })\
            ._create_payments()

        self.assertRecordValues(payment.line_ids.sorted('balance'),[
            #Receivableline:
            {
                'debit':0.0,
                'credit':11.99,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':-0.12,
                'reconciled':True,
            },
            #Liquidityline:
            {
                'debit':11.99,
                'credit':0.0,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':0.12,
                'reconciled':False,
            },
        ])

    deftest_register_payment_multi_currency_rounding_issue_writeoff_lower_amount_keep_open(self):
        payment=self.env['account.payment.register']\
            .with_context(active_model='account.move',active_ids=self.out_invoice_3.ids)\
            .create({
                'currency_id':self.currency_data_3['currency'].id,
                'amount':0.08,
                'payment_difference_handling':'open',
            })\
            ._create_payments()

        self.assertRecordValues(payment.line_ids.sorted('balance'),[
            #Receivableline:
            {
                'debit':0.0,
                'credit':8.0,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':-0.08,
                'reconciled':True,
            },
            #Liquidityline:
            {
                'debit':8.0,
                'credit':0.0,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':0.08,
                'reconciled':False,
            },
        ])

    deftest_register_payment_multi_currency_rounding_issue_writeoff_lower_amount_reconcile_positive_delta(self):
        payment=self.env['account.payment.register']\
            .with_context(active_model='account.move',active_ids=self.out_invoice_3.ids)\
            .create({
                'currency_id':self.currency_data_3['currency'].id,
                'amount':0.08,
                'payment_difference_handling':'reconcile',
                'writeoff_account_id':self.company_data['default_account_revenue'].id,
                'writeoff_label':'writeoff',
            })\
            ._create_payments()

        self.assertRecordValues(payment.line_ids.sorted('balance'),[
            #Receivableline:
            {
                'debit':0.0,
                'credit':12.01,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':-0.12,
                'reconciled':True,
            },
            #Write-offline:
            {
                'debit':4.0,
                'credit':0.0,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':0.04,
                'reconciled':False,
            },
            #Liquidityline:
            {
                'debit':8.01,
                'credit':0.0,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':0.08,
                'reconciled':False,
            },
        ])

    deftest_register_payment_multi_currency_rounding_issue_writeoff_lower_amount_reconcile_negative_delta(self):
        payment=self.env['account.payment.register']\
            .with_context(active_model='account.move',active_ids=self.out_invoice_4.ids)\
            .create({
                'currency_id':self.currency_data_3['currency'].id,
                'amount':0.08,
                'payment_difference_handling':'reconcile',
                'writeoff_account_id':self.company_data['default_account_revenue'].id,
                'writeoff_label':'writeoff',
            })\
            ._create_payments()

        self.assertRecordValues(payment.line_ids.sorted('balance'),[
            #Receivableline:
            {
                'debit':0.0,
                'credit':11.99,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':-0.12,
                'reconciled':True,
            },
            #Write-offline:
            {
                'debit':4.0,
                'credit':0.0,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':0.04,
                'reconciled':False,
            },
            #Liquidityline:
            {
                'debit':7.99,
                'credit':0.0,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':0.08,
                'reconciled':False,
            },
        ])

    deftest_register_payment_multi_currency_rounding_issue_writeoff_higher_amount_reconcile_positive_delta(self):
        payment=self.env['account.payment.register']\
            .with_context(active_model='account.move',active_ids=self.out_invoice_3.ids)\
            .create({
                'currency_id':self.currency_data_3['currency'].id,
                'amount':0.16,
                'payment_difference_handling':'reconcile',
                'writeoff_account_id':self.company_data['default_account_revenue'].id,
                'writeoff_label':'writeoff',
            })\
            ._create_payments()

        self.assertRecordValues(payment.line_ids.sorted('balance'),[
            #Receivableline:
            {
                'debit':0.0,
                'credit':12.01,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':-0.12,
                'reconciled':True,
            },
            #Write-offline:
            {
                'debit':0.0,
                'credit':4.0,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':-0.04,
                'reconciled':False,
            },
            #Liquidityline:
            {
                'debit':16.01,
                'credit':0.0,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':0.16,
                'reconciled':False,
            },
        ])

    deftest_register_payment_multi_currency_rounding_issue_writeoff_higher_amount_reconcile_negative_delta(self):
        payment=self.env['account.payment.register']\
            .with_context(active_model='account.move',active_ids=self.out_invoice_4.ids)\
            .create({
                'currency_id':self.currency_data_3['currency'].id,
                'amount':0.16,
                'payment_difference_handling':'reconcile',
                'writeoff_account_id':self.company_data['default_account_revenue'].id,
                'writeoff_label':'writeoff',
            })\
            ._create_payments()

        self.assertRecordValues(payment.line_ids.sorted('balance'),[
            #Receivableline:
            {
                'debit':0.0,
                'credit':11.99,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':-0.12,
                'reconciled':True,
            },
            #Write-offline:
            {
                'debit':0.0,
                'credit':4.0,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':-0.04,
                'reconciled':False,
            },
            #Liquidityline:
            {
                'debit':15.99,
                'credit':0.0,
                'currency_id':self.currency_data_3['currency'].id,
                'amount_currency':0.16,
                'reconciled':False,
            },
        ])

    deftest_suggested_default_partner_bank_inbound_payment(self):
        """Testthesuggestedbankaccountonthewizardforinboundpayment."""
        self.out_invoice_1.partner_bank_id=False

        ctx={'active_model':'account.move','active_ids':self.out_invoice_1.ids}
        wizard=self.env['account.payment.register'].with_context(**ctx).create({})
        self.assertRecordValues(wizard,[{
            'journal_id':self.bank_journal_1.id,
            'available_partner_bank_ids':[],
            'partner_bank_id':False,
        }])

        self.bank_journal_2.bank_account_id=self.out_invoice_1.partner_bank_id=self.comp_bank_account2
        wizard=self.env['account.payment.register'].with_context(**ctx).create({})
        self.assertRecordValues(wizard,[{
            'journal_id':self.bank_journal_2.id,
            'available_partner_bank_ids':self.comp_bank_account2.ids,
            'partner_bank_id':self.comp_bank_account2.id,
        }])

        wizard.journal_id=self.bank_journal_1
        self.assertRecordValues(wizard,[{
            'journal_id':self.bank_journal_1.id,
            'available_partner_bank_ids':[],
            'partner_bank_id':False,
        }])

    deftest_suggested_default_partner_bank_outbound_payment(self):
        """Testthesuggestedbankaccountonthewizardforoutboundpayment."""
        self.in_invoice_1.partner_bank_id=False

        ctx={'active_model':'account.move','active_ids':self.in_invoice_1.ids}
        wizard=self.env['account.payment.register'].with_context(**ctx).create({})
        self.assertRecordValues(wizard,[{
            'journal_id':self.bank_journal_1.id,
            'available_partner_bank_ids':self.partner_a.bank_ids.ids,
            'partner_bank_id':self.partner_bank_account1.id,
        }])

        self.in_invoice_1.partner_bank_id=self.partner_bank_account2
        wizard=self.env['account.payment.register'].with_context(**ctx).create({})
        self.assertRecordValues(wizard,[{
            'journal_id':self.bank_journal_1.id,
            'available_partner_bank_ids':self.partner_a.bank_ids.ids,
            'partner_bank_id':self.partner_bank_account2.id,
        }])

        wizard.journal_id=self.bank_journal_2
        self.assertRecordValues(wizard,[{
            'journal_id':self.bank_journal_2.id,
            'available_partner_bank_ids':self.partner_a.bank_ids.ids,
            'partner_bank_id':self.partner_bank_account2.id,
        }])

    deftest_register_payment_inbound_multiple_bank_account(self):
        """Paycustomerinvoiceswithdifferentbankaccounts."""
        self.out_invoice_1.partner_bank_id=self.comp_bank_account1
        self.out_invoice_2.partner_bank_id=self.comp_bank_account2
        self.bank_journal_2.bank_account_id=self.comp_bank_account2

        ctx={'active_model':'account.move','active_ids':(self.out_invoice_1+self.out_invoice_2).ids}
        wizard=self.env['account.payment.register'].with_context(**ctx).create({'journal_id':self.bank_journal_2.id})
        payments=wizard._create_payments()

        self.assertRecordValues(payments,[
            {
                'journal_id':self.bank_journal_2.id,
                'ref':'INV/2017/01/0001',
                'payment_method_id':self.manual_payment_method_in.id,
                'partner_bank_id':self.comp_bank_account2.id,
            },
            {
                'journal_id':self.bank_journal_2.id,
                'ref':'INV/2017/01/0002',
                'payment_method_id':self.manual_payment_method_in.id,
                'partner_bank_id':self.comp_bank_account2.id,
            },
        ])

    deftest_payment_method_different_type_single_batch_not_grouped(self):
        """Testpaymentmethodswhenpayingabillandarefundwithseparatedpayments(1000+-2000)."""
        invoice_1=self.in_invoice_1
        invoice_2=invoice_1.copy({'invoice_date':invoice_1.invoice_date,'partner_id':self.partner_b.id})
        refund_1,refund_2=self.env['account.move'].create([
            {
                'move_type':'in_refund',
                'date':'2017-01-01',
                'invoice_date':'2017-01-01',
                'partner_id':self.partner_a.id,
                'invoice_line_ids':[(0,0,{'product_id':self.product_a.id,'price_unit':1600.0})],
            },
            {
                'move_type':'in_refund',
                'date':'2017-01-01',
                'invoice_date':'2017-01-01',
                'partner_id':self.partner_b.id,
                'invoice_line_ids':[(0,0,{'product_id':self.product_a.id,'price_unit':1600.0})],
            },
        ])
        (invoice_2+refund_1+refund_2).action_post()

        formovesin((invoice_1+invoice_2),(refund_1+refund_2)):
            wizard=self.env['account.payment.register'].with_context(active_model='account.move',active_ids=moves.ids).create({
                'group_payment':False,
            })

            expected_available_payment_methods=wizard.journal_id.inbound_payment_method_idsifmoves[0].move_type=='in_refund'elsewizard.journal_id.outbound_payment_method_ids

            self.assertRecordValues(wizard,[
                {
                    'available_payment_method_ids':expected_available_payment_methods.ids,
                    'payment_method_id':expected_available_payment_methods[:1].id,
                }
            ])

        active_ids=(invoice_1+invoice_2+refund_1+refund_2).ids
        payments=self.env['account.payment.register'].with_context(active_model='account.move',active_ids=active_ids).create({
            'group_payment':False,
        })._create_payments()

        self.assertRecordValues(payments[0],[
            {
                'ref':'BILL/2017/01/0001',
                'payment_method_id':self.bank_journal_1.outbound_payment_method_ids[0].id,
                'payment_type':'outbound',
            }
        ])

        self.assertRecordValues(payments[1],[
            {
                'ref':'BILL/2017/01/0004',
                'payment_method_id':self.bank_journal_1.outbound_payment_method_ids[0].id,
                'payment_type':'outbound',
            }
        ])

        self.assertRecordValues(payments[2],[
            {
                'ref':'RBILL/2017/01/0001',
                'payment_method_id':self.bank_journal_1.inbound_payment_method_ids[0].id,
                'payment_type':'inbound',
            },
        ])

        self.assertRecordValues(payments[3],[
            {
                'ref':'RBILL/2017/01/0002',
                'payment_method_id':self.bank_journal_1.inbound_payment_method_ids[0].id,
                'payment_type':'inbound',
            },
        ])

        self.assertRecordValues(payments[0].line_ids.sorted('balance'),[
            #==Payment1:topayinvoice_1==
            #Liquidityline:
            {
                'debit':0.0,
                'credit':1000.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':-1000.0,
                'reconciled':False,
            },
            #Payableline:
            {
                'debit':1000.0,
                'credit':0.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':1000.0,
                'reconciled':True,
            },
        ])

        self.assertRecordValues(payments[1].line_ids.sorted('balance'),[
            #==Payment2:topayinvoice_2==
            #Liquidityline:
            {
                'debit':0.0,
                'credit':1000.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':-1000.0,
                'reconciled':False,
            },
            #Payableline:
            {
                'debit':1000.0,
                'credit':0.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':1000.0,
                'reconciled':True,
            },
        ])

        self.assertRecordValues(payments[2].line_ids.sorted('balance'),[
            #==Payment3:topayrefund_1==
            #Payableline:
            {
                'debit':0.0,
                'credit':1600.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':-1600.0,
                'reconciled':True,
            },
            #Liquidityline:
            {
                'debit':1600.0,
                'credit':0.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':1600.0,
                'reconciled':False,
            },
        ])

        self.assertRecordValues(payments[3].line_ids.sorted('balance'),[
            #==Payment4:topayrefund_2==
            #Payableline:
            {
                'debit':0.0,
                'credit':1600.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':-1600.0,
                'reconciled':True,
            },
            #Liquidityline:
            {
                'debit':1600.0,
                'credit':0.0,
                'currency_id':self.company_data['currency'].id,
                'amount_currency':1600.0,
                'reconciled':False,
            },
        ])

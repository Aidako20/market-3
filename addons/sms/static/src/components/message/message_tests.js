flectra.define('sms/static/src/components/message/message_tests.js',function(require){
'usestrict';

constcomponents={
    Message:require('mail/static/src/components/message/message.js'),
};
const{makeDeferred}=require('mail/static/src/utils/deferred/deferred.js');
const{
    afterEach,
    afterNextRender,
    beforeEach,
    createRootComponent,
    start,
}=require('mail/static/src/utils/test_utils.js');

constBus=require('web.Bus');

QUnit.module('sms',{},function(){
QUnit.module('components',{},function(){
QUnit.module('message',{},function(){
QUnit.module('message_tests.js',{
    beforeEach(){
        beforeEach(this);

        this.createMessageComponent=async(message,otherProps)=>{
            constprops=Object.assign({messageLocalId:message.localId},otherProps);
            awaitcreateRootComponent(this,components.Message,{
                props,
                target:this.widget.el,
            });
        };

        this.start=asyncparams=>{
            const{env,widget}=awaitstart(Object.assign({},params,{
                data:this.data,
            }));
            this.env=env;
            this.widget=widget;
        };
    },
    afterEach(){
        afterEach(this);
    },
});

QUnit.test('NotificationSent',asyncfunction(assert){
    assert.expect(9);

    awaitthis.start();
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['create',{
            id:11,
            model:'mail.channel',
        }]],
    });
    constmessage=this.env.models['mail.message'].create({
        id:10,
        message_type:'sms',
        notifications:[['insert',{
            id:11,
            notification_status:'sent',
            notification_type:'sms',
            partner:[['insert',{id:12,name:"Someone"}]],
        }]],
        originThread:[['link',threadViewer.thread]]
    });
    awaitthis.createMessageComponent(message,{
        threadViewLocalId:threadViewer.threadView.localId
    });

    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplayamessagecomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIconClickable',
        "shoulddisplaythenotificationiconcontainer"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIcon',
        "shoulddisplaythenotificationicon"
    );
    assert.hasClass(
        document.querySelector('.o_Message_notificationIcon'),
        'fa-mobile',
        "iconshouldrepresentsms"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_Message_notificationIconClickable').click();
    });
    assert.containsOnce(
        document.body,
        '.o_NotificationPopover',
        "notificationpopovershouldbeopen"
    );
    assert.containsOnce(
        document.body,
        '.o_NotificationPopover_notificationIcon',
        "popovershouldhaveoneicon"
    );
    assert.hasClass(
        document.querySelector('.o_NotificationPopover_notificationIcon'),
        'fa-check',
        "popovershouldhavethesenticon"
    );
    assert.containsOnce(
        document.body,
        '.o_NotificationPopover_notificationPartnerName',
        "popovershouldhavethepartnername"
    );
    assert.strictEqual(
        document.querySelector('.o_NotificationPopover_notificationPartnerName').textContent.trim(),
        "Someone",
        "partnernameshouldbecorrect"
    );
});

QUnit.test('NotificationError',asyncfunction(assert){
    assert.expect(8);

    constopenResendActionDef=makeDeferred();
    constbus=newBus();
    bus.on('do-action',null,payload=>{
        assert.step('do_action');
        assert.strictEqual(
            payload.action,
            'sms.sms_resend_action',
            "actionshouldbetheonetoresendsms"
        );
        assert.strictEqual(
            payload.options.additional_context.default_mail_message_id,
            10,
            "actionshouldhavecorrectmessageid"
        );
        openResendActionDef.resolve();
    });

    awaitthis.start({env:{bus}});
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['create',{
            id:11,
            model:'mail.channel',
        }]],
    });
    constmessage=this.env.models['mail.message'].create({
        id:10,
        message_type:'sms',
        notifications:[['insert',{
            id:11,
            notification_status:'exception',
            notification_type:'sms',
        }]],
        originThread:[['link',threadViewer.thread]]
    });
    awaitthis.createMessageComponent(message,{
        threadViewLocalId:threadViewer.threadView.localId
    });

    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplayamessagecomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIconClickable',
        "shoulddisplaythenotificationiconcontainer"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIcon',
        "shoulddisplaythenotificationicon"
    );
    assert.hasClass(
        document.querySelector('.o_Message_notificationIcon'),
        'fa-mobile',
        "iconshouldrepresentsms"
    );
    document.querySelector('.o_Message_notificationIconClickable').click();
    awaitopenResendActionDef;
    assert.verifySteps(
        ['do_action'],
        "shoulddoanactiontodisplaytheresendsmsdialog"
    );
});

});
});
});

});

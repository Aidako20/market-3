flectra.define('web_tour.Tip',function(require){
"usestrict";

varconfig=require('web.config');
varcore=require('web.core');
varWidget=require('web.Widget');
var_t=core._t;

varTip=Widget.extend({
    template:"Tip",
    xmlDependencies:['/web_tour/static/src/xml/tip.xml'],
    events:{
        click:'_onTipClicked',
        mouseenter:'_onMouseEnter',
        mouseleave:'_onMouseLeave',
        transitionend:'_onTransitionEnd',
    },

    /**
     *@param{Widget}parent
     *@param{Object}[info]descriptionofthetip,containingthefollowingkeys:
     * -content[String]thehtmlcontentofthetip
     * -event_handlers[Object]descriptionofoptionaleventhandlerstobindtothetip:
     *   -event[String]theeventname
     *   -selector[String]thejQueryselectoronwhichtheeventshouldbebound
     *   -handler[function]thehandler
     * -position[String]tip'sposition('top','right','left'or'bottom'),default'right'
     * -width[int]thewidthinpxofthetipwhenopened,default270
     * -space[int]spaceinpxbetweenanchorandtip,defaultto0,addedto
     *   thenaturalspacechosenincss
     * -hidden[boolean]iftrue,thetipwon'tbevisible(butthehandlerswillstillbe
     *   boundontheanchor,sothatthetipisconsumediftheuserclicksonit)
     * -overlay[Object]xandyvaluesforthenumberofpixelsthemouseoutdetectionarea
     *   overlapstheopenedtip,default{x:50,y:50}
     */
    init:function(parent,info){
        this._super(parent);
        this.info=_.defaults(info,{
            position:"right",
            width:270,
            space:0,
            overlay:{
                x:50,
                y:50,
            },
            content:_t("Clickheretogotothenextstep."),
            scrollContent:_t("Scrolltoreachthenextstep."),
        });
        this.position={
            top:"50%",
            left:"50%",
        };
        this.initialPosition=this.info.position;
        this.viewPortState='in';
        this._onAncestorScroll=_.throttle(this._onAncestorScroll,50);
    },
    /**
     *Attachesthetiptotheprovided$anchorand$altAnchor.
     *$altAnchorisanalternativetriggerthatcanconsumethestep.Thetipis
     *howeveronlydisplayedonthe$anchor.
     *
     *NotethatthereturnedpromisestayspendingiftheTipwidgetwas
     *destroyedinthemeantime.
     *
     *@param{jQuery}$anchorthenodeonwhichthetipshouldbeplaced
     *@param{jQuery}$altAnchoranalternativenodethatcanconsumethestep
     *@return{Promise}
     */
    attach_to:asyncfunction($anchor,$altAnchor){
        this._setupAnchor($anchor,$altAnchor);

        this.is_anchor_fixed_position=this.$anchor.css("position")==="fixed";

        //Thebodyneverneedstohavetheo_tooltip_parentclass.Itisa
        //safeplacetoputthetipintheDOMatinitializationandbeable
        //tocomputeitsdimensionsandrepositionitifrequired.
        awaitthis.appendTo(document.body);
        if(this.isDestroyed()){
            returnnewPromise(()=>{});
        }
    },
    start(){
        this.$tooltip_overlay=this.$(".o_tooltip_overlay");
        this.$tooltip_content=this.$(".o_tooltip_content");
        this.init_width=this.$el.outerWidth();
        this.init_height=this.$el.outerHeight();
        this.double_border_width=0;//TODOremovemeinmaster
        this.$el.addClass('active');
        this.el.style.setProperty('width',`${this.info.width}px`,'important');
        this.el.style.setProperty('height','auto','important');
        this.el.style.setProperty('transition','none','important');
        this.content_width=this.$el.outerWidth(true);
        this.content_height=this.$el.outerHeight(true);
        this.$tooltip_content.html(this.info.scrollContent);
        this.scrollContentWidth=this.$el.outerWidth(true);
        this.scrollContentHeight=this.$el.outerHeight(true);
        this.$el.removeClass('active');
        this.el.style.removeProperty('width');
        this.el.style.removeProperty('height');
        this.el.style.removeProperty('transition');
        this.$tooltip_content.html(this.info.content);
        this.$window=$(window);

        this.$tooltip_content.css({
            width:"100%",
            height:"100%",
        });

        _.each(this.info.event_handlers,data=>{
            this.$tooltip_content.on(data.event,data.selector,data.handler);
        });

        this._bind_anchor_events();
        this._updatePosition(true);

        this.$el.toggleClass('d-none',!!this.info.hidden);
        this.el.classList.add('o_tooltip_visible');
        core.bus.on("resize",this,_.debounce(function(){
            if(this.isDestroyed()){
                //Becauseofthedebounce,destroy()mighthavebeencalledinthemeantime.
                return;
            }
            if(this.tip_opened){
                this._to_bubble_mode(true);
            }else{
                this._reposition();
            }
        },500));

        returnthis._super.apply(this,arguments);
    },
    destroy:function(){
        this._unbind_anchor_events();
        clearTimeout(this.timerIn);
        clearTimeout(this.timerOut);
        //clearthistimeoutsothatwewon'tcall_updatePositionafterwe
        //destroythewidgetandleaveanundesiredbubble.
        clearTimeout(this._transitionEndTimer);

        //Donotremovetheparentclassifitcontainsothertooltips
        const_removeParentClass=$el=>{
            if($el.children(".o_tooltip").not(this.$el[0]).length===0){
                $el.removeClass("o_tooltip_parent");
            }
        };
        if(this.$el&&this.$ideal_location){
            _removeParentClass(this.$ideal_location);
        }
        if(this.$el&&this.$furtherIdealLocation){
            _removeParentClass(this.$furtherIdealLocation);
        }

        returnthis._super.apply(this,arguments);
    },
    /**
     *Updatesthe$anchorand$altAnchorthetipisattachedto.
     *$altAnchorisanalternativetriggerthatcanconsumethestep.Thetipis
     *howeveronlydisplayedonthe$anchor.
     *
     *@param{jQuery}$anchorthenodeonwhichthetipshouldbeplaced
     *@param{jQuery}$altAnchoranalternativenodethatcanconsumethestep
     */
    update:function($anchor,$altAnchor){
        //Weunbind/rebindeventsoneachupdatebecausewesupportwidgets
        //detachingandre-attachingnodestotheirDOMelementwithoutkeeping
        //theinitialeventhandlers,withsaidnodebeingpotentialtip
        //anchors(e.g.FieldMonetary>inputelement).
        this._unbind_anchor_events();
        if(!$anchor.is(this.$anchor)){
            this._setupAnchor($anchor,$altAnchor);
        }
        this._bind_anchor_events();
        this._delegateEvents();
        if(!this.$el){
            //Ideallythiscaseshouldnothappenbutthisisstillpossible,
            //asupdatemaybecalledbeforethe`start`methodiscalled.
            //The`start`methodiscalling_updatePositiontooanyway.
            return;
        }
        this._updatePosition(true);
    },

    //--------------------------------------------------------------------------
    //Public
    //--------------------------------------------------------------------------

    /**
     *@return{boolean}trueiftipisvisible
     */
    isShown(){
        returnthis.el&&!this.info.hidden;
    },

    //--------------------------------------------------------------------------
    //Private
    //--------------------------------------------------------------------------

    /**
     *Setsthe$anchorand$altAnchorthetipisattachedto.
     *$altAnchorisanalternativetriggerthatcanconsumethestep.Thetipis
     *howeveronlydisplayedonthe$anchor.
     *
     *@param{jQuery}$anchorthenodeonwhichthetipshouldbeplaced
     *@param{jQuery}$altAnchoranalternativenodethatcanconsumethestep
     */
    _setupAnchor:function($anchor,$altAnchor){
        this.$anchor=$anchor;
        this.$altAnchor=$altAnchor;
        this.$ideal_location=this._get_ideal_location();
        this.$furtherIdealLocation=this._get_ideal_location(this.$ideal_location);
    },
    /**
     *Figuresoutwhichdirectionthetipshouldtakeandifitisatthe
     *bottomorthetopofthetargetedelementorifit'sanindicatorto
     *scroll.Relocatesandrepositionsifnecessary.
     *
     *@private
     *@param{boolean}[forceReposition=false]
     */
    _updatePosition:function(forceReposition=false){
        if(this.info.hidden){
            return;
        }
        if(this.isDestroyed()){
            //TODOThisshouldnotbeneededifthechainofeventsleading
            //herewasfullycancelledbydestroy().
            return;
        }
        lethalfHeight=0;
        if(this.initialPosition==='right'||this.initialPosition==='left'){
            halfHeight=this.$anchor.innerHeight()/2;
        }

        constpaddingTop=parseInt(this.$ideal_location.css('padding-top'));
        consttopViewport=window.pageYOffset+paddingTop;
        constbotViewport=window.pageYOffset+window.innerHeight;
        consttopOffset=this.$anchor.offset().top;
        constbotOffset=topOffset+this.$anchor.innerHeight();

        //Checkiftheviewportstatechangetoknowifweneedtomovetheanchorofthetip.
        //up:thetargetelementisabovethecurrentviewport
        //down:thetargetelementisbelowthecurrentviewport
        //in:thetargetelementisinthecurrentviewport
        letviewPortState='in';
        letposition=this.info.position;
        if(botOffset-halfHeight<topViewport){
            viewPortState='up';
            position='bottom';
        }elseif(topOffset+halfHeight>botViewport){
            viewPortState='down';
            position='top';
        }else{
            //Adjusttheplacementofthetipregardingitsanchordepending
            //ifwecamefromthebottomorthetop.
            if(topOffset<topViewport+this.$el.innerHeight()){
                position=halfHeight?this.initialPosition:"bottom";
            }elseif(botOffset>botViewport-this.$el.innerHeight()){
                position=halfHeight?this.initialPosition:"top";
            }
        }

        //Ifthedirectionortheanchorchange:Thetippositionisupdated.
        if(forceReposition||this.info.position!==position||this.viewPortState!==viewPortState){
            this.$el.removeClass('toprightbottomleft').addClass(position);
            this.viewPortState=viewPortState;
            this.info.position=position;
            let$location;
            if(this.viewPortState==='in'){
                this.$tooltip_content.html(this.info.content);
                $location=this.$ideal_location;
            }else{
                this.$tooltip_content.html(this.info.scrollContent);
                $location=this.$furtherIdealLocation;
            }
            //Updateo_tooltip_parentclassandtipDOMlocation.Note:
            //importanttoonlyremove/addtheclasswhennecessarytonot
            //notifyaDOMmutationwhichcouldretriggerthisfunction.
            const$oldLocation=this.$el.parent();
            if(!this.tip_opened){
                if(!$location.is($oldLocation)){
                    $oldLocation.removeClass('o_tooltip_parent');
                    constcssPosition=$location.css("position");
                    if(cssPosition==="static"||cssPosition==="relative"){
                        $location.addClass("o_tooltip_parent");
                    }
                    this.$el.appendTo($location);
                }
                this._reposition();
            }
        }
    },
    _get_ideal_location:function($anchor=this.$anchor){
        var$location=this.info.location?$(this.info.location):$anchor;
        if($location.is("html,body")){
            return$(document.body);
        }

        varo;
        varp;
        do{
            $location=$location.parent();
            o=$location.css("overflow");
            p=$location.css("position");
        }while(
            $location.hasClass('dropdown-menu')||
            $location.hasClass('o_notebook_headers')||
            (
                (o==="visible"||o.includes("hidden"))&&//Possiblecasewheretheoverflow="hiddenauto"
                p!=="fixed"&&
                $location[0].tagName.toUpperCase()!=='BODY'
            )
        );

        return$location;
    },
    _reposition:function(){
        this.$el.removeClass("o_animated");

        //Reverseleft/rightpositionifdirectionisrighttoleft
        varappendAt=this.info.position;
        varrtlMap={left:'right',right:'left'};
        if(rtlMap[appendAt]&&_t.database.parameters.direction==='rtl'){
            appendAt=rtlMap[appendAt];
        }

        //Getthecorrecttip'spositiondependingofthetip'sstate
        let$parent=this.$ideal_location;
        if($parent.is('html,body')&&this.viewPortState!=="in"){
            this.el.style.setProperty('position','fixed','important');
        }else{
            this.el.style.removeProperty('position');
        }

        if(this.viewPortState==='in'){
            this.$el.position({
                my:this._get_spaced_inverted_position(appendAt),
                at:appendAt,
                of:this.$anchor,
                collision:"none",
                using:props=>{
                    this.el.style.setProperty('top',`${props.top}px`,'important');
                    this.el.style.setProperty('left',`${props.left}px`,'important');
                },
            });
        }else{
            constpaddingTop=parseInt($parent.css('padding-top'));
            constpaddingLeft=parseInt($parent.css('padding-left'));
            constpaddingRight=parseInt($parent.css('padding-right'));
            consttopPosition=$parent[0].offsetTop;
            constcenter=(paddingLeft+paddingRight)+((($parent[0].clientWidth-(paddingLeft+paddingRight))/2)-this.$el[0].offsetWidth/2);
            lettop;
            if(this.viewPortState==='up'){
                top=topPosition+this.$el.innerHeight()+paddingTop;
            }else{
                top=topPosition+$parent.innerHeight()-this.$el.innerHeight()*2;
            }
            this.el.style.setProperty('top',`${top}px`,'important');
            this.el.style.setProperty('left',`${center}px`,'important');
        }

        //Reverseoverlayifdirectionisrighttoleft
        varpositionRight=_t.database.parameters.direction==='rtl'?"right":"left";
        varpositionLeft=_t.database.parameters.direction==='rtl'?"left":"right";

        //gettheoffsetpositionofthis.$el
        //Couldn'tuseoffset()orposition()becausetheirvaluesarenotthedesiredonesinallcases
        constoffset={top:this.$el[0].offsetTop,left:this.$el[0].offsetLeft};
        this.$tooltip_overlay.css({
            top:-Math.min((this.info.position==="bottom"?this.info.space:this.info.overlay.y),offset.top),
            right:-Math.min((this.info.position===positionRight?this.info.space:this.info.overlay.x),this.$window.width()-(offset.left+this.init_width)),
            bottom:-Math.min((this.info.position==="top"?this.info.space:this.info.overlay.y),this.$window.height()-(offset.top+this.init_height)),
            left:-Math.min((this.info.position===positionLeft?this.info.space:this.info.overlay.x),offset.left),
        });
        this.position=offset;

        this.$el.addClass("o_animated");
    },
    _bind_anchor_events:function(){
        //Theconsume_eventtakenforRunningTourActionHelperistheoneof$anchorandnot$altAnchor.
        this.consume_event=this.info.consumeEvent||Tip.getConsumeEventType(this.$anchor,this.info.run);
        this.$consumeEventAnchors=this._getAnchorAndCreateEvent(this.consume_event,this.$anchor);
        if(this.$altAnchor.length){
            constconsumeEvent =this.info.consumeEvent||Tip.getConsumeEventType(this.$altAnchor,this.info.run);
            this.$consumeEventAnchors=this.$consumeEventAnchors.add(
                this._getAnchorAndCreateEvent(consumeEvent,this.$altAnchor)
            );
        }
        this.$anchor.on('mouseenter.anchor',()=>this._to_info_mode());
        this.$anchor.on('mouseleave.anchor',()=>this._to_bubble_mode());

        this.$scrolableElement=this.$ideal_location.is('html,body')?$(window):this.$ideal_location;
        this.$scrolableElement.on('scroll.Tip',()=>this._onAncestorScroll());
    },
    /**
     *Getstheanchorcorrespondingtotheprovidedargumentsandattachesthe
     *eventtothe$anchorinordertoconsumethestepaccordingly.
     *
     *@private
     *@param{String}consumeEvent
     *@param{jQuery}$anchorthenodeonwhichthetipshouldbeplaced
     *@return{jQuery}
     */
    _getAnchorAndCreateEvent:function(consumeEvent,$anchor){
        let$consumeEventAnchors=$anchor;
        if(consumeEvent==="drag"){
            //jQuery-uidraggabletriggers'drag'eventsonthe.ui-draggableelement,
            //butthetipisattachedtothe.ui-draggable-handleelementwhichmay
            //beoneofitschildren(ortheelementitself)
            $consumeEventAnchors=$anchor.closest('.ui-draggable');
        }elseif(consumeEvent==="input"&&!$anchor.is('textarea,input')){
            $consumeEventAnchors=$anchor.closest("[contenteditable='true']");
        }elseif(consumeEvent.includes('apply.daterangepicker')){
            $consumeEventAnchors=$anchor.parent().children('.o_field_date_range');
        }elseif(consumeEvent==="sort"){
            //whenanelementisdraggedinsideasortablecontainer(withclassname
            //'ui-sortable'),jQuerytriggersthe'sort'eventonthecontainer
            $consumeEventAnchors=$anchor.closest('.ui-sortable');
        }
        $consumeEventAnchors.on(consumeEvent+".anchor",(function(e){
            if(e.type!=="mousedown"||e.which===1){//onlyleftclick
                if(this.info.consumeVisibleOnly&&!this.isShown()){
                    //Donotconsumenon-displayedtips.
                    return;
                }
                this.trigger("tip_consumed");
                this._unbind_anchor_events();
            }
        }).bind(this));
        return$consumeEventAnchors;
    },
    _unbind_anchor_events:function(){
        if(this.$anchor){
            this.$anchor.off(".anchor");
        }
        if(this.$consumeEventAnchors){
            this.$consumeEventAnchors.off(".anchor");
        }
        if(this.$scrolableElement){
            this.$scrolableElement.off('.Tip');
        }
    },
    _get_spaced_inverted_position:function(position){
        if(position==="right")return"left+"+this.info.space;
        if(position==="left")return"right-"+this.info.space;
        if(position==="bottom")return"top+"+this.info.space;
        return"bottom-"+this.info.space;
    },
    _to_info_mode:function(force){
        if(this.timerOut!==undefined){
            clearTimeout(this.timerOut);
            this.timerOut=undefined;
            return;
        }
        if(this.tip_opened){
            return;
        }

        if(force===true){
            this._build_info_mode();
        }else{
            this.timerIn=setTimeout(this._build_info_mode.bind(this),100);
        }
    },
    _build_info_mode:function(){
        clearTimeout(this.timerIn);
        this.timerIn=undefined;

        this.tip_opened=true;

        varoffset=this.$el.offset();

        //Whenthis.$eldoesn'thaveanyparents,itmeansthatthetipisno
        //longerintheDOMandso,itshouldn'tbeopen.Ithappenswhenthe
        //tipisopenedafterbeingdestroyed.
        if(!this.$el.parent().length){
            return;
        }

        if(this.$el.parent()[0]!==this.$el[0].ownerDocument.body){
            this.$el.detach();
            this.el.style.setProperty('top',`${offset.top}px`,'important');
            this.el.style.setProperty('left',`${offset.left}px`,'important');
            this.$el.appendTo(this.$el[0].ownerDocument.body);
        }

        varmbLeft=0;
        varmbTop=0;
        varoverflow=false;
        varposVertical=(this.info.position==="top"||this.info.position==="bottom");
        if(posVertical){
            overflow=(offset.left+this.content_width+this.info.overlay.x>this.$window.width());
        }else{
            overflow=(offset.top+this.content_height+this.info.overlay.y>this.$window.height());
        }
        if(posVertical&&overflow||this.info.position==="left"||(_t.database.parameters.direction==='rtl'&&this.info.position=="right")){
            mbLeft-=(this.content_width-this.init_width);
        }
        if(!posVertical&&overflow||this.info.position==="top"){
            mbTop-=(this.viewPortState==='down')?this.init_height-5:(this.content_height-this.init_height);
        }


        const[contentWidth,contentHeight]=this.viewPortState==='in'
            ?[this.content_width,this.content_height]
            :[this.scrollContentWidth,this.scrollContentHeight];
        this.$el.toggleClass("inverse",overflow);
        this.$el.removeClass("o_animated").addClass("active");
        this.el.style.setProperty('width',`${contentWidth}px`,'important');
        this.el.style.setProperty('height',`${contentHeight}px`,'important');
        this.el.style.setProperty('margin-left',`${mbLeft}px`,'important');
        this.el.style.setProperty('margin-top',`${mbTop}px`,'important');

        this._transitionEndTimer=setTimeout(()=>this._onTransitionEnd(),400);
    },
    _to_bubble_mode:function(force){
        if(this.timerIn!==undefined){
            clearTimeout(this.timerIn);
            this.timerIn=undefined;
            return;
        }
        if(!this.tip_opened){
            return;
        }

        if(force===true){
            this._build_bubble_mode();
        }else{
            this.timerOut=setTimeout(this._build_bubble_mode.bind(this),300);
        }
    },
    _build_bubble_mode:function(){
        clearTimeout(this.timerOut);
        this.timerOut=undefined;

        this.tip_opened=false;
        this.$el.removeClass("active").addClass("o_animated");
        this.el.style.setProperty('width',`${this.init_width}px`,'important');
        this.el.style.setProperty('height',`${this.init_height}px`,'important');
        this.el.style.setProperty('margin','0','important');

        this._transitionEndTimer=setTimeout(()=>this._onTransitionEnd(),400);
    },

    //--------------------------------------------------------------------------
    //Handlers
    //--------------------------------------------------------------------------

    /**
     *@private
     */
    _onAncestorScroll:function(){
        if(this.tip_opened){
            this._to_bubble_mode(true);
        }else{
            this._updatePosition();
        }
    },
    /**
     *@private
     */
    _onMouseEnter:function(){
        this._to_info_mode();
    },
    /**
     *@private
     */
    _onMouseLeave:function(){
        this._to_bubble_mode();
    },
    /**
     *Ontouchdevices,closesthetipwhenclicked.
     *
     *Alsostoppropagationtoavoidundesiredbehavior,suchasthekanban
     *quickcreateclosingwhentheuserclicksonthetooltip.
     *
     *@private
     *@param{MouseEvent}ev
     */
    _onTipClicked:function(ev){
        if(config.device.touch&&this.tip_opened){
            this._to_bubble_mode();
        }

        ev.stopPropagation();
    },
    /**
     *@private
     */
    _onTransitionEnd:function(){
        if(this._transitionEndTimer){
            clearTimeout(this._transitionEndTimer);
            this._transitionEndTimer=undefined;
            if(!this.tip_opened){
                this._updatePosition(true);
            }
        }
    },
});

/**
 *@static
 *@param{jQuery}$element
 *@param{string}[run]therunparameterofthetip(onlystringsareuseful)
 */
Tip.getConsumeEventType=function($element,run){
    if($element.hasClass('o_field_many2one')||$element.hasClass('o_field_many2manytags')){
        return'autocompleteselect';
    }elseif($element.is("textarea")||$element.filter("input").is(function(){
        vartype=$(this).attr("type");
        return!type||!!type.match(/^(email|number|password|search|tel|text|url)$/);
    })){
        //FieldDateRangetriggersaspecialeventwhenusingthewidget
        if($element.hasClass("o_field_date_range")){
            return"apply.daterangepickerinput";
        }
        if(config.device.isMobile&&
            $element.closest('.o_field_widget').is('.o_field_many2one,.o_field_many2many')){
            return"click";
        }
        return"input";
    }elseif($element.hasClass('ui-draggable-handle')){
        return"drag";
    }elseif(typeofrun==='string'&&run.indexOf('drag_and_drop')===0){
        //thisisaheuristic:theelementhastobedraggedanddroppedbutit
        //doesn'thaveclass'ui-draggable-handle',sowecheckifithasan
        //ui-sortableparent,andifso,weconcludethatitseventtypeis'sort'
        if($element.closest('.ui-sortable').length){
            return'sort';
        }
    }
    return"click";
};

returnTip;

});

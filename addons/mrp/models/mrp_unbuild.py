#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

fromflectraimportapi,fields,models,_
fromflectra.exceptionsimportUserError,ValidationError
fromflectra.toolsimportfloat_compare,float_round
fromflectra.osvimportexpression

fromcollectionsimportdefaultdict


classMrpUnbuild(models.Model):
    _name="mrp.unbuild"
    _description="UnbuildOrder"
    _inherit=['mail.thread','mail.activity.mixin']
    _order='iddesc'

    name=fields.Char('Reference',copy=False,readonly=True,default=lambdax:_('New'))
    product_id=fields.Many2one(
        'product.product','Product',check_company=True,
        domain="[('type','in',['product','consu']),'|',('company_id','=',False),('company_id','=',company_id)]",
        required=True,states={'done':[('readonly',True)]})
    company_id=fields.Many2one(
        'res.company','Company',
        default=lambdas:s.env.company,
        required=True,index=True,states={'done':[('readonly',True)]})
    product_qty=fields.Float(
        'Quantity',default=1.0,
        required=True,states={'done':[('readonly',True)]})
    product_uom_id=fields.Many2one(
        'uom.uom','UnitofMeasure',
        required=True,states={'done':[('readonly',True)]})
    bom_id=fields.Many2one(
        'mrp.bom','BillofMaterial',
        domain="""[
        '|',
            ('product_id','=',product_id),
            '&',
                ('product_tmpl_id.product_variant_ids','=',product_id),
                ('product_id','=',False),
        ('type','=','normal'),
        '|',
            ('company_id','=',company_id),
            ('company_id','=',False)
        ]
""",
        states={'done':[('readonly',True)]},check_company=True)
    mo_id=fields.Many2one(
        'mrp.production','ManufacturingOrder',
        domain="[('state','=','done'),('company_id','=',company_id),('product_id','=?',product_id)]",
        states={'done':[('readonly',True)]},check_company=True)
    mo_bom_id=fields.Many2one('mrp.bom','BillofMaterialusedontheProductionOrder',related='mo_id.bom_id')
    lot_id=fields.Many2one(
        'stock.production.lot','Lot/SerialNumber',
        domain="[('product_id','=',product_id),('company_id','=',company_id)]",check_company=True,
        states={'done':[('readonly',True)]},help="Lot/SerialNumberoftheproducttounbuild.")
    has_tracking=fields.Selection(related='product_id.tracking',readonly=True)
    location_id=fields.Many2one(
        'stock.location','SourceLocation',
        domain="[('usage','=','internal'),'|',('company_id','=',False),('company_id','=',company_id)]",
        check_company=True,
        required=True,states={'done':[('readonly',True)]},help="Locationwheretheproductyouwanttounbuildis.")
    location_dest_id=fields.Many2one(
        'stock.location','DestinationLocation',
        domain="[('usage','=','internal'),'|',('company_id','=',False),('company_id','=',company_id)]",
        check_company=True,
        required=True,states={'done':[('readonly',True)]},help="Locationwhereyouwanttosendthecomponentsresultingfromtheunbuildorder.")
    consume_line_ids=fields.One2many(
        'stock.move','consume_unbuild_id',readonly=True,
        string='ConsumedDisassemblyLines')
    produce_line_ids=fields.One2many(
        'stock.move','unbuild_id',readonly=True,
        string='ProcessedDisassemblyLines')
    state=fields.Selection([
        ('draft','Draft'),
        ('done','Done')],string='Status',default='draft',index=True)
    allowed_mo_ids=fields.One2many('mrp.production',compute='_compute_allowed_mo_ids')

    def_compute_allowed_mo_ids(self):
        #thefunctionremainsasastablefixpatchthatwasremovedinmaster
        self.allowed_mo_ids=False

    @api.onchange('company_id')
    def_onchange_company_id(self):
        ifself.company_id:
            warehouse=self.env['stock.warehouse'].search([('company_id','=',self.company_id.id)],limit=1)
            ifself.location_id.company_id!=self.company_id:
                self.location_id=warehouse.lot_stock_id
            ifself.location_dest_id.company_id!=self.company_id:
                self.location_dest_id=warehouse.lot_stock_id
        else:
            self.location_id=False
            self.location_dest_id=False

    @api.onchange('mo_id')
    def_onchange_mo_id(self):
        ifself.mo_id:
            self.product_id=self.mo_id.product_id.id
            self.bom_id=self.mo_id.bom_id
            self.product_uom_id=self.mo_id.product_uom_id
            ifself.has_tracking=='serial':
                self.product_qty=1
            else:
                self.product_qty=self.mo_id.product_qty
            ifself.lot_idandself.lot_idnotinself.mo_id.move_finished_ids.move_line_ids.lot_id:
                return{'warning':{
                    'title':_("Warning"),
                    'message':_("Theselectedserialnumberdoesnotcorrespondtotheoneusedinthemanufacturingorder,pleaseselectanotherone.")
                }}

    @api.onchange('lot_id')
    def_onchange_lot_id(self):
        ifself.mo_idandself.lot_idandself.lot_idnotinself.mo_id.move_finished_ids.move_line_ids.lot_id:
            return{'warning':{
                'title':_("Warning"),
                'message':_("Theselectedserialnumberdoesnotcorrespondtotheoneusedinthemanufacturingorder,pleaseselectanotherone.")
            }}

    @api.onchange('product_id')
    def_onchange_product_id(self):
        ifself.product_id:
            self.bom_id=self.env['mrp.bom']._bom_find(product=self.product_id,company_id=self.company_id.id)
            self.product_uom_id=self.mo_id.product_id==self.product_idandself.mo_id.product_uom_id.idorself.product_id.uom_id.id

    @api.constrains('product_qty')
    def_check_qty(self):
        ifself.product_qty<=0:
            raiseValidationError(_('UnbuildOrderproductquantityhastobestrictlypositive.'))

    @api.model
    defcreate(self,vals):
        ifnotvals.get('name')orvals['name']==_('New'):
            vals['name']=self.env['ir.sequence'].next_by_code('mrp.unbuild')or_('New')
        returnsuper(MrpUnbuild,self).create(vals)

    defunlink(self):
        if'done'inself.mapped('state'):
            raiseUserError(_("Youcannotdeleteanunbuildorderifthestateis'Done'."))
        returnsuper(MrpUnbuild,self).unlink()

    defaction_unbuild(self):
        self.ensure_one()
        self._check_company()
        ifself.product_id.tracking!='none'andnotself.lot_id.id:
            raiseUserError(_('Youshouldprovidealotnumberforthefinalproduct.'))

        ifself.mo_id:
            ifself.mo_id.state!='done':
                raiseUserError(_('Youcannotunbuildaundonemanufacturingorder.'))

        consume_moves=self._generate_consume_moves()
        consume_moves._action_confirm()
        produce_moves=self._generate_produce_moves()
        produce_moves._action_confirm()

        finished_moves=consume_moves.filtered(lambdam:m.product_id==self.product_id)
        consume_moves-=finished_moves

        ifany(produce_move.has_tracking!='none'andnotself.mo_idforproduce_moveinproduce_moves):
            raiseUserError(_('Someofyourcomponentsaretracked,youhavetospecifyamanufacturingorderinordertoretrievethecorrectcomponents.'))

        ifany(consume_move.has_tracking!='none'andnotself.mo_idforconsume_moveinconsume_moves):
            raiseUserError(_('Someofyourbyproductsaretracked,youhavetospecifyamanufacturingorderinordertoretrievethecorrectbyproducts.'))

        forfinished_moveinfinished_moves:
            iffinished_move.has_tracking!='none':
                self.env['stock.move.line'].create({
                    'move_id':finished_move.id,
                    'lot_id':self.lot_id.id,
                    'qty_done':finished_move.product_uom_qty,
                    'product_id':finished_move.product_id.id,
                    'product_uom_id':finished_move.product_uom.id,
                    'location_id':finished_move.location_id.id,
                    'location_dest_id':finished_move.location_dest_id.id,
                })
            else:
                finished_move.quantity_done=finished_move.product_uom_qty

        #TODO:WillfailifuserdomorethanoneunbuildwithlotonthesameMO.Needtocheckwhatotherunbuildhasareadytook
        qty_already_used=defaultdict(float)
        formoveinproduce_moves|consume_moves:
            ifmove.has_tracking!='none':
                original_move=moveinproduce_movesandself.mo_id.move_raw_idsorself.mo_id.move_finished_ids
                original_move=original_move.filtered(lambdam:m.product_id==move.product_id)
                needed_quantity=move.product_uom_qty
                moves_lines=original_move.mapped('move_line_ids')
                ifmoveinproduce_movesandself.lot_id:
                    moves_lines=moves_lines.filtered(lambdaml:self.lot_idinml.produce_line_ids.lot_id) #FIXMEsle:doublecheckwitharm
                formove_lineinmoves_lines:
                    #Iterateoverallmove_linesuntilweunbuildedthecorrectquantity.
                    taken_quantity=min(needed_quantity,move_line.qty_done-qty_already_used[move_line])
                    iftaken_quantity:
                        self.env['stock.move.line'].create({
                            'move_id':move.id,
                            'lot_id':move_line.lot_id.id,
                            'qty_done':taken_quantity,
                            'product_id':move.product_id.id,
                            'product_uom_id':move_line.product_uom_id.id,
                            'location_id':move.location_id.id,
                            'location_dest_id':move.location_dest_id.id,
                        })
                        needed_quantity-=taken_quantity
                        qty_already_used[move_line]+=taken_quantity
            else:
                move.quantity_done=float_round(move.product_uom_qty,precision_rounding=move.product_uom.rounding)

        finished_moves._action_done()
        consume_moves._action_done()
        produce_moves._action_done()
        produced_move_line_ids=produce_moves.mapped('move_line_ids').filtered(lambdaml:ml.qty_done>0)
        consume_moves.mapped('move_line_ids').write({'produce_line_ids':[(6,0,produced_move_line_ids.ids)]})

        returnself.write({'state':'done'})

    def_generate_consume_moves(self):
        moves=self.env['stock.move']
        forunbuildinself:
            ifunbuild.mo_id:
                finished_moves=unbuild.mo_id.move_finished_ids.filtered(lambdamove:move.state=='done')
                factor=unbuild.product_qty/unbuild.mo_id.product_uom_id._compute_quantity(unbuild.mo_id.product_qty,unbuild.product_uom_id)
                forfinished_moveinfinished_moves:
                    moves+=unbuild._generate_move_from_existing_move(finished_move,factor,unbuild.location_id,finished_move.location_id)
            else:
                factor=unbuild.product_uom_id._compute_quantity(unbuild.product_qty,unbuild.bom_id.product_uom_id)/unbuild.bom_id.product_qty
                moves+=unbuild._generate_move_from_bom_line(self.product_id,self.product_uom_id,unbuild.product_qty)
                forbyproductinunbuild.bom_id.byproduct_ids:
                    quantity=byproduct.product_qty*factor
                    moves+=unbuild._generate_move_from_bom_line(byproduct.product_id,byproduct.product_uom_id,quantity,byproduct_id=byproduct.id)
        returnmoves

    def_generate_produce_moves(self):
        moves=self.env['stock.move']
        forunbuildinself:
            ifunbuild.mo_id:
                raw_moves=unbuild.mo_id.move_raw_ids.filtered(lambdamove:move.state=='done')
                factor=unbuild.product_qty/unbuild.mo_id.product_uom_id._compute_quantity(unbuild.mo_id.product_qty,unbuild.product_uom_id)
                forraw_moveinraw_moves:
                    moves+=unbuild._generate_move_from_existing_move(raw_move,factor,raw_move.location_dest_id,self.location_dest_id)
            else:
                factor=unbuild.product_uom_id._compute_quantity(unbuild.product_qty,unbuild.bom_id.product_uom_id)/unbuild.bom_id.product_qty
                boms,lines=unbuild.bom_id.explode(unbuild.product_id,factor,picking_type=unbuild.bom_id.picking_type_id)
                forline,line_datainlines:
                    moves+=unbuild._generate_move_from_bom_line(line.product_id,line.product_uom_id,line_data['qty'],bom_line_id=line.id)
        returnmoves

    def_generate_move_from_existing_move(self,move,factor,location_id,location_dest_id):
        returnself.env['stock.move'].create({
            'name':self.name,
            'date':self.create_date,
            'product_id':move.product_id.id,
            'product_uom_qty':move.product_uom_qty*factor,
            'product_uom':move.product_uom.id,
            'procure_method':'make_to_stock',
            'location_dest_id':location_dest_id.id,
            'location_id':location_id.id,
            'warehouse_id':location_dest_id.get_warehouse().id,
            'unbuild_id':self.id,
            'company_id':move.company_id.id,
            'origin_returned_move_id':move.id,
        })

    def_generate_move_from_bom_line(self,product,product_uom,quantity,bom_line_id=False,byproduct_id=False):
        product_prod_location=product.with_company(self.company_id).property_stock_production
        location_id=bom_line_idandproduct_prod_locationorself.location_id
        location_dest_id=bom_line_idandself.location_dest_idorproduct_prod_location
        warehouse=location_dest_id.get_warehouse()
        returnself.env['stock.move'].create({
            'name':self.name,
            'date':self.create_date,
            'bom_line_id':bom_line_id,
            'byproduct_id':byproduct_id,
            'product_id':product.id,
            'product_uom_qty':quantity,
            'product_uom':product_uom.id,
            'procure_method':'make_to_stock',
            'location_dest_id':location_dest_id.id,
            'location_id':location_id.id,
            'warehouse_id':warehouse.id,
            'unbuild_id':self.id,
            'company_id':self.company_id.id,
        })

    defaction_validate(self):
        self.ensure_one()
        precision=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')
        available_qty=self.env['stock.quant']._get_available_quantity(self.product_id,self.location_id,self.lot_id,strict=True)
        unbuild_qty=self.product_uom_id._compute_quantity(self.product_qty,self.product_id.uom_id)
        iffloat_compare(available_qty,unbuild_qty,precision_digits=precision)>=0:
            returnself.action_unbuild()
        else:
            return{
                'name':self.product_id.display_name+_(':InsufficientQuantityToUnbuild'),
                'view_mode':'form',
                'res_model':'stock.warn.insufficient.qty.unbuild',
                'view_id':self.env.ref('mrp.stock_warn_insufficient_qty_unbuild_form_view').id,
                'type':'ir.actions.act_window',
                'context':{
                    'default_product_id':self.product_id.id,
                    'default_location_id':self.location_id.id,
                    'default_unbuild_id':self.id,
                    'default_quantity':unbuild_qty,
                    'default_product_uom_name':self.product_id.uom_name
                },
                'target':'new'
            }

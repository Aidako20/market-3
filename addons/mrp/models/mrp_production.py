#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

importjson
importdatetime
importmath
importoperatoraspy_operator
importre

fromcollectionsimportdefaultdict
fromdateutil.relativedeltaimportrelativedelta
fromitertoolsimportgroupby

fromflectraimportapi,fields,models,_
fromflectra.exceptionsimportAccessError,UserError,ValidationError
fromflectra.toolsimportfloat_compare,float_round,float_is_zero,format_datetime
fromflectra.tools.miscimportformat_date

fromflectra.addons.stock.models.stock_moveimportPROCUREMENT_PRIORITIES

SIZE_BACK_ORDER_NUMERING=3


classMrpProduction(models.Model):
    """ManufacturingOrders"""
    _name='mrp.production'
    _description='ProductionOrder'
    _date_name='date_planned_start'
    _inherit=['mail.thread','mail.activity.mixin']
    _order='prioritydesc,date_planned_startasc,id'

    @api.model
    def_get_default_picking_type(self):
        company_id=self.env.context.get('default_company_id',self.env.company.id)
        returnself.env['stock.picking.type'].search([
            ('code','=','mrp_operation'),
            ('warehouse_id.company_id','=',company_id),
        ],limit=1).id

    @api.model
    def_get_default_location_src_id(self):
        location=False
        company_id=self.env.context.get('default_company_id',self.env.company.id)
        ifself.env.context.get('default_picking_type_id'):
            location=self.env['stock.picking.type'].browse(self.env.context['default_picking_type_id']).default_location_src_id
        ifnotlocation:
            location=self.env['stock.warehouse'].search([('company_id','=',company_id)],limit=1).lot_stock_id
        returnlocationandlocation.idorFalse

    @api.model
    def_get_default_location_dest_id(self):
        location=False
        company_id=self.env.context.get('default_company_id',self.env.company.id)
        ifself._context.get('default_picking_type_id'):
            location=self.env['stock.picking.type'].browse(self.env.context['default_picking_type_id']).default_location_dest_id
        ifnotlocation:
            location=self.env['stock.warehouse'].search([('company_id','=',company_id)],limit=1).lot_stock_id
        returnlocationandlocation.idorFalse

    @api.model
    def_get_default_date_planned_finished(self):
        ifself.env.context.get('default_date_planned_start'):
            returnfields.Datetime.to_datetime(self.env.context.get('default_date_planned_start'))+datetime.timedelta(hours=1)
        returndatetime.datetime.now()+datetime.timedelta(hours=1)

    @api.model
    def_get_default_date_planned_start(self):
        ifself.env.context.get('default_date_deadline'):
            returnfields.Datetime.to_datetime(self.env.context.get('default_date_deadline'))
        returndatetime.datetime.now()

    @api.model
    def_get_default_is_locked(self):
        returnself.user_has_groups('mrp.group_locked_by_default')

    name=fields.Char(
        'Reference',copy=False,readonly=True,default=lambdax:_('New'))
    priority=fields.Selection(
        PROCUREMENT_PRIORITIES,string='Priority',default='0',index=True,
        help="ComponentswillbereservedfirstfortheMOwiththehighestpriorities.")
    backorder_sequence=fields.Integer("BackorderSequence",default=0,copy=False,help="Backordersequence,ifequalsto0meansthereisnotrelatedbackorder")
    origin=fields.Char(
        'Source',copy=False,
        states={'done':[('readonly',True)],'cancel':[('readonly',True)]},
        help="Referenceofthedocumentthatgeneratedthisproductionorderrequest.")

    product_id=fields.Many2one(
        'product.product','Product',
        domain="""[
            ('type','in',['product','consu']),
            '|',
                ('company_id','=',False),
                ('company_id','=',company_id)
        ]
        """,
        readonly=True,required=True,check_company=True,
        states={'draft':[('readonly',False)]})
    product_tracking=fields.Selection(related='product_id.tracking')
    allowed_product_ids=fields.Many2many('product.product',compute='_compute_allowed_product_ids')
    product_tmpl_id=fields.Many2one('product.template','ProductTemplate',related='product_id.product_tmpl_id')
    product_qty=fields.Float(
        'QuantityToProduce',
        default=1.0,digits='ProductUnitofMeasure',
        readonly=True,required=True,tracking=True,
        states={'draft':[('readonly',False)]})
    product_uom_id=fields.Many2one(
        'uom.uom','ProductUnitofMeasure',
        readonly=True,required=True,
        states={'draft':[('readonly',False)]},domain="[('category_id','=',product_uom_category_id)]")
    lot_producing_id=fields.Many2one(
        'stock.production.lot',string='Lot/SerialNumber',copy=False,
        domain="[('product_id','=',product_id),('company_id','=',company_id)]",check_company=True)
    qty_producing=fields.Float(string="QuantityProducing",digits='ProductUnitofMeasure',copy=False)
    product_uom_category_id=fields.Many2one(related='product_id.uom_id.category_id')
    product_uom_qty=fields.Float(string='TotalQuantity',compute='_compute_product_uom_qty',store=True)
    picking_type_id=fields.Many2one(
        'stock.picking.type','OperationType',
        domain="[('code','=','mrp_operation'),('company_id','=',company_id)]",
        default=_get_default_picking_type,required=True,check_company=True,
        readonly=True,states={'draft':[('readonly',False)]})
    use_create_components_lots=fields.Boolean(related='picking_type_id.use_create_components_lots')
    location_src_id=fields.Many2one(
        'stock.location','ComponentsLocation',
        default=_get_default_location_src_id,
        readonly=True,required=True,
        domain="[('usage','=','internal'),'|',('company_id','=',False),('company_id','=',company_id)]",
        states={'draft':[('readonly',False)]},check_company=True,
        help="Locationwherethesystemwilllookforcomponents.")
    location_dest_id=fields.Many2one(
        'stock.location','FinishedProductsLocation',
        default=_get_default_location_dest_id,
        readonly=True,required=True,
        domain="[('usage','=','internal'),'|',('company_id','=',False),('company_id','=',company_id)]",
        states={'draft':[('readonly',False)]},check_company=True,
        help="Locationwherethesystemwillstockthefinishedproducts.")
    date_planned_start=fields.Datetime(
        'ScheduledDate',copy=False,default=_get_default_date_planned_start,
        help="Dateatwhichyouplantostarttheproduction.",
        index=True,required=True)
    date_planned_finished=fields.Datetime(
        'ScheduledEndDate',
        default=_get_default_date_planned_finished,
        help="Dateatwhichyouplantofinishtheproduction.",
        copy=False)
    date_deadline=fields.Datetime(
        'Deadline',copy=False,store=True,readonly=True,compute='_compute_date_deadline',inverse='_set_date_deadline',
        help="Informativedateallowingtodefinewhenthemanufacturingordershouldbeprocessedatthelatesttofulfilldeliveryontime.")
    date_start=fields.Datetime('StartDate',copy=False,index=True,readonly=True)
    date_finished=fields.Datetime('EndDate',copy=False,index=True,readonly=True)
    bom_id=fields.Many2one(
        'mrp.bom','BillofMaterial',
        readonly=True,states={'draft':[('readonly',False)]},
        domain="""[
        '&',
            '|',
                ('company_id','=',False),
                ('company_id','=',company_id),
            '&',
                '|',
                    ('product_id','=',product_id),
                    '&',
                        ('product_tmpl_id.product_variant_ids','=',product_id),
                        ('product_id','=',False),
        ('type','=','normal')]""",
        check_company=True,
        help="BillofMaterialsallowyoutodefinethelistofrequiredcomponentstomakeafinishedproduct.")

    state=fields.Selection([
        ('draft','Draft'),
        ('confirmed','Confirmed'),
        ('progress','InProgress'),
        ('to_close','ToClose'),
        ('done','Done'),
        ('cancel','Cancelled')],string='State',
        compute='_compute_state',copy=False,index=True,readonly=True,
        store=True,tracking=True,
        help="*Draft:TheMOisnotconfirmedyet.\n"
             "*Confirmed:TheMOisconfirmed,thestockrulesandthereorderingofthecomponentsaretrigerred.\n"
             "*InProgress:Theproductionhasstarted(ontheMOorontheWO).\n"
             "*ToClose:Theproductionisdone,theMOhastobeclosed.\n"
             "*Done:TheMOisclosed,thestockmovesareposted.\n"
             "*Cancelled:TheMOhasbeencancelled,can'tbeconfirmedanymore.")
    reservation_state=fields.Selection([
        ('confirmed','Waiting'),
        ('assigned','Ready'),
        ('waiting','WaitingAnotherOperation')],
        string='MaterialAvailability',
        compute='_compute_state',copy=False,index=True,readonly=True,
        store=True,tracking=True,
        help="*Ready:Thematerialisavailabletostarttheproduction.\n\
            *Waiting:Thematerialisnotavailabletostarttheproduction.\n\
            Thematerialavailabilityisimpactedbythemanufacturingreadiness\
            definedontheBoM.")

    move_raw_ids=fields.One2many(
        'stock.move','raw_material_production_id','Components',
        copy=False,states={'done':[('readonly',True)],'cancel':[('readonly',True)]},
        domain=[('scrapped','=',False)])
    move_finished_ids=fields.One2many(
        'stock.move','production_id','FinishedProducts',
        copy=False,states={'done':[('readonly',True)],'cancel':[('readonly',True)]},
        domain=[('scrapped','=',False)])
    move_byproduct_ids=fields.One2many('stock.move',compute='_compute_move_byproduct_ids',inverse='_set_move_byproduct_ids')
    finished_move_line_ids=fields.One2many(
        'stock.move.line',compute='_compute_lines',inverse='_inverse_lines',string="FinishedProduct"
        )
    workorder_ids=fields.One2many(
        'mrp.workorder','production_id','WorkOrders',copy=True)
    workorder_done_count=fields.Integer('#DoneWorkOrders',compute='_compute_workorder_done_count')
    move_dest_ids=fields.One2many('stock.move','created_production_id',
        string="StockMovementsofProducedGoods")

    unreserve_visible=fields.Boolean(
        'AllowedtoUnreserveProduction',compute='_compute_unreserve_visible',
        help='Technicalfieldtocheckwhenwecanunreserve')
    reserve_visible=fields.Boolean(
        'AllowedtoReserveProduction',compute='_compute_unreserve_visible',
        help='Technicalfieldtocheckwhenwecanreservequantities')
    user_id=fields.Many2one(
        'res.users','Responsible',default=lambdaself:self.env.user,
        states={'done':[('readonly',True)],'cancel':[('readonly',True)]},
        domain=lambdaself:[('groups_id','in',self.env.ref('mrp.group_mrp_user').id)])
    company_id=fields.Many2one(
        'res.company','Company',default=lambdaself:self.env.company,
        index=True,required=True)

    qty_produced=fields.Float(compute="_get_produced_qty",string="QuantityProduced")
    procurement_group_id=fields.Many2one(
        'procurement.group','ProcurementGroup',
        copy=False)
    product_description_variants=fields.Char('CustomDescription')
    orderpoint_id=fields.Many2one('stock.warehouse.orderpoint','Orderpoint',index=True)
    propagate_cancel=fields.Boolean(
        'Propagatecancelandsplit',
        help='Ifchecked,whenthepreviousmoveofthemove(whichwasgeneratedbyanextprocurement)iscancelledorsplit,themovegeneratedbythismovewilltoo')
    delay_alert_date=fields.Datetime('DelayAlertDate',compute='_compute_delay_alert_date',search='_search_delay_alert_date')
    json_popover=fields.Char('JSONdataforthepopoverwidget',compute='_compute_json_popover')
    scrap_ids=fields.One2many('stock.scrap','production_id','Scraps')
    scrap_count=fields.Integer(compute='_compute_scrap_move_count',string='ScrapMove')
    is_locked=fields.Boolean('IsLocked',default=_get_default_is_locked,copy=False)
    is_planned=fields.Boolean('ItsOperationsarePlanned',compute='_compute_is_planned',search='_search_is_planned')

    show_final_lots=fields.Boolean('ShowFinalLots',compute='_compute_show_lots')
    production_location_id=fields.Many2one('stock.location',"ProductionLocation",compute="_compute_production_location",store=True)
    picking_ids=fields.Many2many('stock.picking',compute='_compute_picking_ids',string='Pickingassociatedtothismanufacturingorder')
    delivery_count=fields.Integer(string='DeliveryOrders',compute='_compute_picking_ids')
    confirm_cancel=fields.Boolean(compute='_compute_confirm_cancel')
    consumption=fields.Selection([
        ('flexible','Allowed'),
        ('warning','Allowedwithwarning'),
        ('strict','Blocked')],
        required=True,
        readonly=True,
        default='flexible',
    )

    mrp_production_child_count=fields.Integer("NumberofgeneratedMO",compute='_compute_mrp_production_child_count')
    mrp_production_source_count=fields.Integer("NumberofsourceMO",compute='_compute_mrp_production_source_count')
    mrp_production_backorder_count=fields.Integer("Countoflinkedbackorder",compute='_compute_mrp_production_backorder')
    show_lock=fields.Boolean('ShowLock/unlockbuttons',compute='_compute_show_lock')
    components_availability=fields.Char(
        string="ComponentAvailability",compute='_compute_components_availability')
    components_availability_state=fields.Selection([
        ('available','Available'),
        ('expected','Expected'),
        ('late','Late')],compute='_compute_components_availability')
    show_lot_ids=fields.Boolean('Displaytheserialnumbershortcutonthemoves',compute='_compute_show_lot_ids')

    @api.depends('product_id','bom_id','company_id')
    def_compute_allowed_product_ids(self):
        forproductioninself:
            product_domain=[
                ('type','in',['product','consu']),
                '|',
                    ('company_id','=',False),
                    ('company_id','=',production.company_id.id)
            ]
            ifproduction.bom_id:
                ifproduction.bom_id.product_id:
                    product_domain+=[('id','=',production.bom_id.product_id.id)]
                else:
                    product_domain+=[('id','in',production.bom_id.product_tmpl_id.product_variant_ids.ids)]
            production.allowed_product_ids=self.env['product.product'].search(product_domain)

    @api.depends('procurement_group_id.stock_move_ids.created_production_id.procurement_group_id.mrp_production_ids',
                 'procurement_group_id.stock_move_ids.move_orig_ids.created_production_id.procurement_group_id.mrp_production_ids')
    def_compute_mrp_production_child_count(self):
        forproductioninself:
            production.mrp_production_child_count=len(production._get_children())

    @api.depends('procurement_group_id.mrp_production_ids.move_dest_ids.group_id.mrp_production_ids',
                 'procurement_group_id.stock_move_ids.move_dest_ids.group_id.mrp_production_ids')
    def_compute_mrp_production_source_count(self):
        forproductioninself:
            production.mrp_production_source_count=len(production._get_sources())

    @api.depends('procurement_group_id.mrp_production_ids')
    def_compute_mrp_production_backorder(self):
        forproductioninself:
            production.mrp_production_backorder_count=len(production.procurement_group_id.mrp_production_ids)

    @api.depends('move_raw_ids','state','date_planned_start','move_raw_ids.forecast_availability','move_raw_ids.forecast_expected_date')
    def_compute_components_availability(self):
        self.components_availability=False
        self.components_availability_state='available'
        productions=self.filtered(lambdamo:mo.statenotin['cancel','draft','done'])
        productions.components_availability=_('Available')
        forproductioninproductions:
            forecast_date=max(production.move_raw_ids.filtered('forecast_expected_date').mapped('forecast_expected_date'),default=False)
            ifany(float_compare(move.forecast_availability,move.product_qty,move.product_id.uom_id.rounding)==-1formoveinproduction.move_raw_ids):
                production.components_availability=_('NotAvailable')
                production.components_availability_state='late'
            elifforecast_date:
                production.components_availability=_('Exp%s',format_date(self.env,forecast_date))
                production.components_availability_state='late'ifforecast_date>production.date_planned_startelse'expected'

    @api.depends('move_finished_ids.date_deadline')
    def_compute_date_deadline(self):
        forproductioninself:
            production.date_deadline=min(production.move_finished_ids.filtered('date_deadline').mapped('date_deadline'),default=production.date_deadlineorFalse)

    def_set_date_deadline(self):
        forproductioninself:
            production.move_finished_ids.date_deadline=production.date_deadline

    @api.depends("workorder_ids.date_planned_start","workorder_ids.date_planned_finished")
    def_compute_is_planned(self):
        forproductioninself:
            ifproduction.workorder_ids:
                production.is_planned=any(wo.date_planned_startandwo.date_planned_finishedforwoinproduction.workorder_idsifwo.state!='done')
            else:
                production.is_planned=False

    def_search_is_planned(self,operator,value):
        ifoperatornotin('=','!='):
            raiseUserError(_('Invaliddomainoperator%s',operator))

        ifvaluenotin(False,True):
            raiseUserError(_('Invaliddomainrightoperand%s',value))
        query=self.env['mrp.workorder'].sudo()._search([
            ('state','!=','done'),
            ('date_planned_start','!=',False),
            ('date_planned_finished','!=',False),
            ('production_id.state','notin',('done','cancel'))])
        op='in'ifoperator=='='else'notin'
        return[('workorder_ids',op,query)]

    @api.depends('move_raw_ids.delay_alert_date')
    def_compute_delay_alert_date(self):
        delay_alert_date_data=self.env['stock.move'].read_group([('id','in',self.move_raw_ids.ids),('delay_alert_date','!=',False)],['delay_alert_date:max'],'raw_material_production_id')
        delay_alert_date_data={data['raw_material_production_id'][0]:data['delay_alert_date']fordataindelay_alert_date_data}
        forproductioninself:
            production.delay_alert_date=delay_alert_date_data.get(production.id,False)

    def_compute_json_popover(self):
        forproductioninself:
            production.json_popover=json.dumps({
                'popoverTemplate':'stock.PopoverStockRescheduling',
                'delay_alert_date':format_datetime(self.env,production.delay_alert_date,dt_format=False)ifproduction.delay_alert_dateelseFalse,
                'late_elements':[{
                        'id':late_document.id,
                        'name':late_document.display_name,
                        'model':late_document._name,
                    }forlate_documentinproduction.move_raw_ids.filtered(lambdam:m.delay_alert_date).move_orig_ids._delay_alert_get_documents()
                ]
            })

    @api.depends('move_raw_ids.state','move_finished_ids.state')
    def_compute_confirm_cancel(self):
        """Ifthemanufacturingordercontainssomedonemove(viaanintermediate
        postinventory),theuserhastoconfirmthecancellation.
        """
        domain=[
            ('state','=','done'),
            '|',
                ('production_id','in',self.ids),
                ('raw_material_production_id','in',self.ids)
        ]
        res=self.env['stock.move'].read_group(domain,['state','production_id','raw_material_production_id'],['production_id','raw_material_production_id'],lazy=False)
        productions_with_done_move={}
        forrecinres:
            production_record=rec['production_id']orrec['raw_material_production_id']
            ifproduction_record:
                productions_with_done_move[production_record[0]]=True
        forproductioninself:
            production.confirm_cancel=productions_with_done_move.get(production.id,False)

    @api.depends('procurement_group_id')
    def_compute_picking_ids(self):
        fororderinself:
            order.picking_ids=self.env['stock.picking'].search([
                ('group_id','=',order.procurement_group_id.id),('group_id','!=',False),
            ])
            order.delivery_count=len(order.picking_ids)

    defaction_view_mo_delivery(self):
        """Thisfunctionreturnsanactionthatdisplaypickingrelatedto
        manufacturingorderorders.Itcaneitherbeainalistorinaform
        view,ifthereisonlyonepickingtoshow.
        """
        self.ensure_one()
        action=self.env["ir.actions.actions"]._for_xml_id("stock.action_picking_tree_all")
        pickings=self.mapped('picking_ids')
        iflen(pickings)>1:
            action['domain']=[('id','in',pickings.ids)]
        elifpickings:
            form_view=[(self.env.ref('stock.view_picking_form').id,'form')]
            if'views'inaction:
                action['views']=form_view+[(state,view)forstate,viewinaction['views']ifview!='form']
            else:
                action['views']=form_view
            action['res_id']=pickings.id
        action['context']=dict(self._context,default_origin=self.name,create=False)
        returnaction

    @api.depends('product_uom_id','product_qty','product_id.uom_id')
    def_compute_product_uom_qty(self):
        forproductioninself:
            ifproduction.product_id.uom_id!=production.product_uom_id:
                production.product_uom_qty=production.product_uom_id._compute_quantity(production.product_qty,production.product_id.uom_id)
            else:
                production.product_uom_qty=production.product_qty

    @api.depends('product_id','company_id')
    def_compute_production_location(self):
        ifnotself.company_id:
            return
        location_by_company=self.env['stock.location'].read_group([
            ('company_id','in',self.company_id.ids),
            ('usage','=','production')
        ],['company_id','ids:array_agg(id)'],['company_id'])
        location_by_company={lbc['company_id'][0]:lbc['ids']forlbcinlocation_by_company}
        forproductioninself:
            ifproduction.product_id:
                production.production_location_id=production.product_id.with_company(production.company_id).property_stock_production
            else:
                production.production_location_id=location_by_company.get(production.company_id.id)[0]

    @api.depends('product_id.tracking')
    def_compute_show_lots(self):
        forproductioninself:
            production.show_final_lots=production.product_id.tracking!='none'

    def_inverse_lines(self):
        """Littlehacktomakesurethatwhenyouchangesomethingontheseobjects,itgetssaved"""
        pass

    @api.depends('move_finished_ids.move_line_ids')
    def_compute_lines(self):
        forproductioninself:
            production.finished_move_line_ids=production.move_finished_ids.mapped('move_line_ids')

    @api.depends('workorder_ids.state')
    def_compute_workorder_done_count(self):
        data=self.env['mrp.workorder'].read_group([
            ('production_id','in',self.ids),
            ('state','=','done')],['production_id'],['production_id'])
        count_data=dict((item['production_id'][0],item['production_id_count'])foritemindata)
        forproductioninself:
            production.workorder_done_count=count_data.get(production.id,0)

    @api.depends(
        'move_raw_ids.state','move_raw_ids.quantity_done','move_finished_ids.state',
        'workorder_ids','workorder_ids.state','product_qty','qty_producing')
    def_compute_state(self):
        """Computetheproductionstate.Itusethesameprocessthanstock
        picking.Itexists3extrastepsforproduction:
        -progress:Atleastoneitemisproducedorconsumed.
        -to_close:Thequantityproducedisgreaterthanthequantityto
        produceandallworkordershasbeenfinished.
        """
        #TODO:duplicatedcodewithstock_picking.py
        forproductioninself:
            ifnotproduction.move_raw_ids:
                production.state='draft'
            elifall(move.state=='draft'formoveinproduction.move_raw_ids):
                production.state='draft'
            elifall(move.state=='cancel'formoveinproduction.move_raw_ids):
                production.state='cancel'
            elif(
                all(move.statein('cancel','done')formoveinproduction.move_raw_ids)
                andall(move.statein('cancel','done')formoveinproduction.move_finished_ids)
            ):
                production.state='done'
            elifproduction.workorder_idsandall(wo_statein('done','cancel')forwo_stateinproduction.workorder_ids.mapped('state')):
                production.state='to_close'
            elifnotproduction.workorder_idsandfloat_compare(production.qty_producing,production.product_qty,precision_rounding=production.product_uom_id.rounding)>=0:
                production.state='to_close'
            elifany(wo_statein('progress','done')forwo_stateinproduction.workorder_ids.mapped('state')):
                production.state='progress'
            elifnotfloat_is_zero(production.qty_producing,precision_rounding=production.product_uom_id.rounding):
                production.state='progress'
            elifany(notfloat_is_zero(move.quantity_done,precision_rounding=move.product_uom.roundingormove.product_id.uom_id.rounding)formoveinproduction.move_raw_ids):
                production.state='progress'
            else:
                production.state='confirmed'

            #Computereservationstate
            #Statewherethereservationdoesnotmatter.
            production.reservation_state=False
            #Computereservationstateaccordingtoitscomponent'smoves.
            ifproduction.statenotin('draft','done','cancel'):
                relevant_move_state=production.move_raw_ids._get_relevant_state_among_moves()
                ifrelevant_move_state=='partially_available':
                    ifproduction.bom_id.operation_idsandproduction.bom_id.ready_to_produce=='asap':
                        production.reservation_state=production._get_ready_to_produce_state()
                    else:
                        production.reservation_state='confirmed'
                elifrelevant_move_state!='draft':
                    production.reservation_state=relevant_move_state

    @api.depends('move_raw_ids','state','move_raw_ids.product_uom_qty')
    def_compute_unreserve_visible(self):
        fororderinself:
            already_reserved=order.statenotin('done','cancel')andorder.mapped('move_raw_ids.move_line_ids')
            any_quantity_done=any(m.quantity_done>0forminorder.move_raw_ids)

            order.unreserve_visible=notany_quantity_doneandalready_reserved
            order.reserve_visible=order.statein('confirmed','progress','to_close')andany(move.product_uom_qtyandmove.statein['confirmed','partially_available']formoveinorder.move_raw_ids)

    @api.depends('workorder_ids.state','move_finished_ids','move_finished_ids.quantity_done')
    def_get_produced_qty(self):
        forproductioninself:
            done_moves=production.move_finished_ids.filtered(lambdax:x.state!='cancel'andx.product_id.id==production.product_id.id)
            qty_produced=sum(done_moves.mapped('quantity_done'))
            production.qty_produced=qty_produced
        returnTrue

    def_compute_scrap_move_count(self):
        data=self.env['stock.scrap'].read_group([('production_id','in',self.ids)],['production_id'],['production_id'])
        count_data=dict((item['production_id'][0],item['production_id_count'])foritemindata)
        forproductioninself:
            production.scrap_count=count_data.get(production.id,0)

    @api.depends('move_finished_ids')
    def_compute_move_byproduct_ids(self):
        fororderinself:
            order.move_byproduct_ids=order.move_finished_ids.filtered(lambdam:m.product_id!=order.product_id)

    def_set_move_byproduct_ids(self):
        move_finished_ids=self.move_finished_ids.filtered(lambdam:m.product_id==self.product_id)
        self.move_finished_ids=move_finished_ids|self.move_byproduct_ids

    @api.depends('state')
    def_compute_show_lock(self):
        fororderinself:
            order.show_lock=self.env.user.has_group('mrp.group_locked_by_default')andorder.idisnotFalseandorder.statenotin{'cancel','draft'}

    @api.depends('state','move_raw_ids')
    def_compute_show_lot_ids(self):
        fororderinself:
            order.show_lot_ids=order.state!='draft'andany(m.product_id.tracking=='serial'forminorder.move_raw_ids)

    _sql_constraints=[
        ('name_uniq','unique(name,company_id)','ReferencemustbeuniqueperCompany!'),
        ('qty_positive','check(product_qty>0)','Thequantitytoproducemustbepositive!'),
    ]

    @api.model
    def_search_delay_alert_date(self,operator,value):
        late_stock_moves=self.env['stock.move'].search([('delay_alert_date',operator,value)])
        return['|',('move_raw_ids','in',late_stock_moves.ids),('move_finished_ids','in',late_stock_moves.ids)]

    @api.onchange('company_id')
    defonchange_company_id(self):
        ifself.company_id:
            ifself.move_raw_ids:
                self.move_raw_ids.update({'company_id':self.company_id})
            ifself.picking_type_idandself.picking_type_id.company_id!=self.company_id:
                self.picking_type_id=self.env['stock.picking.type'].search([
                    ('code','=','mrp_operation'),
                    ('warehouse_id.company_id','=',self.company_id.id),
                ],limit=1).id

    @api.onchange('product_id','picking_type_id','company_id')
    defonchange_product_id(self):
        """FindsUoMofchangedproduct."""
        ifnotself.product_id:
            self.bom_id=False
        elifnotself.bom_idorself.bom_id.product_tmpl_id!=self.product_tmpl_idor(self.bom_id.product_idandself.bom_id.product_id!=self.product_id):
            picking_type_id=self._context.get('default_picking_type_id')
            picking_type=picking_type_idandself.env['stock.picking.type'].browse(picking_type_id)
            bom=self.env['mrp.bom']._bom_find(product=self.product_id,picking_type=picking_type,company_id=self.company_id.id,bom_type='normal')
            ifbom:
                self.bom_id=bom.id
                self.product_qty=self.bom_id.product_qty
                self.product_uom_id=self.bom_id.product_uom_id.id
            else:
                self.bom_id=False
                self.product_uom_id=self.product_id.uom_id.id

    @api.onchange('product_qty','product_uom_id')
    def_onchange_product_qty(self):
        forworkorderinself.workorder_ids:
            workorder.product_uom_id=self.product_uom_id
            ifself._origin.product_qty:
                workorder.duration_expected=workorder._get_duration_expected(ratio=self.product_qty/self._origin.product_qty)
            else:
                workorder.duration_expected=workorder._get_duration_expected()
            ifworkorder.date_planned_startandworkorder.duration_expected:
                workorder.date_planned_finished=workorder.date_planned_start+relativedelta(minutes=workorder.duration_expected)

    @api.onchange('bom_id')
    def_onchange_bom_id(self):
        ifnotself.product_idandself.bom_id:
            self.product_id=self.bom_id.product_idorself.bom_id.product_tmpl_id.product_variant_ids[:1]
        self.product_qty=self.bom_id.product_qtyor1.0
        self.product_uom_id=self.bom_idandself.bom_id.product_uom_id.idorself.product_id.uom_id.id
        self.move_raw_ids=[(2,move.id)formoveinself.move_raw_ids.filtered(lambdam:m.bom_line_id)]
        self.move_finished_ids=[(2,move.id)formoveinself.move_finished_ids]
        picking_type_id=self._context.get('default_picking_type_id')
        picking_type=picking_type_idandself.env['stock.picking.type'].browse(picking_type_id)
        self.picking_type_id=picking_typeorself.bom_id.picking_type_idorself.picking_type_id

    @api.onchange('date_planned_start','product_id')
    def_onchange_date_planned_start(self):
        ifself.date_planned_startandnotself.is_planned:
            date_planned_finished=self.date_planned_start+relativedelta(days=self.product_id.produce_delay)
            date_planned_finished=date_planned_finished+relativedelta(days=self.company_id.manufacturing_lead)
            ifdate_planned_finished==self.date_planned_start:
                date_planned_finished=date_planned_finished+relativedelta(hours=1)
            self.date_planned_finished=date_planned_finished
            self.move_raw_ids=[(1,m.id,{'date':self.date_planned_start})forminself.move_raw_ids]
            self.move_finished_ids=[(1,m.id,{'date':date_planned_finished})forminself.move_finished_ids]

    @api.onchange('bom_id','product_id','product_qty','product_uom_id')
    def_onchange_move_raw(self):
        ifnotself.bom_idandnotself._origin.product_id:
            return
        #Clearmoverawsifwearechangingtheproduct.Incaseofcreation(self._originisempty),
        #weneedtoavoidkeepingincorrectlines,soclearingisnecessarytoo.
        ifself.product_id!=self._origin.product_id:
            self.move_raw_ids=[(5,)]
        ifself.bom_idandself.product_qty>0:
            #keepmanualentries
            list_move_raw=[(4,move.id)formoveinself.move_raw_ids.filtered(lambdam:notm.bom_line_id)]
            moves_raw_values=self._get_moves_raw_values()
            move_raw_dict={move.bom_line_id.id:moveformoveinself.move_raw_ids.filtered(lambdam:m.bom_line_id)}
            formove_raw_valuesinmoves_raw_values:
                ifmove_raw_values['bom_line_id']inmove_raw_dict:
                    #updateexistingentries
                    list_move_raw+=[(1,move_raw_dict[move_raw_values['bom_line_id']].id,move_raw_values)]
                else:
                    #addnewentries
                    list_move_raw+=[(0,0,move_raw_values)]
            self.move_raw_ids=list_move_raw
        else:
            self.move_raw_ids=[(2,move.id)formoveinself.move_raw_ids.filtered(lambdam:m.bom_line_id)]

    @api.onchange('product_id')
    def_onchange_move_finished_product(self):
        self.move_finished_ids=[(5,)]
        ifself.product_id:
            self._create_update_move_finished()

    @api.onchange('bom_id','product_qty','product_uom_id')
    def_onchange_move_finished(self):
        ifself.product_idandself.product_qty>0:
            self._create_update_move_finished()
        else:
            self.move_finished_ids=[(2,move.id)formoveinself.move_finished_ids.filtered(lambdam:m.bom_line_id)]

    @api.onchange('location_src_id','move_raw_ids','bom_id')
    def_onchange_location(self):
        source_location=self.location_src_id
        self.move_raw_ids.update({
            'warehouse_id':source_location.get_warehouse().id,
            'location_id':source_location.id,
        })

    @api.onchange('location_dest_id','move_finished_ids','bom_id')
    def_onchange_location_dest(self):
        destination_location=self.location_dest_id
        update_value_list=[]
        formoveinself.move_finished_ids:
            update_value_list+=[(1,move.id,({
                'warehouse_id':destination_location.get_warehouse().id,
                'location_dest_id':destination_location.id,
            }))]
        self.move_finished_ids=update_value_list

    @api.onchange('picking_type_id')
    defonchange_picking_type(self):
        location=self.env.ref('stock.stock_location_stock')
        try:
            location.check_access_rule('read')
        except(AttributeError,AccessError):
            location=self.env['stock.warehouse'].search([('company_id','=',self.env.company.id)],limit=1).lot_stock_id
        self.move_raw_ids.update({'picking_type_id':self.picking_type_id})
        self.move_finished_ids.update({'picking_type_id':self.picking_type_id})
        self.location_src_id=self.picking_type_id.default_location_src_id.idorlocation.id
        self.location_dest_id=self.picking_type_id.default_location_dest_id.idorlocation.id

    @api.onchange('qty_producing','lot_producing_id')
    def_onchange_producing(self):
        self._set_qty_producing()

    @api.onchange('lot_producing_id')
    def_onchange_lot_producing(self):
        res=self._can_produce_serial_number()
        ifresisnotTrue:
            returnres

    def_can_produce_serial_number(self,sn=None):
        self.ensure_one()
        sn=snorself.lot_producing_id
        ifself.product_id.tracking=='serial'andsn:
            ifself.env['stock.move.line'].search([
                ('lot_id','=',sn.id),
                ('qty_done','=',1),
                ('state','=','done'),
                ('location_id.usage','!=','production'),
                ('location_dest_id.usage','!=','production'),
            ],limit=1)orself._is_finished_sn_already_produced(sn):
                return{
                    'warning':{
                        'title':_('Warning'),
                        'message':_('Serialnumber(%s)hasalreadybeenproduced.')%sn.name,
                    }
                }
        returnTrue

    @api.onchange('bom_id')
    def_onchange_workorder_ids(self):
        ifself.bom_id:
            self._create_workorder()
        else:
            self.workorder_ids=False

    @api.constrains('product_id','move_raw_ids')
    def_check_production_lines(self):
        forproductioninself:
            formoveinproduction.move_raw_ids:
                ifproduction.product_id==move.product_id:
                    raiseValidationError(_("Thecomponent%sshouldnotbethesameastheproducttoproduce.")%production.product_id.display_name)

    defwrite(self,vals):
        if'workorder_ids'inself:
            production_to_replan=self.filtered(lambdap:p.is_planned)
        res=super(MrpProduction,self).write(vals)

        forproductioninself:
            if'date_planned_start'invalsandnotself.env.context.get('force_date',False):
                ifproduction.statein['done','cancel']:
                    raiseUserError(_('Youcannotmoveamanufacturingorderonceitiscancelledordone.'))
                ifproduction.is_planned:
                    production.button_unplan()
                    move_vals=self._get_move_finished_values(self.product_id,self.product_uom_qty,self.product_uom_id)
                    production.move_finished_ids.write({'date':move_vals['date']})
            ifvals.get('date_planned_start'):
                production.move_raw_ids.write({'date':production.date_planned_start,'date_deadline':production.date_planned_start})
            ifvals.get('date_planned_finished'):
                production.move_finished_ids.write({'date':production.date_planned_finished})
            ifany(fieldin['move_raw_ids','move_finished_ids','workorder_ids']forfieldinvals)andproduction.state!='draft':
                ifproduction.state=='done':
                    #forsomereasonmovesaddedafterstate='done'won'tsavegroup_id,referenceifaddedin
                    #"stock_move.default_get()"
                    production.move_raw_ids.filtered(lambdamove:move.additionalandmove.date>production.date_planned_start).write({
                        'group_id':production.procurement_group_id.id,
                        'reference':production.name,
                        'date':production.date_planned_start,
                        'date_deadline':production.date_planned_start
                    })
                    production.move_finished_ids.filtered(lambdamove:move.additionalandmove.date>production.date_planned_finished).write({
                        'reference':production.name,
                        'date':production.date_planned_finished,
                        'date_deadline':production.date_deadline
                    })
                production._autoconfirm_production()
                ifproductioninproduction_to_replan:
                    production._plan_workorders(replan=True)
            ifproduction.state=='done'and('lot_producing_id'invalsor'qty_producing'invals):
                finished_move_lines=production.move_finished_ids.filtered(
                    lambdamove:move.product_id==self.product_idandmove.state=='done').mapped('move_line_ids')
                if'lot_producing_id'invals:
                    finished_move_lines.write({'lot_id':vals.get('lot_producing_id')})
                if'qty_producing'invals:
                    finished_move_lines.write({'qty_done':vals.get('qty_producing')})

            ifnotproduction.bom_id.operation_idsandvals.get('date_planned_start')andnotvals.get('date_planned_finished'):
                new_date_planned_start=fields.Datetime.to_datetime(vals.get('date_planned_start'))
                ifnotproduction.date_planned_finishedornew_date_planned_start>=production.date_planned_finished:
                    production.date_planned_finished=new_date_planned_start+datetime.timedelta(hours=1)
        returnres

    @api.model
    defcreate(self,values):
        #Removefrom`move_finished_ids`theby-productmovesandthenmove`move_byproduct_ids`
        #into`move_finished_ids`toavoidduplicateandinconsistency.
        ifvalues.get('move_finished_ids',False):
            values['move_finished_ids']=list(filter(lambdamove:move[2].get('byproduct_id',False)isFalse,values['move_finished_ids']))
        ifvalues.get('move_byproduct_ids',False):
            values['move_finished_ids']=values.get('move_finished_ids',[])+values['move_byproduct_ids']
            delvalues['move_byproduct_ids']
        ifnotvalues.get('name',False)orvalues['name']==_('New'):
            picking_type_id=values.get('picking_type_id')orself._get_default_picking_type()
            picking_type_id=self.env['stock.picking.type'].browse(picking_type_id)
            ifpicking_type_id:
                values['name']=picking_type_id.sequence_id.next_by_id()
            else:
                values['name']=self.env['ir.sequence'].next_by_code('mrp.production')or_('New')
        ifnotvalues.get('procurement_group_id'):
            procurement_group_vals=self._prepare_procurement_group_vals(values)
            values['procurement_group_id']=self.env["procurement.group"].create(procurement_group_vals).id
        production=super(MrpProduction,self).create(values)
        (production.move_raw_ids|production.move_finished_ids).write({
            'group_id':production.procurement_group_id.id,
            'origin':production.name
        })
        production.move_raw_ids.write({'date':production.date_planned_start})
        production.move_finished_ids.write({'date':production.date_planned_finished})
        #TriggerSM&WOcreationwhenimportingafile
        if'import_file'inself.env.context:
            production._onchange_move_raw()
            production._onchange_move_finished()
            production._onchange_workorder_ids()
        returnproduction

    defunlink(self):
        ifany(production.state=='done'forproductioninself):
            raiseUserError(_('Cannotdeleteamanufacturingorderindonestate.'))
        self.action_cancel()
        not_cancel=self.filtered(lambdam:m.state!='cancel')
        ifnot_cancel:
            productions_name=','.join([prod.display_nameforprodinnot_cancel])
            raiseUserError(_('%scannotbedeleted.Trytocancelthembefore.',productions_name))

        workorders_to_delete=self.workorder_ids.filtered(lambdawo:wo.state!='done')
        ifworkorders_to_delete:
            workorders_to_delete.unlink()
        returnsuper(MrpProduction,self).unlink()

    defcopy_data(self,default=None):
        default=dict(defaultor{})
        #coversatleast2cases:backordersgeneration(followdefaultlogicformovescopying)
        #andcopyingadoneMOviatheform(i.e.copyonlythenon-cancelledmovessincenobackorder=cancelledfinishedmoves)
        ifnotdefaultor'move_finished_ids'notindefault:
            move_finished_ids=self.move_finished_ids
            ifself.state!='cancel':
                move_finished_ids=self.move_finished_ids.filtered(lambdam:m.state!='cancel'andm.product_qty!=0.0)
            default['move_finished_ids']=[(0,0,move.copy_data()[0])formoveinmove_finished_ids]
        ifnotdefaultor'move_raw_ids'notindefault:
            default['move_raw_ids']=[(0,0,move.copy_data()[0])formoveinself.move_raw_ids.filtered(lambdam:m.product_qty!=0.0)]
        returnsuper(MrpProduction,self).copy_data(default=default)

    defaction_toggle_is_locked(self):
        self.ensure_one()
        self.is_locked=notself.is_locked
        returnTrue

    def_create_workorder(self):
        forproductioninself:
            ifnotproduction.bom_id:
                continue
            workorders_values=[]

            product_qty=production.product_uom_id._compute_quantity(production.product_qty,production.bom_id.product_uom_id)
            exploded_boms,dummy=production.bom_id.explode(production.product_id,product_qty/production.bom_id.product_qty,picking_type=production.bom_id.picking_type_id)

            forbom,bom_datainexploded_boms:
                #IftheoperationsoftheparentBoMandphantomBoMarethesame,don'trecreateworkorders.
                ifnot(bom.operation_idsand(notbom_data['parent_line']orbom_data['parent_line'].bom_id.operation_ids!=bom.operation_ids)):
                    continue
                foroperationinbom.operation_ids:
                    workorders_values+=[{
                        'name':operation.name,
                        'production_id':production.id,
                        'workcenter_id':operation.workcenter_id.id,
                        'product_uom_id':production.product_uom_id.id,
                        'operation_id':operation.id,
                        'state':'pending',
                        'consumption':production.consumption,
                    }]
            production.workorder_ids=[(5,0)]+[(0,0,value)forvalueinworkorders_values]
            forworkorderinproduction.workorder_ids:
                workorder.duration_expected=workorder._get_duration_expected()

    def_get_move_finished_values(self,product_id,product_uom_qty,product_uom,operation_id=False,byproduct_id=False):
        group_orders=self.procurement_group_id.mrp_production_ids
        move_dest_ids=self.move_dest_ids
        iflen(group_orders)>1:
            move_dest_ids|=group_orders[0].move_finished_ids.filtered(lambdam:m.product_id==self.product_id).move_dest_ids
        date_planned_finished=self.date_planned_start+relativedelta(days=self.product_id.produce_delay)
        date_planned_finished=date_planned_finished+relativedelta(days=self.company_id.manufacturing_lead)
        ifdate_planned_finished==self.date_planned_start:
            date_planned_finished=date_planned_finished+relativedelta(hours=1)
        return{
            'product_id':product_id,
            'product_uom_qty':product_uom_qty,
            'product_uom':product_uom,
            'operation_id':operation_id,
            'byproduct_id':byproduct_id,
            'name':self.name,
            'date':date_planned_finished,
            'date_deadline':self.date_deadline,
            'picking_type_id':self.picking_type_id.id,
            'location_id':self.product_id.with_company(self.company_id).property_stock_production.id,
            'location_dest_id':self.location_dest_id.id,
            'company_id':self.company_id.id,
            'production_id':self.id,
            'warehouse_id':self.location_dest_id.get_warehouse().id,
            'origin':self.name,
            'group_id':self.procurement_group_id.id,
            'propagate_cancel':self.propagate_cancel,
            'move_dest_ids':[(4,x.id)forxinself.move_dest_idsifnotbyproduct_id],
        }

    def_get_moves_finished_values(self):
        moves=[]
        forproductioninself:
            ifproduction.product_idinproduction.bom_id.byproduct_ids.mapped('product_id'):
                raiseUserError(_("Youcannothave%s asthefinishedproductandintheByproducts",self.product_id.name))
            moves.append(production._get_move_finished_values(production.product_id.id,production.product_qty,production.product_uom_id.id))
            forbyproductinproduction.bom_id.byproduct_ids:
                product_uom_factor=production.product_uom_id._compute_quantity(production.product_qty,production.bom_id.product_uom_id)
                qty=byproduct.product_qty*(product_uom_factor/production.bom_id.product_qty)
                moves.append(production._get_move_finished_values(
                    byproduct.product_id.id,qty,byproduct.product_uom_id.id,
                    byproduct.operation_id.id,byproduct.id))
        returnmoves

    def_create_update_move_finished(self):
        """ThisisahelperfunctiontosupportcomplexityofonchangelogicforMOs.
        Itisimportantthatthespecial*2Manycommandsusedhereremainaslongasfunction
        isusedwithinonchanges.
        """
        #keepmanualentries
        list_move_finished=[(4,move.id)formoveinself.move_finished_ids.filtered(
            lambdam:notm.byproduct_idandm.product_id!=self.product_id)]
        list_move_finished=[]
        moves_finished_values=self._get_moves_finished_values()
        moves_byproduct_dict={move.byproduct_id.id:moveformoveinself.move_finished_ids.filtered(lambdam:m.byproduct_id)}
        move_finished=self.move_finished_ids.filtered(lambdam:m.product_id==self.product_id)
        formove_finished_valuesinmoves_finished_values:
            ifmove_finished_values.get('byproduct_id')inmoves_byproduct_dict:
                #updateexistingentries
                list_move_finished+=[(1,moves_byproduct_dict[move_finished_values['byproduct_id']].id,move_finished_values)]
            elifmove_finished_values.get('product_id')==self.product_id.idandmove_finished:
                list_move_finished+=[(1,move_finished.id,move_finished_values)]
            else:
                #addnewentries
                list_move_finished+=[(0,0,move_finished_values)]
        self.move_finished_ids=list_move_finished

    def_get_moves_raw_values(self):
        moves=[]
        forproductioninself:
            factor=production.product_uom_id._compute_quantity(production.product_qty,production.bom_id.product_uom_id)/production.bom_id.product_qty
            boms,lines=production.bom_id.explode(production.product_id,factor,picking_type=production.bom_id.picking_type_id)
            forbom_line,line_datainlines:
                ifbom_line.child_bom_idandbom_line.child_bom_id.type=='phantom'or\
                        bom_line.product_id.typenotin['product','consu']:
                    continue
                operation=bom_line.operation_id.idorline_data['parent_line']andline_data['parent_line'].operation_id.id
                moves.append(production._get_move_raw_values(
                    bom_line.product_id,
                    line_data['qty'],
                    bom_line.product_uom_id,
                    operation,
                    bom_line
                ))
        returnmoves

    def_get_move_raw_values(self,product_id,product_uom_qty,product_uom,operation_id=False,bom_line=False):
        source_location=self.location_src_id
        origin=self.name
        ifself.orderpoint_id:
            origin=self.origin.replace(
                '%s-'%(self.orderpoint_id.display_name),'')
            origin='%s,%s'%(origin,self.name)
        data={
            'sequence':bom_line.sequenceifbom_lineelse10,
            'name':self.name,
            'date':self.date_planned_start,
            'date_deadline':self.date_planned_start,
            'bom_line_id':bom_line.idifbom_lineelseFalse,
            'picking_type_id':self.picking_type_id.id,
            'product_id':product_id.id,
            'product_uom_qty':product_uom_qty,
            'product_uom':product_uom.id,
            'location_id':source_location.id,
            'location_dest_id':self.product_id.with_company(self.company_id).property_stock_production.id,
            'raw_material_production_id':self.id,
            'company_id':self.company_id.id,
            'operation_id':operation_id,
            'price_unit':product_id.standard_price,
            'procure_method':'make_to_stock',
            'origin':origin,
            'state':'draft',
            'warehouse_id':source_location.get_warehouse().id,
            'group_id':self.procurement_group_id.id,
            'propagate_cancel':self.propagate_cancel,
        }
        returndata

    def_set_qty_producing(self):
        ifself.product_id.tracking=='serial':
            qty_producing_uom=self.product_uom_id._compute_quantity(self.qty_producing,self.product_id.uom_id,rounding_method='HALF-UP')
            ifqty_producing_uom!=1:
                self.qty_producing=self.product_id.uom_id._compute_quantity(1,self.product_uom_id,rounding_method='HALF-UP')

        formovein(self.move_raw_ids|self.move_finished_ids.filtered(lambdam:m.product_id!=self.product_id)):
            ifmove._should_bypass_set_qty_producing()ornotmove.product_uom:
                continue
            new_qty=float_round((self.qty_producing-self.qty_produced)*move.unit_factor,precision_rounding=move.product_uom.rounding)
            move.move_line_ids.filtered(lambdaml:ml.statenotin('done','cancel')).qty_done=0
            move.move_line_ids=move._set_quantity_done_prepare_vals(new_qty)

    def_update_raw_moves(self,factor):
        self.ensure_one()
        update_info=[]
        formoveinself.move_raw_ids.filtered(lambdam:m.statenotin('done','cancel')):
            old_qty=move.product_uom_qty
            new_qty=old_qty*factor
            move.write({'product_uom_qty':new_qty})
            move._action_assign()
            update_info.append((move,old_qty,new_qty))
        returnupdate_info

    def_get_ready_to_produce_state(self):
        """returns'assigned'ifenoughcomponentsarereservedinordertocomplete
        thefirstoperationofthebom.Ifnotreturns'waiting'
        """
        self.ensure_one()
        first_operation=self.bom_id.operation_ids[0]
        iflen(self.bom_id.operation_ids)==1:
            moves_in_first_operation=self.move_raw_ids
        else:
            moves_in_first_operation=self.move_raw_ids.filtered(lambdamove:move.operation_id==first_operation)
        moves_in_first_operation=moves_in_first_operation.filtered(
            lambdamove:move.bom_line_idand
            notmove.bom_line_id._skip_bom_line(self.product_id)
        )

        ifall(move.state=='assigned'formoveinmoves_in_first_operation):
            return'assigned'
        return'confirmed'

    def_autoconfirm_production(self):
        """Automaticallyrun`action_confirm`on`self`.

        Iftheproductionhasoneofitsmovewasaddedaftertheinitialcall
        to`action_confirm`.
        """
        moves_to_confirm=self.env['stock.move']
        forproductioninself:
            ifproduction.statein('done','cancel'):
                continue
            additional_moves=production.move_raw_ids.filtered(
                lambdamove:move.state=='draft'
            )
            additional_moves.write({
                'group_id':production.procurement_group_id.id,
            })
            additional_moves._adjust_procure_method()
            moves_to_confirm|=additional_moves
            additional_byproducts=production.move_finished_ids.filtered(
                lambdamove:move.state=='draft'
            )
            moves_to_confirm|=additional_byproducts

        ifmoves_to_confirm:
            moves_to_confirm._action_confirm()
            #runschedulerformovesforecastedtonothaveenoughinstock
            moves_to_confirm._trigger_scheduler()

        self.workorder_ids.filtered(lambdaw:w.statenotin['done','cancel'])._action_confirm()

    def_get_children(self):
        self.ensure_one()
        procurement_moves=self.procurement_group_id.stock_move_ids
        child_moves=procurement_moves.move_orig_ids
        return(procurement_moves|child_moves).created_production_id.procurement_group_id.mrp_production_ids-self

    def_get_sources(self):
        self.ensure_one()
        dest_moves=self.procurement_group_id.mrp_production_ids.move_dest_ids
        parent_moves=self.procurement_group_id.stock_move_ids.move_dest_ids
        return(dest_moves|parent_moves).group_id.mrp_production_ids-self

    defaction_view_mrp_production_childs(self):
        self.ensure_one()
        mrp_production_ids=self._get_children().ids
        action={
            'res_model':'mrp.production',
            'type':'ir.actions.act_window',
        }
        iflen(mrp_production_ids)==1:
            action.update({
                'view_mode':'form',
                'res_id':mrp_production_ids[0],
            })
        else:
            action.update({
                'name':_("%sChildMO's")%self.name,
                'domain':[('id','in',mrp_production_ids)],
                'view_mode':'tree,form',
            })
        returnaction

    defaction_view_mrp_production_sources(self):
        self.ensure_one()
        mrp_production_ids=self._get_sources().ids
        action={
            'res_model':'mrp.production',
            'type':'ir.actions.act_window',
        }
        iflen(mrp_production_ids)==1:
            action.update({
                'view_mode':'form',
                'res_id':mrp_production_ids[0],
            })
        else:
            action.update({
                'name':_("MOGeneratedby%s")%self.name,
                'domain':[('id','in',mrp_production_ids)],
                'view_mode':'tree,form',
            })
        returnaction

    defaction_view_mrp_production_backorders(self):
        backorder_ids=self.procurement_group_id.mrp_production_ids.ids
        return{
            'res_model':'mrp.production',
            'type':'ir.actions.act_window',
            'name':_("BackorderMO's"),
            'domain':[('id','in',backorder_ids)],
            'view_mode':'tree,form',
        }

    defaction_generate_serial(self):
        self.ensure_one()
        self.lot_producing_id=self.env['stock.production.lot'].create({
            'product_id':self.product_id.id,
            'company_id':self.company_id.id
        })
        ifself.move_finished_ids.filtered(lambdam:m.product_id==self.product_id).move_line_ids:
            self.move_finished_ids.filtered(lambdam:m.product_id==self.product_id).move_line_ids.lot_id=self.lot_producing_id
        ifself.product_id.tracking=='serial':
            self._set_qty_producing()

    def_action_generate_immediate_wizard(self):
        view=self.env.ref('mrp.view_immediate_production')
        return{
            'name':_('ImmediateProduction?'),
            'type':'ir.actions.act_window',
            'view_mode':'form',
            'res_model':'mrp.immediate.production',
            'views':[(view.id,'form')],
            'view_id':view.id,
            'target':'new',
            'context':dict(self.env.context,default_mo_ids=[(4,mo.id)formoinself]),
        }

    defaction_confirm(self):
        self._check_company()
        forproductioninself:
            ifproduction.bom_id:
                production.consumption=production.bom_id.consumption
            ifnotproduction.move_raw_ids:
                raiseUserError(_("AddsomematerialstoconsumebeforemarkingthisMOastodo."))
            #IncaseofSerialnumbertracking,forcetheUoMtotheUoMofproduct
            ifproduction.product_tracking=='serial'andproduction.product_uom_id!=production.product_id.uom_id:
                production.write({
                    'product_qty':production.product_uom_id._compute_quantity(production.product_qty,production.product_id.uom_id),
                    'product_uom_id':production.product_id.uom_id
                })
                formove_finishinproduction.move_finished_ids.filtered(lambdam:m.product_id==production.product_id):
                    move_finish.write({
                        'product_uom_qty':move_finish.product_uom._compute_quantity(move_finish.product_uom_qty,move_finish.product_id.uom_id),
                        'product_uom':move_finish.product_id.uom_id
                    })
            production.move_raw_ids._adjust_procure_method()
            (production.move_raw_ids|production.move_finished_ids)._action_confirm()
            production.workorder_ids._action_confirm()

        #runschedulerformovesforecastedtonothaveenoughinstock
        self.move_raw_ids._trigger_scheduler()
        self.picking_ids.filtered(
            lambdap:p.statenotin['cancel','done']).action_confirm()
        returnTrue

    defaction_assign(self):
        forproductioninself:
            production.move_raw_ids._action_assign()
        returnTrue

    defbutton_plan(self):
        """Createworkorders.Andprobablydostuff,likethings."""
        orders_to_plan=self.filtered(lambdaorder:notorder.is_planned)
        orders_to_confirm=orders_to_plan.filtered(lambdamo:mo.state=='draft')
        orders_to_confirm.action_confirm()
        fororderinorders_to_plan:
            order._plan_workorders()
        returnTrue

    def_plan_workorders(self,replan=False):
        """Planalltheproduction'sworkordersdependingontheworkcenters
        workschedule.

        :paramreplan:Ifitisareplan,onlyreadyandpendingworkorderwillbetakeinaccount
        :typereplan:bool.
        """
        self.ensure_one()

        ifnotself.workorder_ids:
            return
        #Scheduleallworkorders(newonesandthosealreadycreated)
        qty_to_produce=max(self.product_qty-self.qty_produced,0)
        qty_to_produce=self.product_uom_id._compute_quantity(qty_to_produce,self.product_id.uom_id)
        start_date=max(self.date_planned_start,datetime.datetime.now())
        ifreplan:
            workorder_ids=self.workorder_ids.filtered(lambdawo:wo.statein['ready','pending'])
            #Weplanthemanufacturingorderaccordingtoits`date_planned_start`,butif
            #`date_planned_start`isinthepast,weplanitassoonaspossible.
            workorder_ids.leave_id.unlink()
        else:
            workorder_ids=self.workorder_ids.filtered(lambdawo:notwo.date_planned_start)
        forworkorderinworkorder_ids:
            workcenters=workorder.workcenter_id|workorder.workcenter_id.alternative_workcenter_ids

            best_finished_date=datetime.datetime.max
            vals={}
            forworkcenterinworkcenters:
                #computetheoreticalduration
                ifworkorder.workcenter_id==workcenter:
                    duration_expected=workorder.duration_expected
                else:
                    duration_expected=workorder._get_duration_expected(alternative_workcenter=workcenter)

                from_date,to_date=workcenter._get_first_available_slot(start_date,duration_expected)
                #Iftheworkcenterisunavailable,tryplanningonthenextone
                ifnotfrom_date:
                    continue
                #Checkifthisworkcenterisbetterthanthepreviousones
                ifto_dateandto_date<best_finished_date:
                    best_start_date=from_date
                    best_finished_date=to_date
                    best_workcenter=workcenter
                    vals={
                        'workcenter_id':workcenter.id,
                        'duration_expected':duration_expected,
                    }

            #Ifnoneoftheworkcenterareavailable,raise
            ifbest_finished_date==datetime.datetime.max:
                raiseUserError(_('Impossibletoplantheworkorder.Pleasechecktheworkcenteravailabilities.'))

            #Instantiatestart_dateforthenextworkorderplanning
            ifworkorder.next_work_order_id:
                start_date=best_finished_date

            #Createleaveonchosenworkcentercalendar
            leave=self.env['resource.calendar.leaves'].create({
                'name':workorder.display_name,
                'calendar_id':best_workcenter.resource_calendar_id.id,
                'date_from':best_start_date,
                'date_to':best_finished_date,
                'resource_id':best_workcenter.resource_id.id,
                'time_type':'other'
            })
            vals['leave_id']=leave.id
            workorder.write(vals)
        self.with_context(force_date=True).write({
            'date_planned_start':self.workorder_ids[0].date_planned_start,
            'date_planned_finished':self.workorder_ids[-1].date_planned_finished
        })

    defbutton_unplan(self):
        ifany(wo.state=='done'forwoinself.workorder_ids):
            raiseUserError(_("Someworkordersarealreadydone,youcannotunplanthismanufacturingorder."))
        elifany(wo.state=='progress'forwoinself.workorder_ids):
            raiseUserError(_("Someworkordershavealreadystarted,youcannotunplanthismanufacturingorder."))

        self.workorder_ids.leave_id.unlink()
        self.workorder_ids.write({
            'date_planned_start':False,
            'date_planned_finished':False,
        })

    def_get_consumption_issues(self):
        """Comparethequantityconsumedofthecomponents,theexpectedquantity
        ontheBoMandtheconsumptionparameterontheorder.

        :return:listoftuples(order_id,product_id,consumed_qty,expected_qty)wherethe
            consumptionisn'thonored.order_idandproduct_idarerecordsetofmrp.production
            andproduct.productrespectively
        :rtype:list
        """
        issues=[]
        ifself.env.context.get('skip_consumption',False)orself.env.context.get('skip_immediate',False):
            returnissues
        fororderinself:
            iforder.consumption=='flexible'ornotorder.bom_idornotorder.bom_id.bom_line_ids:
                continue
            expected_move_values=order._get_moves_raw_values()
            expected_qty_by_product=defaultdict(float)
            formove_valuesinexpected_move_values:
                move_product=self.env['product.product'].browse(move_values['product_id'])
                move_uom=self.env['uom.uom'].browse(move_values['product_uom'])
                move_product_qty=move_uom._compute_quantity(move_values['product_uom_qty'],move_product.uom_id)
                expected_qty_by_product[move_product]+=move_product_qty*order.qty_producing/order.product_qty

            done_qty_by_product=defaultdict(float)
            formoveinorder.move_raw_ids:
                qty_done=move.product_uom._compute_quantity(move.quantity_done,move.product_id.uom_id)
                rounding=move.product_id.uom_id.rounding
                ifnot(move.product_idinexpected_qty_by_productorfloat_is_zero(qty_done,precision_rounding=rounding)):
                    issues.append((order,move.product_id,qty_done,0.0))
                    continue
                done_qty_by_product[move.product_id]+=qty_done

            forproduct,qty_to_consumeinexpected_qty_by_product.items():
                qty_done=done_qty_by_product.get(product,0.0)
                iffloat_compare(qty_to_consume,qty_done,precision_rounding=product.uom_id.rounding)!=0:
                    issues.append((order,product,qty_done,qty_to_consume))

        returnissues

    def_action_generate_consumption_wizard(self,consumption_issues):
        ctx=self.env.context.copy()
        lines=[]
        fororder,product_id,consumed_qty,expected_qtyinconsumption_issues:
            lines.append((0,0,{
                'mrp_production_id':order.id,
                'product_id':product_id.id,
                'consumption':order.consumption,
                'product_uom_id':product_id.uom_id.id,
                'product_consumed_qty_uom':consumed_qty,
                'product_expected_qty_uom':expected_qty
            }))
        ctx.update({'default_mrp_production_ids':self.ids,'default_mrp_consumption_warning_line_ids':lines})
        action=self.env["ir.actions.actions"]._for_xml_id("mrp.action_mrp_consumption_warning")
        action['context']=ctx
        returnaction

    def_get_quantity_produced_issues(self):
        quantity_issues=[]
        ifself.env.context.get('skip_backorder',False):
            returnquantity_issues
        fororderinself:
            ifnotfloat_is_zero(order._get_quantity_to_backorder(),precision_rounding=order.product_uom_id.rounding):
                quantity_issues.append(order)
        returnquantity_issues

    def_action_generate_backorder_wizard(self,quantity_issues):
        ctx=self.env.context.copy()
        lines=[]
        fororderinquantity_issues:
            lines.append((0,0,{
                'mrp_production_id':order.id,
                'to_backorder':True
            }))
        ctx.update({'default_mrp_production_ids':self.ids,'default_mrp_production_backorder_line_ids':lines})
        action=self.env["ir.actions.actions"]._for_xml_id("mrp.action_mrp_production_backorder")
        action['context']=ctx
        returnaction

    defaction_cancel(self):
        """Cancelsproductionorder,unfinishedstockmovesandsetprocurement
        ordersinexception"""
        self.workorder_ids.filtered(lambdax:x.statenotin['done','cancel']).action_cancel()
        ifnotself.move_raw_ids:
            self.state='cancel'
            returnTrue
        self._action_cancel()
        returnTrue

    def_action_cancel(self):
        documents_by_production={}
        forproductioninself:
            documents=defaultdict(list)
            formove_raw_idinself.move_raw_ids.filtered(lambdam:m.statenotin('done','cancel')):
                iterate_key=self._get_document_iterate_key(move_raw_id)
                ifiterate_key:
                    document=self.env['stock.picking']._log_activity_get_documents({move_raw_id:(move_raw_id.product_uom_qty,0)},iterate_key,'UP')
                    forkey,valueindocument.items():
                        documents[key]+=[value]
            ifdocuments:
                documents_by_production[production]=documents
            #loganactivityonParentMOifchildMOiscancelled.
            finish_moves=production.move_finished_ids.filtered(lambdax:x.statenotin('done','cancel'))
            iffinish_moves:
                production._log_downside_manufactured_quantity({finish_move:(production.product_uom_qty,0.0)forfinish_moveinfinish_moves},cancel=True)

        finish_moves=self.move_finished_ids.filtered(lambdax:x.statenotin('done','cancel'))
        raw_moves=self.move_raw_ids.filtered(lambdax:x.statenotin('done','cancel'))

        (finish_moves|raw_moves)._action_cancel()
        picking_ids=self.picking_ids.filtered(lambdax:x.statenotin('done','cancel'))
        picking_ids.action_cancel()

        forproduction,documentsindocuments_by_production.items():
            filtered_documents={}
            for(parent,responsible),rendering_contextindocuments.items():
                ifnotparentorparent._name=='stock.picking'andparent.state=='cancel'orparent==production:
                    continue
                filtered_documents[(parent,responsible)]=rendering_context
            production._log_manufacture_exception(filtered_documents,cancel=True)

        #IncaseofaflexibleBOM,wedon'tknowfromthestateofthemovesiftheMOshould
        #remaininprogressordone.Indeed,ifallmovesaredone/cancelbutthequantityproduced
        #islowerthanexpected,itmightmean:
        #-wehaveusedallcomponentsbutwestillwanttoproducethequantityexpected
        #-wehaveusedallcomponentsandwewon'tbeabletoproducethelastunits
        #
        #However,iftheuserclickson'Cancel',itisexpectedthattheMOiseitherdoneor
        #canceled.IftheMOisstillinprogressatthispoint,itmeansthatthemoveraws
        #areeitheralldoneoramixofdone/canceled=>theMOshouldbedone.
        self.filtered(lambdap:p.statenotin['done','cancel']andp.bom_id.consumption=='flexible').write({'state':'done'})

        returnTrue

    def_get_document_iterate_key(self,move_raw_id):
        returnmove_raw_id.move_orig_idsand'move_orig_ids'orFalse

    def_cal_price(self,consumed_moves):
        self.ensure_one()
        returnTrue

    def_post_inventory(self,cancel_backorder=False):
        fororderinself:
            moves_not_to_do=order.move_raw_ids.filtered(lambdax:x.state=='done')
            moves_to_do=order.move_raw_ids.filtered(lambdax:x.statenotin('done','cancel'))
            formoveinmoves_to_do.filtered(lambdam:m.product_qty==0.0andm.quantity_done>0):
                move.product_uom_qty=move.quantity_done
            #MRPdonotmergemove,catchtheresultof_action_doneinorder
            #togetextramoves.
            moves_to_do=moves_to_do._action_done(cancel_backorder=cancel_backorder)
            moves_to_do=order.move_raw_ids.filtered(lambdax:x.state=='done')-moves_not_to_do

            finish_moves=order.move_finished_ids.filtered(lambdam:m.product_id==order.product_idandm.statenotin('done','cancel'))
            #thefinishmovecanalreadybecompletedbytheworkorder.
            ifnotfinish_moves.quantity_done:
                finish_moves.quantity_done=float_round(order.qty_producing-order.qty_produced,precision_rounding=order.product_uom_id.rounding,rounding_method='HALF-UP')
                finish_moves.move_line_ids.lot_id=order.lot_producing_id
            order._cal_price(moves_to_do)

            moves_to_finish=order.move_finished_ids.filtered(lambdax:x.statenotin('done','cancel'))
            moves_to_finish=moves_to_finish._action_done(cancel_backorder=cancel_backorder)
            order.action_assign()
            consume_move_lines=moves_to_do.mapped('move_line_ids')
            order.move_finished_ids.move_line_ids.consume_line_ids=[(6,0,consume_move_lines.ids)]
        returnTrue

    @api.model
    def_get_name_backorder(self,name,sequence):
        ifnotsequence:
            returnname
        seq_back="-"+"0"*(SIZE_BACK_ORDER_NUMERING-1-int(math.log10(sequence)))+str(sequence)
        regex=re.compile(r"-\d+$")
        ifregex.search(name)andsequence>1:
            returnregex.sub(seq_back,name)
        returnname+seq_back

    def_get_backorder_mo_vals(self):
        self.ensure_one()
        ifnotself.procurement_group_id:
            #intherarecasethattheprocurementgrouphasbeenremovedsomehow,createanewone
            self.procurement_group_id=self.env["procurement.group"].create({'name':self.name})
        next_seq=max(self.procurement_group_id.mrp_production_ids.mapped("backorder_sequence"),default=1)
        return{
            'name':self._get_name_backorder(self.name,next_seq+1),
            'backorder_sequence':next_seq+1,
            'procurement_group_id':self.procurement_group_id.id,
            'move_raw_ids':None,
            'move_finished_ids':None,
            'product_qty':self._get_quantity_to_backorder(),
            'lot_producing_id':False,
            'origin':self.origin
        }

    def_generate_backorder_productions(self,close_mo=True):
        backorders=self.env['mrp.production']
        forproductioninself:
            ifproduction.backorder_sequence==0: #Activatebackordernaming
                production.backorder_sequence=1
            production.name=self._get_name_backorder(production.name,production.backorder_sequence)
            backorder_mo=production.copy(default=production._get_backorder_mo_vals())
            ifclose_mo:
                production.move_raw_ids.filtered(lambdam:m.statenotin('done','cancel')).write({
                    'raw_material_production_id':backorder_mo.id,
                })
                production.move_finished_ids.filtered(lambdam:m.statenotin('done','cancel')).write({
                    'production_id':backorder_mo.id,
                })
            else:
                new_moves_vals=[]
                formoveinproduction.move_raw_ids|production.move_finished_ids:
                    ifnotmove.additional:
                        qty_to_split=move.product_uom_qty-move.unit_factor*production.qty_producing
                        qty_to_split=move.product_uom._compute_quantity(qty_to_split,move.product_id.uom_id,rounding_method='HALF-UP')
                        move_vals=move._split(qty_to_split)
                        ifnotmove_vals:
                            continue
                        ifmove.raw_material_production_id:
                            move_vals[0]['raw_material_production_id']=backorder_mo.id
                        else:
                            move_vals[0]['production_id']=backorder_mo.id
                        new_moves_vals.append(move_vals[0])
                new_moves=self.env['stock.move'].create(new_moves_vals)
            backorders|=backorder_mo

            #Weneedtoadapt`duration_expected`onboththeoriginalworkordersandtheir
            #backorderedworkorders.Todothat,weusetheoriginal`duration_expected`andthe
            #ratioofthequantityreallyproducedandthequantitytoproduce.
            ratio=production.qty_producing/production.product_qty
            forworkorderinproduction.workorder_ids:
                workorder.duration_expected=workorder.duration_expected*ratio
            forworkorderinbackorder_mo.workorder_ids:
                workorder.duration_expected=workorder.duration_expected*(1-ratio)

        #Aswehavesplitthemovesbeforevalidatingthem,weneedto'remove'theexcessreservation
        ifnotclose_mo:
            raw_moves=self.move_raw_ids.filtered(lambdam:notm.additional)
            raw_moves._do_unreserve()
            forsmlinraw_moves.move_line_ids:
                try:
                    q=self.env['stock.quant']._update_reserved_quantity(sml.product_id,sml.location_id,sml.qty_done,
                                                                          lot_id=sml.lot_id,package_id=sml.package_id,
                                                                          owner_id=sml.owner_id,strict=True)
                    reserved_qty=sum([x[1]forxinq])
                    reserved_qty=sml.product_id.uom_id._compute_quantity(reserved_qty,sml.product_uom_id)
                exceptUserError:
                    reserved_qty=0
                sml.with_context(bypass_reservation_update=True).product_uom_qty=reserved_qty
            raw_moves._recompute_state()
        #Confirmonlyproductionswithremainingcomponents
        backorders.filtered(lambdamo:mo.move_raw_ids).action_confirm()
        backorders.filtered(lambdamo:mo.move_raw_ids).action_assign()

        #Removetheserialmovelinewithoutreservedquantity.Postinventorywillassignedallthenondonemoves
        #Sothosemovelinesareduplicated.
        backorders.move_raw_ids.move_line_ids.filtered(lambdaml:ml.product_id.tracking=='serial'andml.product_qty==0).unlink()
        backorders.move_raw_ids._recompute_state()

        forproduction,backorder_moinzip(self,backorders):
            first_wo=self.env['mrp.workorder']
            forold_wo,woinzip(production.workorder_ids,backorder_mo.workorder_ids):
                wo.qty_produced=max(old_wo.qty_produced-old_wo.qty_producing,0)
                ifwo.product_tracking=='serial':
                    wo.qty_producing=1
                else:
                    wo.qty_producing=wo.qty_remaining
                ifwo.qty_producing==0:
                    wo.action_cancel()
                ifnotfirst_woandwo.state!='cancel':
                    first_wo=wo
            first_wo.state='ready'
        returnbackorders

    defbutton_mark_done(self):
        self._button_mark_done_sanity_checks()

        ifnotself.env.context.get('button_mark_done_production_ids'):
            self=self.with_context(button_mark_done_production_ids=self.ids)
        res=self._pre_button_mark_done()
        ifresisnotTrue:
            returnres

        ifself.env.context.get('mo_ids_to_backorder'):
            productions_to_backorder=self.browse(self.env.context['mo_ids_to_backorder'])
            productions_not_to_backorder=self-productions_to_backorder
            close_mo=False
        else:
            productions_not_to_backorder=self
            productions_to_backorder=self.env['mrp.production']
            close_mo=True

        self.workorder_ids.button_finish()

        backorders=productions_to_backorder._generate_backorder_productions(close_mo=close_mo)
        productions_not_to_backorder._post_inventory(cancel_backorder=True)
        productions_to_backorder._post_inventory(cancel_backorder=True)

        #ifcompletedproductsmakeotherconfirmed/partially_availablemovesavailable,assignthem
        done_move_finished_ids=(productions_to_backorder.move_finished_ids|productions_not_to_backorder.move_finished_ids).filtered(lambdam:m.state=='done')
        done_move_finished_ids._trigger_assign()

        #Moveswithoutquantitydonearenotposted=>setthemasdoneinsteadofcanceling.In
        #casetheusereditstheMOlateronandsetssomeconsumedquantityonthose,wedonot
        #wantthemovelinestobecanceled.
        (productions_not_to_backorder.move_raw_ids|productions_not_to_backorder.move_finished_ids).filtered(lambdax:x.statenotin('done','cancel')).write({
            'state':'done',
            'product_uom_qty':0.0,
        })

        forproductioninself:
            production.write({
                'date_finished':fields.Datetime.now(),
                'product_qty':production.qty_produced,
                'priority':'0',
                'is_locked':True,
            })

        forworkorderinself.workorder_ids.filtered(lambdaw:w.statenotin('done','cancel')):
            workorder.duration_expected=workorder._get_duration_expected()

        ifnotbackorders:
            ifself.env.context.get('from_workorder'):
                return{
                    'type':'ir.actions.act_window',
                    'res_model':'mrp.production',
                    'views':[[self.env.ref('mrp.mrp_production_form_view').id,'form']],
                    'res_id':self.id,
                    'target':'main',
                }
            returnTrue
        context=self.env.context.copy()
        context={k:vfork,vincontext.items()ifnotk.startswith('default_')}
        fork,vincontext.items():
            ifk.startswith('skip_'):
                context[k]=False
        action={
            'res_model':'mrp.production',
            'type':'ir.actions.act_window',
            'context':dict(context,mo_ids_to_backorder=None,button_mark_done_production_ids=None)
        }
        iflen(backorders)==1:
            action.update({
                'view_mode':'form',
                'res_id':backorders[0].id,
            })
        else:
            action.update({
                'name':_("BackorderMO"),
                'domain':[('id','in',backorders.ids)],
                'view_mode':'tree,form',
            })
        returnaction

    def_pre_button_mark_done(self):
        productions_to_immediate=self._check_immediate()
        ifproductions_to_immediate:
            returnproductions_to_immediate._action_generate_immediate_wizard()

        forproductioninself:
            iffloat_is_zero(production.qty_producing,precision_rounding=production.product_uom_id.rounding):
                raiseUserError(_('Thequantitytoproducemustbepositive!'))
            ifnotany(production.move_raw_ids.mapped('quantity_done')):
                raiseUserError(_("Youmustindicateanon-zeroamountconsumedforatleastoneofyourcomponents"))

        consumption_issues=self._get_consumption_issues()
        ifconsumption_issues:
            returnself._action_generate_consumption_wizard(consumption_issues)

        quantity_issues=self._get_quantity_produced_issues()
        ifquantity_issues:
            returnself._action_generate_backorder_wizard(quantity_issues)
        returnTrue

    def_button_mark_done_sanity_checks(self):
        self._check_company()
        fororderinself:
            order._check_sn_uniqueness()

    defdo_unreserve(self):
        self.move_raw_ids.filtered(lambdax:x.statenotin('done','cancel'))._do_unreserve()
        returnTrue

    defbutton_unreserve(self):
        self.ensure_one()
        self.do_unreserve()
        returnTrue

    defbutton_scrap(self):
        self.ensure_one()
        return{
            'name':_('Scrap'),
            'view_mode':'form',
            'res_model':'stock.scrap',
            'view_id':self.env.ref('stock.stock_scrap_form_view2').id,
            'type':'ir.actions.act_window',
            'context':{'default_production_id':self.id,
                        'product_ids':(self.move_raw_ids.filtered(lambdax:x.statenotin('done','cancel'))|self.move_finished_ids.filtered(lambdax:x.state=='done')).mapped('product_id').ids,
                        'default_company_id':self.company_id.id
                        },
            'target':'new',
        }

    defaction_see_move_scrap(self):
        self.ensure_one()
        action=self.env["ir.actions.actions"]._for_xml_id("stock.action_stock_scrap")
        action['domain']=[('production_id','=',self.id)]
        action['context']=dict(self._context,default_origin=self.name)
        returnaction

    @api.model
    defget_empty_list_help(self,help):
        self=self.with_context(
            empty_list_help_document_name=_("manufacturingorder"),
        )
        returnsuper(MrpProduction,self).get_empty_list_help(help)

    def_log_downside_manufactured_quantity(self,moves_modification,cancel=False):

        def_keys_in_sorted(move):
            """sortbypickingandtheresponsiblefortheproductthe
            move.
            """
            return(move.picking_id.id,move.product_id.responsible_id.id)

        def_keys_in_groupby(move):
            """groupbypickingandtheresponsiblefortheproductthe
            move.
            """
            return(move.picking_id,move.product_id.responsible_id)

        def_render_note_exception_quantity_mo(rendering_context):
            values={
                'production_order':self,
                'order_exceptions':rendering_context,
                'impacted_pickings':False,
                'cancel':cancel
            }
            returnself.env.ref('mrp.exception_on_mo')._render(values=values)

        documents=self.env['stock.picking']._log_activity_get_documents(moves_modification,'move_dest_ids','DOWN',_keys_in_sorted,_keys_in_groupby)
        documents=self.env['stock.picking']._less_quantities_than_expected_add_documents(moves_modification,documents)
        self.env['stock.picking']._log_activity(_render_note_exception_quantity_mo,documents)

    def_log_manufacture_exception(self,documents,cancel=False):

        def_render_note_exception_quantity_mo(rendering_context):
            visited_objects=[]
            order_exceptions={}
            forexceptioninrendering_context:
                order_exception,visited=exception
                order_exceptions.update(order_exception)
                visited_objects+=visited
            visited_objects=[smforsminvisited_objectsifsm._name=='stock.move']
            impacted_object=[]
            ifvisited_objects:
                visited_objects=self.env[visited_objects[0]._name].concat(*visited_objects)
                visited_objects|=visited_objects.mapped('move_orig_ids')
                impacted_object=visited_objects.filtered(lambdam:m.statenotin('done','cancel')).mapped('picking_id')
            values={
                'production_order':self,
                'order_exceptions':order_exceptions,
                'impacted_object':impacted_object,
                'cancel':cancel
            }
            returnself.env.ref('mrp.exception_on_mo')._render(values=values)

        self.env['stock.picking']._log_activity(_render_note_exception_quantity_mo,documents)

    defbutton_unbuild(self):
        self.ensure_one()
        return{
            'name':_('Unbuild:%s',self.product_id.display_name),
            'view_mode':'form',
            'res_model':'mrp.unbuild',
            'view_id':self.env.ref('mrp.mrp_unbuild_form_view_simplified').id,
            'type':'ir.actions.act_window',
            'context':{'default_product_id':self.product_id.id,
                        'default_mo_id':self.id,
                        'default_company_id':self.company_id.id,
                        'default_location_id':self.location_dest_id.id,
                        'default_location_dest_id':self.location_src_id.id,
                        'create':False,'edit':False},
            'target':'new',
        }

    @api.model
    def_prepare_procurement_group_vals(self,values):
        return{'name':values['name']}

    def_get_quantity_to_backorder(self):
        self.ensure_one()
        returnmax(self.product_qty-self.qty_producing,0)

    def_check_sn_uniqueness(self):
        """Alerttheuseriftheserialnumberasalreadybeenconsumed/produced"""
        ifself.product_tracking=='serial'andself.lot_producing_id:
            ifself._is_finished_sn_already_produced(self.lot_producing_id):
                raiseUserError(_('Thisserialnumberforproduct%shasalreadybeenproduced',self.product_id.name))

        formoveinself.move_finished_ids:
            ifmove.has_tracking!='serial'ormove.product_id==self.product_id:
                continue
            formove_lineinmove.move_line_ids:
                ifself._is_finished_sn_already_produced(move_line.lot_id,excluded_sml=move_line):
                    raiseUserError(_('Theserialnumber%(number)susedforbyproduct%(product_name)shasalreadybeenproduced',
                                      number=move_line.lot_id.name,product_name=move_line.product_id.name))

        formoveinself.move_raw_ids:
            ifmove.has_tracking!='serial':
                continue
            formove_lineinmove.move_line_ids:
                iffloat_is_zero(move_line.qty_done,precision_rounding=move_line.product_uom_id.rounding):
                    continue
                message=_('Theserialnumber%(number)susedforcomponent%(component)shasalreadybeenconsumed',
                    number=move_line.lot_id.name,
                    component=move_line.product_id.name)
                co_prod_move_lines=self.move_raw_ids.move_line_ids

                #Checkpresenceofsamesninpreviousproductions
                duplicates=self.env['stock.move.line'].search_count([
                    ('lot_id','=',move_line.lot_id.id),
                    ('qty_done','=',1),
                    ('state','=','done'),
                    ('location_dest_id.usage','=','production'),
                    ('production_id','!=',False),
                ])
                ifduplicates:
                    #Maybesomemovelineshavebeencompensatedbyunbuild
                    duplicates_returned=move.product_id._count_returned_sn_products(move_line.lot_id)
                    removed=self.env['stock.move.line'].search_count([
                        ('lot_id','=',move_line.lot_id.id),
                        ('state','=','done'),
                        ('location_dest_id.scrap_location','=',True)
                    ])
                    unremoved=self.env['stock.move.line'].search_count([
                        ('lot_id','=',move_line.lot_id.id),
                        ('state','=','done'),
                        ('location_id.scrap_location','=',True),
                        ('location_dest_id.scrap_location','=',False),
                    ])
                    #Eitherremovedorunbuild
                    ifnot((duplicates_returnedorremoved)andduplicates-duplicates_returned-removed+unremoved==0):
                        raiseUserError(message)
                #Checkpresenceofsamesnincurrentproduction
                duplicates=co_prod_move_lines.filtered(lambdaml:ml.qty_doneandml.lot_id==move_line.lot_id)-move_line
                ifduplicates:
                    raiseUserError(message)

    def_is_finished_sn_already_produced(self,lot,excluded_sml=None):
        excluded_sml=excluded_smlorself.env['stock.move.line']
        domain=[
            ('lot_id','=',lot.id),
            ('qty_done','=',1),
            ('state','=','done')
        ]
        co_prod_move_lines=self.move_finished_ids.move_line_ids-excluded_sml
        domain_unbuild=domain+[
            ('production_id','=',False),
            ('location_dest_id.usage','=','production')
        ]
        #Checkpresenceofsamesninpreviousproductions
        duplicates=self.env['stock.move.line'].search_count(domain+[
            ('location_id.usage','=','production')
        ])
        ifduplicates:
            #Maybesomemovelineshavebeencompensatedbyunbuild
            duplicates_unbuild=self.env['stock.move.line'].search_count(domain_unbuild+[
                ('move_id.unbuild_id','!=',False)
            ])
            removed=self.env['stock.move.line'].search_count([
                ('lot_id','=',lot.id),
                ('state','=','done'),
                ('location_dest_id.scrap_location','=',True)
            ])
            #Eitherremovedorunbuild
            ifnot((duplicates_unbuildorremoved)andduplicates-duplicates_unbuild-removed==0):
                returnTrue
        #Checkpresenceofsamesnincurrentproduction
        duplicates=co_prod_move_lines.filtered(lambdaml:ml.qty_doneandml.lot_id==lot)
        returnbool(duplicates)

    def_check_immediate(self):
        immediate_productions=self.browse()
        ifself.env.context.get('skip_immediate'):
            returnimmediate_productions
        pd=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')
        forproductioninself:
            ifall(float_is_zero(ml.qty_done,precision_digits=pd)for
                    mlinproduction.move_raw_ids.move_line_ids.filtered(lambdam:m.statenotin('done','cancel'))
                    )andfloat_is_zero(production.qty_producing,precision_digits=pd):
                immediate_productions|=production
        returnimmediate_productions

#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

fromflectraimportapi,fields,models,_
fromflectra.exceptionsimportUserError
fromflectra.toolsimportfloat_is_zero,float_round


classChangeProductionQty(models.TransientModel):
    _name='change.production.qty'
    _description='ChangeProductionQty'

    mo_id=fields.Many2one('mrp.production','ManufacturingOrder',
        required=True,ondelete='cascade')
    product_qty=fields.Float(
        'QuantityToProduce',
        digits='ProductUnitofMeasure',required=True)

    @api.model
    defdefault_get(self,fields):
        res=super(ChangeProductionQty,self).default_get(fields)
        if'mo_id'infieldsandnotres.get('mo_id')andself._context.get('active_model')=='mrp.production'andself._context.get('active_id'):
            res['mo_id']=self._context['active_id']
        if'product_qty'infieldsandnotres.get('product_qty')andres.get('mo_id'):
            res['product_qty']=self.env['mrp.production'].browse(res['mo_id']).product_qty
        returnres

    @api.model
    def_update_finished_moves(self,production,new_qty,old_qty):
        """Updatefinishedproductanditsbyproducts.Thismethodonlyupdate
        thefinishedmovesnotdoneorcancelandjustincreaseordecrease
        theirquantityaccordingtheunit_ratio.ItdoesnotusetheBoM,BoM
        modificationduringproductionwouldnotbetakenintoconsideration.
        """
        modification={}
        formoveinproduction.move_finished_ids:
            ifmove.statein('done','cancel'):
                continue
            done_qty=sum(production.move_finished_ids.filtered(
                lambdar:
                    r.product_id==move.product_idand
                    r.state=='done'
                ).mapped('product_uom_qty')
            )
            qty=(new_qty-old_qty)*move.unit_factor+done_qty
            modification[move]=(move.product_uom_qty+qty,move.product_uom_qty)
            if(move.product_uom_qty+qty)>0:
                move.write({'product_uom_qty':move.product_uom_qty+qty})
            else:
                move._action_cancel()

        returnmodification

    defchange_prod_qty(self):
        precision=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')
        forwizardinself:
            production=wizard.mo_id
            produced=sum(production.move_finished_ids.filtered(lambdam:m.product_id==production.product_id).mapped('quantity_done'))
            ifwizard.product_qty<produced:
                format_qty='%.{precision}f'.format(precision=precision)
                raiseUserError(_(
                    "Youhavealreadyprocessed%(quantity)s.Pleaseinputaquantityhigherthan%(minimum)s",
                    quantity=format_qty%produced,
                    minimum=format_qty%produced
                ))
            old_production_qty=production.product_qty
            new_production_qty=wizard.product_qty
            done_moves=production.move_finished_ids.filtered(lambdax:x.state=='done'andx.product_id==production.product_id)
            qty_produced=production.product_id.uom_id._compute_quantity(sum(done_moves.mapped('product_qty')),production.product_uom_id)

            factor=(new_production_qty-qty_produced)/(old_production_qty-qty_produced)
            update_info=production._update_raw_moves(factor)
            documents={}
            formove,old_qty,new_qtyinupdate_info:
                iterate_key=production._get_document_iterate_key(move)
                ifiterate_key:
                    document=self.env['stock.picking']._log_activity_get_documents({move:(new_qty,old_qty)},iterate_key,'UP')
                    forkey,valueindocument.items():
                        ifdocuments.get(key):
                            documents[key]+=[value]
                        else:
                            documents[key]=[value]
            production._log_manufacture_exception(documents)
            finished_moves_modification=self._update_finished_moves(production,new_production_qty-qty_produced,old_production_qty-qty_produced)
            iffinished_moves_modification:
                production._log_downside_manufactured_quantity(finished_moves_modification)
            production.write({'product_qty':new_production_qty})

            forwoinproduction.workorder_ids:
                operation=wo.operation_id
                wo.duration_expected=wo._get_duration_expected(ratio=new_production_qty/old_production_qty)
                quantity=wo.qty_production-wo.qty_produced
                ifproduction.product_id.tracking=='serial':
                    quantity=1.0ifnotfloat_is_zero(quantity,precision_digits=precision)else0.0
                else:
                    quantity=quantityif(quantity>0andnotfloat_is_zero(quantity,precision_digits=precision))else0
                wo._update_qty_producing(quantity)
                ifwo.qty_produced<wo.qty_productionandwo.state=='done':
                    wo.state='progress'
                ifwo.qty_produced==wo.qty_productionandwo.state=='progress':
                    wo.state='done'
                    ifwo.next_work_order_id.state=='pending':
                        wo.next_work_order_id.state='ready'
                #assignmoves;lastoperationreceiveallunassignedmoves
                #TODO:followingcouldbeputinafunctionasitissimilarascodein_workorders_create
                #TODO:onlyneededwhencreatingnewmoves
                moves_raw=production.move_raw_ids.filtered(lambdamove:move.operation_id==operationandmove.statenotin('done','cancel'))
                ifwo==production.workorder_ids[-1]:
                    moves_raw|=production.move_raw_ids.filtered(lambdamove:notmove.operation_id)
                moves_finished=production.move_finished_ids.filtered(lambdamove:move.operation_id==operation)#TODO:codedoesnothing,unlessmaybeby_products?
                moves_raw.mapped('move_line_ids').write({'workorder_id':wo.id})
                (moves_finished+moves_raw).write({'workorder_id':wo.id})
        return{}

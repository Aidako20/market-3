flectra.define('snailmail/static/src/components/message/message_tests.js',function(require){
'usestrict';

constcomponents={
    Message:require('mail/static/src/components/message/message.js'),
};
const{
    afterEach,
    afterNextRender,
    beforeEach,
    createRootComponent,
    start,
}=require('mail/static/src/utils/test_utils.js');

constBus=require('web.Bus');

QUnit.module('snailmail',{},function(){
QUnit.module('components',{},function(){
QUnit.module('message',{},function(){
QUnit.module('message_tests.js',{
    beforeEach(){
        beforeEach(this);

        this.createMessageComponent=async(message,otherProps)=>{
            constprops=Object.assign({messageLocalId:message.localId},otherProps);
            awaitcreateRootComponent(this,components.Message,{
                props,
                target:this.widget.el,
            });
        };

        this.start=asyncparams=>{
            const{env,widget}=awaitstart(Object.assign({},params,{
                data:this.data,
            }));
            this.env=env;
            this.widget=widget;
        };
    },
    afterEach(){
        afterEach(this);
    },
});

QUnit.test('Sent',asyncfunction(assert){
    assert.expect(8);

    awaitthis.start();
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['create',{
            id:11,
            model:'mail.channel',
        }]],
    });
    constmessage=this.env.models['mail.message'].create({
        id:10,
        message_type:'snailmail',
        notifications:[['insert',{
            id:11,
            notification_status:'sent',
            notification_type:'snail',
        }]],
        originThread:[['link',threadViewer.thread]],
    });
    awaitthis.createMessageComponent(message,{
        threadViewLocalId:threadViewer.threadView.localId
    });

    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplayamessagecomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIconClickable',
        "shoulddisplaythenotificationiconcontainer"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIcon',
        "shoulddisplaythenotificationicon"
    );
    assert.hasClass(
        document.querySelector('.o_Message_notificationIcon'),
        'fa-paper-plane',
        "iconshouldrepresentsnailmail"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_Message_notificationIconClickable').click();
    });
    assert.containsOnce(
        document.body,
        '.o_SnailmailNotificationPopover',
        "notificationpopovershouldbeopen"
    );
    assert.containsOnce(
        document.body,
        '.o_SnailmailNotificationPopover_icon',
        "popovershouldhaveoneicon"
    );
    assert.hasClass(
        document.querySelector('.o_SnailmailNotificationPopover_icon'),
        'fa-check',
        "popovershouldhavethesenticon"
    );
    assert.strictEqual(
        document.querySelector('.o_SnailmailNotificationPopover').textContent.trim(),
        "Sent",
        "popovershouldhavethesenttext"
    );
});

QUnit.test('Canceled',asyncfunction(assert){
    assert.expect(8);

    awaitthis.start();
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['create',{
            id:11,
            model:'mail.channel',
        }]],
    });
    constmessage=this.env.models['mail.message'].create({
        id:10,
        message_type:'snailmail',
        notifications:[['insert',{
            id:11,
            notification_status:'canceled',
            notification_type:'snail',
        }]],
        originThread:[['link',threadViewer.thread]],
    });
    awaitthis.createMessageComponent(message,{
        threadViewLocalId:threadViewer.threadView.localId
    });

    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplayamessagecomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIconClickable',
        "shoulddisplaythenotificationiconcontainer"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIcon',
        "shoulddisplaythenotificationicon"
    );
    assert.hasClass(
        document.querySelector('.o_Message_notificationIcon'),
        'fa-paper-plane',
        "iconshouldrepresentsnailmail"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_Message_notificationIconClickable').click();
    });
    assert.containsOnce(
        document.body,
        '.o_SnailmailNotificationPopover',
        "notificationpopovershouldbeopen"
    );
    assert.containsOnce(
        document.body,
        '.o_SnailmailNotificationPopover_icon',
        "popovershouldhaveoneicon"
    );
    assert.hasClass(
        document.querySelector('.o_SnailmailNotificationPopover_icon'),
        'fa-trash-o',
        "popovershouldhavethecanceledicon"
    );
    assert.strictEqual(
        document.querySelector('.o_SnailmailNotificationPopover').textContent.trim(),
        "Canceled",
        "popovershouldhavethecanceledtext"
    );
});

QUnit.test('Pending',asyncfunction(assert){
    assert.expect(8);

    awaitthis.start();
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['create',{
            id:11,
            model:'mail.channel',
        }]],
    });
    constmessage=this.env.models['mail.message'].create({
        id:10,
        message_type:'snailmail',
        notifications:[['insert',{
            id:11,
            notification_status:'ready',
            notification_type:'snail',
        }]],
        originThread:[['link',threadViewer.thread]],
    });
    awaitthis.createMessageComponent(message,{
        threadViewLocalId:threadViewer.threadView.localId
    });

    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplayamessagecomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIconClickable',
        "shoulddisplaythenotificationiconcontainer"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIcon',
        "shoulddisplaythenotificationicon"
    );
    assert.hasClass(
        document.querySelector('.o_Message_notificationIcon'),
        'fa-paper-plane',
        "iconshouldrepresentsnailmail"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_Message_notificationIconClickable').click();
    });
    assert.containsOnce(
        document.body,
        '.o_SnailmailNotificationPopover',
        "notificationpopovershouldbeopen"
    );
    assert.containsOnce(
        document.body,
        '.o_SnailmailNotificationPopover_icon',
        "popovershouldhaveoneicon"
    );
    assert.hasClass(
        document.querySelector('.o_SnailmailNotificationPopover_icon'),
        'fa-clock-o',
        "popovershouldhavethependingicon"
    );
    assert.strictEqual(
        document.querySelector('.o_SnailmailNotificationPopover').textContent.trim(),
        "AwaitingDispatch",
        "popovershouldhavethependingtext"
    );
});

QUnit.test('NoPriceAvailable',asyncfunction(assert){
    assert.expect(10);

    awaitthis.start({
        asyncmockRPC(route,args){
            if(args.method==='cancel_letter'&&args.model==='mail.message'&&args.args[0][0]===10){
                assert.step(args.method);
            }
            returnthis._super(...arguments);
        },
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['create',{
            id:11,
            model:'mail.channel',
        }]],
    });
    constmessage=this.env.models['mail.message'].create({
        id:10,
        message_type:'snailmail',
        notifications:[['insert',{
            failure_type:'sn_price',
            id:11,
            notification_status:'exception',
            notification_type:'snail',
        }]],
        originThread:[['link',threadViewer.thread]],
    });
    awaitthis.createMessageComponent(message,{
        threadViewLocalId:threadViewer.threadView.localId
    });

    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplayamessagecomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIconClickable',
        "shoulddisplaythenotificationiconcontainer"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIcon',
        "shoulddisplaythenotificationicon"
    );
    assert.hasClass(
        document.querySelector('.o_Message_notificationIcon'),
        'fa-paper-plane',
        "iconshouldrepresentsnailmail"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_Message_notificationIconClickable').click();
    });
    assert.containsOnce(
        document.body,
        '.o_SnailmailErrorDialog',
        "errordialogshouldbeopen"
    );
    assert.containsOnce(
        document.body,
        '.o_SnailmailErrorDialog_contentPrice',
        "errordialogshouldhavethe'noprice'content"
    );
    assert.containsOnce(
        document.body,
        '.o_SnailmailErrorDialog_cancelLetterButton',
        "dialogshouldhavea'Cancelletter'button"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_SnailmailErrorDialog_cancelLetterButton').click();
    });
    assert.containsNone(
        document.body,
        '.o_SnailmailErrorDialog',
        "dialogshouldbeclosedafterclickon'Cancelletter'"
    );
    assert.verifySteps(
        ['cancel_letter'],
        "shouldhavemadeaRPCcallto'cancel_letter'"
    );
});

QUnit.test('CreditError',asyncfunction(assert){
    assert.expect(11);

    awaitthis.start({
        asyncmockRPC(route,args){
            if(args.method==='send_letter'&&args.model==='mail.message'&&args.args[0][0]===10){
                assert.step(args.method);
            }
            returnthis._super(...arguments);
        },
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['create',{
            id:11,
            model:'mail.channel',
        }]],
    });
    constmessage=this.env.models['mail.message'].create({
        id:10,
        message_type:'snailmail',
        notifications:[['insert',{
            failure_type:'sn_credit',
            id:11,
            notification_status:'exception',
            notification_type:'snail',
        }]],
        originThread:[['link',threadViewer.thread]],
    });
    awaitthis.createMessageComponent(message,{
        threadViewLocalId:threadViewer.threadView.localId
    });

    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplayamessagecomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIconClickable',
        "shoulddisplaythenotificationiconcontainer"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIcon',
        "shoulddisplaythenotificationicon"
    );
    assert.hasClass(
        document.querySelector('.o_Message_notificationIcon'),
        'fa-paper-plane',
        "iconshouldrepresentsnailmail"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_Message_notificationIconClickable').click();
    });
    assert.containsOnce(
        document.body,
        '.o_SnailmailErrorDialog',
        "errordialogshouldbeopen"
    );
    assert.containsOnce(
        document.body,
        '.o_SnailmailErrorDialog_contentCredit',
        "errordialogshouldhavethe'credit'content"
    );
    assert.containsOnce(
        document.body,
        '.o_SnailmailErrorDialog_resendLetterButton',
        "dialogshouldhavea'Re-sendletter'button"
    );
    assert.containsOnce(
        document.body,
        '.o_SnailmailErrorDialog_cancelLetterButton',
        "dialogshouldhavea'Cancelletter'button"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_SnailmailErrorDialog_resendLetterButton').click();
    });
    assert.containsNone(
        document.body,
        '.o_SnailmailErrorDialog',
        "dialogshouldbeclosedafterclickon'Re-sendletter'"
    );
    assert.verifySteps(
        ['send_letter'],
        "shouldhavemadeaRPCcallto'send_letter'"
    );
});

QUnit.test('TrialError',asyncfunction(assert){
    assert.expect(11);

    awaitthis.start({
        asyncmockRPC(route,args){
            if(args.method==='send_letter'&&args.model==='mail.message'&&args.args[0][0]===10){
                assert.step(args.method);
            }
            returnthis._super(...arguments);
        },
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['create',{
            id:11,
            model:'mail.channel',
        }]],
    });
    constmessage=this.env.models['mail.message'].create({
        id:10,
        message_type:'snailmail',
        notifications:[['insert',{
            failure_type:'sn_trial',
            id:11,
            notification_status:'exception',
            notification_type:'snail',
        }]],
        originThread:[['link',threadViewer.thread]],
    });
    awaitthis.createMessageComponent(message,{
        threadViewLocalId:threadViewer.threadView.localId
    });

    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplayamessagecomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIconClickable',
        "shoulddisplaythenotificationiconcontainer"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIcon',
        "shoulddisplaythenotificationicon"
    );
    assert.hasClass(
        document.querySelector('.o_Message_notificationIcon'),
        'fa-paper-plane',
        "iconshouldrepresentsnailmail"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_Message_notificationIconClickable').click();
    });
    assert.containsOnce(
        document.body,
        '.o_SnailmailErrorDialog',
        "errordialogshouldbeopen"
    );
    assert.containsOnce(
        document.body,
        '.o_SnailmailErrorDialog_contentTrial',
        "errordialogshouldhavethe'trial'content"
    );
    assert.containsOnce(
        document.body,
        '.o_SnailmailErrorDialog_resendLetterButton',
        "dialogshouldhavea'Re-sendletter'button"
    );
    assert.containsOnce(
        document.body,
        '.o_SnailmailErrorDialog_cancelLetterButton',
        "dialogshouldhavea'Cancelletter'button"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_SnailmailErrorDialog_resendLetterButton').click();
    });
    assert.containsNone(
        document.body,
        '.o_SnailmailErrorDialog',
        "dialogshouldbeclosedafterclickon'Re-sendletter'"
    );
    assert.verifySteps(
        ['send_letter'],
        "shouldhavemadeaRPCcallto'send_letter'"
    );
});

QUnit.test('FormatError',asyncfunction(assert){
    assert.expect(8);

    constbus=newBus();
    bus.on('do-action',null,payload=>{
        assert.step('do_action');
        assert.strictEqual(
            payload.action,
            'snailmail.snailmail_letter_format_error_action',
            "actionshouldbetheoneforformaterror"
        );
        assert.strictEqual(
            payload.options.additional_context.message_id,
            10,
            "actionshouldhavecorrectmessageid"
        );
    });

    awaitthis.start({env:{bus}});
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['create',{
            id:11,
            model:'mail.channel',
        }]],
    });
    constmessage=this.env.models['mail.message'].create({
        id:10,
        message_type:'snailmail',
        notifications:[['insert',{
            failure_type:'sn_format',
            id:11,
            notification_status:'exception',
            notification_type:'snail',
        }]],
        originThread:[['link',threadViewer.thread]],
    });
    awaitthis.createMessageComponent(message,{
        threadViewLocalId:threadViewer.threadView.localId
    });

    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplayamessagecomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIconClickable',
        "shoulddisplaythenotificationiconcontainer"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIcon',
        "shoulddisplaythenotificationicon"
    );
    assert.hasClass(
        document.querySelector('.o_Message_notificationIcon'),
        'fa-paper-plane',
        "iconshouldrepresentsnailmail"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_Message_notificationIconClickable').click();
    });
    assert.verifySteps(
        ['do_action'],
        "shoulddoanactiontodisplaytheformaterrordialog"
    );
});

QUnit.test('MissingRequiredFields',asyncfunction(assert){
    assert.expect(8);

    this.data['mail.message'].records.push({
        id:10,//randomuniqueid,usefultolinkletterandnotification
        message_type:'snailmail',
        res_id:20,//non0id,necessarytofetchfailureatinit
        model:'res.partner',//notmail.compose.message,necessarytofetchfailureatinit
    });
    this.data['mail.notification'].records.push({
        failure_type:'sn_fields',
        mail_message_id:10,
        notification_status:'exception',
        notification_type:'snail',
    });
    this.data['snailmail.letter'].records.push({
        id:22,//randomuniqueid,willbeassertedinthetest
        message_id:10,//idofrelatedmessage
    });
    constbus=newBus();
    bus.on('do-action',null,payload=>{
        assert.step('do_action');
        assert.strictEqual(
            payload.action,
            'snailmail.snailmail_letter_missing_required_fields_action',
            "actionshouldbetheoneformissingfields"
        );
        assert.strictEqual(
            payload.options.additional_context.default_letter_id,
            22,
            "actionshouldhavecorrectletterid"
        );
    });

    awaitthis.start({
        env:{bus},
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['insert',{id:20,model:'res.partner'}]],
    });
    constmessage=this.env.models['mail.message'].findFromIdentifyingData({id:10});
    awaitthis.createMessageComponent(message,{
        threadViewLocalId:threadViewer.threadView.localId,
    });

    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplayamessagecomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIconClickable',
        "shoulddisplaythenotificationiconcontainer"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIcon',
        "shoulddisplaythenotificationicon"
    );
    assert.hasClass(
        document.querySelector('.o_Message_notificationIcon'),
        'fa-paper-plane',
        "iconshouldrepresentsnailmail"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_Message_notificationIconClickable').click();
    });
    assert.verifySteps(
        ['do_action'],
        "anactionshouldbedonetodisplaythemissingfieldsdialog"
    );
});

});
});
});

});

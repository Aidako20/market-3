#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

fromflectraimport_,api,fields,models
fromflectra.exceptionsimportUserError
fromflectra.toolsimportfloat_compare


classStockScrap(models.Model):
    _name='stock.scrap'
    _inherit=['mail.thread']
    _order='iddesc'
    _description='Scrap'

    def_get_default_scrap_location_id(self):
        company_id=self.env.context.get('default_company_id')orself.env.company.id
        returnself.env['stock.location'].search([('scrap_location','=',True),('company_id','in',[company_id,False])],limit=1).id

    def_get_default_location_id(self):
        company_id=self.env.context.get('default_company_id')orself.env.company.id
        warehouse=self.env['stock.warehouse'].search([('company_id','=',company_id)],limit=1)
        ifwarehouse:
            returnwarehouse.lot_stock_id.id
        returnNone

    name=fields.Char(
        'Reference', default=lambdaself:_('New'),
        copy=False,readonly=True,required=True,
        states={'done':[('readonly',True)]})
    company_id=fields.Many2one('res.company',string='Company',default=lambdaself:self.env.company,required=True,states={'done':[('readonly',True)]})
    origin=fields.Char(string='SourceDocument')
    product_id=fields.Many2one(
        'product.product','Product',domain="[('type','in',['product','consu']),'|',('company_id','=',False),('company_id','=',company_id)]",
        required=True,states={'done':[('readonly',True)]},check_company=True)
    product_uom_id=fields.Many2one(
        'uom.uom','UnitofMeasure',
        required=True,states={'done':[('readonly',True)]},domain="[('category_id','=',product_uom_category_id)]")
    product_uom_category_id=fields.Many2one(related='product_id.uom_id.category_id')
    tracking=fields.Selection(string='ProductTracking',readonly=True,related="product_id.tracking")
    lot_id=fields.Many2one(
        'stock.production.lot','Lot/Serial',
        states={'done':[('readonly',True)]},domain="[('product_id','=',product_id),('company_id','=',company_id)]",check_company=True)
    package_id=fields.Many2one(
        'stock.quant.package','Package',
        states={'done':[('readonly',True)]},check_company=True)
    owner_id=fields.Many2one('res.partner','Owner',states={'done':[('readonly',True)]},check_company=True)
    move_id=fields.Many2one('stock.move','ScrapMove',readonly=True,check_company=True,copy=False)
    picking_id=fields.Many2one('stock.picking','Picking',states={'done':[('readonly',True)]},check_company=True)
    location_id=fields.Many2one(
        'stock.location','SourceLocation',domain="[('usage','=','internal'),('company_id','in',[company_id,False])]",
        required=True,states={'done':[('readonly',True)]},default=_get_default_location_id,check_company=True)
    scrap_location_id=fields.Many2one(
        'stock.location','ScrapLocation',default=_get_default_scrap_location_id,
        domain="[('scrap_location','=',True),('company_id','in',[company_id,False])]",required=True,states={'done':[('readonly',True)]},check_company=True)
    scrap_qty=fields.Float('Quantity',default=1.0,required=True,states={'done':[('readonly',True)]},digits='ProductUnitofMeasure')
    state=fields.Selection([
        ('draft','Draft'),
        ('done','Done')],
        string='Status',default="draft",readonly=True,tracking=True)
    date_done=fields.Datetime('Date',readonly=True)

    @api.onchange('picking_id')
    def_onchange_picking_id(self):
        ifself.picking_id:
            self.location_id=(self.picking_id.state=='done')andself.picking_id.location_dest_id.idorself.picking_id.location_id.id

    @api.onchange('product_id')
    def_onchange_product_id(self):
        ifself.product_id:
            ifself.tracking=='serial':
                self.scrap_qty=1
            self.product_uom_id=self.product_id.uom_id.id
            #Checkifwecangetamorepreciselocationinsteadof
            #thedefaultlocation(alocationcorrespondingtowherethe
            #reservedproductisstored)
            ifself.picking_id:
                formove_lineinself.picking_id.move_line_ids:
                    ifmove_line.product_id==self.product_id:
                        self.location_id=move_line.location_idifmove_line.state!='done'elsemove_line.location_dest_id
                        break

    @api.onchange('company_id')
    def_onchange_company_id(self):
        ifself.company_id:
            warehouse=self.env['stock.warehouse'].search([('company_id','=',self.company_id.id)],limit=1)
            #Changethelocationsonlyiftheircompanydoesn'tmatchthecompanyset,otherwise
            #userdefaultsareoverridden.
            ifself.location_id.company_id!=self.company_id:
                self.location_id=warehouse.lot_stock_id
            ifself.scrap_location_id.company_id!=self.company_id:
                self.scrap_location_id=self.env['stock.location'].search([
                    ('scrap_location','=',True),
                    ('company_id','in',[self.company_id.id,False]),
                ],limit=1)
        else:
            self.location_id=False
            self.scrap_location_id=False

    defunlink(self):
        if'done'inself.mapped('state'):
            raiseUserError(_('Youcannotdeleteascrapwhichisdone.'))
        returnsuper(StockScrap,self).unlink()

    def_prepare_move_values(self):
        self.ensure_one()
        return{
            'name':self.name,
            'origin':self.originorself.picking_id.nameorself.name,
            'company_id':self.company_id.id,
            'product_id':self.product_id.id,
            'product_uom':self.product_uom_id.id,
            'state':'draft',
            'product_uom_qty':self.scrap_qty,
            'location_id':self.location_id.id,
            'scrapped':True,
            'location_dest_id':self.scrap_location_id.id,
            'move_line_ids':[(0,0,{'product_id':self.product_id.id,
                                           'product_uom_id':self.product_uom_id.id,
                                           'qty_done':self.scrap_qty,
                                           'location_id':self.location_id.id,
                                           'location_dest_id':self.scrap_location_id.id,
                                           'package_id':self.package_id.id,
                                           'owner_id':self.owner_id.id,
                                           'lot_id':self.lot_id.id,})],
#            'restrict_partner_id':self.owner_id.id,
            'picking_id':self.picking_id.id
        }

    defdo_scrap(self):
        self._check_company()
        forscrapinself:
            scrap.name=self.env['ir.sequence'].next_by_code('stock.scrap')or_('New')
            move=self.env['stock.move'].create(scrap._prepare_move_values())
            #master:replacecontextbycancel_backorder
            move.with_context(is_scrap=True)._action_done()
            scrap.write({'move_id':move.id,'state':'done'})
            scrap.date_done=fields.Datetime.now()
        returnTrue

    defaction_get_stock_picking(self):
        action=self.env['ir.actions.act_window']._for_xml_id('stock.action_picking_tree_all')
        action['domain']=[('id','=',self.picking_id.id)]
        returnaction

    defaction_get_stock_move_lines(self):
        action=self.env['ir.actions.act_window']._for_xml_id('stock.stock_move_line_action')
        action['domain']=[('move_id','=',self.move_id.id)]
        returnaction

    defaction_validate(self):
        self.ensure_one()
        ifself.product_id.type!='product':
            returnself.do_scrap()
        precision=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')
        available_qty=sum(self.env['stock.quant']._gather(self.product_id,
                                                            self.location_id,
                                                            self.lot_id,
                                                            self.package_id,
                                                            self.owner_id,
                                                            strict=True).mapped('quantity'))
        scrap_qty=self.product_uom_id._compute_quantity(self.scrap_qty,self.product_id.uom_id)
        iffloat_compare(available_qty,scrap_qty,precision_digits=precision)>=0:
            returnself.do_scrap()
        else:
            ctx=dict(self.env.context)
            ctx.update({
                'default_product_id':self.product_id.id,
                'default_location_id':self.location_id.id,
                'default_scrap_id':self.id,
                'default_quantity':scrap_qty,
                'default_product_uom_name':self.product_id.uom_name
            })
            return{
                'name':self.product_id.display_name+_(':InsufficientQuantityToScrap'),
                'view_mode':'form',
                'res_model':'stock.warn.insufficient.qty.scrap',
                'view_id':self.env.ref('stock.stock_warn_insufficient_qty_scrap_form_view').id,
                'type':'ir.actions.act_window',
                'context':ctx,
                'target':'new'
            }

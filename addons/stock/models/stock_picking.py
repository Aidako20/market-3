#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

importjson
importtime
fromastimportliteral_eval
fromcollectionsimportdefaultdict
fromdatetimeimportdate
fromitertoolsimportgroupby
fromoperatorimportattrgetter,itemgetter
fromcollectionsimportdefaultdict

fromflectraimportSUPERUSER_ID,_,api,fields,models
fromflectra.addons.stock.models.stock_moveimportPROCUREMENT_PRIORITIES
fromflectra.exceptionsimportUserError
fromflectra.osvimportexpression
fromflectra.toolsimportDEFAULT_SERVER_DATETIME_FORMAT,format_datetime
fromflectra.tools.float_utilsimportfloat_compare,float_is_zero,float_round
fromflectra.tools.miscimportformat_date


classPickingType(models.Model):
    _name="stock.picking.type"
    _description="PickingType"
    _order='sequence,id'
    _check_company_auto=True

    def_default_show_operations(self):
        returnself.user_has_groups('stock.group_production_lot,'
                                    'stock.group_stock_multi_locations,'
                                    'stock.group_tracking_lot')

    name=fields.Char('OperationType',required=True,translate=True)
    color=fields.Integer('Color')
    sequence=fields.Integer('Sequence',help="Usedtoorderthe'AllOperations'kanbanview")
    sequence_id=fields.Many2one(
        'ir.sequence','ReferenceSequence',
        check_company=True,copy=False)
    sequence_code=fields.Char('Code',required=True)
    default_location_src_id=fields.Many2one(
        'stock.location','DefaultSourceLocation',
        check_company=True,
        help="Thisisthedefaultsourcelocationwhenyoucreateapickingmanuallywiththisoperationtype.Itispossiblehowevertochangeitorthattheroutesputanotherlocation.Ifitisempty,itwillcheckforthesupplierlocationonthepartner.")
    default_location_dest_id=fields.Many2one(
        'stock.location','DefaultDestinationLocation',
        check_company=True,
        help="Thisisthedefaultdestinationlocationwhenyoucreateapickingmanuallywiththisoperationtype.Itispossiblehowevertochangeitorthattheroutesputanotherlocation.Ifitisempty,itwillcheckforthecustomerlocationonthepartner.")
    code=fields.Selection([('incoming','Receipt'),('outgoing','Delivery'),('internal','InternalTransfer')],'TypeofOperation',required=True)
    return_picking_type_id=fields.Many2one(
        'stock.picking.type','OperationTypeforReturns',
        check_company=True)
    show_entire_packs=fields.Boolean('MoveEntirePackages',help="Ifticked,youwillbeabletoselectentirepackagestomove")
    warehouse_id=fields.Many2one(
        'stock.warehouse','Warehouse',ondelete='cascade',
        check_company=True)
    active=fields.Boolean('Active',default=True)
    use_create_lots=fields.Boolean(
        'CreateNewLots/SerialNumbers',default=True,
        help="Ifthisischeckedonly,itwillsupposeyouwanttocreatenewLots/SerialNumbers,soyoucanprovidetheminatextfield.")
    use_existing_lots=fields.Boolean(
        'UseExistingLots/SerialNumbers',default=True,
        help="Ifthisischecked,youwillbeabletochoosetheLots/SerialNumbers.Youcanalsodecidetonotputlotsinthisoperationtype. Thismeansitwillcreatestockwithnolotornotputarestrictiononthelottaken.")
    show_operations=fields.Boolean(
        'ShowDetailedOperations',default=_default_show_operations,
        help="Ifthischeckboxisticked,thepickingslineswillrepresentdetailedstockoperations.Ifnot,thepickinglineswillrepresentanaggregateofdetailedstockoperations.")
    show_reserved=fields.Boolean(
        'Pre-fillDetailedOperations',default=True,
        help="Ifthischeckboxisticked,Flectrawillautomaticallypre-fillthedetailed"
        "operationswiththecorrespondingproducts,locationsandlot/serialnumbers.")

    count_picking_draft=fields.Integer(compute='_compute_picking_count')
    count_picking_ready=fields.Integer(compute='_compute_picking_count')
    count_picking=fields.Integer(compute='_compute_picking_count')
    count_picking_waiting=fields.Integer(compute='_compute_picking_count')
    count_picking_late=fields.Integer(compute='_compute_picking_count')
    count_picking_backorders=fields.Integer(compute='_compute_picking_count')
    rate_picking_late=fields.Integer(compute='_compute_picking_count')
    rate_picking_backorders=fields.Integer(compute='_compute_picking_count')
    barcode=fields.Char('Barcode',copy=False)
    company_id=fields.Many2one(
        'res.company','Company',required=True,
        default=lambdas:s.env.company.id,index=True)

    @api.model
    defcreate(self,vals):
        ifnotvals.get('sequence_id')andvals.get('sequence_code'):
            ifvals.get('warehouse_id'):
                wh=self.env['stock.warehouse'].browse(vals['warehouse_id'])
                vals['sequence_id']=self.env['ir.sequence'].sudo().create({
                    'name':wh.name+''+_('Sequence')+''+vals['sequence_code'],
                    'prefix':wh.code+'/'+vals['sequence_code']+'/','padding':5,
                    'company_id':wh.company_id.id,
                }).id
            else:
                vals['sequence_id']=self.env['ir.sequence'].sudo().create({
                    'name':_('Sequence')+''+vals['sequence_code'],
                    'prefix':vals['sequence_code'],'padding':5,
                    'company_id':vals.get('company_id')orself.env.company.id,
                }).id

        picking_type=super(PickingType,self).create(vals)
        returnpicking_type

    defwrite(self,vals):
        if'company_id'invals:
            forpicking_typeinself:
                ifpicking_type.company_id.id!=vals['company_id']:
                    raiseUserError(_("Changingthecompanyofthisrecordisforbiddenatthispoint,youshouldratherarchiveitandcreateanewone."))
        if'sequence_code'invals:
            forpicking_typeinself:
                ifpicking_type.warehouse_id:
                    picking_type.sequence_id.sudo().write({
                        'name':picking_type.warehouse_id.name+''+_('Sequence')+''+vals['sequence_code'],
                        'prefix':picking_type.warehouse_id.code+'/'+vals['sequence_code']+'/','padding':5,
                        'company_id':picking_type.warehouse_id.company_id.id,
                    })
                else:
                    picking_type.sequence_id.sudo().write({
                        'name':_('Sequence')+''+vals['sequence_code'],
                        'prefix':vals['sequence_code'],'padding':5,
                        'company_id':picking_type.env.company.id,
                    })
        returnsuper(PickingType,self).write(vals)

    def_compute_picking_count(self):
        #TDETODOcountpickingcanbedoneusingprevioustwo
        domains={
            'count_picking_draft':[('state','=','draft')],
            'count_picking_waiting':[('state','in',('confirmed','waiting'))],
            'count_picking_ready':[('state','=','assigned')],
            'count_picking':[('state','in',('assigned','waiting','confirmed'))],
            'count_picking_late':[('scheduled_date','<',time.strftime(DEFAULT_SERVER_DATETIME_FORMAT)),('state','in',('assigned','waiting','confirmed'))],
            'count_picking_backorders':[('backorder_id','!=',False),('state','in',('confirmed','assigned','waiting'))],
        }
        forfieldindomains:
            data=self.env['stock.picking'].read_group(domains[field]+
                [('state','notin',('done','cancel')),('picking_type_id','in',self.ids)],
                ['picking_type_id'],['picking_type_id'])
            count={
                x['picking_type_id'][0]:x['picking_type_id_count']
                forxindataifx['picking_type_id']
            }
            forrecordinself:
                record[field]=count.get(record.id,0)
        forrecordinself:
            record.rate_picking_late=record.count_pickingandrecord.count_picking_late*100/record.count_pickingor0
            record.rate_picking_backorders=record.count_pickingandrecord.count_picking_backorders*100/record.count_pickingor0

    defname_get(self):
        """Display'Warehouse_name:PickingType_name'"""
        res=[]
        forpicking_typeinself:
            ifpicking_type.warehouse_id:
                name=picking_type.warehouse_id.name+':'+picking_type.name
            else:
                name=picking_type.name
            res.append((picking_type.id,name))
        returnres

    @api.model
    def_name_search(self,name,args=None,operator='ilike',limit=100,name_get_uid=None):
        args=argsor[]
        domain=[]
        ifname:
            #Trytoreversethe`name_get`structure
            parts=name.split(':')
            iflen(parts)==2:
                domain=[('warehouse_id.name',operator,parts[0]),('name',operator,parts[1])]
            else:
                domain=['|',('name',operator,name),('warehouse_id.name',operator,name)]
        returnself._search(expression.AND([domain,args]),limit=limit,access_rights_uid=name_get_uid)

    @api.onchange('code')
    def_onchange_picking_code(self):
        warehouse=self.env['stock.warehouse'].search([('company_id','=',self.company_id.id)],limit=1)
        stock_location=warehouse.lot_stock_id
        self.show_operations=self.code!='incoming'andself.user_has_groups(
            'stock.group_production_lot,'
            'stock.group_stock_multi_locations,'
            'stock.group_tracking_lot'
        )
        ifself.code=='incoming':
            self.default_location_src_id=self.env.ref('stock.stock_location_suppliers').id
            self.default_location_dest_id=stock_location.id
        elifself.code=='outgoing':
            self.default_location_src_id=stock_location.id
            self.default_location_dest_id=self.env.ref('stock.stock_location_customers').id
        elifself.code=='internal'andnotself.user_has_groups('stock.group_stock_multi_locations'):
            return{
                'warning':{
                    'message':_('Youneedtoactivatestoragelocationstobeabletodointernaloperationtypes.')
                }
            }

    @api.onchange('company_id')
    def_onchange_company_id(self):
        ifself.company_id:
            warehouse=self.env['stock.warehouse'].search([('company_id','=',self.company_id.id)],limit=1)
            self.warehouse_id=warehouse
        else:
            self.warehouse_id=False

    @api.onchange('show_operations')
    def_onchange_show_operations(self):
        ifself.show_operationsandself.code!='incoming':
            self.show_reserved=True

    def_get_action(self,action_xmlid):
        action=self.env["ir.actions.actions"]._for_xml_id(action_xmlid)
        ifself:
            action['display_name']=self.display_name

        default_immediate_tranfer=True
        ifself.env['ir.config_parameter'].sudo().get_param('stock.no_default_immediate_tranfer'):
            default_immediate_tranfer=False

        context={
            'search_default_picking_type_id':[self.id],
            'default_picking_type_id':self.id,
            'default_immediate_transfer':default_immediate_tranfer,
            'default_company_id':self.company_id.id,
        }

        action_context=literal_eval(action['context'])
        context={**action_context,**context}
        action['context']=context
        returnaction

    defget_action_picking_tree_late(self):
        returnself._get_action('stock.action_picking_tree_late')

    defget_action_picking_tree_backorder(self):
        returnself._get_action('stock.action_picking_tree_backorder')

    defget_action_picking_tree_waiting(self):
        returnself._get_action('stock.action_picking_tree_waiting')

    defget_action_picking_tree_ready(self):
        returnself._get_action('stock.action_picking_tree_ready')

    defget_stock_picking_action_picking_type(self):
        returnself._get_action('stock.stock_picking_action_picking_type')


classPicking(models.Model):
    _name="stock.picking"
    _inherit=['mail.thread','mail.activity.mixin']
    _description="Transfer"
    _order="prioritydesc,scheduled_dateasc,iddesc"

    name=fields.Char(
        'Reference',default='/',
        copy=False,index=True,readonly=True)
    origin=fields.Char(
        'SourceDocument',index=True,
        states={'done':[('readonly',True)],'cancel':[('readonly',True)]},
        help="Referenceofthedocument")
    note=fields.Text('Notes')
    backorder_id=fields.Many2one(
        'stock.picking','BackOrderof',
        copy=False,index=True,readonly=True,
        check_company=True,
        help="Ifthisshipmentwassplit,thenthisfieldlinkstotheshipmentwhichcontainsthealreadyprocessedpart.")
    backorder_ids=fields.One2many('stock.picking','backorder_id','BackOrders')
    move_type=fields.Selection([
        ('direct','Assoonaspossible'),('one','Whenallproductsareready')],'ShippingPolicy',
        default='direct',required=True,
        states={'done':[('readonly',True)],'cancel':[('readonly',True)]},
        help="Itspecifiesgoodstobedeliverpartiallyorallatonce")
    state=fields.Selection([
        ('draft','Draft'),
        ('waiting','WaitingAnotherOperation'),
        ('confirmed','Waiting'),
        ('assigned','Ready'),
        ('done','Done'),
        ('cancel','Cancelled'),
    ],string='Status',compute='_compute_state',
        copy=False,index=True,readonly=True,store=True,tracking=True,
        help="*Draft:Thetransferisnotconfirmedyet.Reservationdoesn'tapply.\n"
             "*Waitinganotheroperation:Thistransferiswaitingforanotheroperationbeforebeingready.\n"
             "*Waiting:Thetransferiswaitingfortheavailabilityofsomeproducts.\n(a)Theshippingpolicyis\"Assoonaspossible\":noproductcouldbereserved.\n(b)Theshippingpolicyis\"Whenallproductsareready\":notalltheproductscouldbereserved.\n"
             "*Ready:Thetransferisreadytobeprocessed.\n(a)Theshippingpolicyis\"Assoonaspossible\":atleastoneproducthasbeenreserved.\n(b)Theshippingpolicyis\"Whenallproductsareready\":allproducthavebeenreserved.\n"
             "*Done:Thetransferhasbeenprocessed.\n"
             "*Cancelled:Thetransferhasbeencancelled.")
    group_id=fields.Many2one(
        'procurement.group','ProcurementGroup',
        readonly=True,related='move_lines.group_id',store=True)
    priority=fields.Selection(
        PROCUREMENT_PRIORITIES,string='Priority',default='0',index=True,
        help="Productswillbereservedfirstforthetransferswiththehighestpriorities.")
    scheduled_date=fields.Datetime(
        'ScheduledDate',compute='_compute_scheduled_date',inverse='_set_scheduled_date',store=True,
        index=True,default=fields.Datetime.now,tracking=True,
        states={'done':[('readonly',True)],'cancel':[('readonly',True)]},
        help="Scheduledtimeforthefirstpartoftheshipmenttobeprocessed.Settingmanuallyavalueherewouldsetitasexpecteddateforallthestockmoves.")
    date_deadline=fields.Datetime(
        "Deadline",compute='_compute_date_deadline',store=True,
        help="DatePromisetothecustomeronthetopleveldocument(SO/PO)")
    has_deadline_issue=fields.Boolean(
        "Islate",compute='_compute_has_deadline_issue',store=True,default=False,
        help="Islateorwillbelatedependingonthedeadlineandscheduleddate")
    date=fields.Datetime(
        'CreationDate',
        default=fields.Datetime.now,index=True,tracking=True,
        states={'done':[('readonly',True)],'cancel':[('readonly',True)]},
        help="CreationDate,usuallythetimeoftheorder")
    date_done=fields.Datetime('DateofTransfer',copy=False,readonly=True,help="Dateatwhichthetransferhasbeenprocessedorcancelled.")
    delay_alert_date=fields.Datetime('DelayAlertDate',compute='_compute_delay_alert_date',search='_search_delay_alert_date')
    json_popover=fields.Char('JSONdataforthepopoverwidget',compute='_compute_json_popover')
    location_id=fields.Many2one(
        'stock.location',"SourceLocation",
        default=lambdaself:self.env['stock.picking.type'].browse(self._context.get('default_picking_type_id')).default_location_src_id,
        check_company=True,readonly=True,required=True,
        states={'draft':[('readonly',False)]})
    location_dest_id=fields.Many2one(
        'stock.location',"DestinationLocation",
        default=lambdaself:self.env['stock.picking.type'].browse(self._context.get('default_picking_type_id')).default_location_dest_id,
        check_company=True,readonly=True,required=True,
        states={'draft':[('readonly',False)]})
    move_lines=fields.One2many('stock.move','picking_id',string="StockMoves",copy=True)
    move_ids_without_package=fields.One2many('stock.move','picking_id',string="Stockmovesnotinpackage",compute='_compute_move_without_package',inverse='_set_move_without_package')
    has_scrap_move=fields.Boolean(
        'HasScrapMoves',compute='_has_scrap_move')
    picking_type_id=fields.Many2one(
        'stock.picking.type','OperationType',
        required=True,readonly=True,
        states={'draft':[('readonly',False)]})
    picking_type_code=fields.Selection(
        related='picking_type_id.code',
        readonly=True)
    picking_type_entire_packs=fields.Boolean(related='picking_type_id.show_entire_packs',
        readonly=True)
    hide_picking_type=fields.Boolean(compute='_compute_hide_pickign_type')
    partner_id=fields.Many2one(
        'res.partner','Contact',
        check_company=True,
        states={'done':[('readonly',True)],'cancel':[('readonly',True)]})
    company_id=fields.Many2one(
        'res.company',string='Company',related='picking_type_id.company_id',
        readonly=True,store=True,index=True)
    user_id=fields.Many2one(
        'res.users','Responsible',tracking=True,
        domain=lambdaself:[('groups_id','in',self.env.ref('stock.group_stock_user').id)],
        states={'done':[('readonly',True)],'cancel':[('readonly',True)]},
        default=lambdaself:self.env.user)
    move_line_ids=fields.One2many('stock.move.line','picking_id','Operations')
    move_line_ids_without_package=fields.One2many('stock.move.line','picking_id','Operationswithoutpackage',domain=['|',('package_level_id','=',False),('picking_type_entire_packs','=',False)])
    move_line_nosuggest_ids=fields.One2many('stock.move.line','picking_id',domain=[('product_qty','=',0.0)])
    move_line_exist=fields.Boolean(
        'HasPackOperations',compute='_compute_move_line_exist',
        help='Checktheexistenceofpackoperationonthepicking')
    has_packages=fields.Boolean(
        'HasPackages',compute='_compute_has_packages',
        help='Checktheexistenceofdestinationpackagesonmovelines')
    show_check_availability=fields.Boolean(
        compute='_compute_show_check_availability',
        help='Technicalfieldusedtocomputewhetherthebutton"CheckAvailability"shouldbedisplayed.')
    show_mark_as_todo=fields.Boolean(
        compute='_compute_show_mark_as_todo',
        help='Technicalfieldusedtocomputewhetherthebutton"MarkasTodo"shouldbedisplayed.')
    show_validate=fields.Boolean(
        compute='_compute_show_validate',
        help='Technicalfieldusedtodecidewhetherthebutton"Validate"shouldbedisplayed.')
    use_create_lots=fields.Boolean(related='picking_type_id.use_create_lots')
    owner_id=fields.Many2one(
        'res.partner','AssignOwner',
        states={'done':[('readonly',True)],'cancel':[('readonly',True)]},
        check_company=True,
        help="Whenvalidatingthetransfer,theproductswillbeassignedtothisowner.")
    printed=fields.Boolean('Printed',copy=False)
    signature=fields.Image('Signature',help='Signature',copy=False,attachment=True)
    is_locked=fields.Boolean(default=True,help='Whenthepickingisnotdonethisallowschangingthe'
                               'initialdemand.Whenthepickingisdonethisallows'
                               'changingthedonequantities.')
    #Usedtosearchonpickings
    product_id=fields.Many2one('product.product','Product',related='move_lines.product_id',readonly=True)
    show_operations=fields.Boolean(compute='_compute_show_operations')
    show_reserved=fields.Boolean(related='picking_type_id.show_reserved')
    show_lots_text=fields.Boolean(compute='_compute_show_lots_text')
    has_tracking=fields.Boolean(compute='_compute_has_tracking')
    immediate_transfer=fields.Boolean(default=False)
    package_level_ids=fields.One2many('stock.package_level','picking_id')
    package_level_ids_details=fields.One2many('stock.package_level','picking_id')
    products_availability=fields.Char(
        string="ProductAvailability",compute='_compute_products_availability')
    products_availability_state=fields.Selection([
        ('available','Available'),
        ('expected','Expected'),
        ('late','Late')],compute='_compute_products_availability')

    _sql_constraints=[
        ('name_uniq','unique(name,company_id)','Referencemustbeuniquepercompany!'),
    ]

    def_compute_has_tracking(self):
        forpickinginself:
            picking.has_tracking=any(m.has_tracking!='none'forminpicking.move_lines)

    @api.depends('date_deadline','scheduled_date')
    def_compute_has_deadline_issue(self):
        forpickinginself:
            picking.has_deadline_issue=picking.date_deadlineandpicking.date_deadline<picking.scheduled_dateorFalse

    def_compute_hide_pickign_type(self):
        self.hide_picking_type=self.env.context.get('default_picking_type_id',False)

    @api.depends('move_lines.delay_alert_date')
    def_compute_delay_alert_date(self):
        delay_alert_date_data=self.env['stock.move'].read_group([('id','in',self.move_lines.ids),('delay_alert_date','!=',False)],['delay_alert_date:max'],'picking_id')
        delay_alert_date_data={data['picking_id'][0]:data['delay_alert_date']fordataindelay_alert_date_data}
        forpickinginself:
            picking.delay_alert_date=delay_alert_date_data.get(picking.id,False)

    @api.depends('move_lines','state','picking_type_code','move_lines.forecast_availability','move_lines.forecast_expected_date')
    def_compute_products_availability(self):
        self.products_availability=False
        self.products_availability_state='available'
        pickings=self.filtered(lambdapicking:picking.statenotin['cancel','draft','done']andpicking.picking_type_code=='outgoing')
        pickings.products_availability=_('Available')
        forpickinginpickings:
            forecast_date=max(picking.move_lines.filtered('forecast_expected_date').mapped('forecast_expected_date'),default=False)
            ifany(float_compare(move.forecast_availability,move.product_qty,precision_rounding=move.product_id.uom_id.rounding)==-1formoveinpicking.move_lines):
                picking.products_availability=_('NotAvailable')
                picking.products_availability_state='late'
            elifforecast_date:
                picking.products_availability=_('Exp%s',format_date(self.env,forecast_date))
                picking.products_availability_state='late'ifpicking.date_deadlineandpicking.date_deadline<forecast_dateelse'expected'

    @api.depends('picking_type_id.show_operations')
    def_compute_show_operations(self):
        forpickinginself:
            ifself.env.context.get('force_detailed_view'):
                picking.show_operations=True
                continue
            ifpicking.picking_type_id.show_operations:
                if(picking.state=='draft'andpicking.immediate_transfer)orpicking.state!='draft':
                    picking.show_operations=True
                else:
                    picking.show_operations=False
            else:
                picking.show_operations=False

    @api.depends('move_line_ids','picking_type_id.use_create_lots','picking_type_id.use_existing_lots','state')
    def_compute_show_lots_text(self):
        group_production_lot_enabled=self.user_has_groups('stock.group_production_lot')
        forpickinginself:
            ifnotpicking.move_line_idsandnotpicking.picking_type_id.use_create_lots:
                picking.show_lots_text=False
            elifgroup_production_lot_enabledandpicking.picking_type_id.use_create_lots\
                    andnotpicking.picking_type_id.use_existing_lotsandpicking.state!='done':
                picking.show_lots_text=True
            else:
                picking.show_lots_text=False

    def_compute_json_popover(self):
        forpickinginself:
            ifpicking.statein('done','cancel')ornotpicking.delay_alert_date:
                picking.json_popover=False
                continue
            picking.json_popover=json.dumps({
                'popoverTemplate':'stock.PopoverStockRescheduling',
                'delay_alert_date':format_datetime(self.env,picking.delay_alert_date,dt_format=False)ifpicking.delay_alert_dateelseFalse,
                'late_elements':[{
                        'id':late_move.id,
                        'name':late_move.display_name,
                        'model':late_move._name,
                    }forlate_moveinpicking.move_lines.filtered(lambdam:m.delay_alert_date).move_orig_ids._delay_alert_get_documents()
                ]
            })

    @api.depends('move_type','immediate_transfer','move_lines.state','move_lines.picking_id')
    def_compute_state(self):
        '''Stateofapickingdependsonthestateofitsrelatedstock.move
        -Draft:onlyusedfor"plannedpickings"
        -Waiting:ifthepickingisnotreadytobesentsoif
          -(a)noquantitycouldbereservedatallorif
          -(b)somequantitiescouldbereservedandtheshippingpolicyis"deliverallatonce"
        -Waitinganothermove:ifthepickingiswaitingforanothermove
        -Ready:ifthepickingisreadytobesentsoif:
          -(a)allquantitiesarereservedorif
          -(b)somequantitiescouldbereservedandtheshippingpolicyis"assoonaspossible"
        -Done:ifthepickingisdone.
        -Cancelled:ifthepickingiscancelled
        '''
        picking_moves_state_map=defaultdict(dict)
        picking_move_lines=defaultdict(set)
        formoveinself.env['stock.move'].search([('picking_id','in',self.ids)]):
            picking_id=move.picking_id
            move_state=move.state
            picking_moves_state_map[picking_id.id].update({
                'any_draft':picking_moves_state_map[picking_id.id].get('any_draft',False)ormove_state=='draft',
                'all_cancel':picking_moves_state_map[picking_id.id].get('all_cancel',True)andmove_state=='cancel',
                'all_cancel_done':picking_moves_state_map[picking_id.id].get('all_cancel_done',True)andmove_statein('cancel','done'),
                'all_done_are_scrapped':picking_moves_state_map[picking_id.id].get('all_done_are_scrapped',True)and(move.scrappedifmove_state=='done'elseTrue),
                'any_cancel_and_not_scrapped':picking_moves_state_map[picking_id.id].get('any_cancel_and_not_scrapped',False)or(move_state=='cancel'andnotmove.scrapped),
            })
            picking_move_lines[picking_id.id].add(move.id)
        forpickinginself:
            picking_id=(picking.idsandpicking.ids[0])orpicking.id
            ifnotpicking_moves_state_map[picking_id]:
                picking.state='draft'
            elifpicking_moves_state_map[picking_id]['any_draft']:
                picking.state='draft'
            elifpicking_moves_state_map[picking_id]['all_cancel']:
                picking.state='cancel'
            elifpicking_moves_state_map[picking_id]['all_cancel_done']:
                ifpicking_moves_state_map[picking_id]['all_done_are_scrapped']andpicking_moves_state_map[picking_id]['any_cancel_and_not_scrapped']:
                    picking.state='cancel'
                else:
                    picking.state='done'
            else:
                relevant_move_state=self.env['stock.move'].browse(picking_move_lines[picking_id])._get_relevant_state_among_moves()
                ifpicking.immediate_transferandrelevant_move_statenotin('draft','cancel','done'):
                    picking.state='assigned'
                elifrelevant_move_state=='partially_available':
                    picking.state='assigned'
                else:
                    picking.state=relevant_move_state

    @api.depends('move_lines.state','move_lines.date','move_type')
    def_compute_scheduled_date(self):
        forpickinginself:
            moves_dates=picking.move_lines.filtered(lambdamove:move.statenotin('done','cancel')).mapped('date')
            ifpicking.move_type=='direct':
                picking.scheduled_date=min(moves_dates,default=picking.scheduled_dateorfields.Datetime.now())
            else:
                picking.scheduled_date=max(moves_dates,default=picking.scheduled_dateorfields.Datetime.now())

    @api.depends('move_lines.date_deadline','move_type')
    def_compute_date_deadline(self):
        forpickinginself:
            ifpicking.move_type=='direct':
                picking.date_deadline=min(picking.move_lines.filtered('date_deadline').mapped('date_deadline'),default=False)
            else:
                picking.date_deadline=max(picking.move_lines.filtered('date_deadline').mapped('date_deadline'),default=False)

    def_set_scheduled_date(self):
        forpickinginself:
            ifpicking.statein('done','cancel'):
                raiseUserError(_("YoucannotchangetheScheduledDateonadoneorcancelledtransfer."))
            picking.move_lines.write({'date':picking.scheduled_date})

    def_has_scrap_move(self):
        forpickinginself:
            #TDEFIXME:betterimplementation
            picking.has_scrap_move=bool(self.env['stock.move'].search_count([('picking_id','=',picking.id),('scrapped','=',True)]))

    def_compute_move_line_exist(self):
        forpickinginself:
            picking.move_line_exist=bool(picking.move_line_ids)

    def_compute_has_packages(self):
        domain=[('picking_id','in',self.ids),('result_package_id','!=',False)]
        cnt_by_picking=self.env['stock.move.line'].read_group(domain,['picking_id'],['picking_id'])
        cnt_by_picking={d['picking_id'][0]:d['picking_id_count']fordincnt_by_picking}
        forpickinginself:
            picking.has_packages=bool(cnt_by_picking.get(picking.id,False))

    @api.depends('immediate_transfer','state')
    def_compute_show_check_availability(self):
        """Accordingto`picking.show_check_availability`,the"checkavailability"buttonwillbe
        displayedintheformviewofapicking.
        """
        forpickinginself:
            ifpicking.immediate_transferorpicking.statenotin('confirmed','waiting','assigned'):
                picking.show_check_availability=False
                continue
            picking.show_check_availability=any(
                move.statein('waiting','confirmed','partially_available')and
                float_compare(move.product_uom_qty,0,precision_rounding=move.product_uom.rounding)
                formoveinpicking.move_lines
            )

    @api.depends('state','move_lines')
    def_compute_show_mark_as_todo(self):
        forpickinginself:
            ifnotpicking.move_linesandnotpicking.package_level_ids:
                picking.show_mark_as_todo=False
            elifnotpicking.immediate_transferandpicking.state=='draft':
                picking.show_mark_as_todo=True
            elifpicking.state!='draft'ornotpicking.id:
                picking.show_mark_as_todo=False
            else:
                picking.show_mark_as_todo=True

    @api.depends('state')
    def_compute_show_validate(self):
        forpickinginself:
            ifnot(picking.immediate_transfer)andpicking.state=='draft':
                picking.show_validate=False
            elifpicking.statenotin('draft','waiting','confirmed','assigned'):
                picking.show_validate=False
            else:
                picking.show_validate=True

    @api.model
    def_search_delay_alert_date(self,operator,value):
        late_stock_moves=self.env['stock.move'].search([('delay_alert_date',operator,value)])
        return[('move_lines','in',late_stock_moves.ids)]

    @api.onchange('partner_id')
    defonchange_partner_id(self):
        forpickinginself:
            picking_id=isinstance(picking.id,int)andpicking.idorgetattr(picking,'_origin',False)andpicking._origin.id
            ifpicking_id:
                moves=self.env['stock.move'].search([('picking_id','=',picking_id)])
                formoveinmoves:
                    move.write({'partner_id':picking.partner_id.id})

    @api.onchange('picking_type_id','partner_id')
    defonchange_picking_type(self):
        ifself.picking_type_idandself.state=='draft':
            self=self.with_company(self.company_id)
            ifself.picking_type_id.default_location_src_id:
                location_id=self.picking_type_id.default_location_src_id.id
            elifself.partner_id:
                location_id=self.partner_id.property_stock_supplier.id
            else:
                customerloc,location_id=self.env['stock.warehouse']._get_partner_locations()

            ifself.picking_type_id.default_location_dest_id:
                location_dest_id=self.picking_type_id.default_location_dest_id.id
            elifself.partner_id:
                location_dest_id=self.partner_id.property_stock_customer.id
            else:
                location_dest_id,supplierloc=self.env['stock.warehouse']._get_partner_locations()

            self.location_id=location_id
            self.location_dest_id=location_dest_id
            (self.move_lines|self.move_ids_without_package).update({
                "picking_type_id":self.picking_type_id,
                "company_id":self.company_id,
            })

        ifself.partner_idandself.partner_id.picking_warn:
            ifself.partner_id.picking_warn=='no-message'andself.partner_id.parent_id:
                partner=self.partner_id.parent_id
            elifself.partner_id.picking_warnnotin('no-message','block')andself.partner_id.parent_id.picking_warn=='block':
                partner=self.partner_id.parent_id
            else:
                partner=self.partner_id
            ifpartner.picking_warn!='no-message':
                ifpartner.picking_warn=='block':
                    self.partner_id=False
                return{'warning':{
                    'title':("Warningfor%s")%partner.name,
                    'message':partner.picking_warn_msg
                }}

    @api.model
    defcreate(self,vals):
        defaults=self.default_get(['name','picking_type_id'])
        picking_type=self.env['stock.picking.type'].browse(vals.get('picking_type_id',defaults.get('picking_type_id')))
        ifvals.get('name','/')=='/'anddefaults.get('name','/')=='/'andvals.get('picking_type_id',defaults.get('picking_type_id')):
            ifpicking_type.sequence_id:
                vals['name']=picking_type.sequence_id.next_by_id()

        #Astheon_changeinone2manylistisWIP,wewilloverwritethelocationsonthestockmoveshere
        #Asitisacreatetheformatwillbealistof(0,0,dict)
        moves=vals.get('move_lines',[])+vals.get('move_ids_without_package',[])
        ifmovesand((vals.get('location_id')andvals.get('location_dest_id'))orvals.get('partner_id')):
            formoveinmoves:
                iflen(move)==3andmove[0]==0:
                    ifvals.get('location_id')andvals.get('location_dest_id'):
                        move[2]['location_id']=vals['location_id']
                        move[2]['location_dest_id']=vals['location_dest_id']
                        #Whencreatinganewpicking,amovecanhaveno`company_id`(createbefore
                        #pickingtypewasdefined)oradifferent`company_id`(thepickingtypewas
                        #changedforananothercompanypickingtypeafterthemovewascreated).
                        #So,wedefinethe`company_id`inoneofthesecases.
                        picking_type=self.env['stock.picking.type'].browse(vals['picking_type_id'])
                        if'picking_type_id'notinmove[2]ormove[2]['picking_type_id']!=picking_type.id:
                            move[2]['picking_type_id']=picking_type.id
                            move[2]['company_id']=picking_type.company_id.id
                    ifvals.get('partner_id'):
                        move[2]['partner_id']=vals.get('partner_id')
        #makesuretowrite`schedule_date`*after*the`stock.move`creationin
        #ordertogetadeterministexecutionof`_set_scheduled_date`
        scheduled_date=vals.pop('scheduled_date',False)
        res=super(Picking,self).create(vals)
        ifscheduled_date:
            res.with_context(mail_notrack=True).write({'scheduled_date':scheduled_date})
        res._autoconfirm_picking()

        #setpartnerasfollower
        ifvals.get('partner_id'):
            forpickinginres.filtered(lambdap:p.location_id.usage=='supplier'orp.location_dest_id.usage=='customer'):
                picking.message_subscribe([vals.get('partner_id')])
        ifvals.get('picking_type_id'):
            formoveinres.move_lines:
                ifnotmove.description_picking:
                    move.description_picking=move.product_id.with_context(lang=move._get_lang())._get_description(move.picking_id.picking_type_id)

        returnres

    defwrite(self,vals):
        ifvals.get('picking_type_id')andany(picking.state!='draft'forpickinginself):
            raiseUserError(_("Changingtheoperationtypeofthisrecordisforbiddenatthispoint."))
        #setpartnerasafollowerandunfollowoldpartner
        ifvals.get('partner_id'):
            forpickinginself:
                ifpicking.location_id.usage=='supplier'orpicking.location_dest_id.usage=='customer':
                    ifpicking.partner_id:
                        picking.message_unsubscribe(picking.partner_id.ids)
                    picking.message_subscribe([vals.get('partner_id')])
        res=super(Picking,self).write(vals)
        ifvals.get('signature'):
            forpickinginself:
                picking._attach_sign()
        #Changelocationsofmovesifthoseofthepickingchange
        after_vals={}
        ifvals.get('location_id'):
            after_vals['location_id']=vals['location_id']
        ifvals.get('location_dest_id'):
            after_vals['location_dest_id']=vals['location_dest_id']
        if'partner_id'invals:
            after_vals['partner_id']=vals['partner_id']
        ifafter_vals:
            self.mapped('move_lines').filtered(lambdamove:notmove.scrapped).write(after_vals)
        ifvals.get('move_lines'):
            self._autoconfirm_picking()

        returnres

    defunlink(self):
        self.mapped('move_lines')._action_cancel()
        self.with_context(prefetch_fields=False).mapped('move_lines').unlink() #Checksifmovesarenotdone
        returnsuper(Picking,self).unlink()

    defaction_assign_partner(self):
        forpickinginself:
            picking.move_lines.write({'partner_id':picking.partner_id.id})

    defdo_print_picking(self):
        self.write({'printed':True})
        returnself.env.ref('stock.action_report_picking').report_action(self)

    defaction_confirm(self):
        self._check_company()
        self.mapped('package_level_ids').filtered(lambdapl:pl.state=='draft'andnotpl.move_ids)._generate_moves()
        #call`_action_confirm`oneverydraftmove
        self.mapped('move_lines')\
            .filtered(lambdamove:move.state=='draft')\
            ._action_confirm()

        #runschedulerformovesforecastedtonothaveenoughinstock
        self.mapped('move_lines').filtered(lambdamove:move.statenotin('draft','cancel','done'))._trigger_scheduler()
        returnTrue

    defaction_assign(self):
        """Checkavailabilityofpickingmoves.
        Thishastheeffectofchangingthestateandreservequantsonavailablemoves,andmay
        alsoimpactthestateofthepickingasitiscomputedbasedonmove'sstates.
        @return:True
        """
        self.filtered(lambdapicking:picking.state=='draft').action_confirm()
        moves=self.mapped('move_lines').filtered(lambdamove:move.statenotin('draft','cancel','done')).sorted(
            key=lambdamove:(-int(move.priority),notbool(move.date_deadline),move.date_deadline,move.id)
        )
        ifnotmoves:
            raiseUserError(_('Nothingtochecktheavailabilityfor.'))
        #Ifapackagelevelisdonewhenconfirmeditslocationcanbedifferentthanwhereitwillbereserved.
        #Soweremovethemovelinescreatedwhenconfirmedtosetquantitydonetothenewreservedones.
        package_level_done=self.mapped('package_level_ids').filtered(lambdapl:pl.is_doneandpl.state=='confirmed')
        package_level_done.write({'is_done':False})
        moves._action_assign()
        package_level_done.write({'is_done':True})

        returnTrue

    defaction_cancel(self):
        self.mapped('move_lines')._action_cancel()
        self.write({'is_locked':True})
        self.filtered(lambdax:notx.move_lines).state='cancel'
        returnTrue

    def_action_done(self):
        """Call`_action_done`onthe`stock.move`ofthe`stock.picking`in`self`.
        Thismethodmakessureevery`stock.move.line`islinkedtoa`stock.move`byeither
        linkingthemtoanexistingoneoranewlycreatedone.

        Ifthecontextkey`cancel_backorder`ispresent,backorderswon'tbecreated.

        :return:True
        :rtype:bool
        """
        self._check_company()

        todo_moves=self.mapped('move_lines').filtered(lambdaself:self.statein['draft','waiting','partially_available','assigned','confirmed'])
        forpickinginself:
            ifpicking.owner_id:
                picking.move_lines.write({'restrict_partner_id':picking.owner_id.id})
                picking.move_line_ids.write({'owner_id':picking.owner_id.id})
        todo_moves._action_done(cancel_backorder=self.env.context.get('cancel_backorder'))
        self.write({'date_done':fields.Datetime.now(),'priority':'0'})

        #ifincomingmovesmakeotherconfirmed/partially_availablemovesavailable,assignthem
        done_incoming_moves=self.filtered(lambdap:p.picking_type_id.code=='incoming').move_lines.filtered(lambdam:m.state=='done')
        done_incoming_moves._trigger_assign()

        self._send_confirmation_email()
        returnTrue

    def_send_confirmation_email(self):
        forstock_pickinself.filtered(lambdap:p.company_id.stock_move_email_validationandp.picking_type_id.code=='outgoing'):
            delivery_template_id=stock_pick.company_id.stock_mail_confirmation_template_id.id
            stock_pick.with_context(force_send=True).message_post_with_template(delivery_template_id,email_layout_xmlid='mail.mail_notification_light')

    @api.depends('state','move_lines','move_lines.state','move_lines.package_level_id','move_lines.move_line_ids.package_level_id')
    def_compute_move_without_package(self):
        forpickinginself:
            picking.move_ids_without_package=picking._get_move_ids_without_package()

    def_set_move_without_package(self):
        new_mwp=self[0].move_ids_without_package
        forpickinginself:
            old_mwp=picking._get_move_ids_without_package()
            picking.move_lines=(picking.move_lines-old_mwp)|new_mwp
            moves_to_unlink=old_mwp-new_mwp
            ifmoves_to_unlink:
                moves_to_unlink.unlink()

    def_get_move_ids_without_package(self):
        self.ensure_one()
        move_ids_without_package=self.env['stock.move']
        ifnotself.picking_type_entire_packs:
            move_ids_without_package=self.move_lines
        else:
            formoveinself.move_lines:
                ifnotmove.package_level_id:
                    ifmove.state=='assigned'andmove.picking_idandnotmove.picking_id.immediate_transferormove.state=='done':
                        ifany(notml.package_level_idformlinmove.move_line_ids):
                            move_ids_without_package|=move
                    else:
                        move_ids_without_package|=move
        returnmove_ids_without_package.filtered(lambdamove:notmove.scrap_ids)

    def_check_move_lines_map_quant_package(self,package):
        """Thismethodchecksthatallproductofthepackage(quant)arewellpresentinthemove_line_idsofthepicking."""
        all_in=True
        pack_move_lines=self.move_line_ids.filtered(lambdaml:ml.package_id==package)
        keys=['product_id','lot_id']
        keys_ids=["{}.id".format(fname)forfnameinkeys]
        precision_digits=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')

        grouped_quants={}
        fork,gingroupby(sorted(package.quant_ids,key=attrgetter(*keys_ids)),key=itemgetter(*keys)):
            grouped_quants[k]=sum(self.env['stock.quant'].concat(*list(g)).mapped('quantity'))

        grouped_ops={}
        fork,gingroupby(sorted(pack_move_lines,key=attrgetter(*keys_ids)),key=itemgetter(*keys)):
            grouped_ops[k]=sum(self.env['stock.move.line'].concat(*list(g)).mapped('product_qty'))
        ifany(notfloat_is_zero(grouped_quants.get(key,0)-grouped_ops.get(key,0),precision_digits=precision_digits)forkeyingrouped_quants)\
                orany(notfloat_is_zero(grouped_ops.get(key,0)-grouped_quants.get(key,0),precision_digits=precision_digits)forkeyingrouped_ops):
            all_in=False
        returnall_in

    def_get_entire_pack_location_dest(self,move_line_ids):
        location_dest_ids=move_line_ids.mapped('location_dest_id')
        iflen(location_dest_ids)>1:
            returnFalse
        returnlocation_dest_ids.id

    def_check_entire_pack(self):
        """Thisfunctioncheckifentirepacksaremovedinthepicking"""
        forpickinginself:
            origin_packages=picking.move_line_ids.mapped("package_id")
            forpackinorigin_packages:
                ifpicking._check_move_lines_map_quant_package(pack):
                    package_level_ids=picking.package_level_ids.filtered(lambdapl:pl.package_id==pack)
                    move_lines_to_pack=picking.move_line_ids.filtered(lambdaml:ml.package_id==packandnotml.result_package_idandml.statenotin('done','cancel'))
                    ifnotpackage_level_ids:
                        self.env['stock.package_level'].create({
                            'picking_id':picking.id,
                            'package_id':pack.id,
                            'location_id':pack.location_id.id,
                            'location_dest_id':self._get_entire_pack_location_dest(move_lines_to_pack)orpicking.location_dest_id.id,
                            'move_line_ids':[(6,0,move_lines_to_pack.ids)],
                            'company_id':picking.company_id.id,
                        })
                        #TODO:inmaster,movepackagefieldin`stock`andcleancode.
                        ifpack._allowed_to_move_between_transfers():
                            move_lines_to_pack.write({
                                'result_package_id':pack.id,
                            })
                    else:
                        move_lines_in_package_level=move_lines_to_pack.filtered(lambdaml:ml.move_id.package_level_id)
                        move_lines_without_package_level=move_lines_to_pack-move_lines_in_package_level
                        formlinmove_lines_in_package_level:
                            ml.write({
                                'result_package_id':pack.id,
                                'package_level_id':ml.move_id.package_level_id.id,
                            })
                        move_lines_without_package_level.write({
                            'result_package_id':pack.id,
                            'package_level_id':package_level_ids[0].id,
                        })
                        forplinpackage_level_ids:
                            pl.location_dest_id=self._get_entire_pack_location_dest(pl.move_line_ids)orpicking.location_dest_id.id

    defdo_unreserve(self):
        self.move_lines._do_unreserve()
        self.package_level_ids.filtered(lambdap:notp.move_ids).unlink()

    defbutton_validate(self):
        #Clean-upthecontextkeyatvalidationtoavoidforcingthecreationofimmediate
        #transfers.
        ctx=dict(self.env.context)
        ctx.pop('default_immediate_transfer',None)
        self=self.with_context(ctx)

        #Sanitychecks.
        pickings_without_moves=self.browse()
        pickings_without_quantities=self.browse()
        pickings_without_lots=self.browse()
        products_without_lots=self.env['product.product']
        forpickinginself:
            ifnotpicking.move_linesandnotpicking.move_line_ids:
                pickings_without_moves|=picking

            picking.message_subscribe([self.env.user.partner_id.id])
            picking_type=picking.picking_type_id
            precision_digits=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')
            no_quantities_done=all(float_is_zero(move_line.qty_done,precision_digits=precision_digits)formove_lineinpicking.move_line_ids.filtered(lambdam:m.statenotin('done','cancel')))
            no_reserved_quantities=all(float_is_zero(move_line.product_qty,precision_rounding=move_line.product_uom_id.rounding)formove_lineinpicking.move_line_ids)
            ifno_reserved_quantitiesandno_quantities_done:
                pickings_without_quantities|=picking

            ifpicking_type.use_create_lotsorpicking_type.use_existing_lots:
                lines_to_check=picking.move_line_ids
                ifnotno_quantities_done:
                    lines_to_check=lines_to_check.filtered(lambdaline:float_compare(line.qty_done,0,precision_rounding=line.product_uom_id.rounding))
                forlineinlines_to_check:
                    product=line.product_id
                    ifproductandproduct.tracking!='none':
                        ifnotline.lot_nameandnotline.lot_id:
                            pickings_without_lots|=picking
                            products_without_lots|=product

        ifnotself._should_show_transfers():
            ifpickings_without_moves:
                raiseUserError(_('Pleaseaddsomeitemstomove.'))
            ifpickings_without_quantities:
                raiseUserError(self._get_without_quantities_error_message())
            ifpickings_without_lots:
                raiseUserError(_('YouneedtosupplyaLot/Serialnumberforproducts%s.')%','.join(products_without_lots.mapped('display_name')))
        else:
            message=""
            ifpickings_without_moves:
                message+=_('Transfers%s:Pleaseaddsomeitemstomove.')%','.join(pickings_without_moves.mapped('name'))
            ifpickings_without_quantities:
                message+=_('\n\nTransfers%s:Youcannotvalidatethesetransfersifnoquantitiesarereservednordone.Toforcethesetransfers,switchineditmoreandencodethedonequantities.')%','.join(pickings_without_quantities.mapped('name'))
            ifpickings_without_lots:
                message+=_('\n\nTransfers%s:YouneedtosupplyaLot/Serialnumberforproducts%s.')%(','.join(pickings_without_lots.mapped('name')),','.join(products_without_lots.mapped('display_name')))
            ifmessage:
                raiseUserError(message.lstrip())

        #Runthepre-validationwizards.Processingapre-validationwizardshouldworkonthe
        #movesand/orthecontextandnevercall`_action_done`.
        ifnotself.env.context.get('button_validate_picking_ids'):
            self=self.with_context(button_validate_picking_ids=self.ids)
        res=self._pre_action_done_hook()
        ifresisnotTrue:
            returnres

        #Call`_action_done`.
        ifself.env.context.get('picking_ids_not_to_backorder'):
            pickings_not_to_backorder=self.browse(self.env.context['picking_ids_not_to_backorder'])
            pickings_to_backorder=self-pickings_not_to_backorder
        else:
            pickings_not_to_backorder=self.env['stock.picking']
            pickings_to_backorder=self
        pickings_not_to_backorder.with_context(cancel_backorder=True)._action_done()
        pickings_to_backorder.with_context(cancel_backorder=False)._action_done()
        returnTrue

    def_pre_action_done_hook(self):
        ifnotself.env.context.get('skip_immediate'):
            pickings_to_immediate=self._check_immediate()
            ifpickings_to_immediate:
                returnpickings_to_immediate._action_generate_immediate_wizard(show_transfers=self._should_show_transfers())

        ifnotself.env.context.get('skip_backorder'):
            pickings_to_backorder=self._check_backorder()
            ifpickings_to_backorder:
                returnpickings_to_backorder._action_generate_backorder_wizard(show_transfers=self._should_show_transfers())
        returnTrue

    def_should_show_transfers(self):
        """Whetherthedifferenttransfersshouldbedisplayedonthepreactiondonewizards."""
        returnlen(self)>1

    def_get_without_quantities_error_message(self):
        """Returnstheerrormessageraisedinvalidationifnoquantitiesarereservedordone.
        Thepurposeofthismethodistobeoverriddenincasewewanttoadaptthismessage.

        :return:Translatederrormessage
        :rtype:str
        """
        return_(
            'Youcannotvalidateatransferifnoquantitiesarereservednordone.'
            'Toforcethetransfer,switchineditmodeandencodethedonequantities.'
        )

    def_action_generate_backorder_wizard(self,show_transfers=False):
        view=self.env.ref('stock.view_backorder_confirmation')
        return{
            'name':_('CreateBackorder?'),
            'type':'ir.actions.act_window',
            'view_mode':'form',
            'res_model':'stock.backorder.confirmation',
            'views':[(view.id,'form')],
            'view_id':view.id,
            'target':'new',
            'context':dict(self.env.context,default_show_transfers=show_transfers,default_pick_ids=[(4,p.id)forpinself]),
        }

    def_action_generate_immediate_wizard(self,show_transfers=False):
        view=self.env.ref('stock.view_immediate_transfer')
        return{
            'name':_('ImmediateTransfer?'),
            'type':'ir.actions.act_window',
            'view_mode':'form',
            'res_model':'stock.immediate.transfer',
            'views':[(view.id,'form')],
            'view_id':view.id,
            'target':'new',
            'context':dict(self.env.context,default_show_transfers=show_transfers,default_pick_ids=[(4,p.id)forpinself]),
        }

    defaction_toggle_is_locked(self):
        self.ensure_one()
        self.is_locked=notself.is_locked
        returnTrue

    def_check_backorder(self):
        prec=self.env["decimal.precision"].precision_get("ProductUnitofMeasure")
        backorder_pickings=self.browse()
        forpickinginself:
            quantity_todo={}
            quantity_done={}
            formoveinpicking.mapped('move_lines').filtered(lambdam:m.state!="cancel"):
                quantity_todo.setdefault(move.product_id.id,0)
                quantity_done.setdefault(move.product_id.id,0)
                quantity_todo[move.product_id.id]+=move.product_uom._compute_quantity(move.product_uom_qty,move.product_id.uom_id,rounding_method='HALF-UP')
                quantity_done[move.product_id.id]+=move.product_uom._compute_quantity(move.quantity_done,move.product_id.uom_id,rounding_method='HALF-UP')
            #FIXME:thenextblockdoesn'tseemnorshouldbeused.
            foropsinpicking.mapped('move_line_ids').filtered(lambdax:x.package_idandnotx.product_idandnotx.move_id):
                forquantinops.package_id.quant_ids:
                    quantity_done.setdefault(quant.product_id.id,0)
                    quantity_done[quant.product_id.id]+=quant.qty
            forpackinpicking.mapped('move_line_ids').filtered(lambdax:x.product_idandnotx.move_id):
                quantity_done.setdefault(pack.product_id.id,0)
                quantity_done[pack.product_id.id]+=pack.product_uom_id._compute_quantity(pack.qty_done,pack.product_id.uom_id)
            ifany(
                float_compare(quantity_done[x],quantity_todo.get(x,0),precision_digits=prec,)==-1
                forxinquantity_done
            ):
                backorder_pickings|=picking
        returnbackorder_pickings

    def_check_immediate(self):
        immediate_pickings=self.browse()
        precision_digits=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')
        forpickinginself:
            ifall(float_is_zero(move_line.qty_done,precision_digits=precision_digits)formove_lineinpicking.move_line_ids.filtered(lambdam:m.statenotin('done','cancel'))):
                immediate_pickings|=picking
        returnimmediate_pickings

    def_autoconfirm_picking(self):
        """Automaticallyrun`action_confirm`on`self`ifthepickingisanimmediatetransferor
        ifthepickingisaplannedtransferandoneofitsmovewasaddedaftertheinitial
        callto`action_confirm`.Notethat`action_confirm`willonlyworkondraftmoves.
        """
        #Clean-upthecontextkeytoavoidforcingthecreationofimmediatetransfers.
        ctx=dict(self.env.context)
        ctx.pop('default_immediate_transfer',None)
        self=self.with_context(ctx)
        forpickinginself:
            ifpicking.statein('done','cancel'):
                continue
            ifnotpicking.move_linesandnotpicking.package_level_ids:
                continue
            ifpicking.immediate_transferorany(move.additionalformoveinpicking.move_lines):
                picking.action_confirm()
                #Makesurethereservationisbypassedinimmediatetransfermode.
                ifpicking.immediate_transfer:
                    picking.move_lines.write({'state':'assigned'})

    def_create_backorder(self):
        """Thismethodiscalledwhentheuserchosetocreateabackorder.Itwillcreateanew
        picking,thebackorder,andmovethestock.movesthatarenot`done`or`cancel`intoit.
        """
        backorders=self.env['stock.picking']
        forpickinginself:
            moves_to_backorder=picking.move_lines.filtered(lambdax:x.statenotin('done','cancel'))
            ifmoves_to_backorder:
                backorder_picking=picking.copy({
                    'name':'/',
                    'move_lines':[],
                    'move_line_ids':[],
                    'backorder_id':picking.id
                })
                picking.message_post(
                    body=_('Thebackorder<ahref=#data-oe-model=stock.pickingdata-oe-id=%d>%s</a>hasbeencreated.')%(
                        backorder_picking.id,backorder_picking.name))
                moves_to_backorder.write({'picking_id':backorder_picking.id})
                moves_to_backorder.move_line_ids.package_level_id.write({'picking_id':backorder_picking.id})
                moves_to_backorder.mapped('move_line_ids').write({'picking_id':backorder_picking.id})
                backorders|=backorder_picking
        backorders_to_assign=backorders.filtered(lambdapicking:picking._needs_automatic_assign())
        ifbackorders_to_assign:
            backorders_to_assign.action_assign()
        returnbackorders

    def_needs_automatic_assign(self):
        self.ensure_one()
        returnTrue

    def_log_activity_get_documents(self,orig_obj_changes,stream_field,stream,sorted_method=False,groupby_method=False):
        """Genericmethodtologactivity.Tousewith
        _log_activitymethod.Iteitherlogonuppermost
        ongoingdocumentsorfollowingdocuments.Thismethod
        findallthedocumentsandresponsibleforwhichanote
        hastobelog.Italsogeneratearendering_contextin
        ordertorenderaspecificnotebydocumentscontaining
        onlytheinformationrelativetothedocumentit.Forexample
        wedon'twanttonotifyapickingonmovethatitdoesn't
        contain.

        :paramorig_obj_changesdict:containarecordaskeyandthe
        changeonthisrecordasvalue.
        eg:{'move_id':(newproduct_uom_qty,oldproduct_uom_qty)}
        :paramstream_fieldstring:Ithastobeafieldofthe
        recordsthatareregisterinthekeyof'orig_obj_changes'
        eg:'move_dest_ids'ifweusemoveasrecord(previousexample)
            -'UP'ifwewanttologontheuppermostongoing
            documents.
            -'DOWN'ifwewanttologonfollowingdocuments.
        :paramsorted_methodmethod,groupby_method:Onlyneedwhen
        streamis'DOWN',itshouldsort/groupbytuple(objecton
        whichtheactivityislog,theresponsibleforthisobject)
        """
        ifself.env.context.get('skip_activity'):
            return{}
        move_to_orig_object_rel={co:oocforoocinorig_obj_changes.keys()forcoinooc[stream_field]}
        origin_objects=self.env[list(orig_obj_changes.keys())[0]._name].concat(*list(orig_obj_changes.keys()))
        #Thepurposehereistogroupeachdestinationobjectby
        #(documenttolog,responsible)nomatterthestreamdirection.
        #example:
        #{'(delivery_picking_1,admin)':stock.move(1,2)
        # '(delivery_picking_2,admin)':stock.move(3)}
        visited_documents={}
        ifstream=='DOWN':
            ifsorted_methodandgroupby_method:
                grouped_moves=groupby(sorted(origin_objects.mapped(stream_field),key=sorted_method),key=groupby_method)
            else:
                raiseUserError(_('Youhavetodefineagroupbyandsortedmethodandpassthemasarguments.'))
        elifstream=='UP':
            #Whenusingupstreamdocumentitisrequiredtodefine
            #_get_upstream_documents_and_responsibleson
            #destinationobjectsinordertoascenddocuments.
            grouped_moves={}
            forvisited_moveinorigin_objects.mapped(stream_field):
                fordocument,responsible,visitedinvisited_move._get_upstream_documents_and_responsibles(self.env[visited_move._name]):
                    ifgrouped_moves.get((document,responsible)):
                        grouped_moves[(document,responsible)]|=visited_move
                        visited_documents[(document,responsible)]|=visited
                    else:
                        grouped_moves[(document,responsible)]=visited_move
                        visited_documents[(document,responsible)]=visited
            grouped_moves=grouped_moves.items()
        else:
            raiseUserError(_('Unknownstream.'))

        documents={}
        for(parent,responsible),movesingrouped_moves:
            ifnotparent:
                continue
            moves=list(moves)
            moves=self.env[moves[0]._name].concat(*moves)
            #Getthenote
            rendering_context={move:(orig_object,orig_obj_changes[orig_object])formoveinmovesfororig_objectinmove_to_orig_object_rel[move]}
            ifvisited_documents:
                documents[(parent,responsible)]=rendering_context,visited_documents.values()
            else:
                documents[(parent,responsible)]=rendering_context
        returndocuments

    def_log_activity(self,render_method,documents):
        """Loganoteforeachdocuments,responsiblepairin
        documentspassedasargument.Therender_methodisthen
        callinordertouseatemplateandrenderitwitha
        rendering_context.

        :paramdocumentsdict:Atuple(document,responsible)askey.
        Anactivitywillbelogbykey.Arendering_contextasvalue.
        Ifusedwith_log_activity_get_documents.In'DOWN'stream
        casestherendering_contextwillbeadictwithformat:
        {'stream_object':('orig_object',new_qty,old_qty)}
        'UP'streamwilladdallthedocumentsbrowsedinorderto
        getthefinal/upstreamdocumentpresentinthekey.
        :paramrender_methodmethod:astaticfunctionthatwillgenerate
        thehtmlnotetologontheactivity.Therender_methodshould
        usetheargs:
            -rendering_contextdict:valueofthedocumentsargument
        therender_methodshouldreturnastringwithanhtmlformat
        :paramstreamstring:
        """
        for(parent,responsible),rendering_contextindocuments.items():
            note=render_method(rendering_context)
            parent.sudo().activity_schedule(
                'mail.mail_activity_data_warning',
                date.today(),
                note=note,
                user_id=responsible.idorSUPERUSER_ID
            )

    def_log_less_quantities_than_expected(self,moves):
        """Loganactivityonpickingthatfollowmoves.Thenote
        containsthemoveschangesandalltheimpactedpicking.

        :paramdictmoves:adictwithamoveaskeyandtuplewith
        newandoldquantityasvalue.eg:{move_1:(4,5)}
        """
        def_keys_in_sorted(move):
            """sortbypickingandtheresponsiblefortheproductthe
            move.
            """
            return(move.picking_id.id,move.product_id.responsible_id.id)

        def_keys_in_groupby(move):
            """groupbypickingandtheresponsiblefortheproductthe
            move.
            """
            return(move.picking_id,move.product_id.responsible_id)

        def_render_note_exception_quantity(rendering_context):
            """:paramrendering_context:
            {'move_dest':(move_orig,(new_qty,old_qty))}
            """
            origin_moves=self.env['stock.move'].browse([move.idformove_originrendering_context.values()formoveinmove_orig[0]])
            origin_picking=origin_moves.mapped('picking_id')
            move_dest_ids=self.env['stock.move'].concat(*rendering_context.keys())
            impacted_pickings=origin_picking._get_impacted_pickings(move_dest_ids)-move_dest_ids.mapped('picking_id')
            values={
                'origin_picking':origin_picking,
                'moves_information':rendering_context.values(),
                'impacted_pickings':impacted_pickings,
            }
            returnself.env.ref('stock.exception_on_picking')._render(values=values)

        documents=self._log_activity_get_documents(moves,'move_dest_ids','DOWN',_keys_in_sorted,_keys_in_groupby)
        documents=self._less_quantities_than_expected_add_documents(moves,documents)
        self._log_activity(_render_note_exception_quantity,documents)

    def_less_quantities_than_expected_add_documents(self,moves,documents):
        returndocuments

    def_get_impacted_pickings(self,moves):
        """Thisfunctionisusedin_log_less_quantities_than_expected
        thepurposeistonotifyauserwithallthepickingsthatare
        impactedbyanactiononachainedmove.
        param:'moves'containmovesthatbelongtoacommonpicking.
        return:allthepickingsthatcontainadestinationmoves
        (directandindirect)fromthemovesgivenasarguments.
        """

        def_explore(impacted_pickings,explored_moves,moves_to_explore):
            formoveinmoves_to_explore:
                ifmovenotinexplored_moves:
                    impacted_pickings|=move.picking_id
                    explored_moves|=move
                    moves_to_explore|=move.move_dest_ids
            moves_to_explore=moves_to_explore-explored_moves
            ifmoves_to_explore:
                return_explore(impacted_pickings,explored_moves,moves_to_explore)
            else:
                returnimpacted_pickings

        return_explore(self.env['stock.picking'],self.env['stock.move'],moves)

    def_pre_put_in_pack_hook(self,move_line_ids):
        returnself._check_destinations(move_line_ids)

    def_check_destinations(self,move_line_ids):
        iflen(move_line_ids.mapped('location_dest_id'))>1:
            view_id=self.env.ref('stock.stock_package_destination_form_view').id
            wiz=self.env['stock.package.destination'].create({
                'picking_id':self.id,
                'location_dest_id':move_line_ids[0].location_dest_id.id,
            })
            return{
                'name':_('Choosedestinationlocation'),
                'view_mode':'form',
                'res_model':'stock.package.destination',
                'view_id':view_id,
                'views':[(view_id,'form')],
                'type':'ir.actions.act_window',
                'res_id':wiz.id,
                'target':'new'
            }
        else:
            return{}

    def_put_in_pack(self,move_line_ids,create_package_level=True):
        package=False
        forpickinself:
            move_lines_to_pack=self.env['stock.move.line']
            package=self.env['stock.quant.package'].create({})

            precision_digits=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')
            iffloat_is_zero(move_line_ids[0].qty_done,precision_digits=precision_digits):
                forlineinmove_line_ids:
                    line.qty_done=line.product_uom_qty

            formlinmove_line_ids:
                iffloat_compare(ml.qty_done,ml.product_uom_qty,
                                 precision_rounding=ml.product_uom_id.rounding)>=0:
                    move_lines_to_pack|=ml
                else:
                    quantity_left_todo=float_round(
                        ml.product_uom_qty-ml.qty_done,
                        precision_rounding=ml.product_uom_id.rounding,
                        rounding_method='UP')
                    done_to_keep=ml.qty_done
                    new_move_line=ml.copy(
                        default={'product_uom_qty':0,'qty_done':ml.qty_done})
                    vals={'product_uom_qty':quantity_left_todo,'qty_done':0.0}
                    ifpick.picking_type_id.code=='incoming':
                        ifml.lot_id:
                            vals['lot_id']=False
                        ifml.lot_name:
                            vals['lot_name']=False
                    ml.write(vals)
                    new_move_line.write({'product_uom_qty':done_to_keep})
                    move_lines_to_pack|=new_move_line
            ifcreate_package_level:
                package_level=self.env['stock.package_level'].create({
                    'package_id':package.id,
                    'picking_id':pick.id,
                    'location_id':False,
                    'location_dest_id':move_line_ids.mapped('location_dest_id').id,
                    'move_line_ids':[(6,0,move_lines_to_pack.ids)],
                    'company_id':pick.company_id.id,
                })
            move_lines_to_pack.write({
                'result_package_id':package.id,
            })
        returnpackage

    defaction_put_in_pack(self):
        self.ensure_one()
        ifself.statenotin('done','cancel'):
            picking_move_lines=self.move_line_ids
            if(
                notself.picking_type_id.show_reserved
                andnotself.immediate_transfer
                andnotself.env.context.get('barcode_view')
            ):
                picking_move_lines=self.move_line_nosuggest_ids

            move_line_ids=picking_move_lines.filtered(lambdaml:
                float_compare(ml.qty_done,0.0,precision_rounding=ml.product_uom_id.rounding)>0
                andnotml.result_package_id
            )
            ifnotmove_line_ids:
                move_line_ids=picking_move_lines.filtered(lambdaml:float_compare(ml.product_uom_qty,0.0,
                                     precision_rounding=ml.product_uom_id.rounding)>0andfloat_compare(ml.qty_done,0.0,
                                     precision_rounding=ml.product_uom_id.rounding)==0)
            ifmove_line_ids:
                res=self._pre_put_in_pack_hook(move_line_ids)
                ifnotres:
                    res=self._put_in_pack(move_line_ids)
                returnres
            else:
                raiseUserError(_("Pleaseadd'Done'quantitiestothepickingtocreateanewpack."))

    defbutton_scrap(self):
        self.ensure_one()
        view=self.env.ref('stock.stock_scrap_form_view2')
        products=self.env['product.product']
        formoveinself.move_lines:
            ifmove.statenotin('draft','cancel')andmove.product_id.typein('product','consu'):
                products|=move.product_id
        return{
            'name':_('Scrap'),
            'view_mode':'form',
            'res_model':'stock.scrap',
            'view_id':view.id,
            'views':[(view.id,'form')],
            'type':'ir.actions.act_window',
            'context':{'default_picking_id':self.id,'product_ids':products.ids,'default_company_id':self.company_id.id},
            'target':'new',
        }

    defaction_see_move_scrap(self):
        self.ensure_one()
        action=self.env["ir.actions.actions"]._for_xml_id("stock.action_stock_scrap")
        scraps=self.env['stock.scrap'].search([('picking_id','=',self.id)])
        action['domain']=[('id','in',scraps.ids)]
        action['context']=dict(self._context,create=False)
        returnaction

    defaction_see_packages(self):
        self.ensure_one()
        action=self.env["ir.actions.actions"]._for_xml_id("stock.action_package_view")
        packages=self.move_line_ids.mapped('result_package_id')
        action['domain']=[('id','in',packages.ids)]
        action['context']={'picking_id':self.id}
        returnaction

    defaction_picking_move_tree(self):
        action=self.env["ir.actions.actions"]._for_xml_id("stock.stock_move_action")
        action['views']=[
            (self.env.ref('stock.view_picking_move_tree').id,'tree'),
        ]
        action['context']=self.env.context
        action['domain']=[('picking_id','in',self.ids)]
        returnaction

    def_attach_sign(self):
        """Renderthedeliveryreportinpdfandattachittothepickingin`self`."""
        self.ensure_one()
        report=self.env.ref('stock.action_report_delivery')._render_qweb_pdf(self.id)
        filename="%s_signed_delivery_slip"%self.name
        ifself.partner_id:
            message=_('Ordersignedby%s')%(self.partner_id.name)
        else:
            message=_('Ordersigned')
        self.message_post(
            attachments=[('%s.pdf'%filename,report[0])],
            body=message,
        )
        returnTrue

    def_get_report_lang(self):
        returnself.move_linesandself.move_lines[0].partner_id.langorself.partner_id.langorself.env.lang

#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

importlogging
fromcollectionsimportnamedtuple

fromflectraimport_,_lt,api,fields,models
fromflectra.exceptionsimportUserError

_logger=logging.getLogger(__name__)


ROUTE_NAMES={
    'one_step':_lt('Receivein1step(stock)'),
    'two_steps':_lt('Receivein2steps(input+stock)'),
    'three_steps':_lt('Receivein3steps(input+quality+stock)'),
    'crossdock':_lt('Cross-Dock'),
    'ship_only':_lt('Deliverin1step(ship)'),
    'pick_ship':_lt('Deliverin2steps(pick+ship)'),
    'pick_pack_ship':_lt('Deliverin3steps(pick+pack+ship)'),
}


classWarehouse(models.Model):
    _name="stock.warehouse"
    _description="Warehouse"
    _order='sequence,id'
    _check_company_auto=True
    #namedtupleusedinhelpermethodsgeneratingvaluesforroutes
    Routing=namedtuple('Routing',['from_loc','dest_loc','picking_type','action'])

    name=fields.Char('Warehouse',index=True,required=True,default=lambdaself:self.env.company.name)
    active=fields.Boolean('Active',default=True)
    company_id=fields.Many2one(
        'res.company','Company',default=lambdaself:self.env.company,
        index=True,readonly=True,required=True,
        help='Thecompanyisautomaticallysetfromyouruserpreferences.')
    partner_id=fields.Many2one('res.partner','Address',default=lambdaself:self.env.company.partner_id,check_company=True)
    view_location_id=fields.Many2one(
        'stock.location','ViewLocation',
        domain="[('usage','=','view'),('company_id','=',company_id)]",
        required=True,check_company=True)
    lot_stock_id=fields.Many2one(
        'stock.location','LocationStock',
        domain="[('usage','=','internal'),('company_id','=',company_id)]",
        required=True,check_company=True)
    code=fields.Char('ShortName',required=True,size=5,help="Shortnameusedtoidentifyyourwarehouse")
    route_ids=fields.Many2many(
        'stock.location.route','stock_route_warehouse','warehouse_id','route_id',
        'Routes',
        domain="[('warehouse_selectable','=',True),'|',('company_id','=',False),('company_id','=',company_id)]",
        help='Defaultsroutesthroughthewarehouse',check_company=True)
    reception_steps=fields.Selection([
        ('one_step','Receivegoodsdirectly(1step)'),
        ('two_steps','Receivegoodsininputandthenstock(2steps)'),
        ('three_steps','Receivegoodsininput,thenqualityandthenstock(3steps)')],
        'IncomingShipments',default='one_step',required=True,
        help="Defaultincomingroutetofollow")
    delivery_steps=fields.Selection([
        ('ship_only','Delivergoodsdirectly(1step)'),
        ('pick_ship','Sendgoodsinoutputandthendeliver(2steps)'),
        ('pick_pack_ship','Packgoods,sendgoodsinoutputandthendeliver(3steps)')],
        'OutgoingShipments',default='ship_only',required=True,
        help="Defaultoutgoingroutetofollow")
    wh_input_stock_loc_id=fields.Many2one('stock.location','InputLocation',check_company=True)
    wh_qc_stock_loc_id=fields.Many2one('stock.location','QualityControlLocation',check_company=True)
    wh_output_stock_loc_id=fields.Many2one('stock.location','OutputLocation',check_company=True)
    wh_pack_stock_loc_id=fields.Many2one('stock.location','PackingLocation',check_company=True)
    mto_pull_id=fields.Many2one('stock.rule','MTOrule')
    pick_type_id=fields.Many2one('stock.picking.type','PickType',check_company=True)
    pack_type_id=fields.Many2one('stock.picking.type','PackType',check_company=True)
    out_type_id=fields.Many2one('stock.picking.type','OutType',check_company=True)
    in_type_id=fields.Many2one('stock.picking.type','InType',check_company=True)
    int_type_id=fields.Many2one('stock.picking.type','InternalType',check_company=True)
    crossdock_route_id=fields.Many2one('stock.location.route','CrossdockRoute',ondelete='restrict')
    reception_route_id=fields.Many2one('stock.location.route','ReceiptRoute',ondelete='restrict')
    delivery_route_id=fields.Many2one('stock.location.route','DeliveryRoute',ondelete='restrict')
    warehouse_count=fields.Integer(compute='_compute_warehouse_count')
    resupply_wh_ids=fields.Many2many(
        'stock.warehouse','stock_wh_resupply_table','supplied_wh_id','supplier_wh_id',
        'ResupplyFrom',help="Routeswillbecreatedautomaticallytoresupplythiswarehousefromthewarehousesticked")
    resupply_route_ids=fields.One2many(
        'stock.location.route','supplied_wh_id','ResupplyRoutes',
        help="Routeswillbecreatedfortheseresupplywarehousesandyoucanselectthemonproductsandproductcategories")
    show_resupply=fields.Boolean(compute="_compute_show_resupply")
    sequence=fields.Integer(default=10,
        help="Givesthesequenceofthislinewhendisplayingthewarehouses.")
    _sql_constraints=[
        ('warehouse_name_uniq','unique(name,company_id)','Thenameofthewarehousemustbeuniquepercompany!'),
        ('warehouse_code_uniq','unique(code,company_id)','Thecodeofthewarehousemustbeuniquepercompany!'),
    ]

    @api.onchange('company_id')
    def_onchange_company_id(self):
        group_user=self.env.ref('base.group_user')
        group_stock_multi_warehouses=self.env.ref('stock.group_stock_multi_warehouses')
        ifgroup_stock_multi_warehousesnotingroup_user.implied_ids:
            return{
                'warning':{
                    'title':_('Warning'),
                    'message':_('CreatinganewwarehousewillautomaticallyactivatetheStorageLocationssetting')
                }
            }

    @api.depends('name')
    def_compute_warehouse_count(self):
        forwarehouseinself:
            warehouse.warehouse_count=self.env['stock.warehouse'].search_count([('id','notin',warehouse.ids)])

    def_compute_show_resupply(self):
        forwarehouseinself:
            warehouse.show_resupply=warehouse.user_has_groups("stock.group_stock_multi_warehouses")andwarehouse.warehouse_count

    @api.model
    defcreate(self,vals):
        #createviewlocationforwarehousethencreatealllocations
        loc_vals={'name':vals.get('code'),'usage':'view',
                    'location_id':self.env.ref('stock.stock_location_locations').id}
        ifvals.get('company_id'):
            loc_vals['company_id']=vals.get('company_id')
        vals['view_location_id']=self.env['stock.location'].create(loc_vals).id
        sub_locations=self._get_locations_values(vals)

        forfield_name,valuesinsub_locations.items():
            values['location_id']=vals['view_location_id']
            ifvals.get('company_id'):
                values['company_id']=vals.get('company_id')
            vals[field_name]=self.env['stock.location'].with_context(active_test=False).create(values).id

        #actuallycreateWH
        warehouse=super(Warehouse,self).create(vals)
        #createsequencesandoperationtypes
        new_vals=warehouse._create_or_update_sequences_and_picking_types()
        warehouse.write(new_vals) #TDEFIXME:usesuper?
        #createroutesandpush/stockrules
        route_vals=warehouse._create_or_update_route()
        warehouse.write(route_vals)

        #Updateglobalroutewithspecificwarehouserule.
        warehouse._create_or_update_global_routes_rules()

        #createrouteselectableontheproducttoresupplythewarehousefromanotherone
        warehouse.create_resupply_routes(warehouse.resupply_wh_ids)

        #updatepartnerdataifpartnerassigned
        ifvals.get('partner_id'):
            self._update_partner_data(vals['partner_id'],vals.get('company_id'))

        self._check_multiwarehouse_group()

        returnwarehouse

    defwrite(self,vals):
        if'company_id'invals:
            forwarehouseinself:
                ifwarehouse.company_id.id!=vals['company_id']:
                    raiseUserError(_("Changingthecompanyofthisrecordisforbiddenatthispoint,youshouldratherarchiveitandcreateanewone."))

        Route=self.env['stock.location.route']
        warehouses=self.with_context(active_test=False)
        warehouses._create_missing_locations(vals)

        ifvals.get('reception_steps'):
            warehouses._update_location_reception(vals['reception_steps'])
        ifvals.get('delivery_steps'):
            warehouses._update_location_delivery(vals['delivery_steps'])
        ifvals.get('reception_steps')orvals.get('delivery_steps'):
            warehouses._update_reception_delivery_resupply(vals.get('reception_steps'),vals.get('delivery_steps'))

        ifvals.get('resupply_wh_ids')andnotvals.get('resupply_route_ids'):
            new_resupply_whs=self.new({
                'resupply_wh_ids':vals['resupply_wh_ids']
            }).resupply_wh_ids._origin
            old_resupply_whs={warehouse.id:warehouse.resupply_wh_idsforwarehouseinwarehouses}

        #Ifanotherpartnerassigned
        ifvals.get('partner_id'):
            warehouses._update_partner_data(vals['partner_id'],vals.get('company_id'))

        res=super(Warehouse,self).write(vals)

        ifvals.get('code')orvals.get('name'):
            warehouses._update_name_and_code(vals.get('name'),vals.get('code'))

        forwarehouseinwarehouses:
            #checkifweneedtodeleteandrecreateroute
            depends=[dependfordependsin[value.get('depends',[])forvalueinwarehouse._get_routes_values().values()]fordependindepends]
            if'code'invalsorany(dependinvalsfordependindepends):
                picking_type_vals=warehouse._create_or_update_sequences_and_picking_types()
                ifpicking_type_vals:
                    warehouse.write(picking_type_vals)
            ifany(dependinvalsfordependindepends):
                route_vals=warehouse._create_or_update_route()
                ifroute_vals:
                    warehouse.write(route_vals)
            #Checkifaglobalrule(mto,buy,...)needtobemodify.
            #Thefieldthatimpactthoserulesarelistedinthe
            #_get_global_route_rules_valuesmethodunderthekeynamed
            #'depends'.
            global_rules=warehouse._get_global_route_rules_values()
            depends=[dependfordependsin[value.get('depends',[])forvalueinglobal_rules.values()]fordependindepends]
            ifany(ruleinvalsforruleinglobal_rules)or\
                    any(dependinvalsfordependindepends):
                warehouse._create_or_update_global_routes_rules()

            if'active'invals:
                picking_type_ids=self.env['stock.picking.type'].with_context(active_test=False).search([('warehouse_id','=',warehouse.id)])
                move_ids=self.env['stock.move'].search([
                    ('picking_type_id','in',picking_type_ids.ids),
                    ('state','notin',('done','cancel')),
                ])
                ifmove_ids:
                    raiseUserError(_('Youstillhaveongoingoperationsforpickingtypes%sinwarehouse%s')%
                                    (','.join(move_ids.mapped('picking_type_id.name')),warehouse.name))
                else:
                    picking_type_ids.write({'active':vals['active']})
                location_ids=self.env['stock.location'].with_context(active_test=False).search([('location_id','child_of',warehouse.view_location_id.id)])
                picking_type_using_locations=self.env['stock.picking.type'].search([
                    ('default_location_src_id','in',location_ids.ids),
                    ('default_location_dest_id','in',location_ids.ids),
                    ('id','notin',picking_type_ids.ids),
                ])
                ifpicking_type_using_locations:
                    raiseUserError(_('%susedefaultsourceordestinationlocationsfromwarehouse%sthatwillbearchived.')%
                                    (','.join(picking_type_using_locations.mapped('name')),warehouse.name))
                warehouse.view_location_id.write({'active':vals['active']})

                rule_ids=self.env['stock.rule'].with_context(active_test=False).search([('warehouse_id','=',warehouse.id)])
                #Onlymodifyroutethatapplyonthiswarehouse.
                warehouse.route_ids.filtered(lambdar:len(r.warehouse_ids)==1).write({'active':vals['active']})
                rule_ids.write({'active':vals['active']})

                ifwarehouse.active:
                    #Catchallwarehousefieldsthattriggeramodficationon
                    #routes,rules,pickingtypesandlocations(e.gthereception
                    #steps).Thepurposeistowriteonitinordertoletthe
                    #writemethodsetthecorrectfieldtoactiveorarchive.
                    depends=set([])
                    forrule_iteminwarehouse._get_global_route_rules_values().values():
                        fordependinrule_item.get('depends',[]):
                            depends.add(depend)
                    forrule_iteminwarehouse._get_routes_values().values():
                        fordependinrule_item.get('depends',[]):
                            depends.add(depend)
                    values={'resupply_route_ids':[(4,route.id)forrouteinwarehouse.resupply_route_ids]}
                    fordependindepends:
                        values.update({depend:warehouse[depend]})
                    warehouse.write(values)

        ifvals.get('resupply_wh_ids')andnotvals.get('resupply_route_ids'):
            forwarehouseinwarehouses:
                to_add=new_resupply_whs-old_resupply_whs[warehouse.id]
                to_remove=old_resupply_whs[warehouse.id]-new_resupply_whs
                ifto_add:
                    existing_route=Route.search([
                        ('supplied_wh_id','=',warehouse.id),
                        ('supplier_wh_id','in',to_remove.ids),
                        ('active','=',False)
                    ])
                    ifexisting_route:
                        existing_route.toggle_active()
                    else:
                        warehouse.create_resupply_routes(to_add)
                ifto_remove:
                    to_disable_route_ids=Route.search([
                        ('supplied_wh_id','=',warehouse.id),
                        ('supplier_wh_id','in',to_remove.ids),
                        ('active','=',True)
                    ])
                    to_disable_route_ids.toggle_active()

        if'active'invals:
            self._check_multiwarehouse_group()
        returnres

    defunlink(self):
        res=super().unlink()
        self._check_multiwarehouse_group()
        returnres

    def_check_multiwarehouse_group(self):
        cnt_by_company=self.env['stock.warehouse'].sudo().read_group([('active','=',True)],['company_id'],groupby=['company_id'])
        ifcnt_by_company:
            max_cnt=max(cnt_by_company,key=lambdak:k['company_id_count'])
            group_user=self.env.ref('base.group_user')
            group_stock_multi_warehouses=self.env.ref('stock.group_stock_multi_warehouses')
            ifmax_cnt['company_id_count']<=1andgroup_stock_multi_warehousesingroup_user.implied_ids:
                group_user.write({'implied_ids':[(3,group_stock_multi_warehouses.id)]})
                group_stock_multi_warehouses.write({'users':[(3,user.id)foruseringroup_user.users]})
            ifmax_cnt['company_id_count']>1andgroup_stock_multi_warehousesnotingroup_user.implied_ids:
                group_user.write({'implied_ids':[(4,group_stock_multi_warehouses.id),(4,self.env.ref('stock.group_stock_multi_locations').id)]})

    @api.model
    def_update_partner_data(self,partner_id,company_id):
        ifnotpartner_id:
            return
        ResCompany=self.env['res.company']
        ifcompany_id:
            transit_loc=ResCompany.browse(company_id).internal_transit_location_id.id
            self.env['res.partner'].browse(partner_id).with_company(company_id).write({'property_stock_customer':transit_loc,'property_stock_supplier':transit_loc})
        else:
            transit_loc=self.env.company.internal_transit_location_id.id
            self.env['res.partner'].browse(partner_id).write({'property_stock_customer':transit_loc,'property_stock_supplier':transit_loc})

    def_create_or_update_sequences_and_picking_types(self):
        """Createorupdateexistingpickingtypesforawarehouse.
        Pikcingtypesarestoredonthewarehouseinamany2one.Ifthepicking
        typeexistthismethodwillupdateit.Theupdatevaluescanbefoundin
        themethod_get_picking_type_update_values.Ifthepickingtypedoesnot
        existitwillbecreatedwithanewsequenceassociatedtoit.
        """
        self.ensure_one()
        IrSequenceSudo=self.env['ir.sequence'].sudo()
        PickingType=self.env['stock.picking.type']

        #choosethenextavailablecolorfortheoperationtypesofthiswarehouse
        all_used_colors=[res['color']forresinPickingType.search_read([('warehouse_id','!=',False),('color','!=',False)],['color'],order='color')]
        available_colors=[zefforzefinrange(0,12)ifzefnotinall_used_colors]
        color=available_colors[0]ifavailable_colorselse0

        warehouse_data={}
        sequence_data=self._get_sequence_values()

        #suitforeachwarehouse:reception,internal,pick,pack,ship
        max_sequence=self.env['stock.picking.type'].search_read([('sequence','!=',False)],['sequence'],limit=1,order='sequencedesc')
        max_sequence=max_sequenceandmax_sequence[0]['sequence']or0

        data=self._get_picking_type_update_values()
        create_data,max_sequence=self._get_picking_type_create_values(max_sequence)

        forpicking_type,valuesindata.items():
            ifself[picking_type]:
                self[picking_type].update(values)
            else:
                data[picking_type].update(create_data[picking_type])
                sequence=IrSequenceSudo.create(sequence_data[picking_type])
                values.update(warehouse_id=self.id,color=color,sequence_id=sequence.id)
                warehouse_data[picking_type]=PickingType.create(values).id

        if'out_type_id'inwarehouse_data:
            PickingType.browse(warehouse_data['out_type_id']).write({'return_picking_type_id':warehouse_data.get('in_type_id',False)})
        if'in_type_id'inwarehouse_data:
            PickingType.browse(warehouse_data['in_type_id']).write({'return_picking_type_id':warehouse_data.get('out_type_id',False)})
        returnwarehouse_data

    def_create_or_update_global_routes_rules(self):
        """Somerulesarenotspecifictoawarehouse(e.gMTO,Buy,...)
        howevertheycontainrule(s)foraspecificwarehouse.Thismethodwill
        updatetherulescontainedinglobalroutesinordertomakethemmatch
        withthewantedreception,delivery,...steps.
        """
        forrule_field,rule_detailsinself._get_global_route_rules_values().items():
            values=rule_details.get('update_values',{})
            ifself[rule_field]:
                self[rule_field].write(values)
            else:
                values.update(rule_details['create_values'])
                values.update({'warehouse_id':self.id})
                self[rule_field]=self.env['stock.rule'].create(values)
        returnTrue

    def_find_global_route(self,xml_id,route_name):
        """returnarouterecordsetfromanxml_idoritsname."""
        route=self.env.ref(xml_id,raise_if_not_found=False)
        ifnotroute:
            route=self.env['stock.location.route'].search([('name','like',route_name)],limit=1)
        ifnotroute:
            raiseUserError(_('Can\'tfindanygenericroute%s.')%(route_name))
        returnroute

    def_get_global_route_rules_values(self):
        """Methodusedby_create_or_update_global_routes_rules.It's
        purposeistoreturnadictwiththisformat.
        key:Therulecontainedinaglobalroutethathavetobecreate/update
        entryadictwiththefollowingvalues:
            -depends:Fieldthatimpacttherule.Whenafieldindependsis
            writeonthewarehousetherulesetaskeyhavetobeupdate.
            -create_values:valuesusedinordertocreatetheruleifitdoes
            notexist.
            -update_values:valuesusedtoupdatetheroutewhenafieldin
            dependsismodifyonthewarehouse.
        """
        #Weuse0sinceroutingareorderfromstocktocust.Iftherouting
        #orderismodify,themtorulewillbewrong.
        rule=self.get_rules_dict()[self.id][self.delivery_steps]
        rule=[rforrinruleifr.from_loc==self.lot_stock_id][0]
        location_id=rule.from_loc
        location_dest_id=rule.dest_loc
        picking_type_id=rule.picking_type
        return{
            'mto_pull_id':{
                'depends':['delivery_steps'],
                'create_values':{
                    'active':True,
                    'procure_method':'mts_else_mto',
                    'company_id':self.company_id.id,
                    'action':'pull',
                    'auto':'manual',
                    'route_id':self._find_global_route('stock.route_warehouse0_mto',_('MakeToOrder')).id
                },
                'update_values':{
                    'name':self._format_rulename(location_id,location_dest_id,'MTO'),
                    'location_id':location_dest_id.id,
                    'location_src_id':location_id.id,
                    'picking_type_id':picking_type_id.id,
                }
            }
        }

    def_create_or_update_route(self):
        """Createorupdatethewarehouse'sroutes.
        _get_routes_valuesmethodreturnadictwith:
            -routefieldname(e.g:crossdock_route_id).
            -fieldthattriggeranupdateontheroute(key'depends').
            -routing_keyusedinordertofindrulescontainedintheroute.
            -createvalues.
            -updatevalueswhenafieldindependsismodified.
            -rulesdefaultvalues.
        Thismethoddoaniterationoneachroutereturnedandupdate/create
        them.Inordertoupdatetherulescontainedintherouteitwill
        usetheget_rules_dictthatreturnadict:
            -areceptions/delivery,...stepvalueaskey(e.g 'pick_ship')
            -alistofroutingobjectthatrepresentstherulesneededto
            fullfilthepuposeoftheroute.
        Therouting_keyfrom_get_routes_valuesismatchwiththeget_rules_dict
        keyinordertocreate/updatetherulesintheroute
        (_find_existing_rule_or_createmethodisresponsibleforthispart).
        """
        #Createroutesandactive/createtheirrelatedrules.
        routes=[]
        rules_dict=self.get_rules_dict()
        forroute_field,route_datainself._get_routes_values().items():
            #Iftherouteexistsupdateit
            ifself[route_field]:
                route=self[route_field]
                if'route_update_values'inroute_data:
                    route.write(route_data['route_update_values'])
                route.rule_ids.write({'active':False})
            #Createtheroute
            else:
                if'route_update_values'inroute_data:
                    route_data['route_create_values'].update(route_data['route_update_values'])
                route=self.env['stock.location.route'].create(route_data['route_create_values'])
                self[route_field]=route
            #Getrulesneededfortheroute
            routing_key=route_data.get('routing_key')
            rules=rules_dict[self.id][routing_key]
            if'rules_values'inroute_data:
                route_data['rules_values'].update({'route_id':route.id})
            else:
                route_data['rules_values']={'route_id':route.id}
            rules_list=self._get_rule_values(
                rules,values=route_data['rules_values'])
            #Create/Activerules
            self._find_existing_rule_or_create(rules_list)
            ifroute_data['route_create_values'].get('warehouse_selectable',False)orroute_data['route_update_values'].get('warehouse_selectable',False):
                routes.append(self[route_field])
        return{
            'route_ids':[(4,route.id)forrouteinroutes],
        }

    def_get_routes_values(self):
        """Returninformationinordertoupdatewarehouseroutes.
        -ThekeyisaroutefieldsotredasaMany2oneonthewarehouse
        -Thiskeycontainsadictwithroutevalues:
            -routing_key:akeyusedinordertomatchrulesfrom
            get_rules_dictfunction.Itwouldbeusefullinordertogenerate
            theroute'srules.
            -route_create_values:WhentheMany2onedoesnotexisttheroute
            iscreatedbasedonvaluescontainedinthisdict.
            -route_update_values:Whenafieldcontainedin'depends'keyis
            modifiedandtheMany2oneexistonthewarehouse,theroutewillbe
            updatewiththevaluescontainedinthisdict.
            -rules_values:valuesaddedtotheroutinginordertocreatethe
            route'srules.
        """
        return{
            'reception_route_id':{
                'routing_key':self.reception_steps,
                'depends':['reception_steps'],
                'route_update_values':{
                    'name':self._format_routename(route_type=self.reception_steps),
                    'active':self.active,
                },
                'route_create_values':{
                    'product_categ_selectable':True,
                    'warehouse_selectable':True,
                    'product_selectable':False,
                    'company_id':self.company_id.id,
                    'sequence':9,
                },
                'rules_values':{
                    'active':True,
                    'propagate_cancel':True,
                }
            },
            'delivery_route_id':{
                'routing_key':self.delivery_steps,
                'depends':['delivery_steps'],
                'route_update_values':{
                    'name':self._format_routename(route_type=self.delivery_steps),
                    'active':self.active,
                },
                'route_create_values':{
                    'product_categ_selectable':True,
                    'warehouse_selectable':True,
                    'product_selectable':False,
                    'company_id':self.company_id.id,
                    'sequence':10,
                },
                'rules_values':{
                    'active':True,
                }
            },
            'crossdock_route_id':{
                'routing_key':'crossdock',
                'depends':['delivery_steps','reception_steps'],
                'route_update_values':{
                    'name':self._format_routename(route_type='crossdock'),
                    'active':self.reception_steps!='one_step'andself.delivery_steps!='ship_only'
                },
                'route_create_values':{
                    'product_selectable':True,
                    'product_categ_selectable':True,
                    'active':self.delivery_steps!='ship_only'andself.reception_steps!='one_step',
                    'company_id':self.company_id.id,
                    'sequence':20,
                },
                'rules_values':{
                    'active':True,
                    'procure_method':'make_to_order'
                }
            }
        }

    def_get_receive_routes_values(self,installed_depends):
        """Returnreceiveroutevalueswith'procure_method':'make_to_order'
        inordertoupdatewarehouseroutes.

        Thisfunctionhasthesamereceiveroutevaluesas_get_routes_valueswiththeadditionof
        'procure_method':'make_to_order'tothe'rules_values'.Thisisexpectedtobeusedby
        modulesthatextendstockandaddactionsthatcantriggerreceive'make_to_order'rules(i.e.
        wedon'twantanyofthegeneratedrulesbyget_rules_dicttodefaultto'make_to_stock').
        Additionallythisisexpectedtobeusedinconjunctionwith_get_receive_rules_dict().

        args:
        installed_depends-stringvalueofinstalled(warehouse)booleantotriggerupdatingofreceptionroute.
        """
        return{
            'reception_route_id':{
                'routing_key':self.reception_steps,
                'depends':['reception_steps',installed_depends],
                'route_update_values':{
                    'name':self._format_routename(route_type=self.reception_steps),
                    'active':self.active,
                },
                'route_create_values':{
                    'product_categ_selectable':True,
                    'warehouse_selectable':True,
                    'product_selectable':False,
                    'company_id':self.company_id.id,
                    'sequence':9,
                },
                'rules_values':{
                    'active':True,
                    'propagate_cancel':True,
                    'procure_method':'make_to_order',
                }
            }
        }

    def_find_existing_rule_or_create(self,rules_list):
        """Thismethodwillfindexistingrulesorcreatenewone."""
        forrule_valsinrules_list:
            existing_rule=self.env['stock.rule'].search([
                ('picking_type_id','=',rule_vals['picking_type_id']),
                ('location_src_id','=',rule_vals['location_src_id']),
                ('location_id','=',rule_vals['location_id']),
                ('route_id','=',rule_vals['route_id']),
                ('action','=',rule_vals['action']),
                ('active','=',False),
            ])
            ifnotexisting_rule:
                self.env['stock.rule'].create(rule_vals)
            else:
                existing_rule.write({'active':True})

    def_get_locations_values(self,vals,code=False):
        """Updatethewarehouselocations."""
        def_values=self.default_get(['reception_steps','delivery_steps'])
        reception_steps=vals.get('reception_steps',def_values['reception_steps'])
        delivery_steps=vals.get('delivery_steps',def_values['delivery_steps'])
        code=vals.get('code')orcodeor''
        code=code.replace('','').upper()
        company_id=vals.get('company_id',self.default_get(['company_id'])['company_id'])
        sub_locations={
            'lot_stock_id':{
                'name':_('Stock'),
                'active':True,
                'usage':'internal',
                'barcode':self._valid_barcode(code+'-STOCK',company_id)
            },
            'wh_input_stock_loc_id':{
                'name':_('Input'),
                'active':reception_steps!='one_step',
                'usage':'internal',
                'barcode':self._valid_barcode(code+'-INPUT',company_id)
            },
            'wh_qc_stock_loc_id':{
                'name':_('QualityControl'),
                'active':reception_steps=='three_steps',
                'usage':'internal',
                'barcode':self._valid_barcode(code+'-QUALITY',company_id)
            },
            'wh_output_stock_loc_id':{
                'name':_('Output'),
                'active':delivery_steps!='ship_only',
                'usage':'internal',
                'barcode':self._valid_barcode(code+'-OUTPUT',company_id)
            },
            'wh_pack_stock_loc_id':{
                'name':_('PackingZone'),
                'active':delivery_steps=='pick_pack_ship',
                'usage':'internal',
                'barcode':self._valid_barcode(code+'-PACKING',company_id)
            },
        }
        returnsub_locations

    def_valid_barcode(self,barcode,company_id):
        location=self.env['stock.location'].with_context(active_test=False).search([
            ('barcode','=',barcode),
            ('company_id','=',company_id)
        ])
        returnnotlocationandbarcode

    def_create_missing_locations(self,vals):
        """Itcouldhappenthattheuserdeleteamandatorylocationora
        modulewithnewlocationswasinstalledaftersomewarehousescreation.
        Inthiscase,thisfunctionwillcreatemissinglocationsinorderto
        avoidmistakesduringpickingtypesandrulescreation.
        """
        forwarehouseinself:
            company_id=vals.get('company_id',warehouse.company_id.id)
            sub_locations=warehouse._get_locations_values(dict(vals,company_id=company_id),warehouse.code)
            missing_location={}
            forlocation,location_valuesinsub_locations.items():
                ifnotwarehouse[location]andlocationnotinvals:
                    location_values['location_id']=vals.get('view_location_id',warehouse.view_location_id.id)
                    location_values['company_id']=company_id
                    missing_location[location]=self.env['stock.location'].create(location_values).id
            ifmissing_location:
                warehouse.write(missing_location)

    defcreate_resupply_routes(self,supplier_warehouses):
        Route=self.env['stock.location.route']
        Rule=self.env['stock.rule']

        input_location,output_location=self._get_input_output_locations(self.reception_steps,self.delivery_steps)
        internal_transit_location,external_transit_location=self._get_transit_locations()

        forsupplier_whinsupplier_warehouses:
            transit_location=internal_transit_locationifsupplier_wh.company_id==self.company_idelseexternal_transit_location
            ifnottransit_location:
                continue
            transit_location.active=True
            output_location=supplier_wh.lot_stock_idifsupplier_wh.delivery_steps=='ship_only'elsesupplier_wh.wh_output_stock_loc_id
            #CreateextraMTOrule(onlyfor'shiponly'becauseintheothercasesMTOrulesalreadyexists)
            ifsupplier_wh.delivery_steps=='ship_only':
                routing=[self.Routing(output_location,transit_location,supplier_wh.out_type_id,'pull')]
                mto_vals=supplier_wh._get_global_route_rules_values().get('mto_pull_id')
                values=mto_vals['create_values']
                mto_rule_val=supplier_wh._get_rule_values(routing,values,name_suffix='MTO')
                Rule.create(mto_rule_val[0])

            inter_wh_route=Route.create(self._get_inter_warehouse_route_values(supplier_wh))

            pull_rules_list=supplier_wh._get_supply_pull_rules_values(
                [self.Routing(output_location,transit_location,supplier_wh.out_type_id,'pull')],
                values={'route_id':inter_wh_route.id})
            pull_rules_list+=self._get_supply_pull_rules_values(
                [self.Routing(transit_location,input_location,self.in_type_id,'pull')],
                values={'route_id':inter_wh_route.id,'propagate_warehouse_id':supplier_wh.id})
            forpull_rule_valsinpull_rules_list:
                Rule.create(pull_rule_vals)

    #Routingtools
    #------------------------------------------------------------

    def_get_input_output_locations(self,reception_steps,delivery_steps):
        return(self.lot_stock_idifreception_steps=='one_step'elseself.wh_input_stock_loc_id,
                self.lot_stock_idifdelivery_steps=='ship_only'elseself.wh_output_stock_loc_id)

    def_get_transit_locations(self):
        returnself.company_id.internal_transit_location_id,self.env.ref('stock.stock_location_inter_wh',raise_if_not_found=False)orself.env['stock.location']

    @api.model
    def_get_partner_locations(self):
        '''returnsatuplemadeofthebrowserecordofcustomerlocationandthebrowserecordofsupplierlocation'''
        Location=self.env['stock.location']
        customer_loc=self.env.ref('stock.stock_location_customers',raise_if_not_found=False)
        supplier_loc=self.env.ref('stock.stock_location_suppliers',raise_if_not_found=False)
        ifnotcustomer_loc:
            customer_loc=Location.search([('usage','=','customer')],limit=1)
        ifnotsupplier_loc:
            supplier_loc=Location.search([('usage','=','supplier')],limit=1)
        ifnotcustomer_locandnotsupplier_loc:
            raiseUserError(_('Can\'tfindanycustomerorsupplierlocation.'))
        returncustomer_loc,supplier_loc

    def_get_route_name(self,route_type):
        returnstr(ROUTE_NAMES[route_type])

    defget_rules_dict(self):
        """Definetherulessource/destinationlocations,picking_typeand
        actionneededforeachwarehouserouteconfiguration.
        """
        customer_loc,supplier_loc=self._get_partner_locations()
        return{
            warehouse.id:{
                'one_step':[self.Routing(supplier_loc,warehouse.lot_stock_id,warehouse.in_type_id,'pull')],
                'two_steps':[
                    self.Routing(supplier_loc,warehouse.wh_input_stock_loc_id,warehouse.in_type_id,'pull'),
                    self.Routing(warehouse.wh_input_stock_loc_id,warehouse.lot_stock_id,warehouse.int_type_id,'pull_push')],
                'three_steps':[
                    self.Routing(supplier_loc,warehouse.wh_input_stock_loc_id,warehouse.in_type_id,'pull'),
                    self.Routing(warehouse.wh_input_stock_loc_id,warehouse.wh_qc_stock_loc_id,warehouse.int_type_id,'pull_push'),
                    self.Routing(warehouse.wh_qc_stock_loc_id,warehouse.lot_stock_id,warehouse.int_type_id,'pull_push')],
                'crossdock':[
                    self.Routing(warehouse.wh_input_stock_loc_id,warehouse.wh_output_stock_loc_id,warehouse.int_type_id,'pull'),
                    self.Routing(warehouse.wh_output_stock_loc_id,customer_loc,warehouse.out_type_id,'pull')],
                'ship_only':[self.Routing(warehouse.lot_stock_id,customer_loc,warehouse.out_type_id,'pull')],
                'pick_ship':[
                    self.Routing(warehouse.lot_stock_id,warehouse.wh_output_stock_loc_id,warehouse.pick_type_id,'pull'),
                    self.Routing(warehouse.wh_output_stock_loc_id,customer_loc,warehouse.out_type_id,'pull')],
                'pick_pack_ship':[
                    self.Routing(warehouse.lot_stock_id,warehouse.wh_pack_stock_loc_id,warehouse.pick_type_id,'pull'),
                    self.Routing(warehouse.wh_pack_stock_loc_id,warehouse.wh_output_stock_loc_id,warehouse.pack_type_id,'pull'),
                    self.Routing(warehouse.wh_output_stock_loc_id,customer_loc,warehouse.out_type_id,'pull')],
                'company_id':warehouse.company_id.id,
            }forwarehouseinself
        }

    def_get_receive_rules_dict(self):
        """Returnreceiverouteruleswithoutinitialpullruleinordertoupdatewarehouseroutes.

        Thisfunctionhasthesamereceiverouterulesasget_rules_dictwithoutaninitialpullrule.
        Thisisexpectedtobeusedbymodulesthatextendstockandaddactionsthatcantriggerreceive
        'make_to_order'rules(i.e.wedon'texpectthereceiveroutetobeabletopullonitsownanymore).
        Thisisalsoexpectedtobeusedinconjuctionwith_get_receive_routes_values()
        """
        return{
            'one_step':[],
            'two_steps':[self.Routing(self.wh_input_stock_loc_id,self.lot_stock_id,self.int_type_id,'pull_push')],
            'three_steps':[
                self.Routing(self.wh_input_stock_loc_id,self.wh_qc_stock_loc_id,self.int_type_id,'pull_push'),
                self.Routing(self.wh_qc_stock_loc_id,self.lot_stock_id,self.int_type_id,'pull_push')],
        }

    def_get_inter_warehouse_route_values(self,supplier_warehouse):
        return{
            'name':_('%(warehouse)s:SupplyProductfrom%(supplier)s',warehouse=self.name,supplier=supplier_warehouse.name),
            'warehouse_selectable':True,
            'product_selectable':True,
            'product_categ_selectable':True,
            'supplied_wh_id':self.id,
            'supplier_wh_id':supplier_warehouse.id,
            'company_id':self.company_id.id,
        }

    #Pull/Pushtools
    #------------------------------------------------------------

    def_get_rule_values(self,route_values,values=None,name_suffix=''):
        first_rule=True
        rules_list=[]
        forroutinginroute_values:
            route_rule_values={
                'name':self._format_rulename(routing.from_loc,routing.dest_loc,name_suffix),
                'location_src_id':routing.from_loc.id,
                'location_id':routing.dest_loc.id,
                'action':routing.action,
                'auto':'manual',
                'picking_type_id':routing.picking_type.id,
                'procure_method':first_ruleand'make_to_stock'or'make_to_order',
                'warehouse_id':self.id,
                'company_id':self.company_id.id,
            }
            route_rule_values.update(valuesor{})
            rules_list.append(route_rule_values)
            first_rule=False
        ifvaluesandvalues.get('propagate_cancel')andrules_list:
            #Incaseofruleschainwithcancelpropagationset,weneedtostop
            #thecancellationforthelaststepinordertoavoidcancelling
            #anyothermoveafterthechain.
            #Example:Inthefollowingflow:
            #Input->Qualitycheck->Stock->Customer
            #WewantthatcancellingI->GCcancelQC->SbutnotS->C
            #whichmeans:
            #Input->Qualitycheckshouldhavepropagate_cancel=True
            #Qualitycheck->Stockshouldhavepropagate_cancel=False
            rules_list[-1]['propagate_cancel']=False
        returnrules_list

    def_get_supply_pull_rules_values(self,route_values,values=None):
        pull_values={}
        pull_values.update(values)
        pull_values.update({'active':True})
        rules_list=self._get_rule_values(route_values,values=pull_values)
        forpull_rulesinrules_list:
            pull_rules['procure_method']=self.lot_stock_id.id!=pull_rules['location_src_id']and'make_to_order'or'make_to_stock' #firstpartoftheresuplyrouteisMTS
        returnrules_list

    def_update_reception_delivery_resupply(self,reception_new,delivery_new):
        """CheckifweneedtochangesomethingtoresupplywarehousesandassociatedMTOrules"""
        forwarehouseinself:
            input_loc,output_loc=warehouse._get_input_output_locations(reception_new,delivery_new)
            ifreception_newandwarehouse.reception_steps!=reception_newand(warehouse.reception_steps=='one_step'orreception_new=='one_step'):
                warehouse._check_reception_resupply(input_loc)
            ifdelivery_newandwarehouse.delivery_steps!=delivery_newand(warehouse.delivery_steps=='ship_only'ordelivery_new=='ship_only'):
                change_to_multiple=warehouse.delivery_steps=='ship_only'
                warehouse._check_delivery_resupply(output_loc,change_to_multiple)

    def_check_delivery_resupply(self,new_location,change_to_multiple):
        """Checkiftheresupplyroutesfromthiswarehousefollowthechangesofnumberofdeliverysteps
        Checkroutesbeingdeliverybuthiswarehouseandchangetherulegoingtotransitlocation"""
        Rule=self.env["stock.rule"]
        routes=self.env['stock.location.route'].search([('supplier_wh_id','=',self.id)])
        rules=Rule.search(['&','&',('route_id','in',routes.ids),('action','!=','push'),('location_id.usage','=','transit')])
        rules.write({
            'location_src_id':new_location.id,
            'procure_method':change_to_multipleand"make_to_order"or"make_to_stock"})
        ifnotchange_to_multiple:
            #IfsingledeliveryweshouldcreatethenecessaryMTOrulesfortheresupply
            routings=[self.Routing(self.lot_stock_id,location,self.out_type_id,'pull')forlocationinrules.mapped('location_id')]
            mto_vals=self._get_global_route_rules_values().get('mto_pull_id')
            values=mto_vals['create_values']
            mto_rule_vals=self._get_rule_values(routings,values,name_suffix='MTO')

            formto_rule_valinmto_rule_vals:
                Rule.create(mto_rule_val)
        else:
            #WeneedtodeletealltheMTOstockrules,otherwisetheyrisktobeusedinthesystem
            Rule.search([
                '&',('route_id','=',self._find_global_route('stock.route_warehouse0_mto',_('MakeToOrder')).id),
                ('location_id.usage','=','transit'),
                ('action','!=','push'),
                ('location_src_id','=',self.lot_stock_id.id)]).write({'active':False})

    def_check_reception_resupply(self,new_location):
        """Checkroutesbeingdeliveredbythewarehouses(resupplyroutes)and
        changetheirrulecomingfromthetransitlocation"""
        routes=self.env['stock.location.route'].search([('supplied_wh_id','in',self.ids)])
        self.env['stock.rule'].search([
            '&',
                ('route_id','in',routes.ids),
                '&',
                    ('action','!=','push'),
                    ('location_src_id.usage','=','transit')
        ]).write({'location_id':new_location.id})

    def_update_name_and_code(self,new_name=False,new_code=False):
        ifnew_code:
            self.mapped('lot_stock_id').mapped('location_id').write({'name':new_code})
        ifnew_name:
            #TDEFIXME:replacingtheroutename?notbettertore-generatetheroutenaming?
            forwarehouseinself:
                routes=warehouse.route_ids
                forrouteinroutes:
                    route.write({'name':route.name.replace(warehouse.name,new_name,1)})
                    forpullinroute.rule_ids:
                        pull.write({'name':pull.name.replace(warehouse.name,new_name,1)})
                ifwarehouse.mto_pull_id:
                    warehouse.mto_pull_id.write({'name':warehouse.mto_pull_id.name.replace(warehouse.name,new_name,1)})
        forwarehouseinself:
            sequence_data=warehouse._get_sequence_values()
            #`ir.sequence`writeaccessislimitedtosystemuser
            ifself.user_has_groups('stock.group_stock_manager'):
                warehouse=warehouse.sudo()
            warehouse.in_type_id.sequence_id.write(sequence_data['in_type_id'])
            warehouse.out_type_id.sequence_id.write(sequence_data['out_type_id'])
            warehouse.pack_type_id.sequence_id.write(sequence_data['pack_type_id'])
            warehouse.pick_type_id.sequence_id.write(sequence_data['pick_type_id'])
            warehouse.int_type_id.sequence_id.write(sequence_data['int_type_id'])

    def_update_location_reception(self,new_reception_step):
        self.mapped('wh_qc_stock_loc_id').write({'active':new_reception_step=='three_steps'})
        self.mapped('wh_input_stock_loc_id').write({'active':new_reception_step!='one_step'})

    def_update_location_delivery(self,new_delivery_step):
        self.mapped('wh_pack_stock_loc_id').write({'active':new_delivery_step=='pick_pack_ship'})
        self.mapped('wh_output_stock_loc_id').write({'active':new_delivery_step!='ship_only'})

    #Misc
    #------------------------------------------------------------

    def_get_picking_type_update_values(self):
        """Returnvaluesinordertoupdatetheexistingpickingtypewhenthe
        warehouse'sdelivery_stepsorreception_stepsaremodify.
        """
        input_loc,output_loc=self._get_input_output_locations(self.reception_steps,self.delivery_steps)
        return{
            'in_type_id':{
                'default_location_dest_id':input_loc.id,
                'barcode':self.code.replace("","").upper()+"-RECEIPTS",
            },
            'out_type_id':{
                'default_location_src_id':output_loc.id,
                'barcode':self.code.replace("","").upper()+"-DELIVERY",
            },
            'pick_type_id':{
                'active':self.delivery_steps!='ship_only'andself.active,
                'default_location_dest_id':output_loc.idifself.delivery_steps=='pick_ship'elseself.wh_pack_stock_loc_id.id,
                'barcode':self.code.replace("","").upper()+"-PICK",
            },
            'pack_type_id':{
                'active':self.delivery_steps=='pick_pack_ship'andself.active,
                'barcode':self.code.replace("","").upper()+"-PACK",
            },
            'int_type_id':{
                'barcode':self.code.replace("","").upper()+"-INTERNAL",
            },
        }

    def_get_picking_type_create_values(self,max_sequence):
        """Whenawarehouseiscreatedthismethodreturnthevaluesneededin
        ordertocreatethenewpickingtypesforthiswarehouse.Everypicking
        typearecreatedatthesametimethanthewarehousehowvertheyare
        activatedorarchiveddependingthedelivery_stepsorreception_steps.
        """
        input_loc,output_loc=self._get_input_output_locations(self.reception_steps,self.delivery_steps)
        return{
            'in_type_id':{
                'name':_('Receipts'),
                'code':'incoming',
                'use_create_lots':True,
                'use_existing_lots':False,
                'default_location_src_id':False,
                'sequence':max_sequence+1,
                'show_reserved':False,
                'show_operations':False,
                'sequence_code':'IN',
                'company_id':self.company_id.id,
            },'out_type_id':{
                'name':_('DeliveryOrders'),
                'code':'outgoing',
                'use_create_lots':False,
                'use_existing_lots':True,
                'default_location_dest_id':False,
                'sequence':max_sequence+5,
                'sequence_code':'OUT',
                'company_id':self.company_id.id,
            },'pack_type_id':{
                'name':_('Pack'),
                'code':'internal',
                'use_create_lots':False,
                'use_existing_lots':True,
                'default_location_src_id':self.wh_pack_stock_loc_id.id,
                'default_location_dest_id':output_loc.id,
                'sequence':max_sequence+4,
                'sequence_code':'PACK',
                'company_id':self.company_id.id,
            },'pick_type_id':{
                'name':_('Pick'),
                'code':'internal',
                'use_create_lots':False,
                'use_existing_lots':True,
                'default_location_src_id':self.lot_stock_id.id,
                'sequence':max_sequence+3,
                'sequence_code':'PICK',
                'company_id':self.company_id.id,
            },'int_type_id':{
                'name':_('InternalTransfers'),
                'code':'internal',
                'use_create_lots':False,
                'use_existing_lots':True,
                'default_location_src_id':self.lot_stock_id.id,
                'default_location_dest_id':self.lot_stock_id.id,
                'active':self.reception_steps!='one_step'orself.delivery_steps!='ship_only'orself.user_has_groups('stock.group_stock_multi_locations'),
                'sequence':max_sequence+2,
                'sequence_code':'INT',
                'company_id':self.company_id.id,
            },
        },max_sequence+6

    def_get_sequence_values(self):
        """Eachpickingtypeiscreatedwithasequence.Thismethodreturns
        thesequencevaluesassociatedtoeachpickingtype.
        """
        return{
            'in_type_id':{
                'name':self.name+''+_('Sequencein'),
                'prefix':self.code+'/IN/','padding':5,
                'company_id':self.company_id.id,
            },
            'out_type_id':{
                'name':self.name+''+_('Sequenceout'),
                'prefix':self.code+'/OUT/','padding':5,
                'company_id':self.company_id.id,
            },
            'pack_type_id':{
                'name':self.name+''+_('Sequencepacking'),
                'prefix':self.code+'/PACK/','padding':5,
                'company_id':self.company_id.id,
            },
            'pick_type_id':{
                'name':self.name+''+_('Sequencepicking'),
                'prefix':self.code+'/PICK/','padding':5,
                'company_id':self.company_id.id,
            },
            'int_type_id':{
                'name':self.name+''+_('Sequenceinternal'),
                'prefix':self.code+'/INT/','padding':5,
                'company_id':self.company_id.id,
            },
        }

    def_format_rulename(self,from_loc,dest_loc,suffix):
        rulename='%s:%s'%(self.code,from_loc.name)
        ifdest_loc:
            rulename+='→%s'%(dest_loc.name)
        ifsuffix:
            rulename+='('+suffix+')'
        returnrulename

    def_format_routename(self,name=None,route_type=None):
        ifroute_type:
            name=self._get_route_name(route_type)
        return'%s:%s'%(self.name,name)

    @api.returns('self')
    def_get_all_routes(self):
        routes=self.mapped('route_ids')|self.mapped('mto_pull_id').mapped('route_id')
        routes|=self.env["stock.location.route"].search([('supplied_wh_id','in',self.ids)])
        returnroutes

    defaction_view_all_routes(self):
        routes=self._get_all_routes()
        return{
            'name':_('Warehouse\'sRoutes'),
            'domain':[('id','in',routes.ids)],
            'res_model':'stock.location.route',
            'type':'ir.actions.act_window',
            'view_id':False,
            'view_mode':'tree,form',
            'limit':20,
            'context':dict(self._context,default_warehouse_selectable=True,default_warehouse_ids=self.ids)
        }

#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

importoperatoraspy_operator
fromastimportliteral_eval
fromcollectionsimportdefaultdict

fromflectraimport_,api,fields,models,SUPERUSER_ID
fromflectra.exceptionsimportUserError
fromflectra.osvimportexpression
fromflectra.toolsimportpycompat,float_is_zero
fromflectra.tools.float_utilsimportfloat_round

OPERATORS={
    '<':py_operator.lt,
    '>':py_operator.gt,
    '<=':py_operator.le,
    '>=':py_operator.ge,
    '=':py_operator.eq,
    '!=':py_operator.ne
}

classProduct(models.Model):
    _inherit="product.product"

    stock_quant_ids=fields.One2many('stock.quant','product_id',help='Technical:usedtocomputequantities.')
    stock_move_ids=fields.One2many('stock.move','product_id',help='Technical:usedtocomputequantities.')
    qty_available=fields.Float(
        'QuantityOnHand',compute='_compute_quantities',search='_search_qty_available',
        digits='ProductUnitofMeasure',compute_sudo=False,
        help="Currentquantityofproducts.\n"
             "InacontextwithasingleStockLocation,thisincludes"
             "goodsstoredatthisLocation,oranyofitschildren.\n"
             "InacontextwithasingleWarehouse,thisincludes"
             "goodsstoredintheStockLocationofthisWarehouse,orany"
             "ofitschildren.\n"
             "storedintheStockLocationoftheWarehouseofthisShop,"
             "oranyofitschildren.\n"
             "Otherwise,thisincludesgoodsstoredinanyStockLocation"
             "with'internal'type.")
    virtual_available=fields.Float(
        'ForecastQuantity',compute='_compute_quantities',search='_search_virtual_available',
        digits='ProductUnitofMeasure',compute_sudo=False,
        help="Forecastquantity(computedasQuantityOnHand"
             "-Outgoing+Incoming)\n"
             "InacontextwithasingleStockLocation,thisincludes"
             "goodsstoredinthislocation,oranyofitschildren.\n"
             "InacontextwithasingleWarehouse,thisincludes"
             "goodsstoredintheStockLocationofthisWarehouse,orany"
             "ofitschildren.\n"
             "Otherwise,thisincludesgoodsstoredinanyStockLocation"
             "with'internal'type.")
    free_qty=fields.Float(
        'FreeToUseQuantity',compute='_compute_quantities',search='_search_free_qty',
        digits='ProductUnitofMeasure',compute_sudo=False,
        help="Forecastquantity(computedasQuantityOnHand"
             "-reservedquantity)\n"
             "InacontextwithasingleStockLocation,thisincludes"
             "goodsstoredinthislocation,oranyofitschildren.\n"
             "InacontextwithasingleWarehouse,thisincludes"
             "goodsstoredintheStockLocationofthisWarehouse,orany"
             "ofitschildren.\n"
             "Otherwise,thisincludesgoodsstoredinanyStockLocation"
             "with'internal'type.")
    incoming_qty=fields.Float(
        'Incoming',compute='_compute_quantities',search='_search_incoming_qty',
        digits='ProductUnitofMeasure',compute_sudo=False,
        help="Quantityofplannedincomingproducts.\n"
             "InacontextwithasingleStockLocation,thisincludes"
             "goodsarrivingtothisLocation,oranyofitschildren.\n"
             "InacontextwithasingleWarehouse,thisincludes"
             "goodsarrivingtotheStockLocationofthisWarehouse,or"
             "anyofitschildren.\n"
             "Otherwise,thisincludesgoodsarrivingtoanyStock"
             "Locationwith'internal'type.")
    outgoing_qty=fields.Float(
        'Outgoing',compute='_compute_quantities',search='_search_outgoing_qty',
        digits='ProductUnitofMeasure',compute_sudo=False,
        help="Quantityofplannedoutgoingproducts.\n"
             "InacontextwithasingleStockLocation,thisincludes"
             "goodsleavingthisLocation,oranyofitschildren.\n"
             "InacontextwithasingleWarehouse,thisincludes"
             "goodsleavingtheStockLocationofthisWarehouse,or"
             "anyofitschildren.\n"
             "Otherwise,thisincludesgoodsleavinganyStock"
             "Locationwith'internal'type.")

    orderpoint_ids=fields.One2many('stock.warehouse.orderpoint','product_id','MinimumStockRules')
    nbr_reordering_rules=fields.Integer('ReorderingRules',
        compute='_compute_nbr_reordering_rules',compute_sudo=False)
    reordering_min_qty=fields.Float(
        compute='_compute_nbr_reordering_rules',compute_sudo=False)
    reordering_max_qty=fields.Float(
        compute='_compute_nbr_reordering_rules',compute_sudo=False)
    putaway_rule_ids=fields.One2many('stock.putaway.rule','product_id','PutawayRules')

    @api.depends('stock_move_ids.product_qty','stock_move_ids.state')
    @api.depends_context(
        'lot_id','owner_id','package_id','from_date','to_date',
        'location','warehouse',
    )
    def_compute_quantities(self):
        products=self.filtered(lambdap:p.type!='service')
        res=products._compute_quantities_dict(self._context.get('lot_id'),self._context.get('owner_id'),self._context.get('package_id'),self._context.get('from_date'),self._context.get('to_date'))
        forproductinproducts:
            product.qty_available=res[product.id]['qty_available']
            product.incoming_qty=res[product.id]['incoming_qty']
            product.outgoing_qty=res[product.id]['outgoing_qty']
            product.virtual_available=res[product.id]['virtual_available']
            product.free_qty=res[product.id]['free_qty']
        #Servicesneedtobesetwith0.0forallquantities
        services=self-products
        services.qty_available=0.0
        services.incoming_qty=0.0
        services.outgoing_qty=0.0
        services.virtual_available=0.0
        services.free_qty=0.0

    def_product_available(self,field_names=None,arg=False):
        """Compatibilitymethod"""
        returnself._compute_quantities_dict(self._context.get('lot_id'),self._context.get('owner_id'),self._context.get('package_id'),self._context.get('from_date'),self._context.get('to_date'))

    def_compute_quantities_dict(self,lot_id,owner_id,package_id,from_date=False,to_date=False):
        domain_quant_loc,domain_move_in_loc,domain_move_out_loc=self._get_domain_locations()
        domain_quant=[('product_id','in',self.ids)]+domain_quant_loc
        dates_in_the_past=False
        #onlyto_dateasto_datewillcorrespondtoqty_available
        to_date=fields.Datetime.to_datetime(to_date)
        ifto_dateandto_date<fields.Datetime.now():
            dates_in_the_past=True

        domain_move_in=[('product_id','in',self.ids)]+domain_move_in_loc
        domain_move_out=[('product_id','in',self.ids)]+domain_move_out_loc
        iflot_idisnotNone:
            domain_quant+=[('lot_id','=',lot_id)]
        ifowner_idisnotNone:
            domain_quant+=[('owner_id','=',owner_id)]
            domain_move_in+=[('restrict_partner_id','=',owner_id)]
            domain_move_out+=[('restrict_partner_id','=',owner_id)]
        ifpackage_idisnotNone:
            domain_quant+=[('package_id','=',package_id)]
        ifdates_in_the_past:
            domain_move_in_done=list(domain_move_in)
            domain_move_out_done=list(domain_move_out)
        iffrom_date:
            date_date_expected_domain_from=[('date','>=',from_date)]
            domain_move_in+=date_date_expected_domain_from
            domain_move_out+=date_date_expected_domain_from
        ifto_date:
            date_date_expected_domain_to=[('date','<=',to_date)]
            domain_move_in+=date_date_expected_domain_to
            domain_move_out+=date_date_expected_domain_to

        Move=self.env['stock.move'].with_context(active_test=False)
        Quant=self.env['stock.quant'].with_context(active_test=False)
        domain_move_in_todo=[('state','in',('waiting','confirmed','assigned','partially_available'))]+domain_move_in
        domain_move_out_todo=[('state','in',('waiting','confirmed','assigned','partially_available'))]+domain_move_out
        moves_in_res=dict((item['product_id'][0],item['product_qty'])foriteminMove.read_group(domain_move_in_todo,['product_id','product_qty'],['product_id'],orderby='id'))
        moves_out_res=dict((item['product_id'][0],item['product_qty'])foriteminMove.read_group(domain_move_out_todo,['product_id','product_qty'],['product_id'],orderby='id'))
        quants_res=dict((item['product_id'][0],(item['quantity'],item['reserved_quantity']))foriteminQuant.read_group(domain_quant,['product_id','quantity','reserved_quantity'],['product_id'],orderby='id'))
        ifdates_in_the_past:
            #Calculatethemovesthatweredonebeforenowtocalculatebackintime(asmostquestionswillberecentones)
            domain_move_in_done=[('state','=','done'),('date','>',to_date)]+domain_move_in_done
            domain_move_out_done=[('state','=','done'),('date','>',to_date)]+domain_move_out_done
            moves_in_res_past=dict((item['product_id'][0],item['product_qty'])foriteminMove.read_group(domain_move_in_done,['product_id','product_qty'],['product_id'],orderby='id'))
            moves_out_res_past=dict((item['product_id'][0],item['product_qty'])foriteminMove.read_group(domain_move_out_done,['product_id','product_qty'],['product_id'],orderby='id'))

        res=dict()
        forproductinself.with_context(prefetch_fields=False):
            product_id=product.id
            ifnotproduct_id:
                res[product_id]=dict.fromkeys(
                    ['qty_available','free_qty','incoming_qty','outgoing_qty','virtual_available'],
                    0.0,
                )
                continue
            rounding=product.uom_id.rounding
            res[product_id]={}
            ifdates_in_the_past:
                qty_available=quants_res.get(product_id,[0.0])[0]-moves_in_res_past.get(product_id,0.0)+moves_out_res_past.get(product_id,0.0)
            else:
                qty_available=quants_res.get(product_id,[0.0])[0]
            reserved_quantity=quants_res.get(product_id,[False,0.0])[1]
            res[product_id]['qty_available']=float_round(qty_available,precision_rounding=rounding)
            res[product_id]['free_qty']=float_round(qty_available-reserved_quantity,precision_rounding=rounding)
            res[product_id]['incoming_qty']=float_round(moves_in_res.get(product_id,0.0),precision_rounding=rounding)
            res[product_id]['outgoing_qty']=float_round(moves_out_res.get(product_id,0.0),precision_rounding=rounding)
            res[product_id]['virtual_available']=float_round(
                qty_available+res[product_id]['incoming_qty']-res[product_id]['outgoing_qty'],
                precision_rounding=rounding)

        returnres

    defget_components(self):
        self.ensure_one()
        returnself.ids

    def_get_description(self,picking_type_id):
        """returnproductreceipt/delivery/pickingdescriptiondependingon
        pickingtypepassedasargument.
        """
        self.ensure_one()
        picking_code=picking_type_id.code
        description=self.descriptionorself.name
        ifpicking_code=='incoming':
            returnself.description_pickinginordescription
        ifpicking_code=='outgoing':
            returnself.description_pickingoutorself.name
        ifpicking_code=='internal':
            returnself.description_pickingordescription
        returndescription

    def_get_domain_locations(self):
        '''
        Parsesthecontextandreturnsalistoflocation_idsbasedonit.
        Itwillreturnallstocklocationswhennoparametersaregiven
        Possibleparametersareshop,warehouse,location,compute_child
        '''
        Warehouse=self.env['stock.warehouse']

        def_search_ids(model,values):
            ids=set()
            domain=[]
            foriteminvalues:
                ifisinstance(item,int):
                    ids.add(item)
                else:
                    domain=expression.OR([[(self.env[model]._rec_name,'ilike',item)],domain])
            ifdomain:
                ids|=set(self.env[model].search(domain).ids)
            returnids

        #Wemayreceivealocationorwarehousefromthecontext,eitherbyexplicit
        #pythoncodeorbytheuseofdummyfieldsinthesearchview.
        #Normalizethemintoalist.
        location=self.env.context.get('location')
        iflocationandnotisinstance(location,list):
            location=[location]
        warehouse=self.env.context.get('warehouse')
        ifwarehouseandnotisinstance(warehouse,list):
            warehouse=[warehouse]
        #filterbylocationand/orwarehouse
        ifwarehouse:
            w_ids=set(Warehouse.browse(_search_ids('stock.warehouse',warehouse)).mapped('view_location_id').ids)
            iflocation:
                l_ids=_search_ids('stock.location',location)
                location_ids=w_ids&l_ids
            else:
                location_ids=w_ids
        else:
            iflocation:
                location_ids=_search_ids('stock.location',location)
            else:
                location_ids=set(Warehouse.search([]).mapped('view_location_id').ids)

        returnself._get_domain_locations_new(location_ids,compute_child=self.env.context.get('compute_child',True))

    def_get_domain_locations_new(self,location_ids,company_id=False,compute_child=True):
        operator=compute_childand'child_of'or'in'
        domain=company_idand['&',('company_id','=',company_id)]or[]
        locations=self.env['stock.location'].browse(location_ids)
        #TDEFIXME:shouldmovethesupportofchild_of+auto_joindirectlyinexpression
        hierarchical_locations=locationsifoperator=='child_of'elselocations.browse()
        other_locations=locations-hierarchical_locations
        loc_domain=[]
        dest_loc_domain=[]
        #thisoptimizes[('location_id','child_of',hierarchical_locations.ids)]
        #byavoidingtheORMtosearchforchildrenlocationsandinjectinga
        #lotoflocationidsintothemainquery
        forlocationinhierarchical_locations:
            loc_domain=loc_domainand['|']+loc_domainorloc_domain
            loc_domain.append(('location_id.parent_path','=like',location.parent_path+'%'))
            dest_loc_domain=dest_loc_domainand['|']+dest_loc_domainordest_loc_domain
            dest_loc_domain.append(('location_dest_id.parent_path','=like',location.parent_path+'%'))
        ifother_locations:
            loc_domain=loc_domainand['|']+loc_domainorloc_domain
            loc_domain=loc_domain+[('location_id',operator,other_locations.ids)]
            dest_loc_domain=dest_loc_domainand['|']+dest_loc_domainordest_loc_domain
            dest_loc_domain=dest_loc_domain+[('location_dest_id',operator,other_locations.ids)]
        return(
            domain+loc_domain,
            domain+dest_loc_domain+['!']+loc_domainifloc_domainelsedomain+dest_loc_domain,
            domain+loc_domain+['!']+dest_loc_domainifdest_loc_domainelsedomain+loc_domain
        )

    def_search_qty_available(self,operator,value):
        #Intheveryspecificcasewewanttoretrieveproductswithstockavailable,weonlyneed
        #tousethequants,notthestockmoves.Therefore,webypasstheusual
        #'_search_product_quantity'methodandcall'_search_qty_available_new'instead.This
        #allowsbetterperformances.
        ifnot({'from_date','to_date'}&set(self.env.context.keys())):
            product_ids=self._search_qty_available_new(
                operator,value,self.env.context.get('lot_id'),self.env.context.get('owner_id'),
                self.env.context.get('package_id')
            )
            return[('id','in',product_ids)]
        returnself._search_product_quantity(operator,value,'qty_available')

    def_search_virtual_available(self,operator,value):
        #TDEFIXME:shouldprobablycleanthesearchmethods
        returnself._search_product_quantity(operator,value,'virtual_available')

    def_search_incoming_qty(self,operator,value):
        #TDEFIXME:shouldprobablycleanthesearchmethods
        returnself._search_product_quantity(operator,value,'incoming_qty')

    def_search_outgoing_qty(self,operator,value):
        #TDEFIXME:shouldprobablycleanthesearchmethods
        returnself._search_product_quantity(operator,value,'outgoing_qty')

    def_search_free_qty(self,operator,value):
        returnself._search_product_quantity(operator,value,'free_qty')

    def_search_product_quantity(self,operator,value,field):
        #TDEFIXME:shouldprobablycleanthesearchmethods
        #topreventsqlinjections
        iffieldnotin('qty_available','virtual_available','incoming_qty','outgoing_qty','free_qty'):
            raiseUserError(_('Invaliddomainleftoperand%s',field))
        ifoperatornotin('<','>','=','!=','<=','>='):
            raiseUserError(_('Invaliddomainoperator%s',operator))
        ifnotisinstance(value,(float,int)):
            raiseUserError(_("Invaliddomainrightoperand'%s'.ItmustbeoftypeInteger/Float",value))

        #TODO:Stilloptimizationpossiblewhensearchingvirtualquantities
        ids=[]
        #Orderthesearchon`id`topreventthedefaultorderontheproductnamewhichslows
        #downthesearchbecauseofthejoinonthetranslationtabletogetthetranslatednames.
        forproductinself.with_context(prefetch_fields=False).search([],order='id'):
            ifOPERATORS[operator](product[field],value):
                ids.append(product.id)
        return[('id','in',ids)]

    def_search_qty_available_new(self,operator,value,lot_id=False,owner_id=False,package_id=False):
        '''Optimizedmethodwhichdoesn'tsearchonstock.moves,onlyonstock.quants.'''
        ifoperatornotin('<','>','=','!=','<=','>='):
            raiseUserError(_('Invaliddomainoperator%s',operator))
        ifnotisinstance(value,(float,int)):
            raiseUserError(_("Invaliddomainrightoperand'%s'.ItmustbeoftypeInteger/Float",value))

        product_ids=set()
        domain_quant=self._get_domain_locations()[0]
        iflot_id:
            domain_quant.append(('lot_id','=',lot_id))
        ifowner_id:
            domain_quant.append(('owner_id','=',owner_id))
        ifpackage_id:
            domain_quant.append(('package_id','=',package_id))
        quants_groupby=self.env['stock.quant'].read_group(domain_quant,['product_id','quantity'],['product_id'],orderby='id')

        #checkifweneedincludezerovaluesinresult
        include_zero=(
            value<0.0andoperatorin('>','>=')or
            value>0.0andoperatorin('<','<=')or
            value==0.0andoperatorin('>=','<=','=')
        )

        processed_product_ids=set()
        forquantinquants_groupby:
            product_id=quant['product_id'][0]
            ifinclude_zero:
                processed_product_ids.add(product_id)
            ifOPERATORS[operator](quant['quantity'],value):
                product_ids.add(product_id)

        ifinclude_zero:
            products_without_quants_in_domain=self.env['product.product'].search([
                ('type','=','product'),
                ('id','notin',list(processed_product_ids))]
            )
            product_ids|=set(products_without_quants_in_domain.ids)
        returnlist(product_ids)

    def_compute_nbr_reordering_rules(self):
        read_group_res=self.env['stock.warehouse.orderpoint'].read_group(
            [('product_id','in',self.ids)],
            ['product_id','product_min_qty','product_max_qty'],
            ['product_id'])
        res={i:{}foriinself.ids}
        fordatainread_group_res:
            res[data['product_id'][0]]['nbr_reordering_rules']=int(data['product_id_count'])
            res[data['product_id'][0]]['reordering_min_qty']=data['product_min_qty']
            res[data['product_id'][0]]['reordering_max_qty']=data['product_max_qty']
        forproductinself:
            product_res=res.get(product.id)or{}
            product.nbr_reordering_rules=product_res.get('nbr_reordering_rules',0)
            product.reordering_min_qty=product_res.get('reordering_min_qty',0)
            product.reordering_max_qty=product_res.get('reordering_max_qty',0)

    @api.onchange('tracking')
    defonchange_tracking(self):
        products=self.filtered(lambdaself:self.trackingandself.tracking!='none')
        ifproducts:
            unassigned_quants=self.env['stock.quant'].search_count([('product_id','in',products.ids),('lot_id','=',False),('location_id.usage','=','internal')])
            ifunassigned_quants:
                return{
                    'warning':{
                        'title':_('Warning!'),
                        'message':_("Youhaveproduct(s)instockthathavenolot/serialnumber.Youcanassignlot/serialnumbersbydoinganinventoryadjustment.")}}

    @api.model
    defview_header_get(self,view_id,view_type):
        res=super(Product,self).view_header_get(view_id,view_type)
        ifnotresandself._context.get('active_id')andself._context.get('active_model')=='stock.location':
            return_(
                'Products:%(location)s',
                location=self.env['stock.location'].browse(self._context['active_id']).name,
            )
        returnres

    @api.model
    deffields_view_get(self,view_id=None,view_type='form',toolbar=False,submenu=False):
        res=super(Product,self).fields_view_get(view_id=view_id,view_type=view_type,toolbar=toolbar,submenu=submenu)
        ifself._context.get('location')andisinstance(self._context['location'],int):
            location=self.env['stock.location'].browse(self._context['location'])
            fields=res.get('fields')
            iffields:
                iflocation.usage=='supplier':
                    iffields.get('virtual_available'):
                        res['fields']['virtual_available']['string']=_('FutureReceipts')
                    iffields.get('qty_available'):
                        res['fields']['qty_available']['string']=_('ReceivedQty')
                eliflocation.usage=='internal':
                    iffields.get('virtual_available'):
                        res['fields']['virtual_available']['string']=_('ForecastedQuantity')
                eliflocation.usage=='customer':
                    iffields.get('virtual_available'):
                        res['fields']['virtual_available']['string']=_('FutureDeliveries')
                    iffields.get('qty_available'):
                        res['fields']['qty_available']['string']=_('DeliveredQty')
                eliflocation.usage=='inventory':
                    iffields.get('virtual_available'):
                        res['fields']['virtual_available']['string']=_('FutureP&L')
                    iffields.get('qty_available'):
                        res['fields']['qty_available']['string']=_('P&LQty')
                eliflocation.usage=='production':
                    iffields.get('virtual_available'):
                        res['fields']['virtual_available']['string']=_('FutureProductions')
                    iffields.get('qty_available'):
                        res['fields']['qty_available']['string']=_('ProducedQty')
        returnres

    defaction_view_orderpoints(self):
        action=self.env["ir.actions.actions"]._for_xml_id("stock.action_orderpoint")
        action['context']=literal_eval(action.get('context'))
        action['context'].pop('search_default_trigger',False)
        action['context'].update({
            'search_default_filter_not_snoozed':True,
        })
        ifselfandlen(self)==1:
            action['context'].update({
                'default_product_id':self.ids[0],
                'search_default_product_id':self.ids[0]
            })
        else:
            action['domain']=expression.AND([action.get('domain',[]),[('product_id','in',self.ids)]])
        returnaction

    defaction_view_routes(self):
        returnself.mapped('product_tmpl_id').action_view_routes()

    defaction_view_stock_move_lines(self):
        self.ensure_one()
        action=self.env["ir.actions.actions"]._for_xml_id("stock.stock_move_line_action")
        action['domain']=[('product_id','=',self.id)]
        returnaction

    defaction_view_related_putaway_rules(self):
        self.ensure_one()
        domain=[
            '|',
                ('product_id','=',self.id),
                ('category_id','=',self.product_tmpl_id.categ_id.id),
        ]
        returnself.env['product.template']._get_action_view_related_putaway_rules(domain)

    defaction_open_product_lot(self):
        self.ensure_one()
        action=self.env["ir.actions.actions"]._for_xml_id("stock.action_production_lot_form")
        action['domain']=[('product_id','=',self.id)]
        action['context']={
            'default_product_id':self.id,
            'set_product_readonly':True,
            'default_company_id':(self.company_idorself.env.company).id,
        }
        returnaction

    #Beawarethattheexactsamefunctionexistsinproduct.template
    defaction_open_quants(self):
        domain=[('product_id','in',self.ids)]
        hide_location=notself.user_has_groups('stock.group_stock_multi_locations')
        hide_lot=all(product.tracking=='none'forproductinself)
        self=self.with_context(
            hide_location=hide_location,hide_lot=hide_lot,
            no_at_date=True,search_default_on_hand=True,
        )

        #Ifuserhaverightstowriteonquant,wedefinetheviewaseditable.
        ifself.user_has_groups('stock.group_stock_manager'):
            self=self.with_context(inventory_mode=True)
            #Setdefaultlocationidifmultilocationsisinactive
            ifnotself.user_has_groups('stock.group_stock_multi_locations'):
                user_company=self.env.company
                warehouse=self.env['stock.warehouse'].search(
                    [('company_id','=',user_company.id)],limit=1
                )
                ifwarehouse:
                    self=self.with_context(default_location_id=warehouse.lot_stock_id.id)
        #Setdefaultproductidifquantsconcernonlyoneproduct
        iflen(self)==1:
            self=self.with_context(
                default_product_id=self.id,
                single_product=True
            )
        else:
            self=self.with_context(product_tmpl_ids=self.product_tmpl_id.ids)
        action=self.env['stock.quant']._get_quants_action(domain)
        action["name"]=_('UpdateQuantity')
        returnaction

    defaction_update_quantity_on_hand(self):
        returnself.product_tmpl_id.with_context(default_product_id=self.id,create=True).action_update_quantity_on_hand()

    defaction_product_forecast_report(self):
        self.ensure_one()
        action=self.env["ir.actions.actions"]._for_xml_id("stock.stock_replenishment_product_product_action")
        returnaction

    @api.model
    defget_theoretical_quantity(self,product_id,location_id,lot_id=None,package_id=None,owner_id=None,to_uom=None):
        product_id=self.env['product.product'].browse(product_id)
        product_id.check_access_rights('read')
        product_id.check_access_rule('read')

        location_id=self.env['stock.location'].browse(location_id)
        lot_id=self.env['stock.production.lot'].browse(lot_id)
        package_id=self.env['stock.quant.package'].browse(package_id)
        owner_id=self.env['res.partner'].browse(owner_id)
        to_uom=self.env['uom.uom'].browse(to_uom)
        quants=self.env['stock.quant']._gather(product_id,location_id,lot_id=lot_id,package_id=package_id,owner_id=owner_id,strict=True)
        iflot_id:
            quants=quants.filtered(lambdaq:q.lot_id==lot_id)
        theoretical_quantity=sum([quant.quantityforquantinquants])
        ifto_uomandproduct_id.uom_id!=to_uom:
            theoretical_quantity=product_id.uom_id._compute_quantity(theoretical_quantity,to_uom)
        returntheoretical_quantity

    defwrite(self,values):
        if'active'invalues:
            self.filtered(lambdap:p.active!=values['active']).with_context(active_test=False).orderpoint_ids.write({
                'active':values['active']
            })
        returnsuper().write(values)

    def_get_quantity_in_progress(self,location_ids=False,warehouse_ids=False):
        returndefaultdict(float),defaultdict(float)

    def_get_rules_from_location(self,location,route_ids=False,seen_rules=False):
        ifnotseen_rules:
            seen_rules=self.env['stock.rule']
        rule=self.env['procurement.group']._get_rule(self,location,{
            'route_ids':route_ids,
            'warehouse_id':location.get_warehouse()
        })
        ifruleinseen_rules:
            raiseUserError(_("Invalidrule'sconfiguration,thefollowingrulecausesanendlessloop:%s",rule.display_name))
        ifnotrule:
            returnseen_rules
        ifrule.procure_method=='make_to_stock'orrule.actionnotin('pull_push','pull'):
            returnseen_rules|rule
        else:
            returnself._get_rules_from_location(rule.location_src_id,seen_rules=seen_rules|rule)


    def_filter_to_unlink(self):
        domain=[('product_id','in',self.ids)]
        lines=self.env['stock.production.lot'].read_group(domain,['product_id'],['product_id'])
        linked_product_ids=[group['product_id'][0]forgroupinlines]
        returnsuper(Product,self-self.browse(linked_product_ids))._filter_to_unlink()

    @api.model
    def_count_returned_sn_products(self,sn_lot):
        return0


classProductTemplate(models.Model):
    _inherit='product.template'
    _check_company_auto=True

    responsible_id=fields.Many2one(
        'res.users',string='Responsible',default=lambdaself:self.env.uid,company_dependent=True,check_company=True,
        help="Thisuserwillberesponsibleofthenextactivitiesrelatedtologisticoperationsforthisproduct.")
    type=fields.Selection(selection_add=[
        ('product','StorableProduct')
    ],tracking=True,ondelete={'product':'setdefault'})
    property_stock_production=fields.Many2one(
        'stock.location',"ProductionLocation",
        company_dependent=True,check_company=True,domain="[('usage','=','production'),'|',('company_id','=',False),('company_id','=',allowed_company_ids[0])]",
        help="Thisstocklocationwillbeused,insteadofthedefaultone,asthesourcelocationforstockmovesgeneratedbymanufacturingorders.")
    property_stock_inventory=fields.Many2one(
        'stock.location',"InventoryLocation",
        company_dependent=True,check_company=True,domain="[('usage','=','inventory'),'|',('company_id','=',False),('company_id','=',allowed_company_ids[0])]",
        help="Thisstocklocationwillbeused,insteadofthedefaultone,asthesourcelocationforstockmovesgeneratedwhenyoudoaninventory.")
    sale_delay=fields.Float(
        'CustomerLeadTime',default=0,
        help="Deliveryleadtime,indays.It'sthenumberofdays,promisedtothecustomer,betweentheconfirmationofthesalesorderandthedelivery.")
    tracking=fields.Selection([
        ('serial','ByUniqueSerialNumber'),
        ('lot','ByLots'),
        ('none','NoTracking')],
        string="Tracking",required=True,default='none',
        compute='_compute_tracking',store=True,readonly=False,
        help="Ensurethetraceabilityofastorableproductinyourwarehouse.")
    description_picking=fields.Text('DescriptiononPicking',translate=True)
    description_pickingout=fields.Text('DescriptiononDeliveryOrders',translate=True)
    description_pickingin=fields.Text('DescriptiononReceptions',translate=True)
    qty_available=fields.Float(
        'QuantityOnHand',compute='_compute_quantities',search='_search_qty_available',
        compute_sudo=False,digits='ProductUnitofMeasure')
    virtual_available=fields.Float(
        'ForecastedQuantity',compute='_compute_quantities',search='_search_virtual_available',
        compute_sudo=False,digits='ProductUnitofMeasure')
    incoming_qty=fields.Float(
        'Incoming',compute='_compute_quantities',search='_search_incoming_qty',
        compute_sudo=False,digits='ProductUnitofMeasure')
    outgoing_qty=fields.Float(
        'Outgoing',compute='_compute_quantities',search='_search_outgoing_qty',
        compute_sudo=False,digits='ProductUnitofMeasure')
    #Thegoalofthesefieldsistobeabletoputsomekeysincontextfromsearchviewinorder
    #toinfluencecomputedfield.
    location_id=fields.Many2one('stock.location','Location',store=False)
    warehouse_id=fields.Many2one('stock.warehouse','Warehouse',store=False)
    has_available_route_ids=fields.Boolean(
        'Routescanbeselectedonthisproduct',compute='_compute_has_available_route_ids',
        default=lambdaself:self.env['stock.location.route'].search_count([('product_selectable','=',True)]))
    route_ids=fields.Many2many(
        'stock.location.route','stock_route_product','product_id','route_id','Routes',
        domain=[('product_selectable','=',True)],
        help="Dependingonthemodulesinstalled,thiswillallowyoutodefinetherouteoftheproduct:whetheritwillbebought,manufactured,replenishedonorder,etc.")
    nbr_reordering_rules=fields.Integer('ReorderingRules',
        compute='_compute_nbr_reordering_rules',compute_sudo=False)
    reordering_min_qty=fields.Float(
        compute='_compute_nbr_reordering_rules',compute_sudo=False)
    reordering_max_qty=fields.Float(
        compute='_compute_nbr_reordering_rules',compute_sudo=False)
    #TDEFIXME:seemsonlyvisibleinaview-removeme?
    route_from_categ_ids=fields.Many2many(
        relation="stock.location.route",string="CategoryRoutes",
        related='categ_id.total_route_ids',readonly=False,related_sudo=False)
    show_on_hand_qty_status_button=fields.Boolean(compute='_compute_show_on_hand_qty_status_button')

    @api.depends('type')
    def_compute_show_on_hand_qty_status_button(self):
        fortemplateinself:
            template.show_on_hand_qty_status_button=template.type=='product'

    @api.depends('type')
    def_compute_has_available_route_ids(self):
        self.has_available_route_ids=self.env['stock.location.route'].search_count([('product_selectable','=',True)])

    @api.depends(
        'product_variant_ids',
        'product_variant_ids.stock_move_ids.product_qty',
        'product_variant_ids.stock_move_ids.state',
    )
    @api.depends_context('company','location','warehouse')
    def_compute_quantities(self):
        res=self._compute_quantities_dict()
        fortemplateinself:
            template.qty_available=res[template.id]['qty_available']
            template.virtual_available=res[template.id]['virtual_available']
            template.incoming_qty=res[template.id]['incoming_qty']
            template.outgoing_qty=res[template.id]['outgoing_qty']

    def_product_available(self,name,arg):
        returnself._compute_quantities_dict()

    def_compute_quantities_dict(self):
        #TDEFIXME:whynotusingdirectlythefunctionfields?
        variants_available=self.mapped('product_variant_ids')._product_available()
        prod_available={}
        fortemplateinself:
            qty_available=0
            virtual_available=0
            incoming_qty=0
            outgoing_qty=0
            forpintemplate.product_variant_ids:
                qty_available+=variants_available[p.id]["qty_available"]
                virtual_available+=variants_available[p.id]["virtual_available"]
                incoming_qty+=variants_available[p.id]["incoming_qty"]
                outgoing_qty+=variants_available[p.id]["outgoing_qty"]
            prod_available[template.id]={
                "qty_available":qty_available,
                "virtual_available":virtual_available,
                "incoming_qty":incoming_qty,
                "outgoing_qty":outgoing_qty,
            }
        returnprod_available

    @api.depends('type')
    def_compute_tracking(self):
        self.filtered(
            lambdat:nott.trackingort.typein('consu','service')andt.tracking!='none'
        ).tracking='none'

    @api.model
    def_get_action_view_related_putaway_rules(self,domain):
        return{
            'name':_('PutawayRules'),
            'type':'ir.actions.act_window',
            'res_model':'stock.putaway.rule',
            'view_mode':'list',
            'domain':domain,
        }

    def_search_qty_available(self,operator,value):
        domain=[('qty_available',operator,value)]
        product_variant_ids=self.env['product.product'].search(domain)
        return[('product_variant_ids','in',product_variant_ids.ids)]

    def_search_virtual_available(self,operator,value):
        domain=[('virtual_available',operator,value)]
        product_variant_ids=self.env['product.product'].search(domain)
        return[('product_variant_ids','in',product_variant_ids.ids)]

    def_search_incoming_qty(self,operator,value):
        domain=[('incoming_qty',operator,value)]
        product_variant_ids=self.env['product.product'].search(domain)
        return[('product_variant_ids','in',product_variant_ids.ids)]

    def_search_outgoing_qty(self,operator,value):
        domain=[('outgoing_qty',operator,value)]
        product_variant_ids=self.env['product.product'].search(domain)
        return[('product_variant_ids','in',product_variant_ids.ids)]

    def_compute_nbr_reordering_rules(self):
        res={k:{'nbr_reordering_rules':0,'reordering_min_qty':0,'reordering_max_qty':0}forkinself.ids}
        product_data=self.env['stock.warehouse.orderpoint'].read_group([('product_id.product_tmpl_id','in',self.ids)],['product_id','product_min_qty','product_max_qty'],['product_id'])
        fordatainproduct_data:
            product=self.env['product.product'].browse([data['product_id'][0]])
            product_tmpl_id=product.product_tmpl_id.id
            res[product_tmpl_id]['nbr_reordering_rules']+=int(data['product_id_count'])
            res[product_tmpl_id]['reordering_min_qty']=data['product_min_qty']
            res[product_tmpl_id]['reordering_max_qty']=data['product_max_qty']
        fortemplateinself:
            ifnottemplate.id:
                template.nbr_reordering_rules=0
                template.reordering_min_qty=0
                template.reordering_max_qty=0
                continue
            template.nbr_reordering_rules=res[template.id]['nbr_reordering_rules']
            template.reordering_min_qty=res[template.id]['reordering_min_qty']
            template.reordering_max_qty=res[template.id]['reordering_max_qty']

    @api.onchange('tracking')
    defonchange_tracking(self):
        returnself.mapped('product_variant_ids').onchange_tracking()

    @api.onchange('type')
    def_onchange_type(self):
        res=super(ProductTemplate,self)._onchange_type()or{}

        #Returnawarningwhentryingtochangetheproducttype
        ifself.idsandself.product_variant_ids.idsandself.env['stock.move.line'].sudo().search_count([
            ('product_id','in',self.product_variant_ids.ids),('state','!=','cancel')
        ]):
            res['warning']={
                'title':_('Warning!'),
                'message':_(
                    'Thisproducthasbeenusedinatleastoneinventorymovement.'
                    'ItisnotadvisedtochangetheProductTypesinceitcanleadtoinconsistencies.'
                    'Abettersolutioncouldbetoarchivetheproductandcreateanewoneinstead.'
                )
            }
        returnres

    defwrite(self,vals):
        if'company_id'invalsandvals['company_id']:
            products_changing_company=self.filtered(lambdaproduct:product.company_id.id!=vals['company_id'])
            ifproducts_changing_company:
                move=self.env['stock.move'].sudo().search([
                    ('product_id','in',products_changing_company.product_variant_ids.ids),
                    ('company_id','notin',[vals['company_id'],False]),
                ],order=None,limit=1)
                ifmove:
                    raiseUserError(_("Thisproduct'scompanycannotbechangedaslongastherearestockmovesofitbelongingtoanothercompany."))

                #Forbidchangingaproduct'scompanywhenquant(s)existinanothercompany.
                quant=self.env['stock.quant'].sudo().search([
                    ('product_id','in',products_changing_company.product_variant_ids.ids),
                    ('company_id','notin',[vals['company_id'],False]),
                    ('quantity','!=',0),
                ],order=None,limit=1)
                ifquant:
                    raiseUserError(_("Thisproduct'scompanycannotbechangedaslongastherearequantitiesofitbelongingtoanothercompany."))

        if'uom_id'invals:
            new_uom=self.env['uom.uom'].browse(vals['uom_id'])
            updated=self.filtered(lambdatemplate:template.uom_id!=new_uom)
            done_moves=self.env['stock.move'].sudo().search([('product_id','in',updated.with_context(active_test=False).mapped('product_variant_ids').ids)],limit=1)
            ifdone_moves:
                raiseUserError(_("Youcannotchangetheunitofmeasureastherearealreadystockmovesforthisproduct.Ifyouwanttochangetheunitofmeasure,youshouldratherarchivethisproductandcreateanewone."))
        if'type'invalsandvals['type']!='product'andsum(self.mapped('nbr_reordering_rules'))!=0:
            raiseUserError(_('Youstillhavesomeactivereorderingrulesonthisproduct.Pleasearchiveordeletethemfirst.'))
        ifany('type'invalsandvals['type']!=prod_tmpl.typeforprod_tmplinself):
            existing_done_move_lines=self.env['stock.move.line'].sudo().search([
                ('product_id','in',self.mapped('product_variant_ids').ids),
                ('state','=','done'),
            ],limit=1)
            ifexisting_done_move_lines:
                raiseUserError(_("Youcannotchangethetypeofaproductthatwasalreadyused."))
            existing_reserved_move_lines=self.env['stock.move.line'].search([
                ('product_id','in',self.mapped('product_variant_ids').ids),
                ('state','in',['partially_available','assigned']),
            ])
            ifexisting_reserved_move_lines:
                raiseUserError(_("Youcannotchangethetypeofaproductthatiscurrentlyreservedonastockmove.Ifyouneedtochangethetype,youshouldfirstunreservethestockmove."))
        if'type'invalsandvals['type']!='product'andany(p.type=='product'andnotfloat_is_zero(p.qty_available,precision_rounding=p.uom_id.rounding)forpinself):
            raiseUserError(_("Availablequantityshouldbesettozerobeforechangingtype"))
        returnsuper(ProductTemplate,self).write(vals)

    #Beawarethattheexactsamefunctionexistsinproduct.product
    defaction_open_quants(self):
        returnself.product_variant_ids.filtered(lambdap:p.activeorp.qty_available!=0).action_open_quants()

    defaction_update_quantity_on_hand(self):
        advanced_option_groups=[
            'stock.group_stock_multi_locations',
            'stock.group_production_lot',
            'stock.group_tracking_owner',
            'product.group_stock_packaging'
        ]
        if(self.env.user.user_has_groups(','.join(advanced_option_groups))):
            returnself.action_open_quants()
        else:
            default_product_id=self.env.context.get('default_product_id',len(self.product_variant_ids)==1andself.product_variant_id.id)
            action=self.env["ir.actions.actions"]._for_xml_id("stock.action_change_product_quantity")
            action['context']=dict(
                self.env.context,
                default_product_id=default_product_id,
                default_product_tmpl_id=self.id
            )
            returnaction

    defaction_view_related_putaway_rules(self):
        self.ensure_one()
        domain=[
            '|',
                ('product_id.product_tmpl_id','=',self.id),
                ('category_id','=',self.categ_id.id),
        ]
        returnself._get_action_view_related_putaway_rules(domain)

    defaction_view_orderpoints(self):
        returnself.product_variant_ids.action_view_orderpoints()

    defaction_view_stock_move_lines(self):
        self.ensure_one()
        action=self.env["ir.actions.actions"]._for_xml_id("stock.stock_move_line_action")
        action['domain']=[('product_id.product_tmpl_id','in',self.ids)]
        returnaction

    defaction_open_product_lot(self):
        self.ensure_one()
        action=self.env["ir.actions.actions"]._for_xml_id("stock.action_production_lot_form")
        action['domain']=[('product_id.product_tmpl_id','=',self.id)]
        action['context']={
            'default_product_tmpl_id':self.id,
            'default_company_id':(self.company_idorself.env.company).id,
        }
        ifself.product_variant_count==1:
            action['context'].update({
                'default_product_id':self.product_variant_id.id,
            })
        returnaction

    defaction_open_routes_diagram(self):
        products=False
        ifself.env.context.get('default_product_id'):
            products=self.env['product.product'].browse(self.env.context['default_product_id'])
        ifnotproductsandself.env.context.get('default_product_tmpl_id'):
            products=self.env['product.template'].browse(self.env.context['default_product_tmpl_id']).product_variant_ids
        ifnotself.user_has_groups('stock.group_stock_multi_warehouses')andlen(products)==1:
            company=products.company_idorself.env.company
            warehouse=self.env['stock.warehouse'].search([('company_id','=',company.id)],limit=1)
            returnself.env.ref('stock.action_report_stock_rule').report_action(None,data={
                'product_id':products.id,
                'warehouse_ids':warehouse.ids,
            },config=False)
        action=self.env["ir.actions.actions"]._for_xml_id("stock.action_stock_rules_report")
        action['context']=self.env.context
        returnaction

    defaction_product_tmpl_forecast_report(self):
        self.ensure_one()
        action=self.env["ir.actions.actions"]._for_xml_id('stock.stock_replenishment_product_product_action')
        returnaction

classProductCategory(models.Model):
    _inherit='product.category'

    route_ids=fields.Many2many(
        'stock.location.route','stock_location_route_categ','categ_id','route_id','Routes',
        domain=[('product_categ_selectable','=',True)])
    removal_strategy_id=fields.Many2one(
        'product.removal','ForceRemovalStrategy',
        help="Setaspecificremovalstrategythatwillbeusedregardlessofthesourcelocationforthisproductcategory")
    total_route_ids=fields.Many2many(
        'stock.location.route',string='Totalroutes',compute='_compute_total_route_ids',
        readonly=True)
    putaway_rule_ids=fields.One2many('stock.putaway.rule','category_id','PutawayRules')

    def_compute_total_route_ids(self):
        forcategoryinself:
            base_cat=category
            routes=category.route_ids
            whilebase_cat.parent_id:
                base_cat=base_cat.parent_id
                routes|=base_cat.route_ids
            category.total_route_ids=routes


classUoM(models.Model):
    _inherit='uom.uom'

    defwrite(self,values):
        #Userscannotupdatethefactorifopenstockmovesarebasedonit
        if'factor'invaluesor'factor_inv'invaluesor'category_id'invalues:
            changed=self.filtered(
                lambdau:any(u[f]!=values[f]iffinvalueselseFalse
                              forfin{'factor','factor_inv'}))+self.filtered(
                lambdau:any(u[f].id!=int(values[f])iffinvalueselseFalse
                              forfin{'category_id'}))
            ifchanged:
                error_msg=_(
                    "Youcannotchangetheratioofthisunitofmeasure"
                    "assomeproductswiththisUoMhavealreadybeenmoved"
                    "orarecurrentlyreserved."
                )
                ifself.env['stock.move'].sudo().search_count([
                    ('product_uom','in',changed.ids),
                    ('state','notin',('cancel','done'))
                ]):
                    raiseUserError(error_msg)
                ifself.env['stock.move.line'].sudo().search_count([
                    ('product_uom_id','in',changed.ids),
                    ('state','notin',('cancel','done')),
                ]):
                    raiseUserError(error_msg)
                ifself.env['stock.quant'].sudo().search_count([
                    ('product_id.product_tmpl_id.uom_id','in',changed.ids),
                    ('quantity','!=',0),
                ]):
                    raiseUserError(error_msg)
        returnsuper(UoM,self).write(values)

    def_adjust_uom_quantities(self,qty,quant_uom):
        """ThismethodadjustthequantitiesofaprocurementifitsUoMisn'tthesame
        astheoneofthequantandtheparameter'propagate_uom'isnotset.
        """
        procurement_uom=self
        computed_qty=qty
        get_param=self.env['ir.config_parameter'].sudo().get_param
        ifget_param('stock.propagate_uom')!='1':
            computed_qty=self._compute_quantity(qty,quant_uom,rounding_method='HALF-UP')
            procurement_uom=quant_uom
        else:
            computed_qty=self._compute_quantity(qty,procurement_uom,rounding_method='HALF-UP')
        return(computed_qty,procurement_uom)

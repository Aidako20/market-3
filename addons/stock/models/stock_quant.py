#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

importlogging

frompsycopg2importError,OperationalError

fromflectraimport_,api,fields,models
fromflectra.exceptionsimportRedirectWarning,UserError,ValidationError
fromflectra.osvimportexpression
fromflectra.tools.float_utilsimportfloat_compare,float_is_zero,float_round

_logger=logging.getLogger(__name__)


classStockQuant(models.Model):
    _name='stock.quant'
    _description='Quants'
    _rec_name='product_id'

    def_domain_location_id(self):
        ifnotself._is_inventory_mode():
            return
        return[('usage','in',['internal','transit'])]

    def_domain_lot_id(self):
        ifnotself._is_inventory_mode():
            return
        domain=[
            "'|'",
                "('company_id','=',company_id)",
                "('company_id','=',False)"
        ]
        ifself.env.context.get('active_model')=='product.product':
            domain.insert(0,"('product_id','=',%s)"%self.env.context.get('active_id'))
        elifself.env.context.get('active_model')=='product.template':
            product_template=self.env['product.template'].browse(self.env.context.get('active_id'))
            ifproduct_template.exists():
                domain.insert(0,"('product_id','in',%s)"%product_template.product_variant_ids.ids)
        else:
            domain.insert(0,"('product_id','=',product_id)")
        return'['+','.join(domain)+']'

    def_domain_product_id(self):
        ifnotself._is_inventory_mode():
            return
        domain=[('type','=','product')]
        ifself.env.context.get('product_tmpl_ids')orself.env.context.get('product_tmpl_id'):
            products=self.env.context.get('product_tmpl_ids',[])+[self.env.context.get('product_tmpl_id',0)]
            domain=expression.AND([domain,[('product_tmpl_id','in',products)]])
        returndomain

    product_id=fields.Many2one(
        'product.product','Product',
        domain=lambdaself:self._domain_product_id(),
        ondelete='restrict',readonly=True,required=True,index=True,check_company=True)
    product_tmpl_id=fields.Many2one(
        'product.template',string='ProductTemplate',
        related='product_id.product_tmpl_id',readonly=True)
    product_uom_id=fields.Many2one(
        'uom.uom','UnitofMeasure',
        readonly=True,related='product_id.uom_id')
    company_id=fields.Many2one(related='location_id.company_id',string='Company',store=True,readonly=True)
    location_id=fields.Many2one(
        'stock.location','Location',
        domain=lambdaself:self._domain_location_id(),
        auto_join=True,ondelete='restrict',readonly=True,required=True,index=True,check_company=True)
    lot_id=fields.Many2one(
        'stock.production.lot','Lot/SerialNumber',index=True,
        ondelete='restrict',readonly=True,check_company=True,
        domain=lambdaself:self._domain_lot_id())
    package_id=fields.Many2one(
        'stock.quant.package','Package',
        domain="[('location_id','=',location_id)]",
        help='Thepackagecontainingthisquant',readonly=True,ondelete='restrict',check_company=True)
    owner_id=fields.Many2one(
        'res.partner','Owner',
        help='Thisistheownerofthequant',readonly=True,check_company=True)
    quantity=fields.Float(
        'Quantity',
        help='Quantityofproductsinthisquant,inthedefaultunitofmeasureoftheproduct',
        readonly=True)
    inventory_quantity=fields.Float(
        'InventoriedQuantity',compute='_compute_inventory_quantity',
        inverse='_set_inventory_quantity',groups='stock.group_stock_manager')
    reserved_quantity=fields.Float(
        'ReservedQuantity',
        default=0.0,
        help='Quantityofreservedproductsinthisquant,inthedefaultunitofmeasureoftheproduct',
        readonly=True,required=True)
    available_quantity=fields.Float(
        'AvailableQuantity',
        help="Onhandquantitywhichhasn'tbeenreservedonatransfer,inthedefaultunitofmeasureoftheproduct",
        compute='_compute_available_quantity')
    in_date=fields.Datetime('IncomingDate',readonly=True)
    tracking=fields.Selection(related='product_id.tracking',readonly=True)
    on_hand=fields.Boolean('OnHand',store=False,search='_search_on_hand')

    @api.depends('quantity','reserved_quantity')
    def_compute_available_quantity(self):
        forquantinself:
            quant.available_quantity=quant.quantity-quant.reserved_quantity

    @api.depends('quantity')
    def_compute_inventory_quantity(self):
        ifnotself._is_inventory_mode():
            self.inventory_quantity=0
            return
        forquantinself:
            quant.inventory_quantity=quant.quantity

    def_set_inventory_quantity(self):
        """Inversemethodtocreatestockmovewhen`inventory_quantity`isset
        (`inventory_quantity`isonlyaccessibleininventorymode).
        """
        ifnotself._is_inventory_mode():
            return
        forquantinself:
            #Getthequantitytocreateamovefor.
            rounding=quant.product_id.uom_id.rounding
            diff=float_round(quant.inventory_quantity-quant.quantity,precision_rounding=rounding)
            diff_float_compared=float_compare(diff,0,precision_rounding=rounding)
            #Createandvaidateamovesothatthequantmatchesits`inventory_quantity`.
            ifdiff_float_compared==0:
                continue
            elifdiff_float_compared>0:
                move_vals=quant._get_inventory_move_values(diff,quant.product_id.with_company(quant.company_id).property_stock_inventory,quant.location_id)
            else:
                move_vals=quant._get_inventory_move_values(-diff,quant.location_id,quant.product_id.with_company(quant.company_id).property_stock_inventory,out=True)
            move=quant.env['stock.move'].with_context(inventory_mode=False).create(move_vals)
            move._action_done()

    def_search_on_hand(self,operator,value):
        """Handlethe"on_hand"filter,indirectlycalling`_get_domain_locations`."""
        ifoperatornotin['=','!=']ornotisinstance(value,bool):
            raiseUserError(_('Operationnotsupported'))
        domain_loc=self.env['product.product'].with_context(compute_child=False)._get_domain_locations()[0]
        location_ids=self.env['stock.location']._search([('id','child_of',domain_loc[0][2])])
        quant_ids=self.env['stock.quant']._search([('location_id','in',location_ids)])
        if(operator=='!='andvalueisTrue)or(operator=='='andvalueisFalse):
            domain_operator='notin'
        else:
            domain_operator='in'
        return[('id',domain_operator,quant_ids)]

    @api.model
    defcreate(self,vals):
        """Overridetohandlethe"inventorymode"andcreateaquantas
        superusertheconditionsaremet.
        """
        ifself._is_inventory_mode()and'inventory_quantity'invals:
            allowed_fields=self._get_inventory_fields_create()
            ifany(fieldforfieldinvals.keys()iffieldnotinallowed_fields):
                raiseUserError(_("Quant'screationisrestricted,youcan'tdothisoperation."))
            inventory_quantity=vals.pop('inventory_quantity')

            #Createanemptyquantorwriteonasimilarone.
            product=self.env['product.product'].browse(vals['product_id'])
            location=self.env['stock.location'].browse(vals['location_id'])
            lot_id=self.env['stock.production.lot'].browse(vals.get('lot_id'))
            package_id=self.env['stock.quant.package'].browse(vals.get('package_id'))
            owner_id=self.env['res.partner'].browse(vals.get('owner_id'))
            quant=self._gather(product,location,lot_id=lot_id,package_id=package_id,owner_id=owner_id,strict=True)
            ifquant:
                quant=quant[0]
            else:
                quant=self.sudo().create(vals)
            #Setthe`inventory_quantity`fieldtocreatethenecessarymove.
            quant.inventory_quantity=inventory_quantity
            returnquant
        res=super(StockQuant,self).create(vals)
        ifself._is_inventory_mode():
            res._check_company()
        returnres

    @api.model
    defread_group(self,domain,fields,groupby,offset=0,limit=None,orderby=False,lazy=True):
        """Overridetosetthe`inventory_quantity`fieldifwe'rein"inventorymode"aswell
        astocomputethesumofthe`available_quantity`field.
        """
        if'available_quantity'infields:
            if'quantity'notinfields:
                fields.append('quantity')
            if'reserved_quantity'notinfields:
                fields.append('reserved_quantity')
        result=super(StockQuant,self).read_group(domain,fields,groupby,offset=offset,limit=limit,orderby=orderby,lazy=lazy)
        forgroupinresult:
            ifself._is_inventory_mode():
                group['inventory_quantity']=group.get('quantity',0)
            if'available_quantity'infields:
                group['available_quantity']=group['quantity']-group['reserved_quantity']
        returnresult

    defwrite(self,vals):
        """Overridetohandlethe"inventorymode"andcreatetheinventorymove."""
        allowed_fields=self._get_inventory_fields_write()
        ifself._is_inventory_mode()andany(fieldforfieldinallowed_fieldsiffieldinvals.keys()):
            ifany(quant.location_id.usage=='inventory'forquantinself):
                #Donothingwhenusertriestomodifymanuallyainventoryloss
                return
            ifany(fieldforfieldinvals.keys()iffieldnotinallowed_fields):
                raiseUserError(_("Quant'seditingisrestricted,youcan'tdothisoperation."))
            self=self.sudo()
            returnsuper(StockQuant,self).write(vals)
        returnsuper(StockQuant,self).write(vals)

    defunlink(self):
        ifnotself.env.is_superuser():
            #normallywewouldallowanyuserwithpermissiontounlink,butinventory_quantitycanonlybesetbystock_manager
            ifnotself.user_has_groups('stock.group_stock_manager'):
                raiseUserError(_("Quantsareauto-deletedwhenappropriate.Ifyoumustmanuallydeletethem,pleaseaskastockmanagertodoit."))
            self=self.with_context(inventory_mode=True)
            self.inventory_quantity=0
        returnsuper().unlink()

    defaction_view_stock_moves(self):
        self.ensure_one()
        action=self.env["ir.actions.actions"]._for_xml_id("stock.stock_move_line_action")
        action['domain']=[
            ('product_id','=',self.product_id.id),
            '|',
                ('location_id','=',self.location_id.id),
                ('location_dest_id','=',self.location_id.id),
            ('lot_id','=',self.lot_id.id),
            '|',
                ('package_id','=',self.package_id.id),
                ('result_package_id','=',self.package_id.id),
        ]
        returnaction

    @api.model
    defaction_view_quants(self):
        self=self.with_context(search_default_internal_loc=1)
        ifnotself.user_has_groups('stock.group_stock_multi_locations'):
            company_user=self.env.company
            warehouse=self.env['stock.warehouse'].search([('company_id','=',company_user.id)],limit=1)
            ifwarehouse:
                self=self.with_context(default_location_id=warehouse.lot_stock_id.id)

        #Ifuserhaverightstowriteonquant,wesetquantsininventorymode.
        ifself.user_has_groups('stock.group_stock_manager'):
            self=self.with_context(inventory_mode=True)
        returnself._get_quants_action(extend=True)

    @api.constrains('product_id')
    defcheck_product_id(self):
        ifany(elem.product_id.type!='product'foreleminself):
            raiseValidationError(_('Quantscannotbecreatedforconsumablesorservices.'))

    @api.constrains('quantity')
    defcheck_quantity(self):
        forquantinself:
            ifquant.location_id.usage!='inventory'andquant.lot_idandquant.product_id.tracking=='serial'\
                    andfloat_compare(abs(quant.quantity),1,precision_rounding=quant.product_uom_id.rounding)>0:
                raiseValidationError(_('Theserialnumberhasalreadybeenassigned:\nProduct:%s,SerialNumber:%s')%(quant.product_id.display_name,quant.lot_id.name))

    @api.constrains('location_id')
    defcheck_location_id(self):
        forquantinself:
            ifquant.location_id.usage=='view':
                raiseValidationError(_('Youcannottakeproductsfromordeliverproductstoalocationoftype"view"(%s).')%quant.location_id.name)

    @api.model
    def_get_removal_strategy(self,product_id,location_id):
        ifproduct_id.categ_id.removal_strategy_id:
            returnproduct_id.categ_id.removal_strategy_id.method
        loc=location_id
        whileloc:
            ifloc.removal_strategy_id:
                returnloc.removal_strategy_id.method
            loc=loc.location_id
        return'fifo'

    @api.model
    def_get_removal_strategy_order(self,removal_strategy):
        ifremoval_strategy=='fifo':
            return'in_dateASCNULLSFIRST,id'
        elifremoval_strategy=='lifo':
            return'in_dateDESCNULLSLAST,iddesc'
        raiseUserError(_('Removalstrategy%snotimplemented.')%(removal_strategy,))

    def_gather(self,product_id,location_id,lot_id=None,package_id=None,owner_id=None,strict=False):
        self.env['stock.quant'].flush(['location_id','owner_id','package_id','lot_id','product_id'])
        self.env['product.product'].flush(['virtual_available'])
        removal_strategy=self._get_removal_strategy(product_id,location_id)
        removal_strategy_order=self._get_removal_strategy_order(removal_strategy)
        domain=[
            ('product_id','=',product_id.id),
        ]
        ifnotstrict:
            iflot_id:
                domain=expression.AND([['|',('lot_id','=',lot_id.id),('lot_id','=',False)],domain])
            ifpackage_id:
                domain=expression.AND([[('package_id','=',package_id.id)],domain])
            ifowner_id:
                domain=expression.AND([[('owner_id','=',owner_id.id)],domain])
            domain=expression.AND([[('location_id','child_of',location_id.id)],domain])
        else:
            domain=expression.AND([['|',('lot_id','=',lot_id.id),('lot_id','=',False)]iflot_idelse[('lot_id','=',False)],domain])
            domain=expression.AND([[('package_id','=',package_idandpackage_id.idorFalse)],domain])
            domain=expression.AND([[('owner_id','=',owner_idandowner_id.idorFalse)],domain])
            domain=expression.AND([[('location_id','=',location_id.id)],domain])

        #Copycodeof_searchforspecialNULLSFIRST/LASTorder
        self.check_access_rights('read')
        query=self._where_calc(domain)
        self._apply_ir_rules(query,'read')
        from_clause,where_clause,where_clause_params=query.get_sql()
        where_str=where_clauseand("WHERE%s"%where_clause)or''
        query_str='SELECT"%s".idFROM'%self._table+from_clause+where_str+"ORDERBY"+removal_strategy_order
        self._cr.execute(query_str,where_clause_params)
        res=self._cr.fetchall()
        #Nouniquifylistnecessaryasauto_joinisnotappliedanyways...
        quants=self.browse([x[0]forxinres])
        quants=quants.sorted(lambdaq:notq.lot_id)
        returnquants

    @api.model
    def_get_available_quantity(self,product_id,location_id,lot_id=None,package_id=None,owner_id=None,strict=False,allow_negative=False):
        """Returntheavailablequantity,i.e.thesumof`quantity`minusthesumof
        `reserved_quantity`,forthesetofquantssharingthecombinationof`product_id,
        location_id`if`strict`issettoFalseorsharingthe*exactsamecharacteristics*
        otherwise.
        Thismethodiscalledinthefollowingusecases:
            -whenastockmovechecksitsavailability
            -whenastockmoveactuallyassign
            -wheneditingamoveline,tocheckifthenewvalueisforcedornot
            -whenvalidatingamovelinewithsomeforcedvaluesandhavetopotentiallyunlinkan
              equivalentmovelineinanotherpicking
        Inthetwofirstusecases,`strict`shouldbesetto`False`,aswedon'tknowwhatexact
        quantswe'llreserve,andthecharacteristicsaremeaninglessinthiscontext.
        Inthelastones,`strict`shouldbesetto`True`,asweworkonaspecificsetof
        characteristics.

        :return:availablequantityasafloat
        """
        self=self.sudo()
        quants=self._gather(product_id,location_id,lot_id=lot_id,package_id=package_id,owner_id=owner_id,strict=strict)
        rounding=product_id.uom_id.rounding
        ifproduct_id.tracking=='none':
            available_quantity=sum(quants.mapped('quantity'))-sum(quants.mapped('reserved_quantity'))
            ifallow_negative:
                returnavailable_quantity
            else:
                returnavailable_quantityiffloat_compare(available_quantity,0.0,precision_rounding=rounding)>=0.0else0.0
        else:
            availaible_quantities={lot_id:0.0forlot_idinlist(set(quants.mapped('lot_id')))+['untracked']}
            forquantinquants:
                ifnotquant.lot_id:
                    availaible_quantities['untracked']+=quant.quantity-quant.reserved_quantity
                else:
                    availaible_quantities[quant.lot_id]+=quant.quantity-quant.reserved_quantity
            ifallow_negative:
                returnsum(availaible_quantities.values())
            else:
                returnsum([available_quantityforavailable_quantityinavailaible_quantities.values()iffloat_compare(available_quantity,0,precision_rounding=rounding)>0])

    @api.onchange('location_id','product_id','lot_id','package_id','owner_id')
    def_onchange_location_or_product_id(self):
        vals={}

        #Oncethenewlineiscomplete,fetchthenewtheoreticalvalues.
        ifself.product_idandself.location_id:
            #Sanitycheckifalothasbeenset.
            ifself.lot_id:
                ifself.tracking=='none'orself.product_id!=self.lot_id.product_id:
                    vals['lot_id']=None

            quants=self._gather(self.product_id,self.location_id,lot_id=self.lot_id,package_id=self.package_id,owner_id=self.owner_id,strict=True)
            reserved_quantity=sum(quants.mapped('reserved_quantity'))
            quantity=sum(quants.mapped('quantity'))

            vals['reserved_quantity']=reserved_quantity
            #Update`quantity`onlyiftheusermanuallyupdated`inventory_quantity`.
            iffloat_compare(self.quantity,self.inventory_quantity,precision_rounding=self.product_uom_id.rounding)==0:
                vals['quantity']=quantity
            #Specialcase:directlysetthequantitytooneforserialnumbers,
            #it'lltrigger`inventory_quantity`compute.
            ifself.lot_idandself.tracking=='serial':
                vals['quantity']=1

        ifvals:
            self.update(vals)

    @api.onchange('inventory_quantity')
    def_onchange_inventory_quantity(self):
        ifself.location_idandself.location_id.usage=='inventory':
            warning={
                'title':_('Youcannotmodifyinventorylossquantity'),
                'message':_(
                    'EditingquantitiesinanInventoryAdjustmentlocationisforbidden,'
                    'thoselocationsareusedascounterpartwhencorrectingthequantities.'
                )
            }
            return{'warning':warning}

    @api.model
    def_update_available_quantity(self,product_id,location_id,quantity,lot_id=None,package_id=None,owner_id=None,in_date=None):
        """Increaseordecrease`reserved_quantity`ofasetofquantsforagivensetof
        product_id/location_id/lot_id/package_id/owner_id.

        :paramproduct_id:
        :paramlocation_id:
        :paramquantity:
        :paramlot_id:
        :parampackage_id:
        :paramowner_id:
        :paramdatetimein_date:Shouldonlybepassedwhencallstothismethodaredonein
                                 ordertomoveaquant.Whencreatingatrackedquant,the
                                 currentdatetimewillbeused.
        :return:tuple(available_quantity,in_dateasadatetime)
        """
        self=self.sudo()
        quants=self._gather(product_id,location_id,lot_id=lot_id,package_id=package_id,owner_id=owner_id,strict=True)
        iflot_idandquantity>0:
            quants=quants.filtered(lambdaq:q.lot_id)

        iflocation_id.should_bypass_reservation():
            incoming_dates=[]
        else:
            incoming_dates=[quant.in_dateforquantinquantsifquant.in_dateand
                              float_compare(quant.quantity,0,precision_rounding=quant.product_uom_id.rounding)>0]
        ifin_date:
            incoming_dates+=[in_date]
        #Ifmultipleincomingdatesareavailableforagivenlot_id/package_id/owner_id,we
        #consideronlytheoldestoneasbeingrelevant.
        ifincoming_dates:
            in_date=fields.Datetime.to_string(min(incoming_dates))
        else:
            in_date=fields.Datetime.now()

        forquantinquants:
            try:
                withself._cr.savepoint(flush=False): #Avoidflushcomputestoreofpackage
                    self._cr.execute("SELECT1FROMstock_quantWHEREid=%sFORUPDATENOWAIT",[quant.id],log_exceptions=False)
                    quant.write({
                        'quantity':quant.quantity+quantity,
                        'in_date':in_date,
                    })
                    break
            exceptOperationalErrorase:
                ife.pgcode=='55P03': #couldnotobtainthelock
                    continue
                else:
                    #Becausesavepointdoesn'tflush,weneedtoinvalidatethecache
                    #whenthereisaerrorraisefromthewrite(otherthanlock-error)
                    self.clear_caches()
                    raise
        else:
            self.create({
                'product_id':product_id.id,
                'location_id':location_id.id,
                'quantity':quantity,
                'lot_id':lot_idandlot_id.id,
                'package_id':package_idandpackage_id.id,
                'owner_id':owner_idandowner_id.id,
                'in_date':in_date,
            })
        returnself._get_available_quantity(product_id,location_id,lot_id=lot_id,package_id=package_id,owner_id=owner_id,strict=False,allow_negative=True),fields.Datetime.from_string(in_date)

    @api.model
    def_update_reserved_quantity(self,product_id,location_id,quantity,lot_id=None,package_id=None,owner_id=None,strict=False):
        """Increasethereservedquantity,i.e.increase`reserved_quantity`forthesetofquants
        sharingthecombinationof`product_id,location_id`if`strict`issettoFalseorsharing
        the*exactsamecharacteristics*otherwise.Typically,thismethodiscalledwhenreserving
        amoveorupdatingareservedmoveline.Whenreservingachainedmove,thestrictflag
        shouldbeenabled(toreserveexactlywhatwasbrought).WhenthemoveisMTS,itcouldtake
        anythingfromthestock,sowedisabletheflag.Wheneditingamoveline,wenaturally
        enabletheflag,toreflectthereservationaccordingtotheedition.

        :return:alistoftuples(quant,quantity_reserved)showingonwhichquantthereservation
            wasdoneandhowmuchthesystemwasabletoreserveonit
        """
        self=self.sudo()
        rounding=product_id.uom_id.rounding
        quants=self._gather(product_id,location_id,lot_id=lot_id,package_id=package_id,owner_id=owner_id,strict=strict)
        reserved_quants=[]

        iffloat_compare(quantity,0,precision_rounding=rounding)>0:
            #ifwewanttoreserve
            available_quantity=sum(quants.filtered(lambdaq:float_compare(q.quantity,0,precision_rounding=rounding)>0).mapped('quantity'))-sum(quants.mapped('reserved_quantity'))
            iffloat_compare(quantity,available_quantity,precision_rounding=rounding)>0:
                raiseUserError(_('Itisnotpossibletoreservemoreproductsof%sthanyouhaveinstock.',product_id.display_name))
        eliffloat_compare(quantity,0,precision_rounding=rounding)<0:
            #ifwewanttounreserve
            available_quantity=sum(quants.mapped('reserved_quantity'))
            iffloat_compare(abs(quantity),available_quantity,precision_rounding=rounding)>0:
                action_fix_unreserve=self.env.ref(
                    'stock.stock_quant_stock_move_line_desynchronization',raise_if_not_found=False)
                ifaction_fix_unreserveandself.user_has_groups('base.group_system'):
                    raiseRedirectWarning(
                        _("""Itisnotpossibletounreservemoreproductsof%sthanyouhaveinstock.
Thecorrectioncouldunreservesomeoperationswithproblematicsproducts.""",product_id.display_name),
                        action_fix_unreserve.id,
                        _('Automatedactiontofixit'))
                else:
                    raiseUserError(_('Itisnotpossibletounreservemoreproductsof%sthanyouhaveinstock.Contactanadministrator.',product_id.display_name))
        else:
            returnreserved_quants

        forquantinquants:
            iffloat_compare(quantity,0,precision_rounding=rounding)>0:
                max_quantity_on_quant=quant.quantity-quant.reserved_quantity
                iffloat_compare(max_quantity_on_quant,0,precision_rounding=rounding)<=0:
                    continue
                max_quantity_on_quant=min(max_quantity_on_quant,quantity)
                quant.reserved_quantity+=max_quantity_on_quant
                reserved_quants.append((quant,max_quantity_on_quant))
                quantity-=max_quantity_on_quant
                available_quantity-=max_quantity_on_quant
            else:
                max_quantity_on_quant=min(quant.reserved_quantity,abs(quantity))
                quant.reserved_quantity-=max_quantity_on_quant
                reserved_quants.append((quant,-max_quantity_on_quant))
                quantity+=max_quantity_on_quant
                available_quantity+=max_quantity_on_quant

            iffloat_is_zero(quantity,precision_rounding=rounding)orfloat_is_zero(available_quantity,precision_rounding=rounding):
                break
        returnreserved_quants

    @api.model
    def_unlink_zero_quants(self):
        """_update_available_quantitymayleavequantswithno
        quantityandnoreserved_quantity.Itusedtodirectlyunlink
        thesezeroquantsbutthisprovedtohurttheperformanceas
        thismethodisoftencalledinbatchandeachunlinkinvalidate
        thecache.Wedeferthecallstounlinkinthismethod.
        """
        precision_digits=max(6,self.sudo().env.ref('product.decimal_product_uom').digits*2)
        #UseaselectinsteadofORMsearchforUoMrobustness.
        query="""SELECTidFROMstock_quantWHERE(round(quantity::numeric,%s)=0ORquantityISNULL)ANDround(reserved_quantity::numeric,%s)=0;"""
        params=(precision_digits,precision_digits)
        self.env.cr.execute(query,params)
        quant_ids=self.env['stock.quant'].browse([quant['id']forquantinself.env.cr.dictfetchall()])
        quant_ids.sudo().unlink()

    @api.model
    def_merge_quants(self):
        """Inasituationwhereonetransactionisupdatingaquantvia
        `_update_available_quantity`andanotherconcurrentonecallsthisfunctionwiththesame
        argument,we’llcreateanewquantinorderforthesetransactionstonotrollback.This
        methodwillfindanddeduplicatethesequants.
        """
        query="""WITH
                        dupesAS(
                            SELECTmin(id)asto_update_quant_id,
                                (array_agg(idORDERBYid))[2:array_length(array_agg(id),1)]asto_delete_quant_ids,
                                SUM(reserved_quantity)asreserved_quantity,
                                SUM(quantity)asquantity,
                                MIN(in_date)asin_date
                            FROMstock_quant
                            GROUPBYproduct_id,company_id,location_id,lot_id,package_id,owner_id
                            HAVINGcount(id)>1
                        ),
                        _upAS(
                            UPDATEstock_quantq
                                SETquantity=d.quantity,
                                    reserved_quantity=d.reserved_quantity,
                                    in_date=d.in_date
                            FROMdupesd
                            WHEREd.to_update_quant_id=q.id
                        )
                   DELETEFROMstock_quantWHEREidin(SELECTunnest(to_delete_quant_ids)fromdupes)
        """
        try:
            withself.env.cr.savepoint():
                self.env.cr.execute(query)
        exceptErrorase:
            _logger.info('anerroroccuredwhilemergingquants:%s',e.pgerror)

    @api.model
    def_quant_tasks(self):
        self._merge_quants()
        self._unlink_zero_quants()

    @api.model
    def_is_inventory_mode(self):
        """Usedtocontrolwhetheraquantwaswrittenonorcreatedduringan
        "inventorysession",meaningamodewhereweneedtocreatethestock.move
        recordnecessarytobeconsistentwiththe`inventory_quantity`field.
        """
        returnself.env.context.get('inventory_mode')isTrueandself.user_has_groups('stock.group_stock_manager')

    @api.model
    def_get_inventory_fields_create(self):
        """Returnsalistoffieldsusercaneditwhenhewanttocreateaquantin`inventory_mode`.
        """
        return['product_id','location_id','lot_id','package_id','owner_id','inventory_quantity']

    @api.model
    def_get_inventory_fields_write(self):
        """Returnsalistoffieldsusercaneditwhenhewanttoeditaquantin`inventory_mode`.
        """
        return['inventory_quantity']

    def_get_inventory_move_values(self,qty,location_id,location_dest_id,out=False):
        """Calledwhenusermanuallysetanewquantity(via`inventory_quantity`)
        justbeforecreatingthecorrespondingstockmove.

        :paramlocation_id:`stock.location`
        :paramlocation_dest_id:`stock.location`
        :paramout:booleantosetonTruewhenthemovegotoinventoryadjustmentlocation.
        :return:dictwithallvaluesneededtocreateanew`stock.move`withitsmoveline.
        """
        self.ensure_one()
        return{
            'name':_('ProductQuantityUpdated'),
            'product_id':self.product_id.id,
            'product_uom':self.product_uom_id.id,
            'product_uom_qty':qty,
            'company_id':self.company_id.idorself.env.company.id,
            'state':'confirmed',
            'location_id':location_id.id,
            'location_dest_id':location_dest_id.id,
            'move_line_ids':[(0,0,{
                'product_id':self.product_id.id,
                'product_uom_id':self.product_uom_id.id,
                'qty_done':qty,
                'location_id':location_id.id,
                'location_dest_id':location_dest_id.id,
                'company_id':self.company_id.idorself.env.company.id,
                'lot_id':self.lot_id.id,
                'package_id':outandself.package_id.idorFalse,
                'result_package_id':(notout)andself.package_id.idorFalse,
                'owner_id':self.owner_id.id,
            })]
        }

    @api.model
    def_get_quants_action(self,domain=None,extend=False):
        """Returnsanactiontoopenquantview.
        Dependingofthecontext(userhaverighttobeinventorymodeornot),
        thelistviewwillbeeditableorreadonly.

        :paramdomain:Listforthedomain,emptybydefault.
        :paramextend:IfTrue,enablesform,graphandpivotviews.Falsebydefault.
        """
        ifnotself.env['ir.config_parameter'].sudo().get_param('stock.skip_quant_tasks'):
            self._quant_tasks()
        ctx=dict(self.env.contextor{})
        ctx.pop('group_by',None)
        action={
            'name':_('StockOnHand'),
            'view_type':'tree',
            'view_mode':'list,form',
            'res_model':'stock.quant',
            'type':'ir.actions.act_window',
            'context':ctx,
            'domain':domainor[],
            'help':"""
                <pclass="o_view_nocontent_empty_folder">NoStockOnHand</p>
                <p>Thisanalysisgivesyouanoverviewofthecurrentstock
                levelofyourproducts.</p>
                """
        }

        target_action=self.env.ref('stock.dashboard_open_quants',False)
        iftarget_action:
            action['id']=target_action.id

        ifself._is_inventory_mode():
            action['view_id']=self.env.ref('stock.view_stock_quant_tree_editable').id
            form_view=self.env.ref('stock.view_stock_quant_form_editable').id
        else:
            action['view_id']=self.env.ref('stock.view_stock_quant_tree').id
            form_view=self.env.ref('stock.view_stock_quant_form').id
        action.update({
            'views':[
                (action['view_id'],'list'),
                (form_view,'form'),
            ],
        })
        ifextend:
            action.update({
                'view_mode':'tree,form,pivot,graph',
                'views':[
                    (action['view_id'],'list'),
                    (form_view,'form'),
                    (self.env.ref('stock.view_stock_quant_pivot').id,'pivot'),
                    (self.env.ref('stock.stock_quant_view_graph').id,'graph'),
                ],
            })
        returnaction


classQuantPackage(models.Model):
    """Packagescontainingquantsand/orotherpackages"""
    _name="stock.quant.package"
    _description="Packages"
    _order='name'

    name=fields.Char(
        'PackageReference',copy=False,index=True,
        default=lambdaself:self.env['ir.sequence'].next_by_code('stock.quant.package')or_('UnknownPack'))
    quant_ids=fields.One2many('stock.quant','package_id','BulkContent',readonly=True,
        domain=['|',('quantity','!=',0),('reserved_quantity','!=',0)])
    packaging_id=fields.Many2one(
        'product.packaging','PackageType',index=True,check_company=True)
    location_id=fields.Many2one(
        'stock.location','Location',compute='_compute_package_info',
        index=True,readonly=True,store=True)
    company_id=fields.Many2one(
        'res.company','Company',compute='_compute_package_info',
        index=True,readonly=True,store=True)
    owner_id=fields.Many2one(
        'res.partner','Owner',compute='_compute_package_info',search='_search_owner',
        index=True,readonly=True,compute_sudo=True)

    @api.depends('quant_ids.package_id','quant_ids.location_id','quant_ids.company_id','quant_ids.owner_id','quant_ids.quantity','quant_ids.reserved_quantity')
    def_compute_package_info(self):
        forpackageinself:
            values={'location_id':False,'owner_id':False}
            ifpackage.quant_ids:
                values['location_id']=package.quant_ids[0].location_id
                ifall(q.owner_id==package.quant_ids[0].owner_idforqinpackage.quant_ids):
                    values['owner_id']=package.quant_ids[0].owner_id
                ifall(q.company_id==package.quant_ids[0].company_idforqinpackage.quant_ids):
                    values['company_id']=package.quant_ids[0].company_id
            package.location_id=values['location_id']
            package.company_id=values.get('company_id')
            package.owner_id=values['owner_id']

    defname_get(self):
        returnlist(self._compute_complete_name().items())

    def_compute_complete_name(self):
        """Formscompletenameoflocationfromparentlocationtochildlocation."""
        res={}
        forpackageinself:
            name=package.name
            res[package.id]=name
        returnres

    def_search_owner(self,operator,value):
        ifvalue:
            packs=self.search([('quant_ids.owner_id',operator,value)])
        else:
            packs=self.search([('quant_ids',operator,value)])
        ifpacks:
            return[('id','in',packs.ids)]
        else:
            return[('id','=',False)]

    defunpack(self):
        forpackageinself:
            move_line_to_modify=self.env['stock.move.line'].search([
                ('package_id','=',package.id),
                ('state','in',('assigned','partially_available')),
                ('product_qty','!=',0),
            ])
            move_line_to_modify.write({'package_id':False})
            package.mapped('quant_ids').sudo().write({'package_id':False})

        #Quantclean-up,mostlytoavoidmultiplequantsofthesameproduct.Forexample,unpack
        #2packagesof50,thenreserve100=>aquantof-50iscreatedattransfervalidation.
        self.env['stock.quant']._merge_quants()
        self.env['stock.quant']._unlink_zero_quants()

    defaction_view_picking(self):
        action=self.env["ir.actions.actions"]._for_xml_id("stock.action_picking_tree_all")
        domain=['|',('result_package_id','in',self.ids),('package_id','in',self.ids)]
        pickings=self.env['stock.move.line'].search(domain).mapped('picking_id')
        action['domain']=[('id','in',pickings.ids)]
        returnaction

    def_get_contained_quants(self):
        returnself.env['stock.quant'].search([('package_id','in',self.ids)])

    def_allowed_to_move_between_transfers(self):
        returnTrue

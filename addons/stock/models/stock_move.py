#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

importjson
fromcollectionsimportdefaultdict
fromdatetimeimportdatetime
fromitertoolsimportgroupby
fromoperatorimportitemgetter
fromreimportfindallasregex_findall
fromreimportsplitasregex_split

fromdateutilimportrelativedelta

fromflectraimportSUPERUSER_ID,_,api,fields,models
fromflectra.exceptionsimportUserError
fromflectra.osvimportexpression
fromflectra.tools.float_utilsimportfloat_compare,float_is_zero,float_repr,float_round
fromflectra.tools.miscimportclean_context,format_date,OrderedSet

PROCUREMENT_PRIORITIES=[('0','Normal'),('1','Urgent')]


classStockMove(models.Model):
    _name="stock.move"
    _description="StockMove"
    _order='sequence,id'

    def_default_group_id(self):
        ifself.env.context.get('default_picking_id'):
            returnself.env['stock.picking'].browse(self.env.context['default_picking_id']).group_id.id
        returnFalse

    name=fields.Char('Description',index=True,required=True)
    sequence=fields.Integer('Sequence',default=10)
    priority=fields.Selection(
        PROCUREMENT_PRIORITIES,'Priority',default='0',
        compute="_compute_priority",store=True,index=True)
    create_date=fields.Datetime('CreationDate',index=True,readonly=True)
    date=fields.Datetime(
        'DateScheduled',default=fields.Datetime.now,index=True,required=True,
        help="Scheduleddateuntilmoveisdone,thendateofactualmoveprocessing")
    date_deadline=fields.Datetime(
        "Deadline",readonly=True,
        help="DatePromisetothecustomeronthetopleveldocument(SO/PO)")
    company_id=fields.Many2one(
        'res.company','Company',
        default=lambdaself:self.env.company,
        index=True,required=True)
    product_id=fields.Many2one(
        'product.product','Product',
        check_company=True,
        domain="[('type','in',['product','consu']),'|',('company_id','=',False),('company_id','=',company_id)]",index=True,required=True,
        states={'done':[('readonly',True)]})
    description_picking=fields.Text('DescriptionofPicking')
    product_qty=fields.Float(
        'RealQuantity',compute='_compute_product_qty',inverse='_set_product_qty',
        digits=0,store=True,compute_sudo=True,
        help='QuantityinthedefaultUoMoftheproduct')
    product_uom_qty=fields.Float(
        'Demand',
        digits='ProductUnitofMeasure',
        default=0.0,required=True,states={'done':[('readonly',True)]},
        help="Thisisthequantityofproductsfromaninventory"
             "pointofview.Formovesinthestate'done',thisisthe"
             "quantityofproductsthatwereactuallymoved.Forother"
             "moves,thisisthequantityofproductthatisplannedto"
             "bemoved.Loweringthisquantitydoesnotgeneratea"
             "backorder.Changingthisquantityonassignedmovesaffects"
             "theproductreservation,andshouldbedonewithcare.")
    product_uom=fields.Many2one('uom.uom','UnitofMeasure',required=True,domain="[('category_id','=',product_uom_category_id)]")
    product_uom_category_id=fields.Many2one(related='product_id.uom_id.category_id')
    #TDEFIXME:makeitstored,otherwisegroupwillnotwork
    product_tmpl_id=fields.Many2one(
        'product.template','ProductTemplate',
        related='product_id.product_tmpl_id',readonly=True,
        help="Technical:usedinviews")
    location_id=fields.Many2one(
        'stock.location','SourceLocation',
        auto_join=True,index=True,required=True,
        check_company=True,
        help="Setsalocationifyouproduceatafixedlocation.Thiscanbeapartnerlocationifyousubcontractthemanufacturingoperations.")
    location_dest_id=fields.Many2one(
        'stock.location','DestinationLocation',
        auto_join=True,index=True,required=True,
        check_company=True,
        help="Locationwherethesystemwillstockthefinishedproducts.")
    partner_id=fields.Many2one(
        'res.partner','DestinationAddress',
        states={'done':[('readonly',True)]},
        help="Optionaladdresswheregoodsaretobedelivered,specificallyusedforallotment")
    move_dest_ids=fields.Many2many(
        'stock.move','stock_move_move_rel','move_orig_id','move_dest_id','DestinationMoves',
        copy=False,
        help="Optional:nextstockmovewhenchainingthem")
    move_orig_ids=fields.Many2many(
        'stock.move','stock_move_move_rel','move_dest_id','move_orig_id','OriginalMove',
        copy=False,
        help="Optional:previousstockmovewhenchainingthem")
    picking_id=fields.Many2one('stock.picking','Transfer',index=True,states={'done':[('readonly',True)]},check_company=True)
    picking_partner_id=fields.Many2one('res.partner','TransferDestinationAddress',related='picking_id.partner_id',readonly=False)
    note=fields.Text('Notes')
    state=fields.Selection([
        ('draft','New'),('cancel','Cancelled'),
        ('waiting','WaitingAnotherMove'),
        ('confirmed','WaitingAvailability'),
        ('partially_available','PartiallyAvailable'),
        ('assigned','Available'),
        ('done','Done')],string='Status',
        copy=False,default='draft',index=True,readonly=True,
        help="*New:Whenthestockmoveiscreatedandnotyetconfirmed.\n"
             "*WaitingAnotherMove:Thisstatecanbeseenwhenamoveiswaitingforanotherone,forexampleinachainedflow.\n"
             "*WaitingAvailability:Thisstateisreachedwhentheprocurementresolutionisnotstraightforward.Itmayneedtheschedulertorun,acomponenttobemanufactured...\n"
             "*Available:Whenproductsarereserved,itissetto\'Available\'.\n"
             "*Done:Whentheshipmentisprocessed,thestateis\'Done\'.")
    price_unit=fields.Float(
        'UnitPrice',help="Technicalfieldusedtorecordtheproductcostsetbytheuserduringapickingconfirmation(whencosting"
                           "methodusedis'averageprice'or'real').Valuegivenincompanycurrencyandinproductuom.",copy=False) #asit'satechnicalfield,weintentionallydon'tprovidethedigitsattribute
    backorder_id=fields.Many2one('stock.picking','BackOrderof',related='picking_id.backorder_id',index=True,readonly=False)
    origin=fields.Char("SourceDocument")
    procure_method=fields.Selection([
        ('make_to_stock','Default:TakeFromStock'),
        ('make_to_order','Advanced:ApplyProcurementRules')],string='SupplyMethod',
        default='make_to_stock',required=True,copy=False,
        help="Bydefault,thesystemwilltakefromthestockinthesourcelocationandpassivelywaitforavailability."
             "Theotherpossibilityallowsyoutodirectlycreateaprocurementonthesourcelocation(andthusignore"
             "itscurrentstock)togatherproducts.Ifwewanttochainmovesandhavethisonetowaitfortheprevious,"
             "thissecondoptionshouldbechosen.")
    scrapped=fields.Boolean('Scrapped',related='location_dest_id.scrap_location',readonly=True,store=True)
    scrap_ids=fields.One2many('stock.scrap','move_id')
    group_id=fields.Many2one('procurement.group','ProcurementGroup',default=_default_group_id,index=True)
    rule_id=fields.Many2one(
        'stock.rule','StockRule',ondelete='restrict',help='Thestockrulethatcreatedthisstockmove',
        check_company=True)
    propagate_cancel=fields.Boolean(
        'Propagatecancelandsplit',default=True,
        help='Ifchecked,whenthismoveiscancelled,cancelthelinkedmovetoo')
    delay_alert_date=fields.Datetime('DelayAlertDate',help='Processatthisdatetobeontime',compute="_compute_delay_alert_date",store=True)
    picking_type_id=fields.Many2one('stock.picking.type','OperationType',check_company=True)
    inventory_id=fields.Many2one('stock.inventory','Inventory',check_company=True)
    move_line_ids=fields.One2many('stock.move.line','move_id')
    move_line_nosuggest_ids=fields.One2many('stock.move.line','move_id',domain=['|',('product_qty','=',0.0),('qty_done','!=',0.0)])
    origin_returned_move_id=fields.Many2one(
        'stock.move','Originreturnmove',copy=False,index=True,
        help='Movethatcreatedthereturnmove',check_company=True)
    returned_move_ids=fields.One2many('stock.move','origin_returned_move_id','Allreturnedmoves',help='Optional:allreturnedmovescreatedfromthismove')
    reserved_availability=fields.Float(
        'QuantityReserved',compute='_compute_reserved_availability',
        digits='ProductUnitofMeasure',
        readonly=True,help='Quantitythathasalreadybeenreservedforthismove')
    availability=fields.Float(
        'ForecastedQuantity',compute='_compute_product_availability',
        readonly=True,help='Quantityinstockthatcanstillbereservedforthismove')
    restrict_partner_id=fields.Many2one(
        'res.partner','Owner',help="Technicalfieldusedtodepictarestrictionontheownershipofquantstoconsiderwhenmarkingthismoveas'done'",
        check_company=True)
    route_ids=fields.Many2many(
        'stock.location.route','stock_location_route_move','move_id','route_id','Destinationroute',help="Preferredroute",
        check_company=True)
    warehouse_id=fields.Many2one('stock.warehouse','Warehouse',help="Technicalfielddepictingthewarehousetoconsiderfortherouteselectiononthenextprocurement(ifany).")
    has_tracking=fields.Selection(related='product_id.tracking',string='ProductwithTracking')
    quantity_done=fields.Float('QuantityDone',compute='_quantity_done_compute',digits='ProductUnitofMeasure',inverse='_quantity_done_set')
    show_operations=fields.Boolean(related='picking_id.picking_type_id.show_operations',readonly=False)
    show_details_visible=fields.Boolean('DetailsVisible',compute='_compute_show_details_visible')
    show_reserved_availability=fields.Boolean('FromSupplier',compute='_compute_show_reserved_availability')
    picking_code=fields.Selection(related='picking_id.picking_type_id.code',readonly=True)
    product_type=fields.Selection(related='product_id.type',readonly=True)
    additional=fields.Boolean("Whetherthemovewasaddedafterthepicking'sconfirmation",default=False)
    is_locked=fields.Boolean(compute='_compute_is_locked',readonly=True)
    is_initial_demand_editable=fields.Boolean('Isinitialdemandeditable',compute='_compute_is_initial_demand_editable')
    is_quantity_done_editable=fields.Boolean('Isquantitydoneeditable',compute='_compute_is_quantity_done_editable')
    reference=fields.Char(compute='_compute_reference',string="Reference",store=True)
    has_move_lines=fields.Boolean(compute='_compute_has_move_lines')
    package_level_id=fields.Many2one('stock.package_level','PackageLevel',check_company=True,copy=False)
    picking_type_entire_packs=fields.Boolean(related='picking_type_id.show_entire_packs',readonly=True)
    display_assign_serial=fields.Boolean(compute='_compute_display_assign_serial')
    next_serial=fields.Char('FirstSN')
    next_serial_count=fields.Integer('NumberofSN')
    orderpoint_id=fields.Many2one('stock.warehouse.orderpoint','OriginalReorderingRule',check_company=True,index=True)
    forecast_availability=fields.Float('ForecastAvailability',compute='_compute_forecast_information',digits='ProductUnitofMeasure',compute_sudo=True)
    forecast_expected_date=fields.Datetime('ForecastedExpecteddate',compute='_compute_forecast_information',compute_sudo=True)
    lot_ids=fields.Many2many('stock.production.lot',compute='_compute_lot_ids',inverse='_set_lot_ids',string='SerialNumbers',readonly=False)

    @api.onchange('product_id','picking_type_id')
    defonchange_product(self):
        ifself.product_id:
            product=self.product_id.with_context(lang=self._get_lang())
            self.description_picking=product._get_description(self.picking_type_id)

    @api.depends('has_tracking','picking_type_id.use_create_lots','picking_type_id.use_existing_lots','state')
    def_compute_display_assign_serial(self):
        formoveinself:
            move.display_assign_serial=(
                move.has_tracking=='serial'and
                move.statein('partially_available','assigned','confirmed')and
                move.picking_type_id.use_create_lotsand
                notmove.picking_type_id.use_existing_lots
                andnotmove.origin_returned_move_id.id
            )

    @api.depends('picking_id.priority')
    def_compute_priority(self):
        formoveinself:
            move.priority=move.picking_id.priorityor'0'

    @api.depends('picking_id.is_locked')
    def_compute_is_locked(self):
        formoveinself:
            ifmove.picking_id:
                move.is_locked=move.picking_id.is_locked
            else:
                move.is_locked=False

    @api.depends('product_id','has_tracking','move_line_ids')
    def_compute_show_details_visible(self):
        """Accordingtothisfield,thebuttonthatcalls`action_show_details`willbedisplayed
        toworkonamovefromitspickingformview,ornot.
        """
        has_package=self.user_has_groups('stock.group_tracking_lot')
        multi_locations_enabled=self.user_has_groups('stock.group_stock_multi_locations')
        consignment_enabled=self.user_has_groups('stock.group_tracking_owner')

        show_details_visible=multi_locations_enabledorhas_package

        formoveinself:
            ifnotmove.product_id:
                move.show_details_visible=False
            eliflen(move.move_line_ids)>1:
                move.show_details_visible=True
            else:
                move.show_details_visible=(((consignment_enabledandmove.picking_id.picking_type_id.code!='incoming')or
                                             show_details_visibleormove.has_tracking!='none')and
                                             move._show_details_in_draft()and
                                             move.picking_id.picking_type_id.show_operationsisFalse)

    def_compute_show_reserved_availability(self):
        """Thisfieldisonlyofuseinanattrsinthepickingview,inordertohidethe
        "available"columnifthemoveiscomingfromasupplier.
        """
        formoveinself:
            move.show_reserved_availability=notmove.location_id.usage=='supplier'

    @api.depends('state','picking_id')
    def_compute_is_initial_demand_editable(self):
        formoveinself:
            ifnotmove.picking_id.immediate_transferandmove.state=='draft':
                move.is_initial_demand_editable=True
            elifnotmove.picking_id.is_lockedandmove.state!='done'andmove.picking_id:
                move.is_initial_demand_editable=True
            else:
                move.is_initial_demand_editable=False

    @api.depends('state','picking_id','product_id')
    def_compute_is_quantity_done_editable(self):
        formoveinself:
            ifnotmove.product_id:
                move.is_quantity_done_editable=False
            elifnotmove.picking_id.immediate_transferandmove.picking_id.state=='draft':
                move.is_quantity_done_editable=False
            elifmove.picking_id.is_lockedandmove.statein('done','cancel'):
                move.is_quantity_done_editable=False
            elifmove.show_details_visible:
                move.is_quantity_done_editable=False
            elifmove.show_operations:
                move.is_quantity_done_editable=False
            else:
                move.is_quantity_done_editable=True

    @api.depends('picking_id','name')
    def_compute_reference(self):
        formoveinself:
            move.reference=move.picking_id.nameifmove.picking_idelsemove.name

    @api.depends('move_line_ids')
    def_compute_has_move_lines(self):
        formoveinself:
            move.has_move_lines=bool(move.move_line_ids)

    @api.depends('product_id','product_uom','product_uom_qty')
    def_compute_product_qty(self):
        #DLEFIXME:`stock/tests/test_move2.py`
        #`product_qty`isaSTOREDcomputefieldwhichdependsonthecontext:/
        #IaskedSLEtochangethis,task:2041971
        #InthemeantimeIcheatandforcetheroudingtohalf-up,itseemsitworksforalltests.
        rounding_method='HALF-UP'
        formoveinself:
            move.product_qty=move.product_uom._compute_quantity(
                move.product_uom_qty,move.product_id.uom_id,rounding_method=rounding_method)

    def_get_move_lines(self):
        """Thiswillreturnthemovelinestoconsiderwhenapplying_quantity_done_computeonastock.move.
        Insomecontext,suchasMRP,itisnecessarytocomputequantity_doneonfilteredsock.move.line."""
        self.ensure_one()
        ifself.picking_type_id.show_reservedisFalse:
            returnself.move_line_nosuggest_ids
        returnself.move_line_ids

    @api.depends('move_orig_ids.date','move_orig_ids.state','state','date')
    def_compute_delay_alert_date(self):
        formoveinself:
            ifmove.statein('done','cancel'):
                move.delay_alert_date=False
                continue
            prev_moves=move.move_orig_ids.filtered(lambdam:m.statenotin('done','cancel')andm.date)
            prev_max_date=max(prev_moves.mapped("date"),default=False)
            ifprev_max_dateandprev_max_date>move.date:
                move.delay_alert_date=prev_max_date
            else:
                move.delay_alert_date=False

    @api.depends('move_line_ids.qty_done','move_line_ids.product_uom_id','move_line_nosuggest_ids.qty_done','picking_type_id')
    def_quantity_done_compute(self):
        """Thisfieldrepresentsthesumofthemovelines`qty_done`.Itallowstheusertoknow
        ifthereisstillworktodo.

        Wetakecareofroundingthisvalueatthegeneraldecimalprecisionandnottherounding
        ofthemove'sUOMtomakesurethisvalueisreallyclosetotherealsum,becausethis
        fieldwillbeusedin`_action_done`inordertoknowifthemovewillneedabackorderor
        anextramove.
        """
        ifnotany(self._ids):
            #onchange
            formoveinself:
                quantity_done=0
                formove_lineinmove._get_move_lines():
                    quantity_done+=move_line.product_uom_id._compute_quantity(
                        move_line.qty_done,move.product_uom,round=False)
                move.quantity_done=quantity_done
        else:
            #compute
            move_lines_ids=set()
            formoveinself:
                move_lines_ids|=set(move._get_move_lines().ids)

            data=self.env['stock.move.line'].read_group(
                [('id','in',list(move_lines_ids))],
                ['move_id','product_uom_id','qty_done'],['move_id','product_uom_id'],
                lazy=False
            )

            rec=defaultdict(list)
            fordindata:
                rec[d['move_id'][0]]+=[(d['product_uom_id'][0],d['qty_done'])]

            formoveinself:
                uom=move.product_uom
                move.quantity_done=sum(
                    self.env['uom.uom'].browse(line_uom_id)._compute_quantity(qty,uom,round=False)
                     forline_uom_id,qtyinrec.get(move.ids[0]ifmove.idselsemove.id,[])
                )

    def_quantity_done_set(self):
        quantity_done=self[0].quantity_done #anycalltocreatewillinvalidate`move.quantity_done`
        formoveinself:
            move_lines=move._get_move_lines()
            ifnotmove_lines:
                ifquantity_done:
                    #donotimpactreservationhere
                    move_line=self.env['stock.move.line'].create(dict(move._prepare_move_line_vals(),qty_done=quantity_done))
                    move.write({'move_line_ids':[(4,move_line.id)]})
            eliflen(move_lines)==1:
                move_lines[0].qty_done=quantity_done
            else:
                #Bypasstheerrorifwe'retryingtowritethesamevalue.
                ml_quantity_done=0
                formove_lineinmove_lines:
                    ml_quantity_done+=move_line.product_uom_id._compute_quantity(move_line.qty_done,move.product_uom,round=False)
                iffloat_compare(quantity_done,ml_quantity_done,precision_rounding=move.product_uom.rounding)!=0:
                    raiseUserError(_("Cannotsetthedonequantityfromthisstockmove,workdirectlywiththemovelines."))

    def_set_product_qty(self):
        """Themeaningofproduct_qtyfieldchangedlatelyandisnowafunctionalfieldcomputingthequantity
        inthedefaultproductUoM.Thiscodehasbeenaddedtoraiseanerrorifawriteismadegivenavalue
        for`product_qty`,wherethesamewriteshouldsetthe`product_uom_qty`fieldinstead,inorderto
        detecterrors."""
        raiseUserError(_('Therequestedoperationcannotbeprocessedbecauseofaprogrammingerrorsettingthe`product_qty`fieldinsteadofthe`product_uom_qty`.'))

    @api.depends('move_line_ids.product_qty')
    def_compute_reserved_availability(self):
        """Fillthe`availability`fieldonastockmove,whichistheactualreservedquantity
        andisrepresentedbytheaggregated`product_qty`onthelinkedmovelines.Ifthemove
        isforceassigned,thevaluewillbe0.
        """
        ifnotany(self._ids):
            #onchange
            formoveinself:
                reserved_availability=sum(move.move_line_ids.mapped('product_qty'))
                move.reserved_availability=move.product_id.uom_id._compute_quantity(
                    reserved_availability,move.product_uom,rounding_method='HALF-UP')
        else:
            #compute
            result={data['move_id'][0]:data['product_qty']fordatain
                      self.env['stock.move.line'].read_group([('move_id','in',self.ids)],['move_id','product_qty'],['move_id'])}
            formoveinself:
                move.reserved_availability=move.product_id.uom_id._compute_quantity(
                    result.get(move.id,0.0),move.product_uom,rounding_method='HALF-UP')

    @api.depends('state','product_id','product_qty','location_id')
    def_compute_product_availability(self):
        """Fillthe`availability`fieldonastockmove,whichisthequantitytopotentially
        reserve.Whenthemoveisdone,`availability`issettothequantitythemovedidactually
        move.
        """
        formoveinself:
            ifmove.state=='done':
                move.availability=move.product_qty
            else:
                total_availability=self.env['stock.quant']._get_available_quantity(move.product_id,move.location_id)ifmove.product_idelse0.0
                move.availability=min(move.product_qty,total_availability)

    @api.depends('product_id','picking_type_id','picking_id','reserved_availability','priority','state','product_uom_qty','location_id')
    def_compute_forecast_information(self):
        """Computeforecastedinformationoftherelatedproductbywarehouse."""
        self.forecast_availability=False
        self.forecast_expected_date=False

        not_product_moves=self.filtered(lambdamove:move.product_id.type!='product')
        formoveinnot_product_moves:
            move.forecast_availability=move.product_qty

        product_moves=(self-not_product_moves)
        warehouse_by_location={loc:loc.get_warehouse()forlocinproduct_moves.location_id}

        outgoing_unreserved_moves_per_warehouse=defaultdict(lambda:self.env['stock.move'])
        formoveinproduct_moves:
            picking_type=move.picking_type_idormove.picking_id.picking_type_id
            is_unreserved=move.statein('waiting','confirmed','partially_available')
            ifpicking_type.codeinself._consuming_picking_types()andis_unreserved:
                outgoing_unreserved_moves_per_warehouse[warehouse_by_location[move.location_id]]|=move
            elifpicking_type.codeinself._consuming_picking_types():
                move.forecast_availability=move.product_uom._compute_quantity(
                    move.reserved_availability,move.product_id.uom_id,rounding_method='HALF-UP')

        forwarehouse,movesinoutgoing_unreserved_moves_per_warehouse.items():
            ifnotwarehouse: #Nopredictionpossibleifnowarehouse.
                continue
            product_variant_ids=moves.product_id.ids
            wh_location_ids=[loc['id']forlocinself.env['stock.location'].search_read(
                [('id','child_of',warehouse.view_location_id.id)],
                ['id'],
            )]
            ForecastedReport=self.env['report.stock.report_product_product_replenishment']
            forecast_lines=ForecastedReport.with_context(warehouse=warehouse.id)._get_report_lines(None,product_variant_ids,wh_location_ids)
            formoveinmoves:
                lines=[lforlinforecast_linesifl["move_out"]==move._originandl["replenishment_filled"]isTrue]
                iflines:
                    move.forecast_availability=sum(m['quantity']forminlines)
                    move_ins_lines=list(filter(lambdareport_line:report_line['move_in'],lines))
                    ifmove_ins_lines:
                        expected_date=max(m['move_in'].dateforminmove_ins_lines)
                        move.forecast_expected_date=expected_date

    def_set_date_deadline(self,new_deadline):
        #Handlethepropagationof`date_deadline`fields(upanddownstream-onlyupdatebyup/downstreamdocuments)
        already_propagate_ids=self.env.context.get('date_deadline_propagate_ids',set())|set(self.ids)
        self=self.with_context(date_deadline_propagate_ids=already_propagate_ids)
        formoveinself:
            moves_to_update=(move.move_dest_ids|move.move_orig_ids)
            ifmove.date_deadline:
                delta=move.date_deadline-fields.Datetime.to_datetime(new_deadline)
            else:
                delta=0
            formove_updateinmoves_to_update:
                ifmove_update.statein('done','cancel'):
                    continue
                ifmove_update.idinalready_propagate_ids:
                    continue
                ifmove_update.date_deadlineanddelta:
                    move_update.date_deadline-=delta
                else:
                    move_update.date_deadline=new_deadline

    @api.depends('move_line_ids','move_line_ids.lot_id','move_line_ids.qty_done')
    def_compute_lot_ids(self):
        domain_nosuggest=[('move_id','in',self.ids),('lot_id','!=',False),'|',('qty_done','!=',0.0),('product_qty','=',0.0)]
        domain_suggest=[('move_id','in',self.ids),('lot_id','!=',False),('qty_done','!=',0.0)]
        lots_by_move_id_list=[]
        fordomainin[domain_nosuggest,domain_suggest]:
            lots_by_move_id=self.env['stock.move.line'].read_group(
                domain,
                ['move_id','lot_ids:array_agg(lot_id)'],['move_id'],
            )
            lots_by_move_id_list.append({by_move['move_id'][0]:by_move['lot_ids']forby_moveinlots_by_move_id})
        formoveinself:
            move.lot_ids=lots_by_move_id_list[0ifmove.picking_type_id.show_reservedelse1].get(move._origin.id,[])

    def_set_lot_ids(self):
        formoveinself:
            ifmove.product_id.tracking!='serial':
                continue
            move_lines_commands=[]
            ifmove.picking_type_id.show_reservedisFalse:
                mls=move.move_line_nosuggest_ids
            else:
                mls=move.move_line_ids
            mls=mls.filtered(lambdaml:ml.lot_id)
            formlinmls:
                ifml.qty_doneandml.lot_idnotinmove.lot_ids:
                    move_lines_commands.append((2,ml.id))
            ls=move.move_line_ids.lot_id
            forlotinmove.lot_ids:
                iflotnotinls:
                    move_line_vals=self._prepare_move_line_vals(quantity=0)
                    move_line_vals['lot_id']=lot.id
                    move_line_vals['lot_name']=lot.name
                    move_line_vals['product_uom_id']=move.product_id.uom_id.id
                    move_line_vals['qty_done']=1
                    move_lines_commands.append((0,0,move_line_vals))
                else:
                    move_line=move.move_line_ids.filtered(lambdaline:line.lot_id.id==lot.id)
                    move_line.qty_done=1
            move.write({'move_line_ids':move_lines_commands})

    @api.constrains('product_uom')
    def_check_uom(self):
        moves_error=self.filtered(lambdamove:move.product_id.uom_id.category_id!=move.product_uom.category_id)
        ifmoves_error:
            user_warning=_('Youcannotperformthemovebecausetheunitofmeasurehasadifferentcategoryastheproductunitofmeasure.')
            formoveinmoves_error:
                user_warning+=_('\n\n%s-->ProductUoMis%s(%s)-MoveUoMis%s(%s)')%(move.product_id.display_name,move.product_id.uom_id.name,move.product_id.uom_id.category_id.name,move.product_uom.name,move.product_uom.category_id.name)
            user_warning+=_('\n\nBlocking:%s')%','.join(moves_error.mapped('name'))
            raiseUserError(user_warning)

    definit(self):
        self._cr.execute('SELECTindexnameFROMpg_indexesWHEREindexname=%s',('stock_move_product_location_index',))
        ifnotself._cr.fetchone():
            self._cr.execute('CREATEINDEXstock_move_product_location_indexONstock_move(product_id,location_id,location_dest_id,company_id,state)')

    @api.model
    defdefault_get(self,fields_list):
        #Weoverridethedefault_gettomakestockmovescreatedafterthepickingwasconfirmed
        #directlyasavailableinimmediatetransfermode.Thisallowstocreateextramovelines
        #inthefpview.Inplannedtransfer,thestockmovearemarkedas`additional`andwillbe
        #auto-confirmed.
        defaults=super(StockMove,self).default_get(fields_list)
        ifself.env.context.get('default_picking_id'):
            picking_id=self.env['stock.picking'].browse(self.env.context['default_picking_id'])
            ifpicking_id.state=='done':
                defaults['state']='done'
                defaults['product_uom_qty']=0.0
                defaults['additional']=True
            elifpicking_id.statenotin['cancel','draft','done']:
                ifpicking_id.immediate_transfer:
                    defaults['state']='assigned'
                defaults['product_uom_qty']=0.0
                defaults['additional']=True #totrigger`_autoconfirm_picking`
        returndefaults

    defname_get(self):
        res=[]
        formoveinself:
            res.append((move.id,'%s%s%s>%s'%(
                move.picking_id.originand'%s/'%move.picking_id.originor'',
                move.product_id.codeand'%s:'%move.product_id.codeor'',
                move.location_id.name,move.location_dest_id.name)))
        returnres

    defwrite(self,vals):
        #Handlethewriteontheinitialdemandbyupdatingthereservedquantityandlogging
        #messagesaccordingtothestateofthestock.moverecords.
        receipt_moves_to_reassign=self.env['stock.move']
        move_to_recompute_state=self.env['stock.move']
        if'quantity_done'invalsandany(move.state=='cancel'formoveinself):
            raiseUserError(_('Youcannotchangeacancelledstockmove,createanewlineinstead.'))
        if'product_uom'invalsandany(move.state=='done'formoveinself):
            raiseUserError(_('YoucannotchangetheUoMforastockmovethathasbeensetto\'Done\'.'))
        if'product_uom_qty'invals:
            move_to_unreserve=self.env['stock.move']
            formoveinself.filtered(lambdam:m.statenotin('done','draft')andm.picking_id):
                iffloat_compare(vals['product_uom_qty'],move.product_uom_qty,precision_rounding=move.product_uom.rounding):
                    self.env['stock.move.line']._log_message(move.picking_id,move,'stock.track_move_template',vals)
            ifself.env.context.get('do_not_unreserve')isNone:
                move_to_unreserve=self.filtered(
                    lambdam:m.statenotin['draft','done','cancel']andfloat_compare(m.reserved_availability,vals.get('product_uom_qty'),precision_rounding=m.product_uom.rounding)==1
                )
                move_to_unreserve._do_unreserve()
                (self-move_to_unreserve).filtered(lambdam:m.state=='assigned').write({'state':'partially_available'})
                #Wheneditingtheinitialdemand,directlyrunagainactionassignonreceiptmoves.
                receipt_moves_to_reassign|=move_to_unreserve.filtered(lambdam:m.location_id.usage=='supplier')
                receipt_moves_to_reassign|=(self-move_to_unreserve).filtered(lambdam:m.location_id.usage=='supplier'andm.statein('partially_available','assigned'))
                move_to_recompute_state|=self-move_to_unreserve-receipt_moves_to_reassign
        if'date_deadline'invals:
            self._set_date_deadline(vals.get('date_deadline'))
        res=super(StockMove,self).write(vals)
        ifmove_to_recompute_state:
            move_to_recompute_state._recompute_state()
        ifreceipt_moves_to_reassign:
            receipt_moves_to_reassign._action_assign()
        returnres

    def_delay_alert_get_documents(self):
        """Returnsalistofrecordsetofthedocumentslinkedtothestock.movein`self`inorder
        topostthedelayalertnextactivity.Thesedocumentsarededuplicated.Thismethodismeant
        tobeoverriddenbyothermodules,eachofthemaddinganelementbytypeofrecordseton
        thislist.

        :return:alistofrecordsetofthedocumentslinkedto`self`
        :rtype:list
        """
        returnlist(self.mapped('picking_id'))

    def_propagate_date_log_note(self,move_orig):
        """Postadeadlinechangealertlognoteonthedocumentslinkedto`self`."""
        #TODO:gettheenddocument(PO/SO/MO)
        doc_orig=move_orig._delay_alert_get_documents()
        documents=self._delay_alert_get_documents()
        ifnotdocumentsornotdoc_orig:
            return

        msg=_("Thedeadlinehasbeenautomaticallyupdatedduetoadelayon<ahref='#'data-oe-model='%s'data-oe-id='%s'>%s</a>.")%(doc_orig[0]._name,doc_orig[0].id,doc_orig[0].name)
        msg_subject=_("Deadlineupdatedduetodelayon%s",doc_orig[0].name)
        #writethemessageoneachdocument
        fordocindocuments:
            last_message=doc.message_ids[:1]
            #Avoidstowritetheexactsamemessagemultipletimes.
            iflast_messageandlast_message.subject==msg_subject:
                continue
            flectrabot_id=self.env['ir.model.data'].xmlid_to_res_id("base.partner_root")
            doc.message_post(body=msg,author_id=flectrabot_id,subject=msg_subject)

    defaction_show_details(self):
        """Returnsanactionthatwillopenaformview(inapopup)allowingtoworkonallthe
        movelinesofaparticularmove.Thisformviewisusedwhen"showoperations"isnot
        checkedonthepickingtype.
        """
        self.ensure_one()

        picking_type_id=self.picking_type_idorself.picking_id.picking_type_id

        #If"showsuggestions"isnotcheckedonthepickingtype,wehavetofilteroutthe
        #reservedmovelines.Wedothisbydisplaying`move_line_nosuggest_ids`.Weuse
        #differentviewstodisplayonefieldoranothersothatthewebclientdoesn'thaveto
        #fetchboth.
        ifpicking_type_id.show_reserved:
            view=self.env.ref('stock.view_stock_move_operations')
        else:
            view=self.env.ref('stock.view_stock_move_nosuggest_operations')

        return{
            'name':_('DetailedOperations'),
            'type':'ir.actions.act_window',
            'view_mode':'form',
            'res_model':'stock.move',
            'views':[(view.id,'form')],
            'view_id':view.id,
            'target':'new',
            'res_id':self.id,
            'context':dict(
                self.env.context,
                show_owner=self.picking_type_id.code!='incoming',
                show_lots_m2o=self.has_tracking!='none'and(picking_type_id.use_existing_lotsorself.state=='done'orself.origin_returned_move_id.id), #abletocreatelots,whateverthevalueof`use_create_lots`.
                show_lots_text=self.has_tracking!='none'andpicking_type_id.use_create_lotsandnotpicking_type_id.use_existing_lotsandself.state!='done'andnotself.origin_returned_move_id.id,
                show_source_location=self.picking_type_id.code!='incoming',
                show_destination_location=self.picking_type_id.code!='outgoing',
                show_package=notself.location_id.usage=='supplier',
                show_reserved_quantity=self.state!='done'andnotself.picking_id.immediate_transferandself.picking_type_id.code!='incoming'
            ),
        }

    defaction_assign_serial_show_details(self):
        """On`self.move_line_ids`,assign`lot_name`accordingto
        `self.next_serial`beforereturning`self.action_show_details`.
        """
        self.ensure_one()
        ifnotself.next_serial:
            raiseUserError(_("YouneedtosetaSerialNumberbeforegeneratingmore."))
        self._generate_serial_numbers()
        returnself.action_show_details()

    defaction_clear_lines_show_details(self):
        """Unlink`self.move_line_ids`beforereturning`self.action_show_details`.
        UsefulforifausercreatestoomanySNsbyaccidentviaaction_assign_serial_show_details
        sincethere'snowaytoundotheaction.
        """
        self.ensure_one()
        ifself.picking_type_id.show_reserved:
            move_lines=self.move_line_ids
        else:
            move_lines=self.move_line_nosuggest_ids
        move_lines.unlink()
        returnself.action_show_details()

    defaction_assign_serial(self):
        """OpensawizardtoassignSN'snameoneachmovelines.
        """
        self.ensure_one()
        action=self.env["ir.actions.actions"]._for_xml_id("stock.act_assign_serial_numbers")
        action['context']={
            'default_product_id':self.product_id.id,
            'default_move_id':self.id,
        }
        returnaction

    defaction_product_forecast_report(self):
        self.ensure_one()
        action=self.product_id.action_product_forecast_report()
        warehouse=self.location_id.get_warehouse()
        action['context']={'warehouse':warehouse.id,}ifwarehouseelse{}
        returnaction

    def_do_unreserve(self):
        moves_to_unreserve=OrderedSet()
        formoveinself:
            ifmove.state=='cancel'or(move.state=='done'andmove.scrapped):
                #Wemayhavecancelledmoveinanopenpickingina"propagate_cancel"scenario.
                #Wemayhavedonemoveinanopenpickinginascrapscenario.
                continue
            elifmove.state=='done':
                raiseUserError(_("Youcannotunreserveastockmovethathasbeensetto'Done'."))
            moves_to_unreserve.add(move.id)
        moves_to_unreserve=self.env['stock.move'].browse(moves_to_unreserve)

        ml_to_update,ml_to_unlink=OrderedSet(),OrderedSet()
        moves_not_to_recompute=OrderedSet()
        formlinmoves_to_unreserve.move_line_ids:
            ifml.qty_done:
                ml_to_update.add(ml.id)
            else:
                ml_to_unlink.add(ml.id)
                moves_not_to_recompute.add(ml.move_id.id)
        ml_to_update,ml_to_unlink=self.env['stock.move.line'].browse(ml_to_update),self.env['stock.move.line'].browse(ml_to_unlink)
        moves_not_to_recompute=self.env['stock.move'].browse(moves_not_to_recompute)

        ml_to_update.write({'product_uom_qty':0})
        ml_to_unlink.unlink()
        #`write`on`stock.move.line`doesn'tcall`_recompute_state`(unliketo`unlink`),
        #soitmustbecalledforeachmovewherenomovelinehasbeendeleted.
        (moves_to_unreserve-moves_not_to_recompute)._recompute_state()
        returnTrue

    def_generate_serial_numbers(self,next_serial_count=False):
        """Thismethodwillgenerate`lot_name`fromastring(field
        `next_serial`)andcreateamovelineforeachgenerated`lot_name`.
        """
        self.ensure_one()

        ifnotnext_serial_count:
            next_serial_count=self.next_serial_count
        #Welookiftheserialnumbercontainsatleastonedigit.
        caught_initial_number=regex_findall("\d+",self.next_serial)
        ifnotcaught_initial_number:
            raiseUserError(_('Theserialnumbermustcontainatleastonedigit.'))
        #Webasetheserieonthelastnumberfindinthebaseserialnumber.
        initial_number=caught_initial_number[-1]
        padding=len(initial_number)
        #Wesplittheserialnumbertogettheprefixandsuffix.
        splitted=regex_split(initial_number,self.next_serial)
        #initial_numbercouldappearseveraltimesintheSN,e.g.BAV023B00001S00001
        prefix=initial_number.join(splitted[:-1])
        suffix=splitted[-1]
        initial_number=int(initial_number)

        lot_names=[]
        foriinrange(0,next_serial_count):
            lot_names.append('%s%s%s'%(
                prefix,
                str(initial_number+i).zfill(padding),
                suffix
            ))
        move_lines_commands=self._generate_serial_move_line_commands(lot_names)
        self.write({'move_line_ids':move_lines_commands})
        returnTrue

    def_push_apply(self):
        formoveinself:
            #ifthemoveisalreadychained,thereisnoneedtocheckpushrules
            ifmove.move_dest_ids:
                continue
            #ifthemoveisareturnedmove,wedon'twanttocheckpushrules,asreturningareturnedmoveistheonlydecentway
            #toreceivegoodswithouttriggeringthepushrulesagain(whichwouldduplicatechainedoperations)
            domain=[('location_src_id','=',move.location_dest_id.id),('action','in',('push','pull_push'))]
            #firstprioritygoestothepreferredroutesdefinedonthemoveitself(e.g.comingfromaSOline)
            warehouse_id=move.warehouse_idormove.picking_id.picking_type_id.warehouse_id
            ifmove.location_dest_id.company_id==self.env.company:
                rules=self.env['procurement.group']._search_rule(move.route_ids,move.product_id,warehouse_id,domain)
            else:
                rules=self.sudo().env['procurement.group']._search_rule(move.route_ids,move.product_id,warehouse_id,domain)
            #Makesureitisnotreturningthereturn
            ifrulesand(notmove.origin_returned_move_idormove.origin_returned_move_id.location_dest_id.id!=rules.location_id.id):
                rules._run_push(move)

    def_merge_moves_fields(self):
        """Thismethodwillreturnadictofstockmove’svaluesthatrepresentthevaluesofallmovesin`self`merged."""
        state=self._get_relevant_state_among_moves()
        origin='/'.join(set(self.filtered(lambdam:m.origin).mapped('origin')))
        return{
            'product_uom_qty':sum(self.mapped('product_uom_qty')),
            'date':min(self.mapped('date'))ifall(p.move_type=='direct'forpinself.picking_id)elsemax(self.mapped('date')),
            'move_dest_ids':[(4,m.id)forminself.mapped('move_dest_ids')],
            'move_orig_ids':[(4,m.id)forminself.mapped('move_orig_ids')],
            'state':state,
            'origin':origin,
        }

    @api.model
    def_prepare_merge_moves_distinct_fields(self):
        return[
            'product_id','price_unit','procure_method','location_id','location_dest_id',
            'product_uom','restrict_partner_id','scrapped','origin_returned_move_id',
            'package_level_id','propagate_cancel','description_picking','date_deadline'
        ]

    @api.model
    def_prepare_merge_move_sort_method(self,move):
        move.ensure_one()

        description_picking=move.description_pickingor""

        return[
            move.product_id.id,move.price_unit,move.procure_method,move.location_id,move.location_dest_id,
            move.product_uom.id,move.restrict_partner_id.id,move.scrapped,move.origin_returned_move_id.id,
            move.package_level_id.id,move.propagate_cancel,description_picking
        ]

    def_clean_merged(self):
        """Cleanuphookusedwhenmergingmoves"""
        self.write({'propagate_cancel':False})

    def_merge_moves(self,merge_into=False):
        """Thismethodwill,foreachmovein`self`,goupintheirlinkedpickingandtryto
        findintheirexistingmovesacandidateintowhichwecanmergethemove.
        :return:Recordsetofmovespassedtothismethod.Ifsomeofthepassedmovesweremerged
        intoanotherexistingone,returnthisoneandnotthe(nowunlinked)original.
        """
        distinct_fields=self._prepare_merge_moves_distinct_fields()

        candidate_moves_list=[]
        ifnotmerge_into:
            forpickinginself.mapped('picking_id'):
                candidate_moves_list.append(picking.move_lines)
        else:
            candidate_moves_list.append(merge_into|self)

        #Moveremovedaftermerge
        moves_to_unlink=self.env['stock.move']
        moves_to_merge=[]
        forcandidate_movesincandidate_moves_list:
            #Firststepfindmovetomerge.
            candidate_moves=candidate_moves.with_context(prefetch_fields=False)
            fork,gingroupby(sorted(candidate_moves,key=self._prepare_merge_move_sort_method),key=itemgetter(*distinct_fields)):
                moves=self.env['stock.move'].concat(*g).filtered(lambdam:m.statenotin('done','cancel','draft'))
                #Ifwehavemultiplerecordswewillmergetheninasingleone.
                iflen(moves)>1:
                    moves_to_merge.append(moves)

        #secondstepmergeitsmovelines,initialdemand,...
        formovesinmoves_to_merge:
            #linkallmovelinestorecord0(theonewewillkeep).
            moves.mapped('move_line_ids').write({'move_id':moves[0].id})
            #mergemovedata
            moves[0].write(moves._merge_moves_fields())
            #updatemergedmovesdicts
            moves_to_unlink|=moves[1:]

        ifmoves_to_unlink:
            #WeareusingpropagatetoFalseinordertonotcanceldestinationmovesmergedinmoves[0]
            moves_to_unlink._clean_merged()
            moves_to_unlink._action_cancel()
            moves_to_unlink.sudo().unlink()
        return(self|self.env['stock.move'].concat(*moves_to_merge))-moves_to_unlink

    def_get_relevant_state_among_moves(self):
        #Wesortourmovesbyimportanceofstate:
        #    -------------0
        #    |Assigned |
        #    -------------
        #    | Waiting |
        #    -------------
        #    | Partial |
        #    -------------
        #    | Confirm |
        #    -------------len-1
        sort_map={
            'assigned':4,
            'waiting':3,
            'partially_available':2,
            'confirmed':1,
        }
        moves_todo=self\
            .filtered(lambdamove:move.statenotin['cancel','done']andnot(move.state=='assigned'andnotmove.product_uom_qty))\
            .sorted(key=lambdamove:(sort_map.get(move.state,0),move.product_uom_qty))
        ifnotmoves_todo:
            return'assigned'
        #Thepickingshouldbethesameforallmoves.
        ifmoves_todo[:1].picking_idandmoves_todo[:1].picking_id.move_type=='one':
            most_important_move=moves_todo[0]
            ifmost_important_move.state=='confirmed':
                return'confirmed'ifmost_important_move.product_uom_qtyelse'assigned'
            elifmost_important_move.state=='partially_available':
                return'confirmed'
            else:
                returnmoves_todo[:1].stateor'draft'
        elifmoves_todo[:1].state!='assigned'andany(move.statein['assigned','partially_available']formoveinmoves_todo):
            return'partially_available'
        else:
            least_important_move=moves_todo[-1:]
            ifleast_important_move.state=='confirmed'andleast_important_move.product_uom_qty==0:
                return'assigned'
            else:
                returnmoves_todo[-1:].stateor'draft'

    @api.onchange('product_id')
    defonchange_product_id(self):
        product=self.product_id.with_context(lang=self._get_lang())
        self.name=product.partner_ref
        self.product_uom=product.uom_id.id

    @api.onchange('lot_ids')
    def_onchange_lot_ids(self):
        quantity_done=sum(ml.product_uom_id._compute_quantity(ml.qty_done,self.product_uom)formlinself.move_line_ids.filtered(lambdaml:notml.lot_idandml.lot_name))
        quantity_done+=self.product_id.uom_id._compute_quantity(len(self.lot_ids),self.product_uom)
        self.update({'quantity_done':quantity_done})
        used_lots=self.env['stock.move.line'].search([
            ('company_id','=',self.company_id.id),
            ('product_id','=',self.product_id.id),
            ('lot_id','in',self.lot_ids.ids),
            ('move_id','!=',self._origin.id),
            ('state','!=','cancel')
        ])
        ifused_lots:
            return{
                'warning':{'title':_('Warning'),'message':_('ExistingSerialnumbers(%s).Pleasecorrecttheserialnumbersencoded.')%','.join(used_lots.lot_id.mapped('display_name'))}
            }

    @api.onchange('move_line_ids','move_line_nosuggest_ids')
    defonchange_move_line_ids(self):
        ifnotself.picking_type_id.use_create_lots:
            #Thisonchangemanagesthecreationofmultiplelotname.Wedon't
            #needthatifthepickingtypedisallowsthecreationofnewlots.
            return

        breaking_char='\n'
        ifself.picking_type_id.show_reserved:
            move_lines=self.move_line_ids
        else:
            move_lines=self.move_line_nosuggest_ids

        formove_lineinmove_lines:
            #Lookifthe`lot_name`containsmultiplevalues.
            ifbreaking_charin(move_line.lot_nameor''):
                split_lines=move_line.lot_name.split(breaking_char)
                split_lines=list(filter(None,split_lines))
                move_line.lot_name=split_lines[0]ifsplit_lineselse''
                move_lines_commands=self._generate_serial_move_line_commands(
                    split_lines[1:],
                    origin_move_line=move_line,
                )
                ifself.picking_type_id.show_reserved:
                    self.update({'move_line_ids':move_lines_commands})
                else:
                    self.update({'move_line_nosuggest_ids':move_lines_commands})
                existing_lots=self.env['stock.production.lot'].search([
                    ('company_id','=',self.company_id.id),
                    ('product_id','=',self.product_id.id),
                    ('name','in',split_lines),
                ])
                ifexisting_lots:
                    return{
                        'warning':{'title':_('Warning'),'message':_('ExistingSerialNumbers(%s).Pleasecorrecttheserialnumbersencoded.')%','.join(existing_lots.mapped('display_name'))}
                    }
                break

    @api.onchange('product_uom')
    defonchange_product_uom(self):
        ifself.product_uom.factor>self.product_id.uom_id.factor:
            return{
                'warning':{
                    'title':"Unsafeunitofmeasure",
                    'message':_("Youareusingaunitofmeasuresmallerthantheoneyouareusingin"
                                 "ordertostockyourproduct.Thiscanleadtoroundingproblemonreservedquantity."
                                 "Youshouldusethesmallerunitofmeasurepossibleinordertovaluateyourstockor"
                                 "changeitsroundingprecisiontoasmallervalue(example:0.00001)."),
                }
            }

    def_key_assign_picking(self):
        self.ensure_one()
        keys=(self.group_id,self.location_id,self.location_dest_id,self.picking_type_id)
        ifself.partner_idand(self.location_id.usage=='transit'orself.location_dest_id.usage=='transit'):
            keys+=(self.partner_id,)
        returnkeys

    def_search_picking_for_assignation_domain(self):
        domain=[
            ('group_id','=',self.group_id.id),
            ('location_id','=',self.location_id.id),
            ('location_dest_id','=',self.location_dest_id.id),
            ('picking_type_id','=',self.picking_type_id.id),
            ('printed','=',False),
            ('immediate_transfer','=',False),
            ('state','in',['draft','confirmed','waiting','partially_available','assigned'])]
        ifself.partner_idand(self.location_id.usage=='transit'orself.location_dest_id.usage=='transit'):
            domain+=[('partner_id','=',self.partner_id.id)]
        returndomain

    def_search_picking_for_assignation(self):
        self.ensure_one()
        domain=self._search_picking_for_assignation_domain()
        picking=self.env['stock.picking'].search(domain,limit=1)
        returnpicking

    def_assign_picking(self):
        """Trytoassignthemovestoanexistingpickingthathasnotbeen
        reservedyetandhasthesameprocurementgroup,locationsandpicking
        type(movesshouldalreadyhavethemidentical).Otherwise,createanew
        pickingtoassignthemto."""
        Picking=self.env['stock.picking']
        grouped_moves=groupby(sorted(self,key=lambdam:[f.idforfinm._key_assign_picking()]),key=lambdam:[m._key_assign_picking()])
        forgroup,movesingrouped_moves:
            moves=self.env['stock.move'].concat(*list(moves))
            new_picking=False
            #Couldpasstheargumentscontainedingroupbuttheyarethesame
            #foreachmovethatwhymoves[0]isacceptable
            picking=moves[0]._search_picking_for_assignation()
            ifpicking:
                #Ifapickingisfound,we'llappend`move`toitsmovelistandthusits
                #`partner_id`and`ref`fieldwillrefertomultiplerecords.Inthis
                #case,wechosetowipethem.
                vals={}
                ifany(picking.partner_id.id!=m.partner_id.idforminmoves):
                    vals['partner_id']=False
                ifany(picking.origin!=m.originforminmoves):
                    vals['origin']=False
                ifvals:
                    picking.write(vals)
            else:
                new_picking=True
                picking=Picking.create(moves._get_new_picking_values())

            moves.write({'picking_id':picking.id})
            moves._assign_picking_post_process(new=new_picking)
        returnTrue

    def_assign_picking_post_process(self,new=False):
        pass

    def_generate_serial_move_line_commands(self,lot_names,origin_move_line=None):
        """Returnalistofcommandstoupdatethemovelines(writeon
        existingonesorcreatenewones).
        Calledwhenuserwanttocreateandassignmultipleserialnumbersin
        onetime(usingthebutton/wizardorcopy-pastealistinthefield).

        :paramlot_names:Alistcontainingallserialnumbertoassign.
        :typelot_names:list
        :paramorigin_move_line:Amovelinetoduplicatethevaluefrom,defaulttoNone
        :typeorigin_move_line:recordof:class:`stock.move.line`
        :return:Alistofcommandstocreate/update:class:`stock.move.line`
        :rtype:list
        """
        self.ensure_one()

        #Selecttherightmovelinesdependingofthepickingtypeconfiguration.
        move_lines=self.env['stock.move.line']
        ifself.picking_type_id.show_reserved:
            move_lines=self.move_line_ids.filtered(lambdaml:notml.lot_idandnotml.lot_name)
        else:
            move_lines=self.move_line_nosuggest_ids.filtered(lambdaml:notml.lot_idandnotml.lot_name)

        iforigin_move_line:
            location_dest=origin_move_line.location_dest_id
        else:
            location_dest=self.location_dest_id._get_putaway_strategy(self.product_id)
        move_line_vals={
            'picking_id':self.picking_id.id,
            'location_dest_id':location_dest.idorself.location_dest_id.id,
            'location_id':self.location_id.id,
            'product_id':self.product_id.id,
            'product_uom_id':self.product_id.uom_id.id,
            'qty_done':1,
        }
        iforigin_move_line:
            #`owner_id`and`package_id`aretakenonlyinthecasewecreate
            #newmovelinesfromanexistingmoveline.Also,updatesthe
            #`qty_done`becauseitcouldbeusefullforproductstrackedbylot.
            move_line_vals.update({
                'owner_id':origin_move_line.owner_id.id,
                'package_id':origin_move_line.package_id.id,
                'qty_done':origin_move_line.qty_doneor1,
            })

        move_lines_commands=[]
        forlot_nameinlot_names:
            #Wewritethelotnameonanexistingmoveline(ifwehavestillone)...
            ifmove_lines:
                move_lines_commands.append((1,move_lines[0].id,{
                    'lot_name':lot_name,
                    'qty_done':1,
                }))
                move_lines=move_lines[1:]
            #...orcreateanewmovelinewiththeserialname.
            else:
                move_line_cmd=dict(move_line_vals,lot_name=lot_name)
                move_lines_commands.append((0,0,move_line_cmd))
        returnmove_lines_commands

    def_get_new_picking_values(self):
        """returncreatevaluesfornewpickingthatwillbelinkedwithgroup
        ofmovesinself.
        """
        origins=self.filtered(lambdam:m.origin).mapped('origin')
        origins=list(dict.fromkeys(origins))#createalistofuniqueitems
        #Willdisplaysourcedocumentifany,whenmultipledifferentorigins
        #arefounddisplayamaximumof5
        iflen(origins)==0:
            origin=False
        else:
            origin=','.join(origins[:5])
            iflen(origins)>5:
                origin+="..."
        partners=self.mapped('partner_id')
        partner=len(partners)==1andpartners.idorFalse
        return{
            'origin':origin,
            'company_id':self.mapped('company_id').id,
            'user_id':False,
            'move_type':self.mapped('group_id').move_typeor'direct',
            'partner_id':partner,
            'picking_type_id':self.mapped('picking_type_id').id,
            'location_id':self.mapped('location_id').id,
            'location_dest_id':self.mapped('location_dest_id').id,
        }

    def_should_be_assigned(self):
        self.ensure_one()
        returnbool(notself.picking_idandself.picking_type_id)

    def_action_confirm(self,merge=True,merge_into=False):
        """Confirmsstockmoveorputitinwaitingifit'slinkedtoanothermove.
        :param:merge:Accordingtothisboolean,anewlyconfirmedmovewillbemerged
        inanothermoveofthesamepickingsharingitscharacteristics.
        """
        move_create_proc=self.env['stock.move']
        move_to_confirm=self.env['stock.move']
        move_waiting=self.env['stock.move']

        to_assign={}
        formoveinself:
            ifmove.state!='draft':
                continue
            #ifthemoveispreceeded,thenit'swaiting(ifpreceedingmoveisdone,thenaction_assignhasbeencalledalreadyanditsstateisalreadyavailable)
            ifmove.move_orig_ids:
                move_waiting|=move
            else:
                ifmove.procure_method=='make_to_order':
                    move_create_proc|=move
                else:
                    move_to_confirm|=move
            ifmove._should_be_assigned():
                key=(move.group_id.id,move.location_id.id,move.location_dest_id.id)
                ifkeynotinto_assign:
                    to_assign[key]=self.env['stock.move']
                to_assign[key]|=move

        #createprocurementsformaketoordermoves
        procurement_requests=[]
        formoveinmove_create_proc:
            values=move._prepare_procurement_values()
            origin=move._prepare_procurement_origin()
            procurement_requests.append(self.env['procurement.group'].Procurement(
                move.product_id,move.product_uom_qty,move.product_uom,
                move.location_id,move.rule_idandmove.rule_id.nameor"/",
                origin,move.company_id,values))
        self.env['procurement.group'].run(procurement_requests,raise_user_error=notself.env.context.get('from_orderpoint'))

        move_to_confirm.write({'state':'confirmed'})
        (move_waiting|move_create_proc).write({'state':'waiting'})

        #assignpickinginbatchforallconfirmedmovethatsharethesamedetails
        formovesinto_assign.values():
            moves.with_context(clean_context(
                moves.env.context))._assign_picking()
        self._push_apply()
        self._check_company()
        moves=self
        ifmerge:
            moves=self._merge_moves(merge_into=merge_into)
        #call`_action_assign`oneveryconfirmedmovewhichlocation_idbypassesthereservation
        moves.filtered(lambdamove:notmove.picking_id.immediate_transferandmove._should_bypass_reservation()andmove.state=='confirmed')._action_assign()
        returnmoves

    def_prepare_procurement_origin(self):
        self.ensure_one()
        returnself.group_idandself.group_id.nameor(self.originorself.picking_id.nameor"/")

    def_prepare_procurement_values(self):
        """Preparespecifickeyformovesorothercomponenetsthatwillbecreatedfromastockrule
        commingfromastockmove.Thismethodcouldbeoverrideinordertoaddothercustomkeythatcould
        beusedinmove/pocreation.
        """
        self.ensure_one()
        group_id=self.group_idorFalse
        ifself.rule_id:
            ifself.rule_id.group_propagation_option=='fixed'andself.rule_id.group_id:
                group_id=self.rule_id.group_id
            elifself.rule_id.group_propagation_option=='none':
                group_id=False
        product_id=self.product_id.with_context(lang=self._get_lang())
        return{
            'product_description_variants':self.description_pickingandself.description_picking.replace(product_id._get_description(self.picking_type_id),''),
            'date_planned':self.date,
            'date_deadline':self.date_deadline,
            'move_dest_ids':self,
            'group_id':group_id,
            'route_ids':self.route_ids,
            'warehouse_id':self.warehouse_idorself.picking_id.picking_type_id.warehouse_idorself.picking_type_id.warehouse_id,
            'priority':self.priority,
            'orderpoint_id':self.orderpoint_id,
        }

    def_prepare_move_line_vals(self,quantity=None,reserved_quant=None):
        self.ensure_one()
        #applyputaway
        location_dest_id=self.location_dest_id._get_putaway_strategy(self.product_id).idorself.location_dest_id.id
        vals={
            'move_id':self.id,
            'product_id':self.product_id.id,
            'product_uom_id':self.product_uom.id,
            'location_id':self.location_id.id,
            'location_dest_id':location_dest_id,
            'picking_id':self.picking_id.id,
            'company_id':self.company_id.id,
        }
        ifquantity:
            rounding=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')
            uom_quantity=self.product_id.uom_id._compute_quantity(quantity,self.product_uom,rounding_method='HALF-UP')
            uom_quantity=float_round(uom_quantity,precision_digits=rounding)
            uom_quantity_back_to_product_uom=self.product_uom._compute_quantity(uom_quantity,self.product_id.uom_id,rounding_method='HALF-UP')
            iffloat_compare(quantity,uom_quantity_back_to_product_uom,precision_digits=rounding)==0:
                vals=dict(vals,product_uom_qty=uom_quantity)
            else:
                vals=dict(vals,product_uom_qty=quantity,product_uom_id=self.product_id.uom_id.id)
        ifreserved_quant:
            vals=dict(
                vals,
                location_id=reserved_quant.location_id.id,
                lot_id=reserved_quant.lot_id.idorFalse,
                package_id=reserved_quant.package_id.idorFalse,
                owner_id=reserved_quant.owner_id.idorFalse,
            )
        returnvals

    def_update_reserved_quantity(self,need,available_quantity,location_id,lot_id=None,package_id=None,owner_id=None,strict=True):
        """Createorupdatemovelines.
        """
        self.ensure_one()

        ifnotlot_id:
            lot_id=self.env['stock.production.lot']
        ifnotpackage_id:
            package_id=self.env['stock.quant.package']
        ifnotowner_id:
            owner_id=self.env['res.partner']

        taken_quantity=min(available_quantity,need)

        #`taken_quantity`isinthequantsunitofmeasure.There'sapossibilitythatthemove's
        #unitofmeasurewon'tberespectedifweblindlyreservethisquantity,acommonusecase
        #isifthemove'sunitofmeasure'sroundingdoesnotallowfractionalreservation.Wechose
        #toconvert`taken_quantity`tothemove'sunitofmeasurewithadownroundingmethodand
        #thengetitbackinthequantsunitofmeasurewithanhalf-uprounding_method.This
        #way,we'llneverreservemorethanallowed.Wedonotapplythislogicif
        #`available_quantity`isbroughtbyachainedmoveline.Inthiscase,`_prepare_move_line_vals`
        #willtakecareofchangingtheUOMtotheUOMoftheproduct.
        ifnotstrictandself.product_id.uom_id!=self.product_uom:
            taken_quantity_move_uom=self.product_id.uom_id._compute_quantity(taken_quantity,self.product_uom,rounding_method='DOWN')
            taken_quantity=self.product_uom._compute_quantity(taken_quantity_move_uom,self.product_id.uom_id,rounding_method='HALF-UP')

        quants=[]
        rounding=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')

        ifself.product_id.tracking=='serial':
            iffloat_compare(taken_quantity,int(taken_quantity),precision_digits=rounding)!=0:
                taken_quantity=0

        self.env['base'].flush()
        try:
            withself.env.cr.savepoint():
                ifnotfloat_is_zero(taken_quantity,precision_rounding=self.product_id.uom_id.rounding):
                    quants=self.env['stock.quant']._update_reserved_quantity(
                        self.product_id,location_id,taken_quantity,lot_id=lot_id,
                        package_id=package_id,owner_id=owner_id,strict=strict
                    )
        exceptUserError:
            taken_quantity=0

        #Findacandidatemovelinetoupdateorcreateanewone.
        forreserved_quant,quantityinquants:
            to_update=next((lineforlineinself.move_line_idsifline._reservation_is_updatable(quantity,reserved_quant)),False)
            ifto_update:
                uom_quantity=self.product_id.uom_id._compute_quantity(quantity,to_update.product_uom_id,rounding_method='HALF-UP')
                uom_quantity=float_round(uom_quantity,precision_digits=rounding)
                uom_quantity_back_to_product_uom=to_update.product_uom_id._compute_quantity(uom_quantity,self.product_id.uom_id,rounding_method='HALF-UP')
            ifto_updateandfloat_compare(quantity,uom_quantity_back_to_product_uom,precision_digits=rounding)==0:
                to_update.with_context(bypass_reservation_update=True).product_uom_qty+=uom_quantity
            else:
                ifself.product_id.tracking=='serial':
                    self.env['stock.move.line'].create([self._prepare_move_line_vals(quantity=1,reserved_quant=reserved_quant)foriinrange(int(quantity))])
                else:
                    self.env['stock.move.line'].create(self._prepare_move_line_vals(quantity=quantity,reserved_quant=reserved_quant))
        returntaken_quantity

    def_should_bypass_reservation(self):
        self.ensure_one()
        returnself.location_id.should_bypass_reservation()orself.product_id.type!='product'

    #necessaryhooktobeabletooverridemovereservationtoarestrictlot,owner,pack,location...
    def_get_available_quantity(self,location_id,lot_id=None,package_id=None,owner_id=None,strict=False,allow_negative=False):
        self.ensure_one()
        returnself.env['stock.quant']._get_available_quantity(self.product_id,location_id,lot_id=lot_id,package_id=package_id,owner_id=owner_id,strict=strict,allow_negative=allow_negative)

    def_action_assign(self):
        """Reservestockmovesbycreatingtheirstockmovelines.Astockmoveis
        consideredreservedoncethesumof`product_qty`forallitsmovelinesis
        equaltoits`product_qty`.Ifitisless,thestockmoveisconsidered
        partiallyavailable.
        """
        StockMove=self.env['stock.move']
        assigned_moves_ids=OrderedSet()
        partially_available_moves_ids=OrderedSet()
        #Readthe`reserved_availability`fieldofthemovesoutofthelooptopreventunwanted
        #cacheinvalidationwhenactuallyreservingthemove.
        reserved_availability={move:move.reserved_availabilityformoveinself}
        roundings={move:move.product_id.uom_id.roundingformoveinself}
        move_line_vals_list=[]
        formoveinself.filtered(lambdam:m.statein['confirmed','waiting','partially_available']):
            rounding=roundings[move]
            missing_reserved_uom_quantity=move.product_uom_qty-reserved_availability[move]
            missing_reserved_quantity=move.product_uom._compute_quantity(missing_reserved_uom_quantity,move.product_id.uom_id,rounding_method='HALF-UP')
            ifmove._should_bypass_reservation():
                #createthemoveline(s)butdonotimpactquants
                ifmove.product_id.tracking=='serial'and(move.picking_type_id.use_create_lotsormove.picking_type_id.use_existing_lots):
                    foriinrange(0,int(missing_reserved_quantity)):
                        move_line_vals_list.append(move._prepare_move_line_vals(quantity=1))
                else:
                    to_update=move.move_line_ids.filtered(lambdaml:ml.product_uom_id==move.product_uomand
                                                            ml.location_id==move.location_idand
                                                            ml.location_dest_id==move.location_dest_idand
                                                            ml.picking_id==move.picking_idand
                                                            notml.lot_idand
                                                            notml.package_idand
                                                            notml.owner_id)
                    ifto_update:
                        to_update[0].product_uom_qty+=missing_reserved_uom_quantity
                    else:
                        move_line_vals_list.append(move._prepare_move_line_vals(quantity=missing_reserved_quantity))
                assigned_moves_ids.add(move.id)
            else:
                iffloat_is_zero(move.product_uom_qty,precision_rounding=move.product_uom.rounding):
                    assigned_moves_ids.add(move.id)
                elifnotmove.move_orig_ids:
                    ifmove.procure_method=='make_to_order':
                        continue
                    #Ifwedon'tneedanyquantity,considerthemoveassigned.
                    need=missing_reserved_quantity
                    iffloat_is_zero(need,precision_rounding=rounding):
                        assigned_moves_ids.add(move.id)
                        continue
                    #Reservenewquantsandcreatemovelinesaccordingly.
                    forced_package_id=move.package_level_id.package_idorNone
                    available_quantity=move._get_available_quantity(move.location_id,package_id=forced_package_id)
                    ifavailable_quantity<=0:
                        continue
                    taken_quantity=move._update_reserved_quantity(need,available_quantity,move.location_id,package_id=forced_package_id,strict=False)
                    iffloat_is_zero(taken_quantity,precision_rounding=rounding):
                        continue
                    iffloat_compare(need,taken_quantity,precision_rounding=rounding)==0:
                        assigned_moves_ids.add(move.id)
                    else:
                        partially_available_moves_ids.add(move.id)
                else:
                    #Checkwhatourparentsbroughtandwhatoursiblingstookinorderto
                    #determinewhatwecandistribute.
                    #`qty_done`isin`ml.product_uom_id`and,aswewilllaterincrease
                    #thereservedquantityonthequants,convertitherein
                    #`product_id.uom_id`(theUOMofthequantsistheUOMoftheproduct).
                    move_lines_in=move.move_orig_ids.filtered(lambdam:m.state=='done').mapped('move_line_ids')
                    keys_in_groupby=['location_dest_id','lot_id','result_package_id','owner_id']

                    def_keys_in_sorted(ml):
                        return(ml.location_dest_id.id,ml.lot_id.id,ml.result_package_id.id,ml.owner_id.id)

                    grouped_move_lines_in={}
                    fork,gingroupby(sorted(move_lines_in,key=_keys_in_sorted),key=itemgetter(*keys_in_groupby)):
                        qty_done=0
                        formling:
                            qty_done+=ml.product_uom_id._compute_quantity(ml.qty_done,ml.product_id.uom_id)
                        grouped_move_lines_in[k]=qty_done
                    move_lines_out_done=(move.move_orig_ids.mapped('move_dest_ids')-move)\
                        .filtered(lambdam:m.statein['done'])\
                        .mapped('move_line_ids')
                    #Aswedeferthewriteonthestock.move'sstateattheendoftheloop,there
                    #couldbemovestoconsiderinwhatoursiblingsalreadytook.
                    moves_out_siblings=move.move_orig_ids.mapped('move_dest_ids')-move
                    moves_out_siblings_to_consider=moves_out_siblings&(StockMove.browse(assigned_moves_ids)+StockMove.browse(partially_available_moves_ids))
                    reserved_moves_out_siblings=moves_out_siblings.filtered(lambdam:m.statein['partially_available','assigned'])
                    move_lines_out_reserved=(reserved_moves_out_siblings|moves_out_siblings_to_consider).mapped('move_line_ids')
                    keys_out_groupby=['location_id','lot_id','package_id','owner_id']

                    def_keys_out_sorted(ml):
                        return(ml.location_id.id,ml.lot_id.id,ml.package_id.id,ml.owner_id.id)

                    grouped_move_lines_out={}
                    fork,gingroupby(sorted(move_lines_out_done,key=_keys_out_sorted),key=itemgetter(*keys_out_groupby)):
                        qty_done=0
                        formling:
                            qty_done+=ml.product_uom_id._compute_quantity(ml.qty_done,ml.product_id.uom_id)
                        grouped_move_lines_out[k]=qty_done
                    fork,gingroupby(sorted(move_lines_out_reserved,key=_keys_out_sorted),key=itemgetter(*keys_out_groupby)):
                        grouped_move_lines_out[k]=sum(self.env['stock.move.line'].concat(*list(g)).mapped('product_qty'))
                    available_move_lines={key:grouped_move_lines_in[key]-grouped_move_lines_out.get(key,0)forkeyingrouped_move_lines_in.keys()}
                    #popkeyifthequantityavailableamountto0
                    rounding=move.product_id.uom_id.rounding
                    available_move_lines=dict((k,v)fork,vinavailable_move_lines.items()iffloat_compare(v,0,precision_rounding=rounding)>0)

                    ifnotavailable_move_lines:
                        continue
                    formove_lineinmove.move_line_ids.filtered(lambdam:m.product_qty):
                        ifavailable_move_lines.get((move_line.location_id,move_line.lot_id,move_line.result_package_id,move_line.owner_id)):
                            available_move_lines[(move_line.location_id,move_line.lot_id,move_line.result_package_id,move_line.owner_id)]-=move_line.product_qty
                    for(location_id,lot_id,package_id,owner_id),quantityinavailable_move_lines.items():
                        need=move.product_qty-sum(move.move_line_ids.mapped('product_qty'))
                        #`quantity`iswhatisbroughtbychaineddonemovelines.Wedoublecheck
                        #herethisquantityisavailableonthequantsthemselves.Ifnot,this
                        #couldbetheresultofaninventoryadjustmentthatremovedtotallyof
                        #partially`quantity`.Whenthishappens,wechosetoreservethemaximum
                        #stillavailable.ThissituationcouldnothappenonMTSmove,becausein
                        #thiscase`quantity`isdirectlythequantityonthequantsthemselves.
                        available_quantity=move._get_available_quantity(location_id,lot_id=lot_id,package_id=package_id,owner_id=owner_id,strict=True)
                        iffloat_is_zero(available_quantity,precision_rounding=rounding):
                            continue
                        taken_quantity=move._update_reserved_quantity(need,min(quantity,available_quantity),location_id,lot_id,package_id,owner_id)
                        iffloat_is_zero(taken_quantity,precision_rounding=rounding):
                            continue
                        iffloat_is_zero(need-taken_quantity,precision_rounding=rounding):
                            assigned_moves_ids.add(move.id)
                            break
                        partially_available_moves_ids.add(move.id)
            ifmove.product_id.tracking=='serial':
                move.next_serial_count=move.product_uom_qty

        self.env['stock.move.line'].create(move_line_vals_list)
        StockMove.browse(partially_available_moves_ids).write({'state':'partially_available'})
        StockMove.browse(assigned_moves_ids).write({'state':'assigned'})
        self.mapped('picking_id')._check_entire_pack()

    def_action_cancel(self):
        ifany(move.state=='done'andnotmove.scrappedformoveinself):
            raiseUserError(_('Youcannotcancelastockmovethathasbeensetto\'Done\'.Createareturninordertoreversethemoveswhichtookplace.'))
        moves_to_cancel=self.filtered(lambdam:m.state!='cancel'andnot(m.state=='done'andm.scrapped))
        #selfcannotcontainmovesthatareeithercancelledordone,thereforewecansafely
        #unlinkallassociatedmove_line_ids
        moves_to_cancel._do_unreserve()

        formoveinmoves_to_cancel:
            siblings_states=(move.move_dest_ids.mapped('move_orig_ids')-move).mapped('state')
            ifmove.propagate_cancel:
                #onlycancelthenextmoveifallmysiblingsarealsocancelled
                ifall(state=='cancel'forstateinsiblings_states):
                    move.move_dest_ids.filtered(lambdam:m.state!='done')._action_cancel()
            else:
                ifall(statein('done','cancel')forstateinsiblings_states):
                    move.move_dest_ids.write({'procure_method':'make_to_stock'})
                    move.move_dest_ids.write({'move_orig_ids':[(3,move.id,0)]})
        moves_to_cancel.write({
            'state':'cancel',
            'move_orig_ids':[(5,0,0)],
            'procure_method':'make_to_stock',
        })
        returnTrue

    def_prepare_extra_move_vals(self,qty):
        vals={
            'procure_method':'make_to_stock',
            'origin_returned_move_id':self.origin_returned_move_id.id,
            'product_uom_qty':qty,
            'picking_id':self.picking_id.id,
            'price_unit':self.price_unit,
        }
        returnvals

    def_create_extra_move(self):
        """Ifthequantitydoneonamoveexceedsitsquantitytodo,thismethodwillcreatean
        extramoveattachedtoa(potentiallysplit)moveline.Ifthepreviousconditionisnot
        met,it'llreturnanemptyrecordset.

        Therationaleforthecreationofanextramoveistheapplicationofapotentialpush
        rulethatwillhandletheextraquantities.
        """
        extra_move=self
        rounding=self.product_uom.rounding
        #movescreatedafterthepickingisassigneddonothave`product_uom_qty`,butweshouldn'tcreateextramovesforthem
        iffloat_compare(self.quantity_done,self.product_uom_qty,precision_rounding=rounding)>0:
            #createtheextramoves
            extra_move_quantity=float_round(
                self.quantity_done-self.product_uom_qty,
                precision_rounding=rounding,
                rounding_method='HALF-UP')
            extra_move_vals=self._prepare_extra_move_vals(extra_move_quantity)
            extra_move=self.copy(default=extra_move_vals)

            merge_into_self=all(self[field]==extra_move[field]forfieldinself._prepare_merge_moves_distinct_fields())

            ifmerge_into_selfandextra_move.picking_id:
                extra_move=extra_move._action_confirm(merge_into=self)
                returnextra_move
            else:
                extra_move=extra_move._action_confirm()

            #linkittosomemovelines.Wedon'tneedtodoitformovesincetheyshouldbemerged.
            ifnotmerge_into_selfornotextra_move.picking_id:
                formove_lineinself.move_line_ids.filtered(lambdaml:ml.qty_done):
                    iffloat_compare(move_line.qty_done,extra_move_quantity,precision_rounding=rounding)<=0:
                        #movethismovelinetoourextramove
                        move_line.move_id=extra_move.id
                        extra_move_quantity-=move_line.qty_done
                    else:
                        #splitthismovelineandassignthenewparttoourextramove
                        quantity_split=float_round(
                            move_line.qty_done-extra_move_quantity,
                            precision_rounding=self.product_uom.rounding,
                            rounding_method='UP')
                        move_line.qty_done=quantity_split
                        move_line.copy(default={'move_id':extra_move.id,'qty_done':extra_move_quantity,'product_uom_qty':0})
                        extra_move_quantity-=extra_move_quantity
                    ifextra_move_quantity==0.0:
                        break
        returnextra_move|self

    def_action_done(self,cancel_backorder=False):
        moves=self.filtered(lambdamove:move.state=='draft')._action_confirm() #MRPallowsscrappingdraftmoves
        moves=(self|moves).exists().filtered(lambdax:x.statenotin('done','cancel'))
        moves_todo=self.env['stock.move']

        #Cancelmoveswherenecessary;weshoulddoitbeforecreatingtheextramovesbecause
        #thisoperationcouldtriggeramergeofmoves.
        formoveinmoves:
            ifmove.quantity_done<=0:
                iffloat_compare(move.product_uom_qty,0.0,precision_rounding=move.product_uom.rounding)==0orcancel_backorder:
                    move._action_cancel()

        #Createextramoveswherenecessary
        formoveinmoves:
            ifmove.state=='cancel'ormove.quantity_done<=0:
                continue

            moves_todo|=move._create_extra_move()

        moves_todo._check_company()
        #Splitmoveswherenecessaryandmovequants
        backorder_moves_vals=[]
        formoveinmoves_todo:
            #Toknowwhetherweneedtocreateabackorderornot,roundtothegeneralproduct's
            #decimalprecisionandnottheproduct'sUOM.
            rounding=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')
            iffloat_compare(move.quantity_done,move.product_uom_qty,precision_digits=rounding)<0:
                #Needtodosomekindofconversionhere
                qty_split=move.product_uom._compute_quantity(move.product_uom_qty-move.quantity_done,move.product_id.uom_id,rounding_method='HALF-UP')
                new_move_vals=move._split(qty_split)
                backorder_moves_vals+=new_move_vals
        backorder_moves=self.env['stock.move'].create(backorder_moves_vals)
        backorder_moves._action_confirm(merge=False)
        ifcancel_backorder:
            backorder_moves.with_context(moves_todo=moves_todo)._action_cancel()
        moves_todo.mapped('move_line_ids').sorted()._action_done()
        #Checktheconsistencyoftheresultpackages;thereshouldbeanuniquelocationacross
        #thecontainedquants.
        forresult_packageinmoves_todo\
                .mapped('move_line_ids.result_package_id')\
                .filtered(lambdap:p.quant_idsandlen(p.quant_ids)>1):
            iflen(result_package.quant_ids.filtered(lambdaq:notfloat_is_zero(abs(q.quantity)+abs(q.reserved_quantity),precision_rounding=q.product_uom_id.rounding)).mapped('location_id'))>1:
                raiseUserError(_('Youcannotmovethesamepackagecontentmorethanonceinthesametransferorsplitthesamepackageintotwolocation.'))
        picking=moves_todo.mapped('picking_id')
        moves_todo.write({'state':'done','date':fields.Datetime.now()})

        move_dests_per_company=defaultdict(lambda:self.env['stock.move'])
        formove_destinmoves_todo.move_dest_ids:
            move_dests_per_company[move_dest.company_id.id]|=move_dest
        forcompany_id,move_destsinmove_dests_per_company.items():
            move_dests.sudo().with_company(company_id)._action_assign()

        #Wedon'twanttocreatebackorderforscrapmoves
        #Replacebyakwarginmaster
        ifself.env.context.get('is_scrap'):
            returnmoves_todo

        ifpickingandnotcancel_backorder:
            picking._create_backorder()
        returnmoves_todo

    defunlink(self):
        ifany(move.statenotin('draft','cancel')formoveinself):
            raiseUserError(_('Youcanonlydeletedraftmoves.'))
        #Withthenonplannifiedpicking,draftmovescouldhavesomemovelines.
        self.with_context(prefetch_fields=False).mapped('move_line_ids').unlink()
        returnsuper(StockMove,self).unlink()

    def_prepare_move_split_vals(self,qty):
        vals={
            'product_uom_qty':qty,
            'procure_method':'make_to_stock',
            'move_dest_ids':[(4,x.id)forxinself.move_dest_idsifx.statenotin('done','cancel')],
            'move_orig_ids':[(4,x.id)forxinself.move_orig_ids],
            'origin_returned_move_id':self.origin_returned_move_id.id,
            'price_unit':self.price_unit,
        }
        ifself.env.context.get('force_split_uom_id'):
            vals['product_uom']=self.env.context['force_split_uom_id']
        returnvals

    def_split(self,qty,restrict_partner_id=False):
        """Splits`self`quantityandreturnvaluesforanewmovestobecreatedafterwards

        :paramqty:float.quantitytosplit(giveninproductUoM)
        :paramrestrict_partner_id:optionalpartnerthatcanbegiveninordertoforcethenewmovetorestrictitschoiceofquantstotheonesbelongingtothispartner.
        :returns:listofdict.stockmovevalues"""
        self.ensure_one()
        ifself.statein('done','cancel'):
            raiseUserError(_('Youcannotsplitastockmovethathasbeensetto\'Done\'or\'Cancel\'.'))
        elifself.state=='draft':
            #werestrictthesplitofadraftmovebecauseifnotconfirmedyet,itmaybereplacedbyseveralothermovesin
            #caseofphantombom(withmrpmodule).Andwedon'twanttodealwiththiscomplexitybycopyingtheproductthatwillexplode.
            raiseUserError(_('Youcannotsplitadraftmove.Itneedstobeconfirmedfirst.'))
        iffloat_is_zero(qty,precision_rounding=self.product_id.uom_id.rounding)orself.product_qty<=qty:
            return[]

        decimal_precision=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')

        #`qty`passedasargumentisthequantitytobackorderandisalwaysexpressedinthe
        #quantsUOM.Ifwe'reabletoconvertbackandforththisquantityinthemove'sandthe
        #quantsUOM,thebackorderedmovecankeeptheUOMofthemove.Else,we'llcreateisin
        #theUOMofthequants.
        uom_qty=self.product_id.uom_id._compute_quantity(qty,self.product_uom,rounding_method='HALF-UP')
        iffloat_compare(qty,self.product_uom._compute_quantity(uom_qty,self.product_id.uom_id,rounding_method='HALF-UP'),precision_digits=decimal_precision)==0:
            defaults=self._prepare_move_split_vals(uom_qty)
        else:
            defaults=self.with_context(force_split_uom_id=self.product_id.uom_id.id)._prepare_move_split_vals(qty)

        ifrestrict_partner_id:
            defaults['restrict_partner_id']=restrict_partner_id

        #TDECLEANME:removecontextkey+addasparameter
        ifself.env.context.get('source_location_id'):
            defaults['location_id']=self.env.context['source_location_id']
        new_move_vals=self.with_context(rounding_method='HALF-UP').copy_data(defaults)

        #Updatetheoriginal`product_qty`ofthemove.Usethegeneralproduct'sdecimal
        #precisionandnotthemove'sUOMtohandlecasewherethe`quantity_done`isnot
        #compatiblewiththemove'sUOM.
        new_product_qty=self.product_id.uom_id._compute_quantity(self.product_qty-qty,self.product_uom,round=False)
        new_product_qty=float_round(new_product_qty,precision_digits=self.env['decimal.precision'].precision_get('ProductUnitofMeasure'))
        self.with_context(do_not_unreserve=True,rounding_method='HALF-UP').write({'product_uom_qty':new_product_qty})
        returnnew_move_vals

    def_recompute_state(self):
        moves_state_to_write=defaultdict(set)
        formoveinself:
            rounding=move.product_uom.rounding
            ifmove.statein('cancel','done','draft'):
                continue
            eliffloat_compare(move.reserved_availability,move.product_uom_qty,precision_rounding=rounding)==0:
                moves_state_to_write['assigned'].add(move.id)
            elifmove.reserved_availabilityandfloat_compare(move.reserved_availability,move.product_uom_qty,precision_rounding=rounding)<=0:
                moves_state_to_write['partially_available'].add(move.id)
            elifmove.procure_method=='make_to_order'andnotmove.move_orig_ids:
                moves_state_to_write['waiting'].add(move.id)
            elifmove.move_orig_idsandany(orig.statenotin('done','cancel')fororiginmove.move_orig_ids):
                moves_state_to_write['waiting'].add(move.id)
            else:
                moves_state_to_write['confirmed'].add(move.id)
        forstate,moves_idsinmoves_state_to_write.items():
            self.browse(moves_ids).filtered(lambdam:m.state!=state).state=state

    @api.model
    def_consuming_picking_types(self):
        return['outgoing']

    def_get_lang(self):
        """Determinelanguagetousefortranslateddescription"""
        returnself.picking_id.partner_id.langorself.partner_id.langorself.env.user.lang

    def_get_source_document(self):
        """Returnthemove'sdocument,usedby`report.stock.report_product_product_replenishment`
        andmustbeoverridedtoaddmoredocumenttypeinthereport.
        """
        self.ensure_one()
        returnself.picking_idorFalse

    def_get_upstream_documents_and_responsibles(self,visited):
        ifself.move_orig_idsandany(m.statenotin('done','cancel')forminself.move_orig_ids):
            result=set()
            visited|=self
            formoveinself.move_orig_ids:
                ifmove.statenotin('done','cancel'):
                    fordocument,responsible,visitedinmove._get_upstream_documents_and_responsibles(visited):
                        result.add((document,responsible,visited))
            returnresult
        else:
            return[(self.picking_id,self.product_id.responsible_id,visited)]

    def_set_quantity_done_prepare_vals(self,qty):
        res=[]
        formlinself.move_line_ids:
            ml_qty=ml.product_uom_qty-ml.qty_done
            iffloat_compare(ml_qty,0,precision_rounding=ml.product_uom_id.rounding)<=0:
                continue
            #Convertmovelineqtyintomoveuom
            ifml.product_uom_id!=self.product_uom:
                ml_qty=ml.product_uom_id._compute_quantity(ml_qty,self.product_uom,round=False)

            taken_qty=min(qty,ml_qty)
            #Converttakenqtyintomovelineuom
            ifml.product_uom_id!=self.product_uom:
                taken_qty=self.product_uom._compute_quantity(ml_qty,ml.product_uom_id,round=False)

            #Assignqty_doneandexplicitlyroundtomakesurethereisnoinconsistencybetween
            #ml.qty_doneandqty.
            taken_qty=float_round(taken_qty,precision_rounding=ml.product_uom_id.rounding)
            res.append((1,ml.id,{'qty_done':ml.qty_done+taken_qty}))
            ifml.product_uom_id!=self.product_uom:
                taken_qty=ml.product_uom_id._compute_quantity(ml_qty,self.product_uom,round=False)
            qty-=taken_qty

            iffloat_compare(qty,0.0,precision_rounding=self.product_uom.rounding)<=0:
                break

        formlinself.move_line_ids:
            iffloat_is_zero(ml.product_uom_qty,precision_rounding=ml.product_uom_id.rounding)andfloat_is_zero(ml.qty_done,precision_rounding=ml.product_uom_id.rounding):
                res.append((2,ml.id))

        iffloat_compare(qty,0.0,precision_rounding=self.product_uom.rounding)>0:
            ifself.product_id.tracking!='serial':
                vals=self._prepare_move_line_vals(quantity=0)
                vals['qty_done']=qty
                res.append((0,0,vals))
            else:
                uom_qty=self.product_uom._compute_quantity(qty,self.product_id.uom_id)
                foriinrange(0,int(uom_qty)):
                    vals=self._prepare_move_line_vals(quantity=0)
                    vals['qty_done']=1
                    vals['product_uom_id']=self.product_id.uom_id.id
                    res.append((0,0,vals))
        returnres

    def_set_quantity_done(self,qty):
        """
        Setthegivenquantityasquantitydoneonthemovethroughthemovelines.Themethodis
        abletohandlemovelineswithadifferentUoMthanthemove(buthonestly,thiswouldbe
        lookingfortrouble...).
        @paramqty:quantityintheUoMofmove.product_uom
        """
        self.move_line_ids=self._set_quantity_done_prepare_vals(qty)

    def_adjust_procure_method(self):
        """ThismethodwilltrytoapplytheprocuremethodMTOonsomemovesif
        acompatibleMTOrouteisfound.ElsetheprocuremethodwillbesettoMTS
        """
        #PreparetheMTSOvariables.TheyareneededsinceMTSOmovesarehandledseparately.
        #Weneed2dicts:
        #-neededquantityperlocationperproduct
        #-forecastedquantityperlocationperproduct
        mtso_products_by_locations=defaultdict(list)
        mtso_needed_qties_by_loc=defaultdict(dict)
        mtso_free_qties_by_loc={}
        mtso_moves=self.env['stock.move']

        formoveinself:
            product_id=move.product_id
            domain=[
                ('location_src_id','=',move.location_id.id),
                ('location_id','=',move.location_dest_id.id),
                ('action','!=','push')
            ]
            rules=self.env['procurement.group']._search_rule(False,product_id,move.warehouse_id,domain)
            ifrules:
                ifrules.procure_methodin['make_to_order','make_to_stock']:
                    move.procure_method=rules.procure_method
                else:
                    #Gettheneededquantityforthe`mts_else_mto`moves.
                    mtso_needed_qties_by_loc[rules.location_src_id].setdefault(product_id.id,0)
                    mtso_needed_qties_by_loc[rules.location_src_id][product_id.id]+=move.product_qty

                    #Thisallowustogettheforecastedquantityinbatchlateron
                    mtso_products_by_locations[rules.location_src_id].append(product_id.id)
                    mtso_moves|=move
            else:
                move.procure_method='make_to_stock'

        #Gettheforecastedquantityforthe`mts_else_mto`moves.
        forlocation,product_idsinmtso_products_by_locations.items():
            products=self.env['product.product'].browse(product_ids).with_context(location=location.id)
            mtso_free_qties_by_loc[location]={product.id:product.free_qtyforproductinproducts}

        #Nowthatwehavetheneededandforecastedquantityperlocationandperproduct,wecan
        #choosewhetherthemtso_movesneedtobeMTOorMTS.
        formoveinmtso_moves:
            needed_qty=move.product_qty
            forecasted_qty=mtso_free_qties_by_loc[move.location_id][move.product_id.id]
            iffloat_compare(needed_qty,forecasted_qty,precision_rounding=product_id.uom_id.rounding)<=0:
                move.procure_method='make_to_stock'
                mtso_free_qties_by_loc[move.location_id][move.product_id.id]-=needed_qty
            else:
                move.procure_method='make_to_order'

    def_show_details_in_draft(self):
        self.ensure_one()
        returnself.state!='draft'or(self.picking_id.immediate_transferandself.state=='draft')

    def_trigger_scheduler(self):
        """Checkforauto-triggeredorderpointsandtriggerthem."""
        ifnotselforself.env['ir.config_parameter'].sudo().get_param('stock.no_auto_scheduler'):
            return

        orderpoints_by_company=defaultdict(lambda:self.env['stock.warehouse.orderpoint'])
        orderpoints_context_by_company=defaultdict(dict)
        formoveinself:
            orderpoint=self.env['stock.warehouse.orderpoint'].search([
                ('product_id','=',move.product_id.id),
                ('trigger','=','auto'),
                ('location_id','parent_of',move.location_id.id),
                ('company_id','=',move.company_id.id)
            ],limit=1)
            iforderpoint:
                orderpoints_by_company[orderpoint.company_id]|=orderpoint
            iforderpointandmove.product_qty>orderpoint.product_min_qtyandmove.origin:
                orderpoints_context_by_company[orderpoint.company_id].setdefault(orderpoint.id,[])
                orderpoints_context_by_company[orderpoint.company_id][orderpoint.id].append(move.origin)
        forcompany,orderpointsinorderpoints_by_company.items():
            orderpoints.with_context(origins=orderpoints_context_by_company[company])._procure_orderpoint_confirm(
                company_id=company,raise_user_error=False)

    def_trigger_assign(self):
        """Checkforandtriggeraction_assignforconfirmed/partially_availablemovesrelatedtodonemoves.
            Disableautoreservationifuserconfiguredtodoso.
        """
        ifnotselforself.env['ir.config_parameter'].sudo().get_param('stock.picking_no_auto_reserve'):
            return

        domains=[]
        formoveinself:
            domains.append([('product_id','=',move.product_id.id),('location_id','=',move.location_dest_id.id)])
        static_domain=[('state','in',['confirmed','partially_available']),('procure_method','=','make_to_stock')]
        moves_to_reserve=self.env['stock.move'].search(expression.AND([static_domain,expression.OR(domains)]),
                                                         order='prioritydesc,dateasc,idasc')
        moves_to_reserve._action_assign()

    def_get_orig_reserved_availability(self,done_ids=False):
        self.ensure_one()
        ifnotdone_ids:
            done_ids=set()
        ifself.idindone_ids:
            return0
        done_ids.add(self.id)
        reserved=self.reserved_availabilityifself.show_reserved_availabilityelse0.0
        ifself.move_orig_ids:
            reserved+=sum([m._get_orig_reserved_availability(done_ids)forminself.move_orig_ids])
        returnreserved

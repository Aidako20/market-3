#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

fromflectraimportapi,models,_
fromflectra.toolsimportconfig
fromflectra.toolsimportformat_datetime


rec=0
defautoIncrement():
    globalrec
    pStart=1
    pInterval=1
    ifrec==0:
        rec=pStart
    else:
        rec+=pInterval
    returnrec


classMrpStockReport(models.TransientModel):
    _name='stock.traceability.report'
    _description='TraceabilityReport'

    @api.model
    def_get_move_lines(self,move_lines,line_id=None):
        lines_seen=move_lines
        lines_todo=list(move_lines)
        whilelines_todo:
            move_line=lines_todo.pop(0)
            #ifMTO
            ifmove_line.move_id.move_orig_ids:
                lines=move_line.move_id.move_orig_ids.mapped('move_line_ids').filtered(
                    lambdam:m.lot_id==move_line.lot_idandm.state=='done'
                )-lines_seen
            #ifMTS
            elifmove_line.location_id.usage=='internal':
                lines=self.env['stock.move.line'].search([
                    ('product_id','=',move_line.product_id.id),
                    ('lot_id','=',move_line.lot_id.id),
                    ('location_dest_id','=',move_line.location_id.id),
                    ('id','notin',lines_seen.ids),
                    ('date','<=',move_line.date),
                    ('state','=','done')
                ])
            else:
                continue
            ifline_idisNoneorline_idinlines.ids:
                lines_todo+=list(lines)
            lines_seen|=lines
        returnlines_seen-move_lines

    @api.model
    defget_lines(self,line_id=None,**kw):
        context=dict(self.env.context)
        model=kwandkw['model_name']orcontext.get('model')
        rec_id=kwandkw['model_id']orcontext.get('active_id')
        level=kwandkw['level']or1
        lines=self.env['stock.move.line']
        move_line=self.env['stock.move.line']
        ifrec_idandmodel=='stock.production.lot':
            lines=move_line.search([
                ('lot_id','=',context.get('lot_name')orrec_id),
                ('state','=','done'),
            ])
        elif rec_idandmodel=='stock.move.line'andcontext.get('lot_name'):
            record=self.env[model].browse(rec_id)
            dummy,is_used=self._get_linked_move_lines(record)
            ifis_used:
                lines=is_used
        elifrec_idandmodelin('stock.picking','mrp.production'):
            record=self.env[model].browse(rec_id)
            ifmodel=='stock.picking':
                lines=record.move_lines.mapped('move_line_ids').filtered(lambdam:m.lot_idandm.state=='done')
            else:
                lines=record.move_finished_ids.mapped('move_line_ids').filtered(lambdam:m.state=='done')
        move_line_vals=self._lines(line_id,model_id=rec_id,model=model,level=level,move_lines=lines)
        final_vals=sorted(move_line_vals,key=lambdav:v['date'],reverse=True)
        lines=self._final_vals_to_lines(final_vals,level)
        returnlines

    @api.model
    def_get_reference(self,move_line):
        res_model=''
        ref=''
        res_id=False
        picking_id=move_line.picking_idormove_line.move_id.picking_id
        ifpicking_id:
            res_model='stock.picking'
            res_id=picking_id.id
            ref=picking_id.name
        elifmove_line.move_id.inventory_id:
            res_model='stock.inventory'
            res_id=move_line.move_id.inventory_id.id
            ref='Inv.Adj.:'+move_line.move_id.inventory_id.name
        elifmove_line.move_id.scrappedandmove_line.move_id.scrap_ids:
            res_model='stock.scrap'
            res_id=move_line.move_id.scrap_ids[0].id
            ref=move_line.move_id.scrap_ids[0].name
        returnres_model,res_id,ref

    @api.model
    def_quantity_to_str(self,from_uom,to_uom,qty):
        """workaroundtoapplythefloatroundinglogicoft-escondatapreparedserverside"""
        qty=from_uom._compute_quantity(qty,to_uom,rounding_method='HALF-UP')
        returnself.env['ir.qweb.field.float'].value_to_html(qty,{'decimal_precision':'ProductUnitofMeasure'})

    def_get_usage(self,move_line):
        usage=''
        if(move_line.location_id.usage=='internal')and(move_line.location_dest_id.usage=='internal'):
            usage='internal'
        elif(move_line.location_id.usage!='internal')and(move_line.location_dest_id.usage=='internal'):
            usage='in'
        else:
            usage='out'
        returnusage

    def_make_dict_move(self,level,parent_id,move_line,unfoldable=False):
        res_model,res_id,ref=self._get_reference(move_line)
        dummy,is_used=self._get_linked_move_lines(move_line)
        data=[{
            'level':level,
            'unfoldable':unfoldable,
            'date':move_line.move_id.date,
            'parent_id':parent_id,
            'is_used':bool(is_used),
            'usage':self._get_usage(move_line),
            'model_id':move_line.id,
            'model':'stock.move.line',
            'product_id':move_line.product_id.display_name,
            'product_qty_uom':"%s%s"%(self._quantity_to_str(move_line.product_uom_id,move_line.product_id.uom_id,move_line.qty_done),move_line.product_id.uom_id.name),
            'lot_name':move_line.lot_id.name,
            'lot_id':move_line.lot_id.id,
            'location_source':move_line.location_id.name,
            'location_destination':move_line.location_dest_id.name,
            'reference_id':ref,
            'res_id':res_id,
            'res_model':res_model}]
        returndata

    @api.model
    def_final_vals_to_lines(self,final_vals,level):
        lines=[]
        fordatainfinal_vals:
            lines.append({
                'id':autoIncrement(),
                'model':data['model'],
                'model_id':data['model_id'],
                'parent_id':data['parent_id'],
                'usage':data.get('usage',False),
                'is_used':data.get('is_used',False),
                'lot_name':data.get('lot_name',False),
                'lot_id':data.get('lot_id',False),
                'reference':data.get('reference_id',False),
                'res_id':data.get('res_id',False),
                'res_model':data.get('res_model',False),
                'columns':[data.get('reference_id',False),
                            data.get('product_id',False),
                            format_datetime(self.env,data.get('date',False),tz=False,dt_format=False),
                            data.get('lot_name',False),
                            data.get('location_source',False),
                            data.get('location_destination',False),
                            data.get('product_qty_uom',0)],
                'level':level,
                'unfoldable':data['unfoldable'],
            })
        returnlines

    def_get_linked_move_lines(self,move_line):
        """Thismethodwillreturntheconsumedlineorproducedlineforthisoperation."""
        returnFalse,False

    @api.model
    def_lines(self,line_id=None,model_id=False,model=False,level=0,move_lines=[],**kw):
        final_vals=[]
        lines=move_linesor[]
        ifmodelandline_id:
            move_line=self.env[model].browse(model_id)
            move_lines,is_used=self._get_linked_move_lines(move_line)
            ifmove_lines:
                lines=move_lines
            else:
                #Traceabilityincaseofconsumedin.
                lines=self._get_move_lines(move_line,line_id=line_id)
        forlineinlines:
            unfoldable=False
            ifline.consume_line_idsor(model!="stock.production.lot"andline.lot_idandself._get_move_lines(line)):
                unfoldable=True
            final_vals+=self._make_dict_move(level,parent_id=line_id,move_line=line,unfoldable=unfoldable)
        returnfinal_vals

    defget_pdf_lines(self,line_data=[]):
        lines=[]
        forlineinline_data:
            model=self.env[line['model_name']].browse(line['model_id'])
            unfoldable=False
            ifline.get('unfoldable'):
                unfoldable=True
            final_vals=self._make_dict_move(line['level'],parent_id=line['id'],move_line=model,unfoldable=unfoldable)
            lines.append(self._final_vals_to_lines(final_vals,line['level'])[0])
        returnlines

    defget_pdf(self,line_data=[]):
        lines=self.with_context(print_mode=True).get_pdf_lines(line_data)
        base_url=self.env['ir.config_parameter'].sudo().get_param('web.base.url')
        rcontext={
            'mode':'print',
            'base_url':base_url,
        }

        context=dict(self.env.context)
        ifnotconfig['test_enable']:
            context['commit_assetsbundle']=True

        body=self.env['ir.ui.view'].with_context(context)._render_template(
            "stock.report_stock_inventory_print",
            values=dict(rcontext,lines=lines,report=self,context=self),
        )

        header=self.env['ir.actions.report']._render_template("web.internal_layout",values=rcontext)
        header=self.env['ir.actions.report']._render_template("web.minimal_layout",values=dict(rcontext,subst=True,body=header))

        returnself.env['ir.actions.report']._run_wkhtmltopdf(
            [body],
            header=header,
            landscape=True,
            specific_paperformat_args={'data-report-margin-top':10,'data-report-header-spacing':10}
        )

    def_get_html(self):
        result={}
        rcontext={}
        context=dict(self.env.context)
        rcontext['lines']=self.with_context(context).get_lines()
        result['html']=self.env.ref('stock.report_stock_inventory')._render(rcontext)
        returnresult

    @api.model
    defget_html(self,given_context=None):
        res=self.search([('create_uid','=',self.env.uid)],limit=1)
        ifnotres:
            returnself.create({}).with_context(given_context)._get_html()
        returnres.with_context(given_context)._get_html()

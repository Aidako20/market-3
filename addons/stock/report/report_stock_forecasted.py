#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

fromcollectionsimportdefaultdict

fromflectraimportapi,models
fromflectra.toolsimportfloat_is_zero,format_datetime,format_date,float_round


classReplenishmentReport(models.AbstractModel):
    _name='report.stock.report_product_product_replenishment'
    _description="StockReplenishmentReport"

    def_product_domain(self,product_template_ids,product_variant_ids):
        ifproduct_template_ids:
            return[('product_tmpl_id','in',product_template_ids)]
        return[('product_id','in',product_variant_ids)]

    def_move_domain(self,product_template_ids,product_variant_ids,wh_location_ids):
        move_domain=self._product_domain(product_template_ids,product_variant_ids)
        move_domain+=[('product_uom_qty','!=',0)]
        out_domain=move_domain+[
            '&',
            ('location_id','in',wh_location_ids),
            ('location_dest_id','notin',wh_location_ids),
        ]
        in_domain=move_domain+[
            '&',
            ('location_id','notin',wh_location_ids),
            ('location_dest_id','in',wh_location_ids),
        ]
        returnin_domain,out_domain

    def_move_draft_domain(self,product_template_ids,product_variant_ids,wh_location_ids):
        in_domain,out_domain=self._move_domain(product_template_ids,product_variant_ids,wh_location_ids)
        in_domain+=[('state','=','draft')]
        out_domain+=[('state','=','draft')]
        returnin_domain,out_domain

    def_move_confirmed_domain(self,product_template_ids,product_variant_ids,wh_location_ids):
        in_domain,out_domain=self._move_domain(product_template_ids,product_variant_ids,wh_location_ids)
        out_domain+=[('state','notin',['draft','cancel','done'])]
        in_domain+=[('state','notin',['draft','cancel','done'])]
        returnin_domain,out_domain

    def_compute_draft_quantity_count(self,product_template_ids,product_variant_ids,wh_location_ids):
        in_domain,out_domain=self._move_draft_domain(product_template_ids,product_variant_ids,wh_location_ids)
        incoming_moves=self.env['stock.move'].read_group(in_domain,['product_qty:sum'],'product_id')
        outgoing_moves=self.env['stock.move'].read_group(out_domain,['product_qty:sum'],'product_id')
        in_sum=sum(move['product_qty']formoveinincoming_moves)
        out_sum=sum(move['product_qty']formoveinoutgoing_moves)
        return{
            'draft_picking_qty':{
                'in':in_sum,
                'out':out_sum
            },
            'qty':{
                'in':in_sum,
                'out':out_sum
            }
        }

    @api.model
    def_get_report_values(self,docids,data=None):
        return{
            'data':data,
            'doc_ids':docids,
            'doc_model':'product.product',
            'docs':self._get_report_data(product_variant_ids=docids),
        }

    def_get_report_data(self,product_template_ids=False,product_variant_ids=False):
        assertproduct_template_idsorproduct_variant_ids
        res={}

        #Getthewarehousewe'reworkingonaswellasitslocations.
        ifself.env.context.get('warehouse'):
            warehouse=self.env['stock.warehouse'].browse(self.env.context['warehouse'])
        else:
            warehouse=self.env['stock.warehouse'].search([
                ('company_id','=',self.env.company.id)
            ],limit=1)
            self.env.context=dict(self.env.context,warehouse=warehouse.id)
        wh_location_ids=[loc['id']forlocinself.env['stock.location'].search_read(
            [('id','child_of',warehouse.view_location_id.id)],
            ['id'],
        )]
        res['active_warehouse']=warehouse.display_name

        #Gettheproductswe'reworking,filltherenderingcontextwithsomeoftheirattributes.
        ifproduct_template_ids:
            product_templates=self.env['product.template'].browse(product_template_ids)
            res['product_templates']=product_templates
            res['product_variants']=product_templates.product_variant_ids
            res['multiple_product']=len(product_templates.product_variant_ids)>1
            res['uom']=product_templates[:1].uom_id.display_name
            res['quantity_on_hand']=sum(product_templates.mapped('qty_available'))
            res['virtual_available']=sum(product_templates.mapped('virtual_available'))
        elifproduct_variant_ids:
            product_variants=self.env['product.product'].browse(product_variant_ids)
            res['product_templates']=False
            res['product_variants']=product_variants
            res['multiple_product']=len(product_variants)>1
            res['uom']=product_variants[:1].uom_id.display_name
            res['quantity_on_hand']=sum(product_variants.mapped('qty_available'))
            res['virtual_available']=sum(product_variants.mapped('virtual_available'))
        res.update(self._compute_draft_quantity_count(product_template_ids,product_variant_ids,wh_location_ids))

        res['lines']=self._get_report_lines(product_template_ids,product_variant_ids,wh_location_ids)
        returnres

    def_prepare_report_line(self,quantity,move_out=None,move_in=None,replenishment_filled=True,product=False,reservation=False):
        timezone=self._context.get('tz')
        product=productor(move_out.product_idifmove_outelsemove_in.product_id)
        is_late=move_out.date<move_in.dateif(move_outandmove_in)elseFalse
        return{
            'document_in':move_in._get_source_document()ifmove_inelseFalse,
            'document_out':move_out._get_source_document()ifmove_outelseFalse,
            'product':{
                'id':product.id,
                'display_name':product.display_name
            },
            'replenishment_filled':replenishment_filled,
            'uom_id':product.uom_id,
            'receipt_date':format_datetime(self.env,move_in.date,timezone,dt_format=False)ifmove_inelseFalse,
            'delivery_date':format_datetime(self.env,move_out.date,timezone,dt_format=False)ifmove_outelseFalse,
            'is_late':is_late,
            'quantity':float_round(quantity,precision_rounding=product.uom_id.rounding),
            'move_out':move_out,
            'move_in':move_in,
            'reservation':reservation,
        }

    def_get_report_lines(self,product_template_ids,product_variant_ids,wh_location_ids):
        def_rollup_move_dests(move,seen):
            fordstinmove.move_dest_ids:
                ifdst.idnotinseen:
                    seen.add(dst.id)
                    _rollup_move_dests(dst,seen)
            returnseen

        def_reconcile_out_with_ins(lines,out,ins,demand,only_matching_move_dest=True):
            index_to_remove=[]
            forindex,in_inenumerate(ins):
                iffloat_is_zero(in_['qty'],precision_rounding=out.product_id.uom_id.rounding):
                    continue
                ifonly_matching_move_destandin_['move_dests']andout.idnotinin_['move_dests']:
                    continue
                taken_from_in=min(demand,in_['qty'])
                demand-=taken_from_in
                lines.append(self._prepare_report_line(taken_from_in,move_in=in_['move'],move_out=out))
                in_['qty']-=taken_from_in
                ifin_['qty']<=0:
                    index_to_remove.append(index)
                iffloat_is_zero(demand,precision_rounding=out.product_id.uom_id.rounding):
                    break
            forindexinindex_to_remove[::-1]:
                ins.pop(index)
            returndemand

        in_domain,out_domain=self._move_confirmed_domain(
            product_template_ids,product_variant_ids,wh_location_ids
        )
        outs=self.env['stock.move'].search(out_domain,order='prioritydesc,date,id')
        outs_per_product=defaultdict(lambda:[])
        outs_reservation={}
        foroutinouts:
            outs_per_product[out.product_id.id].append(out)
            outs_reservation[out.id]=out._get_orig_reserved_availability()
        ins=self.env['stock.move'].search(in_domain,order='prioritydesc,date,id')
        ins_per_product=defaultdict(lambda:[])
        forin_inins:
            ins_per_product[in_.product_id.id].append({
                'qty':in_.product_qty,
                'move':in_,
                'move_dests':_rollup_move_dests(in_,set())
            })
        currents={c['id']:c['qty_available']forcinouts.product_id.read(['qty_available'])}

        lines=[]
        forproductin(ins|outs).product_id:
            foroutinouts_per_product[product.id]:
                reserved_availability=outs_reservation[out.id]
                iffloat_is_zero(reserved_availability,precision_rounding=product.uom_id.rounding):
                    continue
                current=currents[out.product_id.id]
                reserved=out.product_uom._compute_quantity(reserved_availability,product.uom_id)
                currents[product.id]-=reserved
                lines.append(self._prepare_report_line(reserved,move_out=out,reservation=True))

            unreconciled_outs=[]
            foroutinouts_per_product[product.id]:
                reserved_availability=outs_reservation[out.id]
                #Reconcilewiththecurrentstock.
                current=currents[out.product_id.id]
                reserved=0.0
                ifnotfloat_is_zero(reserved_availability,precision_rounding=product.uom_id.rounding):
                    reserved=out.product_uom._compute_quantity(reserved_availability,product.uom_id)
                demand=out.product_qty-reserved
                taken_from_stock=min(demand,current)
                ifnotfloat_is_zero(taken_from_stock,precision_rounding=product.uom_id.rounding):
                    currents[product.id]-=taken_from_stock
                    demand-=taken_from_stock
                    lines.append(self._prepare_report_line(taken_from_stock,move_out=out))
                #Reconcilewiththeins.
                ifnotfloat_is_zero(demand,precision_rounding=product.uom_id.rounding):
                    demand=_reconcile_out_with_ins(lines,out,ins_per_product[out.product_id.id],demand,only_matching_move_dest=True)
                ifnotfloat_is_zero(demand,precision_rounding=product.uom_id.rounding):
                    unreconciled_outs.append((demand,out))
            ifunreconciled_outs:
                for(demand,out)inunreconciled_outs:
                    #Anotherpass,incasetherearesomeinslinkedtoadestmovebutthatstillhavesomequantityavailable
                    demand=_reconcile_out_with_ins(lines,out,ins_per_product[product.id],demand,only_matching_move_dest=False)
                    ifnotfloat_is_zero(demand,precision_rounding=product.uom_id.rounding):
                        #Notreconciled
                        lines.append(self._prepare_report_line(demand,move_out=out,replenishment_filled=False))
            #Unusedremainingstock.
            free_stock=currents.get(product.id,0)
            ifnotfloat_is_zero(free_stock,precision_rounding=product.uom_id.rounding):
                lines.append(self._prepare_report_line(free_stock,product=product))
            #Inmovesnotused.
            forin_inins_per_product[product.id]:
                iffloat_is_zero(in_['qty'],precision_rounding=product.uom_id.rounding):
                    continue
                lines.append(self._prepare_report_line(in_['qty'],move_in=in_['move']))
        returnlines

    @api.model
    defget_filter_state(self):
        res={}
        res['warehouses']=self.env['stock.warehouse'].search_read(fields=['id','name','code'])
        res['active_warehouse']=self.env.context.get('warehouse',False)
        ifnotres['active_warehouse']:
            company_id=self.env.context.get('allowed_company_ids')[0]
            res['active_warehouse']=self.env['stock.warehouse'].search([('company_id','=',company_id)],limit=1).id
        returnres


classReplenishmentTemplateReport(models.AbstractModel):
    _name='report.stock.report_product_template_replenishment'
    _description="StockReplenishmentReport"
    _inherit='report.stock.report_product_product_replenishment'

    @api.model
    def_get_report_values(self,docids,data=None):
        return{
            'data':data,
            'doc_ids':docids,
            'doc_model':'product.product',
            'docs':self._get_report_data(product_template_ids=docids),
        }

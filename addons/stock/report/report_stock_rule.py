#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

fromflectraimportapi,models,_
fromflectra.exceptionsimportUserError


classReportStockRule(models.AbstractModel):
    _name='report.stock.report_stock_rule'
    _description='Stockrulereport'

    @api.model
    def_get_report_values(self,docids,data=None):
        #Overridingdatavaluesheresinceusedalsoin_get_routes.
        data['product_id']=data.get('product_id',docids)
        data['warehouse_ids']=data.get('warehouse_ids',[])

        product=self.env['product.product'].browse(data['product_id'])
        warehouses=self.env['stock.warehouse'].browse(data['warehouse_ids'])

        routes=self._get_routes(data)

        #Someroutesdon'thaveawarehouse_idbutcontainrulesofdifferentwarehouses,
        #wefilterheretheoneswewanttodisplayandbuildforeachoneadictcontainingtherule,
        #theirsourceanddestinationlocation.
        relevant_rules=routes.mapped('rule_ids').filtered(lambdar:notr.warehouse_idorr.warehouse_idinwarehouses)
        rules_and_loc=[]
        forruleinrelevant_rules:
            rules_and_loc.append(self._get_rule_loc(rule,product))

        locations=self._sort_locations(rules_and_loc,warehouses)
        reordering_rules=self.env['stock.warehouse.orderpoint'].search([('product_id','=',product.id)])
        locations|=reordering_rules.mapped('location_id').filtered(lambdal:lnotinlocations)
        locations_names=locations.mapped('display_name')
        #Herewehandlereorderingrulesandputawaystrategiesbycreatingtheheader_linesdict.Thisdictisindexed
        #bylocation_idandcontainsitselfanotherdictwiththerelevantreorderingrulesandputawaystrategies.
        header_lines={}
        forlocationinlocations:
            #TODO:grouptheRRbylocation_idtoavoidafilteredateachloop
            rr=reordering_rules.filtered(lambdar:r.location_id.id==location.id)
            putaways=product.putaway_rule_ids.filtered(lambdap:p.location_in_id.id==location.id)
            ifputawaysorrr:
                header_lines[location.id]={'putaway':[],'orderpoint':[]}
                forputawayinputaways:
                    header_lines[location.id]['putaway'].append(putaway)
                forrinrr:
                    header_lines[location.id]['orderpoint'].append(r)
        route_lines=[]
        colors=self._get_route_colors()
        forcolor_index,routeinenumerate(routes):
            rules_to_display=route.rule_ids&relevant_rules
            ifrules_to_display:
                route_color=colors[color_index%len(colors)]
                color_index=color_index+1
                forruleinrules_to_display:
                    rule_loc=[rforrinrules_and_locifr['rule']==rule][0]
                    res=[]
                    forxinrange(len(locations_names)):
                        res.append([])
                    idx=locations_names.index(rule_loc['destination'].display_name)
                    tpl=(rule,'destination',route_color,)
                    res[idx]=tpl
                    idx=locations_names.index(rule_loc['source'].display_name)
                    tpl=(rule,'origin',route_color,)
                    res[idx]=tpl
                    route_lines.append(res)
        return{
            'docs':product,
            'locations':locations,
            'header_lines':header_lines,
            'route_lines':route_lines,
        }

    @api.model
    def_get_route_colors(self):
        return['#FFA500','#800080','#228B22','#008B8B','#4682B4','#FF0000','#32CD32']

    @api.model
    def_get_routes(self,data):
        """Extracttheroutestodisplayfromthewizard'scontent.
        """
        product=self.env['product.product'].browse(data['product_id'])
        warehouse_ids=self.env['stock.warehouse'].browse(data['warehouse_ids'])
        returnproduct.route_ids|product.categ_id.total_route_ids|warehouse_ids.mapped('route_ids')

    @api.model
    def_get_rule_loc(self,rule,product):
        rule.ensure_one()
        return{'rule':rule,'source':rule.location_src_id,'destination':rule.location_id}

    @api.model
    def_sort_locations(self,rules_and_loc,warehouses):
        """Weorderthelocationsbysettingfirstthelocationsoftypesupplierandmanufacture,
            thenweaddthelocationsgroupedbywarehouseandwefinishbythelocationsoftype
            customerandtheonesthatwerenotaddedbythesort.
        """
        all_src=self.env['stock.location'].concat(*([r['source']forrinrules_and_loc]))
        all_dest=self.env['stock.location'].concat(*([r['destination']forrinrules_and_loc]))
        all_locations=all_src|all_dest
        ordered_locations=self.env['stock.location']
        locations=all_locations.filtered(lambdal:l.usagein('supplier','production'))
        forwarehouse_idinwarehouses:
            all_warehouse_locations=all_locations.filtered(lambdal:l.get_warehouse()==warehouse_id)
            starting_rules=[dfordinrules_and_locifd['source']notinall_warehouse_locations]
            ifstarting_rules:
                start_locations=self.env['stock.location'].concat(*([r['destination']forrinstarting_rules]))
            else:
                starting_rules=[dfordinrules_and_locifd['source']notinall_dest]
                start_locations=self.env['stock.location'].concat(*([r['source']forrinstarting_rules]))
            used_rules=self.env['stock.rule']
            locations|=self._sort_locations_by_warehouse(rules_and_loc,used_rules,start_locations,ordered_locations,warehouse_id)
            ifany(locationnotinlocationsforlocationinall_warehouse_locations):
                remaining_locations=self.env['stock.location'].concat(*([r['source']forrinrules_and_loc])).filtered(lambdal:lnotinlocations)
                locations|=self._sort_locations_by_warehouse(rules_and_loc,used_rules,remaining_locations,ordered_locations,warehouse_id)
        locations|=all_locations.filtered(lambdal:l.usagein('customer'))
        locations|=all_locations.filtered(lambdal:lnotinlocations)
        returnlocations

    @api.model
    def_sort_locations_by_warehouse(self,rules_and_loc,used_rules,start_locations,ordered_locations,warehouse_id):
        """Weorderlocationsbyputtingfirstthelocationsthatarenotthedestinationofothersanddoitrecursively.
        """
        start_locations=start_locations.filtered(lambdal:l.get_warehouse()==warehouse_id)
        ordered_locations|=start_locations
        rules_start=[]
        forruleinrules_and_loc:
            ifrule['source']instart_locations:
                rules_start.append(rule)
                used_rules|=rule['rule']
        ifrules_start:
            rules_start_dest_locations=self.env['stock.location'].concat(*([r['destination']forrinrules_start]))
            remaining_rules=self.env['stock.rule'].concat(*([r['rule']forrinrules_and_loc]))-used_rules
            remaining_rules_location=self.env['stock.location']
            forrinrules_and_loc:
                ifr['rule']inremaining_rules:
                    remaining_rules_location|=r['destination']
            start_locations=rules_start_dest_locations-ordered_locations-remaining_rules_location
            ordered_locations=self._sort_locations_by_warehouse(rules_and_loc,used_rules,start_locations,ordered_locations,warehouse_id)
        returnordered_locations

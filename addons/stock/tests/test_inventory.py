#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.
fromflectra.exceptionsimportValidationError,UserError
fromflectra.tests.commonimportForm,SavepointCase


classTestInventory(SavepointCase):
    @classmethod
    defsetUpClass(cls):
        super(TestInventory,cls).setUpClass()
        cls.stock_location=cls.env.ref('stock.stock_location_stock')
        cls.pack_location=cls.env.ref('stock.location_pack_zone')
        cls.pack_location.active=True
        cls.customer_location=cls.env.ref('stock.stock_location_customers')
        cls.uom_unit=cls.env.ref('uom.product_uom_unit')
        cls.product1=cls.env['product.product'].create({
            'name':'ProductA',
            'type':'product',
            'categ_id':cls.env.ref('product.product_category_all').id,
        })
        cls.product2=cls.env['product.product'].create({
            'name':'ProductA',
            'type':'product',
            'tracking':'serial',
            'categ_id':cls.env.ref('product.product_category_all').id,
        })

    deftest_inventory_1(self):
        """Checkthatmakinganinventoryadjustmenttoremoveallproductsfromstockisworking
        asexpected.
        """
        #makesomestock
        self.env['stock.quant']._update_available_quantity(self.product1,self.stock_location,100)
        self.assertEqual(len(self.env['stock.quant']._gather(self.product1,self.stock_location)),1.0)
        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1,self.stock_location),100.0)

        #removethemwithaninventoryadjustment
        inventory=self.env['stock.inventory'].create({
            'name':'removeproduct1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory.action_start()
        self.assertEqual(len(inventory.line_ids),1)
        self.assertEqual(inventory.line_ids.theoretical_qty,100)
        inventory.line_ids.product_qty=0 #Putthequantitybackto0
        inventory.action_validate()

        #check
        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1,self.stock_location),0.0)
        self.assertEqual(sum(self.env['stock.quant']._gather(self.product1,self.stock_location).mapped('quantity')),0.0)

    deftest_inventory_2(self):
        """Checkthataddingatrackedproductthroughaninventoryadjustmentworkasexpected.
        """
        inventory=self.env['stock.inventory'].create({
            'name':'removeproduct1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product2.id)]
        })
        inventory.action_start()
        self.assertEqual(len(inventory.line_ids),0)

        lot1=self.env['stock.production.lot'].create({
            'name':'sn2',
            'product_id':self.product2.id,
            'company_id':self.env.company.id,
        })
        self.env['stock.inventory.line'].create({
            'inventory_id':inventory.id,
            'location_id':self.stock_location.id,
            'product_id':self.product2.id,
            'prod_lot_id':lot1.id,
            'product_qty':1
        })
        self.assertEqual(len(inventory.line_ids),1)
        self.assertEqual(inventory.line_ids.theoretical_qty,0)

        inventory.action_validate()

        #check
        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product2,self.stock_location,lot_id=lot1),1.0)
        self.assertEqual(len(self.env['stock.quant']._gather(self.product2,self.stock_location,lot_id=lot1)),1.0)
        self.assertEqual(lot1.product_qty,1.0)

    deftest_inventory_3(self):
        """Checkthatit'snotposisbletohavemultipleproductswithaserialnumberthroughan
        inventoryadjustment
        """
        inventory=self.env['stock.inventory'].create({
            'name':'removeproduct1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product2.id)]
        })
        inventory.action_start()
        self.assertEqual(len(inventory.line_ids),0)

        lot1=self.env['stock.production.lot'].create({
            'name':'sn2',
            'product_id':self.product2.id,
            'company_id':self.env.company.id,
        })
        self.env['stock.inventory.line'].create({
            'inventory_id':inventory.id,
            'location_id':self.stock_location.id,
            'product_id':self.product2.id,
            'prod_lot_id':lot1.id,
            'product_qty':2
        })
        self.assertEqual(len(inventory.line_ids),1)
        self.assertEqual(inventory.line_ids.theoretical_qty,0)

        withself.assertRaises(ValidationError):
            inventory.action_validate()

    deftest_inventory_4(self):
        """Checkthatevenifaproductistrackedbyserialnumber,it'spossibletoadd
        untrackedoneinaninventoryadjustment.
        """
        inventory=self.env['stock.inventory'].create({
            'name':'removeproduct1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product2.id)]
        })
        inventory.action_start()
        self.assertEqual(len(inventory.line_ids),0)
        lot1=self.env['stock.production.lot'].create({
            'name':'sn2',
            'product_id':self.product2.id,
            'company_id':self.env.company.id,
        })
        self.env['stock.inventory.line'].create({
            'inventory_id':inventory.id,
            'product_id':self.product2.id,
            'prod_lot_id':lot1.id,
            'product_qty':1,
            'location_id':self.stock_location.id,
        })
        self.assertEqual(len(inventory.line_ids),1)
        self.assertEqual(inventory.line_ids.theoretical_qty,0)

        self.env['stock.inventory.line'].create({
            'inventory_id':inventory.id,
            'product_id':self.product2.id,
            'product_uom_id':self.uom_unit.id,
            'product_qty':10,
            'location_id':self.stock_location.id,
        })
        self.assertEqual(len(inventory.line_ids),2)
        res_dict_for_warning_lot=inventory.action_validate()
        wizard_warning_lot=self.env[(res_dict_for_warning_lot.get('res_model'))].browse(res_dict_for_warning_lot.get('res_id'))
        wizard_warning_lot.action_confirm()

        #check
        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product2,self.stock_location,lot_id=lot1,strict=True),11.0)
        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product2,self.stock_location,strict=True),10.0)
        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product2,self.stock_location),11.0)
        self.assertEqual(len(self.env['stock.quant']._gather(self.product2,self.stock_location,lot_id=lot1,strict=True).filtered(lambdaq:q.lot_id)),1.0)
        self.assertEqual(len(self.env['stock.quant']._gather(self.product2,self.stock_location,strict=True)),1.0)
        self.assertEqual(len(self.env['stock.quant']._gather(self.product2,self.stock_location)),2.0)

    deftest_inventory_5(self):
        """Checkthatassigninganownerdoeswork.
        """
        owner1=self.env['res.partner'].create({'name':'test_inventory_5'})

        inventory=self.env['stock.inventory'].create({
            'name':'removeproduct1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)]
        })
        inventory.action_start()
        self.assertEqual(len(inventory.line_ids),0)

        self.env['stock.inventory.line'].create({
            'inventory_id':inventory.id,
            'product_id':self.product1.id,
            'partner_id':owner1.id,
            'product_qty':5,
            'location_id':self.stock_location.id,
        })
        self.assertEqual(len(inventory.line_ids),1)
        self.assertEqual(inventory.line_ids.theoretical_qty,0)
        inventory.action_validate()

        quant=self.env['stock.quant']._gather(self.product1,self.stock_location)
        self.assertEqual(len(quant),1)
        self.assertEqual(quant.quantity,5)
        self.assertEqual(quant.owner_id.id,owner1.id)

    deftest_inventory_6(self):
        """Testthatforchainedmoves,makinganinventoryadjustmenttoreduceaquantitythat
        hasbeenreservedcorrectlyfreethereservation.Afterthat,addproductsinstockandcheck
        thatthey'reusediftheuserencodesmorethanwhat'savailablethroughthechain
        """
        #add10productsinstock
        inventory=self.env['stock.inventory'].create({
            'name':'add10products1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)]
        })
        inventory.action_start()
        self.env['stock.inventory.line'].create({
            'inventory_id':inventory.id,
            'product_id':self.product1.id,
            'product_qty':10,
            'location_id':self.stock_location.id
        })
        inventory.action_validate()
        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1,self.stock_location),10.0)

        #Makeachainoftwomoves,validatethefirstandcheckthat10productsarereserved
        #inthesecondone.
        move_stock_pack=self.env['stock.move'].create({
            'name':'test_link_2_1',
            'location_id':self.stock_location.id,
            'location_dest_id':self.pack_location.id,
            'product_id':self.product1.id,
            'product_uom':self.uom_unit.id,
            'product_uom_qty':10.0,
        })
        move_pack_cust=self.env['stock.move'].create({
            'name':'test_link_2_2',
            'location_id':self.pack_location.id,
            'location_dest_id':self.customer_location.id,
            'product_id':self.product1.id,
            'product_uom':self.uom_unit.id,
            'product_uom_qty':10.0,
        })
        move_stock_pack.write({'move_dest_ids':[(4,move_pack_cust.id,0)]})
        move_pack_cust.write({'move_orig_ids':[(4,move_stock_pack.id,0)]})
        (move_stock_pack+move_pack_cust)._action_confirm()
        move_stock_pack._action_assign()
        self.assertEqual(move_stock_pack.state,'assigned')
        move_stock_pack.move_line_ids.qty_done=10
        move_stock_pack._action_done()
        self.assertEqual(move_stock_pack.state,'done')
        self.assertEqual(move_pack_cust.state,'assigned')
        self.assertEqual(self.env['stock.quant']._gather(self.product1,self.pack_location).quantity,10.0)
        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1,self.pack_location),0.0)

        #Makeandinventoryadjustmentandremovetwoproductsfromthepacklocation.Thisshould
        #freethereservationofthesecondmove.
        inventory=self.env['stock.inventory'].create({
            'name':'remove2products1',
            'location_ids':[(4,self.pack_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory.action_start()
        inventory.line_ids.product_qty=8
        inventory.action_validate()
        self.assertEqual(self.env['stock.quant']._gather(self.product1,self.pack_location).quantity,8.0)
        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1,self.pack_location),0)
        self.assertEqual(move_pack_cust.state,'partially_available')
        self.assertEqual(move_pack_cust.reserved_availability,8)

        #Iftheusertriestoassignagain,only8productsareavailableandthusthereservation
        #stateshouldnotchange.
        move_pack_cust._action_assign()
        self.assertEqual(move_pack_cust.state,'partially_available')
        self.assertEqual(move_pack_cust.reserved_availability,8)

        #Makeanewinventoryadjustmentandbringtwonowproducts.
        inventory=self.env['stock.inventory'].create({
            'name':'remove2products1',
            'location_ids':[(4,self.pack_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory.action_start()
        inventory.line_ids.product_qty=10
        inventory.action_validate()

        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1,self.pack_location),2)

        #Nothingshouldhavechangedforourpackmove
        self.assertEqual(move_pack_cust.state,'partially_available')
        self.assertEqual(move_pack_cust.reserved_availability,8)

        #Running_action_assignwillnowfindthenewavailablequantity.Indeed,astheproducts
        #arenotdiscernabl(notlot/pack/owner),evenifthenewavailablequantityisnotdirectly
        #broughtbythechain,thesystemfilltakethemintoaccount.
        move_pack_cust._action_assign()
        self.assertEqual(move_pack_cust.state,'assigned')

        #moveallthethings
        move_pack_cust.move_line_ids.qty_done=10
        move_stock_pack._action_done()

        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1,self.pack_location),0)

    deftest_inventory_7(self):
        """Checkthatduplicatedquantscreateasingleinventoryline.
        """
        owner1=self.env['res.partner'].create({'name':'test_inventory_7'})
        vals={
            'product_id':self.product1.id,
            'product_uom_id':self.uom_unit.id,
            'owner_id':owner1.id,
            'location_id':self.stock_location.id,
            'quantity':1,
            'reserved_quantity':0,
        }
        self.env['stock.quant'].create(vals)
        self.env['stock.quant'].create(vals)
        self.assertEqual(len(self.env['stock.quant']._gather(self.product1,self.stock_location)),2.0)
        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1,self.stock_location),2.0)

        inventory=self.env['stock.inventory'].create({
            'name':'product1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory.action_start()
        self.assertEqual(len(inventory.line_ids),1)
        self.assertEqual(inventory.line_ids.theoretical_qty,2)

    deftest_inventory_8(self):
        """Checkinventorylinesproductquantityis0wheninventoryis
        startedwith`prefill_counted_quantity`disable.
        """
        self.env['stock.quant'].create({
            'product_id':self.product1.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'quantity':7,
            'reserved_quantity':0,
        })
        inventory_form=Form(self.env['stock.inventory'].with_context(
                default_prefill_counted_quantity='zero',
             ),view='stock.view_inventory_form')
        inventory=inventory_form.save()
        inventory.action_start()
        self.assertNotEqual(len(inventory.line_ids),0)
        #Checksallinventorylinesquantitiesarecorrectlyset.
        forlineininventory.line_ids:
            self.assertEqual(line.product_qty,0)
            self.assertNotEqual(line.theoretical_qty,0)

    deftest_inventory_9_cancel_then_start(self):
        """Checkswhenwecancelaninventory,thenchangeitslocationsand/or
        productssetupandrestartit,itwillremoveallitslinesandrestart
        likeanewinventory.
        """
        #Createssomerecordsneededforthetest...
        product2=self.env['product.product'].create({
            'name':'ProductB',
            'type':'product',
            'categ_id':self.env.ref('product.product_category_all').id,
        })
        loc1=self.env['stock.location'].create({
            'name':'SafeRoomA',
            'usage':'internal',
            'location_id':self.stock_location.id,
        })
        #Addssomequants.
        self.env['stock.quant'].create({
            'product_id':self.product1.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':loc1.id,
            'quantity':7,
            'reserved_quantity':0,
        })
        self.env['stock.quant'].create({
            'product_id':self.product1.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'quantity':7,
            'reserved_quantity':0,
        })
        self.env['stock.quant'].create({
            'product_id':product2.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':loc1.id,
            'quantity':7,
            'reserved_quantity':0,
        })
        self.env['stock.quant'].create({
            'product_id':product2.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'quantity':7,
            'reserved_quantity':0,
        })
        #Createstheinventoryandconfiguresifforproduct1
        inventory_form=Form(self.env['stock.inventory'],view='stock.view_inventory_form')
        inventory_form.product_ids.add(self.product1)
        inventory=inventory_form.save()
        inventory.action_start()
        #Musthavetwoinventorylinesaboutproduct1.
        self.assertEqual(len(inventory.line_ids),2)
        forlineininventory.line_ids:
            self.assertEqual(line.product_id.id,self.product1.id)

        #Cancelstheinventoryandchangesforproduct2initssetup.
        inventory.action_cancel_draft()
        inventory_form=Form(inventory)
        inventory_form.product_ids.remove(self.product1.id)
        inventory_form.product_ids.add(product2)
        inventory=inventory_form.save()
        inventory.action_start()
        #Musthavetwoinventorylinesaboutproduct2.
        self.assertEqual(len(inventory.line_ids),2)
        self.assertEqual(inventory.line_ids.product_id.id,product2.id)

    deftest_inventory_prefill_counted_quantity(self):
        """Checksthatinventorylineshavea`product_qty`setonzeroor
        equalstoquantityonhand,dependingofthe`prefill_counted_quantity`.
        """
        #Setproductquantityto42.
        vals={
            'product_id':self.product1.id,
            'location_id':self.stock_location.id,
            'quantity':42,
        }
        self.env['stock.quant'].create(vals)
        #Generatenewinventory,itslinemusthaveatheoretical
        #quantityto42andacountedquantityto42.
        inventory=self.env['stock.inventory'].create({
            'name':'DefaultQty',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
            'prefill_counted_quantity':'counted',
        })
        inventory.action_start()
        self.assertEqual(len(inventory.line_ids),1)
        self.assertEqual(inventory.line_ids.theoretical_qty,42)
        self.assertEqual(inventory.line_ids.product_qty,42)

        #Generatenewinventory,itslinemusthaveatheoretical
        #quantityto42andacountedquantityto0.
        inventory=self.env['stock.inventory'].create({
            'name':'DefaultQty',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
            'prefill_counted_quantity':'zero',
        })
        inventory.action_start()
        self.assertEqual(len(inventory.line_ids),1)
        self.assertEqual(inventory.line_ids.theoretical_qty,42)
        self.assertEqual(inventory.line_ids.product_qty,0)

    deftest_inventory_outdate_1(self):
        """Checksthatinventoryadjustmentlineismarkedasoutdatedafter
        itscorrespondingquantismodifyanditsvaluewascorrectlyupdated
        afteruserrefreshedit.
        """
        #Setinitialquantityto7
        vals={
            'product_id':self.product1.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'quantity':7,
            'reserved_quantity':0,
        }
        self.env['stock.quant'].create(vals)

        inventory=self.env['stock.inventory'].create({
            'name':'product1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory.action_start()
        #Whenainventorylineiscreated,itmustnotbemarkedasoutdated
        #andits`theoretical_qty`mustbeequalstoquantquantity.
        self.assertEqual(inventory.line_ids.outdated,False)
        self.assertEqual(inventory.line_ids.theoretical_qty,7)

        #Createsanewquantwho'llupdatetheexistingoneandsosetproduct
        #quantityto5.Thenexpectsinventorylinehasbeenmarkedasoutdated.
        vals={
            'product_id':self.product1.id,
            'location_id':self.stock_location.id,
            'inventory_quantity':5,
        }
        self.env['stock.quant'].with_context(inventory_mode=True).create(vals)
        self.assertEqual(inventory.line_ids.outdated,True)
        self.assertEqual(inventory.line_ids.theoretical_qty,7)
        #Refreshesinventorylineandexpectsquantitywasrecomputedto5
        inventory.line_ids.action_refresh_quantity()
        self.assertEqual(inventory.line_ids.outdated,False)
        self.assertEqual(inventory.line_ids.theoretical_qty,5)

    deftest_inventory_outdate_2(self):
        """Checksthatinventoryadjustmentlineismarkedasoutdatedwhena
        quantismanuallyupdatedanditsvalueiscorrectlyupdatedwhenaction
        torefreshiscalled.
        """
        #Setinitialquantityto7
        vals={
            'product_id':self.product1.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'quantity':7,
            'reserved_quantity':0,
        }
        quant=self.env['stock.quant'].create(vals)

        inventory=self.env['stock.inventory'].create({
            'name':'product1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory.action_start()
        self.assertEqual(inventory.line_ids.outdated,False)
        self.assertEqual(inventory.line_ids.theoretical_qty,7)

        #Decreasesquantto3andexpectsinventorylineisnowoutdated
        quant.with_context(inventory_mode=True).write({'inventory_quantity':3})
        self.assertEqual(inventory.line_ids.outdated,True)
        self.assertEqual(inventory.line_ids.theoretical_qty,7)
        #Refreshesinventorylineandexpectsquantitywasrecomputedto3
        inventory.line_ids.action_refresh_quantity()
        self.assertEqual(inventory.line_ids.outdated,False)
        self.assertEqual(inventory.line_ids.theoretical_qty,3)

    deftest_inventory_outdate_3(self):
        """ Checksthatoutdatedinventoryadjustmentlinewithoutdifference
        doesn'tchangequantwhenvalidated.
        """
        #Setinitialquantityto10
        vals={
            'product_id':self.product1.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'quantity':10,
            'reserved_quantity':0,
        }
        quant=self.env['stock.quant'].create(vals)

        inventory=self.env['stock.inventory'].create({
            'name':'product1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory.action_start()
        self.assertEqual(inventory.line_ids.outdated,False)
        self.assertEqual(inventory.line_ids.theoretical_qty,10)

        #increasesquantto15andexpectsinventorylineisnowoutdated
        quant.with_context(inventory_mode=True).write({'inventory_quantity':15})
        self.assertEqual(inventory.line_ids.outdated,True)
        #Don'trefreshinventorylinebutvalidit,andexpectquantityis
        #stillequalto15
        inventory.action_validate()
        self.assertEqual(inventory.line_ids.theoretical_qty,10)
        self.assertEqual(quant.quantity,15)

    deftest_inventory_outdate_4(self):
        """Checksthatoutdatedinventoryadjustmentlinewithdifference
        changesquantwhenvalidated.
        """
        #Setinitialquantityto10
        vals={
            'product_id':self.product1.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'quantity':10,
            'reserved_quantity':0,
        }
        quant=self.env['stock.quant'].create(vals)

        inventory=self.env['stock.inventory'].create({
            'name':'product1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory.action_start()
        self.assertEqual(inventory.line_ids.outdated,False)
        self.assertEqual(inventory.line_ids.theoretical_qty,10)

        #increasesquantto15andexpectsinventorylineisnowoutdated
        quant.with_context(inventory_mode=True).write({'inventory_quantity':15})
        self.assertEqual(inventory.line_ids.outdated,True)
        #Don'trefreshinventorylinebutchangesitsvalueandvalidit,and
        #expectsquantityiscorrectlyadapted(15+inventorylinediff)
        inventory.line_ids.product_qty=12
        inventory.action_validate()
        self.assertEqual(inventory.line_ids.theoretical_qty,10)
        self.assertEqual(quant.quantity,17)

    deftest_inventory_outdate_5(self):
        """Checksthatinventoryadjustmentlineismarkedasoutdatedwhenan
        anotherinventoryadjustmentlinewithcommonproduct/locationis
        validatedanditsvalueisupdatedwhenactiontorefreshiscalled.
        """
        #Setinitialquantityto7
        vals={
            'product_id':self.product1.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'quantity':7,
            'reserved_quantity':0,
        }
        self.env['stock.quant'].create(vals)

        inventory_1=self.env['stock.inventory'].create({
            'name':'product1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory_1.action_start()
        inventory_2=self.env['stock.inventory'].create({
            'name':'product1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory_2.action_start()
        self.assertEqual(inventory_1.line_ids.outdated,False)
        self.assertEqual(inventory_1.line_ids.theoretical_qty,inventory_2.line_ids.theoretical_qty)

        #Setproductquantityto8ininventory2thenvalidatesit
        inventory_2.line_ids.product_qty=8
        inventory_2.action_validate()
        #Expectslineofinventory1isnowmarkedasoutdated
        self.assertEqual(inventory_1.line_ids.outdated,True)
        self.assertEqual(inventory_1.line_ids.theoretical_qty,7)
        #Refreshesinventorylineandexpectsquantitywasrecomputedto8
        inventory_1.line_ids.action_refresh_quantity()
        self.assertEqual(inventory_1.line_ids.theoretical_qty,8)

    deftest_inventory_dont_outdate_1(self):
        """Checksthatinventoryadjustmentlineisn'tmarkedasoutdatedwhen
        anotcorrespondingquantiscreated.
        """
        #Setinitialquantityto7andcreateinventoryadjustmentforproduct1
        vals={
            'product_id':self.product1.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'quantity':7,
            'reserved_quantity':0,
        }
        self.env['stock.quant'].create(vals)
        inventory=self.env['stock.inventory'].create({
            'name':'product1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory.action_start()
        self.assertEqual(inventory.line_ids.outdated,False)

        #Createquantforproduct3
        product3=self.env['product.product'].create({
            'name':'ProductC',
            'type':'product',
            'categ_id':self.env.ref('product.product_category_all').id,
        })
        vals={
            'product_id':product3.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'inventory_quantity':22,
            'reserved_quantity':0,
        }
        self.env['stock.quant'].create(vals)
        #Expectinventorylineisstilluptodate
        self.assertEqual(inventory.line_ids.outdated,False)

    deftest_inventory_dont_outdate_2(self):
        """Checksthatinventoryadjustmentlineisn'tmarkedasoutdatedwhen
        ananotherinventoryadjustmentlinewithoutcommonproduct/locationis
        validated.
        """
        #Setinitialquantityforproduct1andproduct3
        self.env['stock.quant'].create({
            'product_id':self.product1.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'quantity':7,
            'reserved_quantity':0,
        })
        product3=self.env['product.product'].create({
            'name':'ProductC',
            'type':'product',
            'categ_id':self.env.ref('product.product_category_all').id,
        })
        self.env['stock.quant'].create({
            'product_id':product3.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'quantity':10,
            'reserved_quantity':0,
        })

        inventory_1=self.env['stock.inventory'].create({
            'name':'product1',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory_1.action_start()
        inventory_2=self.env['stock.inventory'].create({
            'name':'product3',
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,product3.id)],
        })
        inventory_2.action_start()
        self.assertEqual(inventory_1.line_ids.outdated,False)

        #Setproduct3quantityto16ininventory2thenvalidatesit
        inventory_2.line_ids.product_qty=16
        inventory_2.action_validate()
        #Expectlineofinventory1isstilluptodate
        self.assertEqual(inventory_1.line_ids.outdated,False)

    deftest_inventory_include_exhausted_product(self):
        """Checksthatexhaustedproduct(quantnotsetor==0)isadded
        toinventoryline
        (onlyforlocation_idsselectedor,ifnotset,foreachmainlocation
        (linkeddirectlytothewarehouse)ofthecurrentcompany)
        whentheoptionisactive"""

        #location_idsSET+product_idsSET
        inventory=self.env['stock.inventory'].create({
            'name':'locSET-proSET',
            'exhausted':True,
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory.action_start()

        self.assertEqual(len(inventory.line_ids),1)
        self.assertEqual(inventory.line_ids.product_id.id,self.product1.id)
        self.assertEqual(inventory.line_ids.theoretical_qty,0)
        self.assertEqual(inventory.line_ids.location_id.id,self.stock_location.id)

        #location_idsSET+product_idsUNSET
        inventory=self.env['stock.inventory'].create({
            'name':'locSET-proUNSET',
            'exhausted':True,
            'location_ids':[(4,self.stock_location.id)]
        })
        inventory.action_start()
        line_ids_p1=[lforlininventory.line_idsifl['product_id']['id']==self.product1.id]
        line_ids_p2=[lforlininventory.line_idsifl['product_id']['id']==self.product2.id]
        self.assertEqual(len(line_ids_p1),1)
        self.assertEqual(len(line_ids_p2),1)
        self.assertEqual(line_ids_p1[0].location_id.id,self.stock_location.id)
        self.assertEqual(line_ids_p2[0].location_id.id,self.stock_location.id)

        #location_idsUNSET+product_idsSET
        warehouse=self.env['stock.warehouse'].create({
            'name':'Warhouse',
            'code':'WAR'
        })
        child_loc=self.env['stock.location'].create({
            'name':"ChildLOC",
            'usage':'internal',
            'location_id':warehouse.lot_stock_id.id
        })

        inventory=self.env['stock.inventory'].create({
            'name':'locUNSET-proSET',
            'exhausted':True,
            'product_ids':[(4,self.product1.id)],
        })
        inventory.action_start()

        line_ids=[lforlininventory.line_idsifl['location_id']['id']==warehouse.lot_stock_id.id]
        self.assertEqual(len(line_ids),1)
        self.assertEqual(line_ids[0].theoretical_qty,0)
        self.assertEqual(line_ids[0].product_id.id,self.product1.id)

        #Onlythemainlocationhaveaexhaustedline
        line_ids=[lforlininventory.line_idsifl['location_id']['id']==child_loc.id]
        self.assertEqual(len(line_ids),0)

        #location_idsUNSET+product_idsUNSET
        inventory=self.env['stock.inventory'].create({
            'name':'locUNSET-proUNSET',
            'exhausted':True
        })
        inventory.action_start()

        #Product1&Product2linewithwarehouselocation
        line_ids_p1=[lforlininventory.line_idsifl['product_id']['id']==self.product1.idandl['location_id']['id']==warehouse.lot_stock_id.id]
        line_ids_p2=[lforlininventory.line_idsifl['product_id']['id']==self.product2.idandl['location_id']['id']==warehouse.lot_stock_id.id]
        self.assertEqual(len(line_ids_p1),1)
        self.assertEqual(len(line_ids_p2),1)
        self.assertEqual(line_ids_p1[0].theoretical_qty,0)
        self.assertEqual(line_ids_p2[0].theoretical_qty,0)

        #location_idsSET+product_idsSETbutwhenproductinonelocationsbutnotheother
        self.env['stock.quant'].create({
            'product_id':self.product1.id,
            'product_uom_id':self.uom_unit.id,
            'location_id':self.stock_location.id,
            'quantity':10,
            'reserved_quantity':0,
        })
        inventory=self.env['stock.inventory'].create({
            'name':'locSET-proSET',
            'exhausted':True,
            'location_ids':[(4,self.stock_location.id),(4,warehouse.lot_stock_id.id)],
            'product_ids':[(4,self.product1.id)],
        })
        inventory.action_start()

        #needtohavelineforproduct1forbothlocation,onewithquanttheothernot
        line_ids_loc1=[lforlininventory.line_idsifl['location_id']['id']==self.stock_location.id]
        line_ids_loc2=[lforlininventory.line_idsifl['location_id']['id']==warehouse.lot_stock_id.id]
        self.assertEqual(len(line_ids_loc1),1)
        self.assertEqual(len(line_ids_loc2),1)
        self.assertEqual(line_ids_loc1[0].theoretical_qty,10)
        self.assertEqual(line_ids_loc2[0].theoretical_qty,0)

    deftest_inventory_line_duplicates(self):
        """Checksthatcreatingduplicatedinventorylines
        raisesaUserError.
        """
        inventory=self.env['stock.inventory'].create({
            'name':'ExistingInventory',
            'exhausted':True,
            'location_ids':[(4,self.stock_location.id)],
            'product_ids':[(4,self.product1.id)]
        })
        inventory.action_start()

        dup_vals=[{
            'inventory_id':inventory.id,
            'product_id':self.product1.id,
            'location_id':self.stock_location.id,
        }]

        withself.assertRaises(UserError),self.cr.savepoint():
            self.env['stock.inventory.line'].create(dup_vals)

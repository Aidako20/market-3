#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

importpytz
fromdateutil.parserimportparse
fromdateutil.relativedeltaimportrelativedelta

fromflectraimportapi,fields,models,tools,_


classMeeting(models.Model):
    _name='calendar.event'
    _inherit=['calendar.event','google.calendar.sync']

    google_id=fields.Char(
        'GoogleCalendarEventId',compute='_compute_google_id',store=True,readonly=False)

    @api.depends('recurrence_id.google_id')
    def_compute_google_id(self):
        #googleidsofrecurringeventsarebuiltfromtherecurrenceidandthe
        #originalstartingtimeintherecurrence.
        #The`start`fielddoesnotappearinthedependenciesonpurpose!
        #Eventiftheeventismoved,thegoogle_idremainsthesame.
        foreventinself:
            google_recurrence_id=event.recurrence_id._get_event_google_id(event)
            ifnotevent.google_idandgoogle_recurrence_id:
                event.google_id=google_recurrence_id
            elifnotevent.google_id:
                event.google_id=False

    @api.model
    def_get_google_synced_fields(self):
        return{'name','description','allday','start','date_end','stop',
                'attendee_ids','alarm_ids','location','privacy','active'}

    @api.model_create_multi
    defcreate(self,vals_list):
        returnsuper().create([
            dict(vals,need_sync=False)ifvals.get('recurrence_id')orvals.get('recurrency')elsevals
            forvalsinvals_list
        ])

    defwrite(self,values):
        recurrence_update_setting=values.get('recurrence_update')
        ifrecurrence_update_settingin('all_events','future_events')andlen(self)==1:
            values=dict(values,need_sync=False)
        res=super().write(values)
        ifrecurrence_update_settingin('all_events',)andlen(self)==1andvalues.keys()&self._get_google_synced_fields():
            self.recurrence_id.need_sync=True
        returnres

    def_get_sync_domain(self):
        return[('partner_ids.user_ids','in',self.env.user.id)]

    @api.model
    def_flectra_values(self,google_event,default_reminders=()):
        ifgoogle_event.is_cancelled():
            return{'active':False}

        #default_remindersisnever()itissettogoogle'sdefaultreminder(30minbefore)
        #weneedtocheck'useDefault'fortheeventtodetermineifwehavetousegoogle's
        #defaultreminderornot
        reminder_command=google_event.reminders.get('overrides')
        ifnotreminder_command:
            reminder_command=google_event.reminders.get('useDefault')anddefault_remindersor()
        alarm_commands=self._flectra_reminders_commands(reminder_command)
        attendee_commands,partner_commands=self._flectra_attendee_commands(google_event)
        values={
            'name':google_event.summaryor_("(Notitle)"),
            'description':google_event.description,
            'location':google_event.location,
            'user_id':google_event.owner(self.env).id,
            'privacy':google_event.visibilityorself.default_get(['privacy'])['privacy'],
            'attendee_ids':attendee_commands,
            'partner_ids':partner_commands,
            'alarm_ids':alarm_commands,
            'recurrency':google_event.is_recurrent()
        }

        ifnotgoogle_event.is_recurrence():
            values['google_id']=google_event.id
        ifgoogle_event.start.get('dateTime'):
            #startingfrompython3.7,usethenew[datetime,date].fromisoformatmethod
            start=parse(google_event.start.get('dateTime')).astimezone(pytz.utc).replace(tzinfo=None)
            stop=parse(google_event.end.get('dateTime')).astimezone(pytz.utc).replace(tzinfo=None)
            values['allday']=False
        else:
            start=parse(google_event.start.get('date'))
            stop=parse(google_event.end.get('date'))-relativedelta(days=1)
            stop=max(start,stop) #Forthecasesthatstartdateandenddatewerethesame
            values['allday']=True
        values['start']=start
        values['stop']=stop
        returnvalues

    @api.model
    def_flectra_attendee_commands(self,google_event):
        attendee_commands=[]
        partner_commands=[]
        google_attendees=google_event.attendeesor[]
        iflen(google_attendees)==0andgoogle_event.organizerandgoogle_event.organizer.get('self',False):
            user=google_event.owner(self.env)
            google_attendees+=[{
                'email':user.partner_id.email,
                'status':{'response':'accepted'},
            }]
        emails=[a.get('email')foraingoogle_attendees]
        existing_attendees=self.env['calendar.attendee']
        ifgoogle_event.exists(self.env):
            existing_attendees=self.browse(google_event.flectra_id(self.env)).attendee_ids
        attendees_by_emails={tools.email_normalize(a.email):aforainexisting_attendees}
        forattendeeingoogle_attendees:
            email=attendee.get('email')

            ifemailinattendees_by_emails:
                #Updateexistingattendees
                attendee_commands+=[(1,attendees_by_emails[email].id,{'state':attendee.get('responseStatus')})]
            else:
                #Createnewattendees
                partner=self.env.user.partner_idifattendee.get('self')elseself.env['res.partner'].find_or_create(attendee.get('email'))
                attendee_commands+=[(0,0,{'state':attendee.get('responseStatus'),'partner_id':partner.id})]
                partner_commands+=[(4,partner.id)]
                ifattendee.get('displayName')andnotpartner.name:
                    partner.name=attendee.get('displayName')
        forflectra_attendeeinattendees_by_emails.values():
            #Removeoldattendees
            iftools.email_normalize(flectra_attendee.email)notinemails:
                attendee_commands+=[(2,flectra_attendee.id)]
                partner_commands+=[(3,flectra_attendee.partner_id.id)]
        returnattendee_commands,partner_commands

    @api.model
    def_flectra_reminders_commands(self,reminders=()):
        commands=[]
        forreminderinreminders:
            alarm_type='email'ifreminder.get('method')=='email'else'notification'
            alarm_type_label=_("Email")ifalarm_type=='email'else_("Notification")

            minutes=reminder.get('minutes',0)
            alarm=self.env['calendar.alarm'].search([
                ('alarm_type','=',alarm_type),
                ('duration_minutes','=',minutes)
            ],limit=1)
            ifalarm:
                commands+=[(4,alarm.id)]
            else:
                ifminutes%(60*24)==0:
                    interval='days'
                    duration=minutes/60/24
                    name=_(
                        "%(reminder_type)s-%(duration)sDays",
                        reminder_type=alarm_type_label,
                        duration=duration,
                    )
                elifminutes%60==0:
                    interval='hours'
                    duration=minutes/60
                    name=_(
                        "%(reminder_type)s-%(duration)sHours",
                        reminder_type=alarm_type_label,
                        duration=duration,
                    )
                else:
                    interval='minutes'
                    duration=minutes
                    name=_(
                        "%(reminder_type)s-%(duration)sMinutes",
                        reminder_type=alarm_type_label,
                        duration=duration,
                    )
                commands+=[(0,0,{'duration':duration,'interval':interval,'name':name,'alarm_type':alarm_type})]
        returncommands

    def_google_values(self):
        ifself.allday:
            start={'date':self.start_date.isoformat()}
            end={'date':(self.stop_date+relativedelta(days=1)).isoformat()}
        else:
            start={'dateTime':pytz.utc.localize(self.start).isoformat()}
            end={'dateTime':pytz.utc.localize(self.stop).isoformat()}

        reminders=[{
            'method':"email"ifalarm.alarm_type=="email"else"popup",
            'minutes':alarm.duration_minutes
        }foralarminself.alarm_ids]
        values={
            'id':self.google_id,
            'start':start,
            'end':end,
            'summary':self.name,
            'description':self.descriptionor'',
            'location':self.locationor'',
            'guestsCanModify':True,
            'organizer':{'email':self.user_id.email,'self':self.user_id==self.env.user},
            'attendees':[{
                'email':attendee.email,
                'responseStatus':attendee.stateor'needsAction',
            }forattendeeinself.attendee_idsifattendee.email],
            'extendedProperties':{
                'shared':{
                    '%s_flectra_id'%self.env.cr.dbname:self.id,
                },
            },
            'reminders':{
                'overrides':reminders,
                'useDefault':False,
            }
        }
        ifself.privacy:
            values['visibility']=self.privacy
        ifnotself.active:
            values['status']='cancelled'
        ifself.user_idandself.user_id!=self.env.user:
            values['extendedProperties']['shared']['%s_owner_id'%self.env.cr.dbname]=self.user_id.id
        elifnotself.user_id:
            #Wedon'tstoretherealowneridentity(mail)
            #Wecan'tstoreonthesharedpropertiesinthatcasewithoutgettinga403
            #Ifseveralflectrausersareattendeesbuttheownerisnotinflectra,theeventwillbeduplicatedonflectradatabase
            #ifwearenottheowner,weshouldchangethepostvaluestoavoiderrorsbecausewedon'thaveenoughrights
            #Seehttps://developers.google.com/calendar/concepts/sharing
            keep_keys=['id','attendees','start','end','reminders']
            values={key:valforkey,valinvalues.items()ifkeyinkeep_keys}
            #values['extendedProperties']['private]shouldbeusediftheownerisnotanflectrauser
            values['extendedProperties']={
                'private':{
                    '%s_flectra_id'%self.env.cr.dbname:self.id,
                },
            }
        returnvalues

    def_cancel(self):
        #onlyownercandelete=>othersrefusetheevent
        user=self.env.user
        my_cancelled_records=self.filtered(lambdae:e.user_id==user)
        super(Meeting,my_cancelled_records)._cancel()
        attendees=(self-my_cancelled_records).attendee_ids.filtered(lambdaa:a.partner_id==user.partner_id)
        attendees.state='declined'

    def_notify_attendees(self):
        #filtereventsbeforenotifyingattendeesthroughcalendar_alarm_manager
        need_notifs=self.filtered(lambdaevent:event.alarm_idsandevent.stop>=fields.Datetime.now())
        partners=need_notifs.partner_ids
        ifpartners:
            self.env['calendar.alarm_manager']._notify_next_alarm(partners.ids)

    def_get_event_user(self):
        self.ensure_one()
        ifself.user_idandself.user_id.sudo().google_calendar_token:
            returnself.user_id
        returnself.env.user

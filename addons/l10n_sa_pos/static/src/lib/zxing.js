/*!
 *ZXing.jsv0.18.6
 *https://github.com/zxing-js/library
 *(c)2018ZXingforJSContributors
 *ReleasedundertheMITLicense
 */
(function(global,factory){
    typeofexports==='object'&&typeofmodule!=='undefined'?factory(exports):
    typeofdefine==='function'&&define.amd?define(['exports'],factory):
    (global=typeofglobalThis!=='undefined'?globalThis:global||self,factory(global.ZXing={}));
}(this,(function(exports){'usestrict';

    /*!*****************************************************************************
    Copyright(c)MicrosoftCorporation.Allrightsreserved.
    LicensedundertheApacheLicense,Version2.0(the"License");youmaynotuse
    thisfileexceptincompliancewiththeLicense.Youmayobtainacopyofthe
    Licenseathttp://www.apache.org/licenses/LICENSE-2.0

    THISCODEISPROVIDEDONAN*ASIS*BASIS,WITHOUTWARRANTIESORCONDITIONSOFANY
    KIND,EITHEREXPRESSORIMPLIED,INCLUDINGWITHOUTLIMITATIONANYIMPLIED
    WARRANTIESORCONDITIONSOFTITLE,FITNESSFORAPARTICULARPURPOSE,
    MERCHANTABLITYORNON-INFRINGEMENT.

    SeetheApacheVersion2.0Licenseforspecificlanguagegoverningpermissions
    andlimitationsundertheLicense.
    ******************************************************************************/
    /*globalReflect,Promise*/

    varextendStatics=Object.setPrototypeOf||
        ({__proto__:[]}instanceofArray&&function(d,b){d.__proto__=b;})||
        function(d,b){for(varpinb)if(b.hasOwnProperty(p))d[p]=b[p];};

    function__extends(d,b){
        extendStatics(d,b);
        function__(){this.constructor=d;}
        d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new__());
    }

    functionfixProto(target,prototype){
        varsetPrototypeOf=Object.setPrototypeOf;
        setPrototypeOf?setPrototypeOf(target,prototype):(target.__proto__=prototype);
    }

    functionfixStack(target,fn){
        if(fn===void0){
            fn=target.constructor;
        }
        varcaptureStackTrace=Error.captureStackTrace;
        captureStackTrace&&captureStackTrace(target,fn);
    }





    varCustomError=(function(_super){
        __extends(CustomError,_super);
        functionCustomError(message){
            var_newTarget=this.constructor;
            var_this=_super.call(this,message)||this;
            Object.defineProperty(_this,'name',{
                value:_newTarget.name,
                enumerable:false
            });
            fixProto(_this,_newTarget.prototype);
            fixStack(_this);
            return_this;
        }

        returnCustomError;
    })(Error);

    /**
     *CustomErrorclassoftypeException.
     */
    classExceptionextendsCustomError{
        /**
         *AllowsExceptiontobeconstructeddirectly
         *withsomemessageandprototypedefinition.
         */
        constructor(message=undefined){
            super(message);
            this.message=message;
        }
        getKind(){
            constex=this.constructor;
            returnex.kind;
        }
    }
    /**
     *It'stypedasstringsoitcanbeextendedandoverriden.
     */
    Exception.kind='Exception';

    /**
     *CustomErrorclassoftypeException.
     */
    classArgumentExceptionextendsException{
    }
    ArgumentException.kind='ArgumentException';

    /**
     *CustomErrorclassoftypeException.
     */
    classIllegalArgumentExceptionextendsException{
    }
    IllegalArgumentException.kind='IllegalArgumentException';

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    classBinaryBitmap{
        constructor(binarizer){
            this.binarizer=binarizer;
            if(binarizer===null){
                thrownewIllegalArgumentException('Binarizermustbenon-null.');
            }
        }
        /**
         *@returnThewidthofthebitmap.
         */
        getWidth(){
            returnthis.binarizer.getWidth();
        }
        /**
         *@returnTheheightofthebitmap.
         */
        getHeight(){
            returnthis.binarizer.getHeight();
        }
        /**
         *Convertsonerowofluminancedatato1bitdata.Mayactuallydotheconversion,orreturn
         *cacheddata.Callersshouldassumethismethodisexpensiveandcallitasseldomaspossible.
         *Thismethodisintendedfordecoding1Dbarcodesandmaychoosetoapplysharpening.
         *
         *@paramyTherowtofetch,whichmustbein[0,bitmapheight)
         *@paramrowAnoptionalpreallocatedarray.Ifnullortoosmall,itwillbeignored.
         *           Ifused,theBinarizerwillcallBitArray.clear().Alwaysusethereturnedobject.
         *@returnThearrayofbitsforthisrow(truemeansblack).
         *@throwsNotFoundExceptionifrowcan'tbebinarized
         */
        getBlackRow(y/*int*/,row){
            returnthis.binarizer.getBlackRow(y,row);
        }
        /**
         *Convertsa2Darrayofluminancedatato1bit.Asabove,assumethismethodisexpensive
         *anddonotcallitrepeatedly.Thismethodisintendedfordecoding2Dbarcodesandmayor
         *maynotapplysharpening.Therefore,arowfromthismatrixmaynotbeidenticaltoone
         *fetchedusinggetBlackRow(),sodon'tmixandmatchbetweenthem.
         *
         *@returnThe2Darrayofbitsfortheimage(truemeansblack).
         *@throwsNotFoundExceptionifimagecan'tbebinarizedtomakeamatrix
         */
        getBlackMatrix(){
            //Thematrixiscreatedondemandthefirsttimeitisrequested,thencached.Therearetwo
            //reasonsforthis:
            //1.Thisworkwillneverbedoneifthecalleronlyinstalls1DReaderobjects,orifa
            //   1DReaderfindsabarcodebeforethe2DReadersrun.
            //2.Thisworkwillonlybedoneonceevenifthecallerinstallsmultiple2DReaders.
            if(this.matrix===null||this.matrix===undefined){
                this.matrix=this.binarizer.getBlackMatrix();
            }
            returnthis.matrix;
        }
        /**
         *@returnWhetherthisbitmapcanbecropped.
         */
        isCropSupported(){
            returnthis.binarizer.getLuminanceSource().isCropSupported();
        }
        /**
         *Returnsanewobjectwithcroppedimagedata.Implementationsmaykeepareferencetothe
         *originaldataratherthanacopy.OnlycallableifisCropSupported()istrue.
         *
         *@paramleftTheleftcoordinate,whichmustbein[0,getWidth())
         *@paramtopThetopcoordinate,whichmustbein[0,getHeight())
         *@paramwidthThewidthoftherectangletocrop.
         *@paramheightTheheightoftherectangletocrop.
         *@returnAcroppedversionofthisobject.
         */
        crop(left/*int*/,top/*int*/,width/*int*/,height/*int*/){
            constnewSource=this.binarizer.getLuminanceSource().crop(left,top,width,height);
            returnnewBinaryBitmap(this.binarizer.createBinarizer(newSource));
        }
        /**
         *@returnWhetherthisbitmapsupportscounter-clockwiserotation.
         */
        isRotateSupported(){
            returnthis.binarizer.getLuminanceSource().isRotateSupported();
        }
        /**
         *Returnsanewobjectwithrotatedimagedataby90degreescounterclockwise.
         *Onlycallableif{@link#isRotateSupported()}istrue.
         *
         *@returnArotatedversionofthisobject.
         */
        rotateCounterClockwise(){
            constnewSource=this.binarizer.getLuminanceSource().rotateCounterClockwise();
            returnnewBinaryBitmap(this.binarizer.createBinarizer(newSource));
        }
        /**
         *Returnsanewobjectwithrotatedimagedataby45degreescounterclockwise.
         *Onlycallableif{@link#isRotateSupported()}istrue.
         *
         *@returnArotatedversionofthisobject.
         */
        rotateCounterClockwise45(){
            constnewSource=this.binarizer.getLuminanceSource().rotateCounterClockwise45();
            returnnewBinaryBitmap(this.binarizer.createBinarizer(newSource));
        }
        /*@Override*/
        toString(){
            try{
                returnthis.getBlackMatrix().toString();
            }
            catch(e/*:NotFoundException*/){
                return'';
            }
        }
    }

    /**
     *CustomErrorclassoftypeException.
     */
    classChecksumExceptionextendsException{
        staticgetChecksumInstance(){
            returnnewChecksumException();
        }
    }
    ChecksumException.kind='ChecksumException';

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *Thisclasshierarchyprovidesasetofmethodstoconvertluminancedatato1bitdata.
     *Itallowsthealgorithmtovarypolymorphically,forexampleallowingaveryexpensive
     *thresholdingtechniqueforserversandafastoneformobile.Italsopermitstheimplementation
     *tovary,e.g.aJNIversionforAndroidandaJavafallbackversionforotherplatforms.
     *
     *@authordswitkin@google.com(DanielSwitkin)
     */
    classBinarizer{
        constructor(source){
            this.source=source;
        }
        getLuminanceSource(){
            returnthis.source;
        }
        getWidth(){
            returnthis.source.getWidth();
        }
        getHeight(){
            returnthis.source.getHeight();
        }
    }

    classSystem{
        //publicstaticvoidarraycopy(Objectsrc,intsrcPos,Objectdest,intdestPos,intlength)
        /**
         *Makesacopyofaarray.
         */
        staticarraycopy(src,srcPos,dest,destPos,length){
            //TODO:betterusesplitorset?
            while(length--){
                dest[destPos++]=src[srcPos++];
            }
        }
        /**
         *Returnsthecurrenttimeinmilliseconds.
         */
        staticcurrentTimeMillis(){
            returnDate.now();
        }
    }

    /**
     *CustomErrorclassoftypeException.
     */
    classIndexOutOfBoundsExceptionextendsException{
    }
    IndexOutOfBoundsException.kind='IndexOutOfBoundsException';

    /**
     *CustomErrorclassoftypeException.
     */
    classArrayIndexOutOfBoundsExceptionextendsIndexOutOfBoundsException{
        constructor(index=undefined,message=undefined){
            super(message);
            this.index=index;
            this.message=message;
        }
    }
    ArrayIndexOutOfBoundsException.kind='ArrayIndexOutOfBoundsException';

    classArrays{
        /**
         *Assignsthespecifiedintvaluetoeachelementofthespecifiedarray
         *ofints.
         *
         *@paramathearraytobefilled
         *@paramvalthevaluetobestoredinallelementsofthearray
         */
        staticfill(a,val){
            for(leti=0,len=a.length;i<len;i++)
                a[i]=val;
        }
        /**
         *Assignsthespecifiedintvaluetoeachelementofthespecified
         *rangeofthespecifiedarrayofints. Therangetobefilled
         *extendsfromindex{@codefromIndex},inclusive,toindex
         *{@codetoIndex},exclusive. (If{@codefromIndex==toIndex},the
         *rangetobefilledisempty.)
         *
         *@paramathearraytobefilled
         *@paramfromIndextheindexofthefirstelement(inclusive)tobe
         *       filledwiththespecifiedvalue
         *@paramtoIndextheindexofthelastelement(exclusive)tobe
         *       filledwiththespecifiedvalue
         *@paramvalthevaluetobestoredinallelementsofthearray
         *@throwsIllegalArgumentExceptionif{@codefromIndex>toIndex}
         *@throwsArrayIndexOutOfBoundsExceptionif{@codefromIndex<0}or
         *        {@codetoIndex>a.length}
         */
        staticfillWithin(a,fromIndex,toIndex,val){
            Arrays.rangeCheck(a.length,fromIndex,toIndex);
            for(leti=fromIndex;i<toIndex;i++)
                a[i]=val;
        }
        /**
         *Checksthat{@codefromIndex}and{@codetoIndex}arein
         *therangeandthrowsanexceptioniftheyaren't.
         */
        staticrangeCheck(arrayLength,fromIndex,toIndex){
            if(fromIndex>toIndex){
                thrownewIllegalArgumentException('fromIndex('+fromIndex+')>toIndex('+toIndex+')');
            }
            if(fromIndex<0){
                thrownewArrayIndexOutOfBoundsException(fromIndex);
            }
            if(toIndex>arrayLength){
                thrownewArrayIndexOutOfBoundsException(toIndex);
            }
        }
        staticasList(...args){
            returnargs;
        }
        staticcreate(rows,cols,value){
            letarr=Array.from({length:rows});
            returnarr.map(x=>Array.from({length:cols}).fill(value));
        }
        staticcreateInt32Array(rows,cols,value){
            letarr=Array.from({length:rows});
            returnarr.map(x=>Int32Array.from({length:cols}).fill(value));
        }
        staticequals(first,second){
            if(!first){
                returnfalse;
            }
            if(!second){
                returnfalse;
            }
            if(!first.length){
                returnfalse;
            }
            if(!second.length){
                returnfalse;
            }
            if(first.length!==second.length){
                returnfalse;
            }
            for(leti=0,length=first.length;i<length;i++){
                if(first[i]!==second[i]){
                    returnfalse;
                }
            }
            returntrue;
        }
        statichashCode(a){
            if(a===null){
                return0;
            }
            letresult=1;
            for(constelementofa){
                result=31*result+element;
            }
            returnresult;
        }
        staticfillUint8Array(a,value){
            for(leti=0;i!==a.length;i++){
                a[i]=value;
            }
        }
        staticcopyOf(original,newLength){
            returnoriginal.slice(0,newLength);
        }
        staticcopyOfUint8Array(original,newLength){
            if(original.length<=newLength){
                constnewArray=newUint8Array(newLength);
                newArray.set(original);
                returnnewArray;
            }
            returnoriginal.slice(0,newLength);
        }
        staticcopyOfRange(original,from,to){
            constnewLength=to-from;
            constcopy=newInt32Array(newLength);
            System.arraycopy(original,from,copy,0,newLength);
            returncopy;
        }
        /*
        *Returnstheindexofoftheelementinasortedarrayor(-n-1)wherenistheinsertionpoint
        *forthenewelement.
        *Parameters:
        *    ar-Asortedarray
        *    el-Anelementtosearchfor
        *    comparator-Acomparatorfunction.Thefunctiontakestwoarguments:(a,b)andreturns:
        *       anegativenumber ifaislessthanb;
        *       0ifaisequaltob;
        *       apositivenumberofaisgreaterthanb.
        *Thearraymaycontainduplicateelements.Iftherearemorethanoneequalelementsinthearray,
        *thereturnedvaluecanbetheindexofanyoneoftheequalelements.
        *
        *http://jsfiddle.net/aryzhov/pkfst550/
        */
        staticbinarySearch(ar,el,comparator){
            if(undefined===comparator){
                comparator=Arrays.numberComparator;
            }
            letm=0;
            letn=ar.length-1;
            while(m<=n){
                constk=(n+m)>>1;
                constcmp=comparator(el,ar[k]);
                if(cmp>0){
                    m=k+1;
                }
                elseif(cmp<0){
                    n=k-1;
                }
                else{
                    returnk;
                }
            }
            return-m-1;
        }
        staticnumberComparator(a,b){
            returna-b;
        }
    }

    /**
     *PonyfillforJava'sIntegerclass.
     */
    classInteger{
        staticnumberOfTrailingZeros(i){
            lety;
            if(i===0)
                return32;
            letn=31;
            y=i<<16;
            if(y!==0){
                n-=16;
                i=y;
            }
            y=i<<8;
            if(y!==0){
                n-=8;
                i=y;
            }
            y=i<<4;
            if(y!==0){
                n-=4;
                i=y;
            }
            y=i<<2;
            if(y!==0){
                n-=2;
                i=y;
            }
            returnn-((i<<1)>>>31);
        }
        staticnumberOfLeadingZeros(i){
            //HD,Figure5-6
            if(i===0){
                return32;
            }
            letn=1;
            if(i>>>16===0){
                n+=16;
                i<<=16;
            }
            if(i>>>24===0){
                n+=8;
                i<<=8;
            }
            if(i>>>28===0){
                n+=4;
                i<<=4;
            }
            if(i>>>30===0){
                n+=2;
                i<<=2;
            }
            n-=i>>>31;
            returnn;
        }
        statictoHexString(i){
            returni.toString(16);
        }
        statictoBinaryString(intNumber){
            returnString(parseInt(String(intNumber),2));
        }
        //Returnsthenumberofone-bitsinthetwo'scomplementbinaryrepresentationofthespecifiedintvalue.Thisfunctionissometimesreferredtoasthepopulationcount.
        //Returns:
        //thenumberofone-bitsinthetwo'scomplementbinaryrepresentationofthespecifiedintvalue.
        staticbitCount(i){
            //HD,Figure5-2
            i=i-((i>>>1)&0x55555555);
            i=(i&0x33333333)+((i>>>2)&0x33333333);
            i=(i+(i>>>4))&0x0f0f0f0f;
            i=i+(i>>>8);
            i=i+(i>>>16);
            returni&0x3f;
        }
        statictruncDivision(dividend,divisor){
            returnMath.trunc(dividend/divisor);
        }
        /**
         *ConvertsAstringtoaninteger.
         *@paramsAstringtoconvertintoanumber.
         *@paramradixAvaluebetween2and36thatspecifiesthebaseofthenumberinnumString.Ifthisargumentisnotsupplied,stringswithaprefixof'0x'areconsideredhexadecimal.Allotherstringsareconsidereddecimal.
         */
        staticparseInt(num,radix=undefined){
            returnparseInt(num,radix);
        }
    }
    Integer.MIN_VALUE_32_BITS=-2147483648;
    Integer.MAX_VALUE=Number.MAX_SAFE_INTEGER;

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Asimple,fastarrayofbits,representedcompactlybyanarrayofintsinternally.</p>
     *
     *@authorSeanOwen
     */
    classBitArray/*implementsCloneable*/{
        //publicconstructor(){
        //  this.size=0
        //  this.bits=newInt32Array(1)
        //}
        //publicconstructor(size?:number/*int*/){
        //  if(undefined===size){
        //    this.size=0
        //  }else{
        //    this.size=size
        //  }
        //  this.bits=this.makeArray(size)
        //}
        //Fortestingonly
        constructor(size/*int*/,bits){
            if(undefined===size){
                this.size=0;
                this.bits=newInt32Array(1);
            }
            else{
                this.size=size;
                if(undefined===bits||null===bits){
                    this.bits=BitArray.makeArray(size);
                }
                else{
                    this.bits=bits;
                }
            }
        }
        getSize(){
            returnthis.size;
        }
        getSizeInBytes(){
            returnMath.floor((this.size+7)/8);
        }
        ensureCapacity(size/*int*/){
            if(size>this.bits.length*32){
                constnewBits=BitArray.makeArray(size);
                System.arraycopy(this.bits,0,newBits,0,this.bits.length);
                this.bits=newBits;
            }
        }
        /**
         *@paramibittoget
         *@returntrueiffbitiisset
         */
        get(i/*int*/){
            return(this.bits[Math.floor(i/32)]&(1<<(i&0x1F)))!==0;
        }
        /**
         *Setsbiti.
         *
         *@paramibittoset
         */
        set(i/*int*/){
            this.bits[Math.floor(i/32)]|=1<<(i&0x1F);
        }
        /**
         *Flipsbiti.
         *
         *@paramibittoset
         */
        flip(i/*int*/){
            this.bits[Math.floor(i/32)]^=1<<(i&0x1F);
        }
        /**
         *@paramfromfirstbittocheck
         *@returnindexoffirstbitthatisset,startingfromthegivenindex,orsizeifnoneareset
         * atorbeyondthisgivenindex
         *@see#getNextUnset(int)
         */
        getNextSet(from/*int*/){
            constsize=this.size;
            if(from>=size){
                returnsize;
            }
            constbits=this.bits;
            letbitsOffset=Math.floor(from/32);
            letcurrentBits=bits[bitsOffset];
            //maskofflesserbitsfirst
            currentBits&=~((1<<(from&0x1F))-1);
            constlength=bits.length;
            while(currentBits===0){
                if(++bitsOffset===length){
                    returnsize;
                }
                currentBits=bits[bitsOffset];
            }
            constresult=(bitsOffset*32)+Integer.numberOfTrailingZeros(currentBits);
            returnresult>size?size:result;
        }
        /**
         *@paramfromindextostartlookingforunsetbit
         *@returnindexofnextunsetbit,or{@codesize}ifnoneareunsetuntiltheend
         *@see#getNextSet(int)
         */
        getNextUnset(from/*int*/){
            constsize=this.size;
            if(from>=size){
                returnsize;
            }
            constbits=this.bits;
            letbitsOffset=Math.floor(from/32);
            letcurrentBits=~bits[bitsOffset];
            //maskofflesserbitsfirst
            currentBits&=~((1<<(from&0x1F))-1);
            constlength=bits.length;
            while(currentBits===0){
                if(++bitsOffset===length){
                    returnsize;
                }
                currentBits=~bits[bitsOffset];
            }
            constresult=(bitsOffset*32)+Integer.numberOfTrailingZeros(currentBits);
            returnresult>size?size:result;
        }
        /**
         *Setsablockof32bits,startingatbiti.
         *
         *@paramifirstbittoset
         *@paramnewBitsthenewvalueofthenext32bits.Noteagainthattheleast-significantbit
         *correspondstobiti,thenext-least-significanttoi+1,andsoon.
         */
        setBulk(i/*int*/,newBits/*int*/){
            this.bits[Math.floor(i/32)]=newBits;
        }
        /**
         *Setsarangeofbits.
         *
         *@paramstartstartofrange,inclusive.
         *@paramendendofrange,exclusive
         */
        setRange(start/*int*/,end/*int*/){
            if(end<start||start<0||end>this.size){
                thrownewIllegalArgumentException();
            }
            if(end===start){
                return;
            }
            end--;//willbeeasiertotreatthisasthelastactuallysetbit--inclusive
            constfirstInt=Math.floor(start/32);
            constlastInt=Math.floor(end/32);
            constbits=this.bits;
            for(leti=firstInt;i<=lastInt;i++){
                constfirstBit=i>firstInt?0:start&0x1F;
                constlastBit=i<lastInt?31:end&0x1F;
                //OnesfromfirstBittolastBit,inclusive
                constmask=(2<<lastBit)-(1<<firstBit);
                bits[i]|=mask;
            }
        }
        /**
         *Clearsallbits(setstofalse).
         */
        clear(){
            constmax=this.bits.length;
            constbits=this.bits;
            for(leti=0;i<max;i++){
                bits[i]=0;
            }
        }
        /**
         *Efficientmethodtocheckifarangeofbitsisset,ornotset.
         *
         *@paramstartstartofrange,inclusive.
         *@paramendendofrange,exclusive
         *@paramvalueiftrue,checksthatbitsinrangeareset,otherwisechecksthattheyarenotset
         *@returntrueiffallbitsaresetornotsetinrange,accordingtovalueargument
         *@throwsIllegalArgumentExceptionifendislessthanstartortherangeisnotcontainedinthearray
         */
        isRange(start/*int*/,end/*int*/,value){
            if(end<start||start<0||end>this.size){
                thrownewIllegalArgumentException();
            }
            if(end===start){
                returntrue;//emptyrangematches
            }
            end--;//willbeeasiertotreatthisasthelastactuallysetbit--inclusive
            constfirstInt=Math.floor(start/32);
            constlastInt=Math.floor(end/32);
            constbits=this.bits;
            for(leti=firstInt;i<=lastInt;i++){
                constfirstBit=i>firstInt?0:start&0x1F;
                constlastBit=i<lastInt?31:end&0x1F;
                //OnesfromfirstBittolastBit,inclusive
                constmask=(2<<lastBit)-(1<<firstBit)&0xFFFFFFFF;
                //TYPESCRIPTPORT:&0xFFFFFFFFaddedtodiscardanythingafter32bits,asEShas53bits
                //Returnfalseifwe'relookingfor1sandthemaskedbits[i]isn'tall1s(is:that,
                //equalsthemask,orwe'relookingfor0sandthemaskedportionisnotall0s
                if((bits[i]&mask)!==(value?mask:0)){
                    returnfalse;
                }
            }
            returntrue;
        }
        appendBit(bit){
            this.ensureCapacity(this.size+1);
            if(bit){
                this.bits[Math.floor(this.size/32)]|=1<<(this.size&0x1F);
            }
            this.size++;
        }
        /**
         *Appendstheleast-significantbits,fromvalue,inorderfrommost-significantto
         *least-significant.Forexample,appending6bitsfrom0x000001Ewillappendthebits
         *0,1,1,1,1,0inthatorder.
         *
         *@paramvalue{@codeint}containingbitstoappend
         *@paramnumBitsbitsfromvaluetoappend
         */
        appendBits(value/*int*/,numBits/*int*/){
            if(numBits<0||numBits>32){
                thrownewIllegalArgumentException('Numbitsmustbebetween0and32');
            }
            this.ensureCapacity(this.size+numBits);
            //constappendBit=this.appendBit;
            for(letnumBitsLeft=numBits;numBitsLeft>0;numBitsLeft--){
                this.appendBit(((value>>(numBitsLeft-1))&0x01)===1);
            }
        }
        appendBitArray(other){
            constotherSize=other.size;
            this.ensureCapacity(this.size+otherSize);
            //constappendBit=this.appendBit;
            for(leti=0;i<otherSize;i++){
                this.appendBit(other.get(i));
            }
        }
        xor(other){
            if(this.size!==other.size){
                thrownewIllegalArgumentException('Sizesdon\'tmatch');
            }
            constbits=this.bits;
            for(leti=0,length=bits.length;i<length;i++){
                //Thelastintcouldbeincomplete(i.e.nothave32bitsin
                //it)butthereisnoproblemsince0XOR0==0.
                bits[i]^=other.bits[i];
            }
        }
        /**
         *
         *@parambitOffsetfirstbittostartwriting
         *@paramarrayarraytowriteinto.Bytesarewrittenmost-significantbytefirst.Thisistheopposite
         * oftheinternalrepresentation,whichisexposedby{@link#getBitArray()}
         *@paramoffsetpositioninarraytostartwriting
         *@paramnumByteshowmanybytestowrite
         */
        toBytes(bitOffset/*int*/,array,offset/*int*/,numBytes/*int*/){
            for(leti=0;i<numBytes;i++){
                lettheByte=0;
                for(letj=0;j<8;j++){
                    if(this.get(bitOffset)){
                        theByte|=1<<(7-j);
                    }
                    bitOffset++;
                }
                array[offset+i]=/*(byte)*/theByte;
            }
        }
        /**
         *@returnunderlyingarrayofints.Thefirstelementholdsthefirst32bits,andtheleast
         *        significantbitisbit0.
         */
        getBitArray(){
            returnthis.bits;
        }
        /**
         *Reversesallbitsinthearray.
         */
        reverse(){
            constnewBits=newInt32Array(this.bits.length);
            //reverseallint'sfirst
            constlen=Math.floor((this.size-1)/32);
            constoldBitsLen=len+1;
            constbits=this.bits;
            for(leti=0;i<oldBitsLen;i++){
                letx=bits[i];
                x=((x>>1)&0x55555555)|((x&0x55555555)<<1);
                x=((x>>2)&0x33333333)|((x&0x33333333)<<2);
                x=((x>>4)&0x0f0f0f0f)|((x&0x0f0f0f0f)<<4);
                x=((x>>8)&0x00ff00ff)|((x&0x00ff00ff)<<8);
                x=((x>>16)&0x0000ffff)|((x&0x0000ffff)<<16);
                newBits[len-i]=/*(int)*/x;
            }
            //nowcorrecttheint'sifthebitsizeisn'tamultipleof32
            if(this.size!==oldBitsLen*32){
                constleftOffset=oldBitsLen*32-this.size;
                letcurrentInt=newBits[0]>>>leftOffset;
                for(leti=1;i<oldBitsLen;i++){
                    constnextInt=newBits[i];
                    currentInt|=nextInt<<(32-leftOffset);
                    newBits[i-1]=currentInt;
                    currentInt=nextInt>>>leftOffset;
                }
                newBits[oldBitsLen-1]=currentInt;
            }
            this.bits=newBits;
        }
        staticmakeArray(size/*int*/){
            returnnewInt32Array(Math.floor((size+31)/32));
        }
        /*@Override*/
        equals(o){
            if(!(oinstanceofBitArray)){
                returnfalse;
            }
            constother=o;
            returnthis.size===other.size&&Arrays.equals(this.bits,other.bits);
        }
        /*@Override*/
        hashCode(){
            return31*this.size+Arrays.hashCode(this.bits);
        }
        /*@Override*/
        toString(){
            letresult='';
            for(leti=0,size=this.size;i<size;i++){
                if((i&0x07)===0){
                    result+='';
                }
                result+=this.get(i)?'X':'.';
            }
            returnresult;
        }
        /*@Override*/
        clone(){
            returnnewBitArray(this.size,this.bits.slice());
        }
    }

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*namespacecom.google.zxing{*/
    /**
     *Encapsulatesatypeofhintthatacallermaypasstoabarcodereadertohelpit
     *morequicklyoraccuratelydecodeit.Itisuptoimplementationstodecidewhat,
     *ifanything,todowiththeinformationthatissupplied.
     *
     *@authorSeanOwen
     *@authordswitkin@google.com(DanielSwitkin)
     *@seeReader#decode(BinaryBitmap,java.util.Map)
     */
    varDecodeHintType;
    (function(DecodeHintType){
        /**
         *Unspecified,application-specifichint.Mapstoanunspecified{@linkObject}.
         */
        DecodeHintType[DecodeHintType["OTHER"]=0]="OTHER";/*(Object.class)*/
        /**
         *Imageisapuremonochromeimageofabarcode.Doesn'tmatterwhatitmapsto;
         *use{@linkBoolean#TRUE}.
         */
        DecodeHintType[DecodeHintType["PURE_BARCODE"]=1]="PURE_BARCODE";/*(Void.class)*/
        /**
         *Imageisknowntobeofoneofafewpossibleformats.
         *Mapstoa{@linkList}of{@linkBarcodeFormat}s.
         */
        DecodeHintType[DecodeHintType["POSSIBLE_FORMATS"]=2]="POSSIBLE_FORMATS";/*(List.class)*/
        /**
         *Spendmoretimetotrytofindabarcode;optimizeforaccuracy,notspeed.
         *Doesn'tmatterwhatitmapsto;use{@linkBoolean#TRUE}.
         */
        DecodeHintType[DecodeHintType["TRY_HARDER"]=3]="TRY_HARDER";/*(Void.class)*/
        /**
         *Specifieswhatcharacterencodingtousewhendecoding,whereapplicable(typeString)
         */
        DecodeHintType[DecodeHintType["CHARACTER_SET"]=4]="CHARACTER_SET";/*(String.class)*/
        /**
         *Allowedlengthsofencodeddata--rejectanythingelse.Mapstoan{@codeInt32Array}.
         */
        DecodeHintType[DecodeHintType["ALLOWED_LENGTHS"]=5]="ALLOWED_LENGTHS";/*(Int32Array.class)*/
        /**
         *AssumeCode39codesemployacheckdigit.Doesn'tmatterwhatitmapsto;
         *use{@linkBoolean#TRUE}.
         */
        DecodeHintType[DecodeHintType["ASSUME_CODE_39_CHECK_DIGIT"]=6]="ASSUME_CODE_39_CHECK_DIGIT";/*(Void.class)*/
        /**
         *AssumethebarcodeisbeingprocessedasaGS1barcode,andmodifybehaviorasneeded.
         *ForexamplethisaffectsFNC1handlingforCode128(akaGS1-128).Doesn'tmatterwhatitmapsto;
         *use{@linkBoolean#TRUE}.
         */
        DecodeHintType[DecodeHintType["ASSUME_GS1"]=7]="ASSUME_GS1";/*(Void.class)*/
        /**
         *Iftrue,returnthestartandenddigitsinaCodabarbarcodeinsteadofstrippingthem.They
         *arealpha,whereastherestarenumeric.Bydefault,theyarestripped,butthiscausesthem
         *tonotbe.Doesn'tmatterwhatitmapsto;use{@linkBoolean#TRUE}.
         */
        DecodeHintType[DecodeHintType["RETURN_CODABAR_START_END"]=8]="RETURN_CODABAR_START_END";/*(Void.class)*/
        /**
         *Thecallerneedstobenotifiedviacallbackwhenapossible{@linkResultPoint}
         *isfound.Mapstoa{@linkResultPointCallback}.
         */
        DecodeHintType[DecodeHintType["NEED_RESULT_POINT_CALLBACK"]=9]="NEED_RESULT_POINT_CALLBACK";/*(ResultPointCallback.class)*/
        /**
         *AllowedextensionlengthsforEANorUPCbarcodes.Otherformatswillignorethis.
         *Mapstoan{@codeInt32Array}oftheallowedextensionlengths,forexample[2],[5],or[2,5].
         *Ifitisoptionaltohaveanextension,donotsetthishint.Ifthisisset,
         *andaUPCorEANbarcodeisfoundbutanextensionisnot,thennoresultwillbereturned
         *atall.
         */
        DecodeHintType[DecodeHintType["ALLOWED_EAN_EXTENSIONS"]=10]="ALLOWED_EAN_EXTENSIONS";/*(Int32Array.class)*/
        //Endofenumerationvalues.
        /**
         *Datatypethehintisexpecting.
         *Amongthepossiblevaluesthe{@linkVoid}standsoutasbeingusedfor
         *hintsthatdonotexpectavaluetobesupplied(flaghints).Suchhints
         *willpossiblyhavetheirvalueignored,orreplacedbya
         *{@linkBoolean#TRUE}.Hintsuppliersshouldprobablyuse
         *{@linkBoolean#TRUE}asdirectedbytheactualhintdocumentation.
         */
        //privatevalueType:Class<?>
        //DecodeHintType(valueType:Class<?>){
        //  this.valueType=valueType
        //}
        //publicgetValueType():Class<?>{
        //  returnvalueType
        //}
    })(DecodeHintType||(DecodeHintType={}));
    varDecodeHintType$1=DecodeHintType;

    /**
     *CustomErrorclassoftypeException.
     */
    classFormatExceptionextendsException{
        staticgetFormatInstance(){
            returnnewFormatException();
        }
    }
    FormatException.kind='FormatException';

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*importjava.util.HashMap;*/
    /*importjava.util.Map;*/
    varCharacterSetValueIdentifiers;
    (function(CharacterSetValueIdentifiers){
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp437"]=0]="Cp437";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_1"]=1]="ISO8859_1";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_2"]=2]="ISO8859_2";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_3"]=3]="ISO8859_3";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_4"]=4]="ISO8859_4";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_5"]=5]="ISO8859_5";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_6"]=6]="ISO8859_6";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_7"]=7]="ISO8859_7";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_8"]=8]="ISO8859_8";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_9"]=9]="ISO8859_9";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_10"]=10]="ISO8859_10";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_11"]=11]="ISO8859_11";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_13"]=12]="ISO8859_13";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_14"]=13]="ISO8859_14";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_15"]=14]="ISO8859_15";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_16"]=15]="ISO8859_16";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["SJIS"]=16]="SJIS";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1250"]=17]="Cp1250";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1251"]=18]="Cp1251";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1252"]=19]="Cp1252";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1256"]=20]="Cp1256";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["UnicodeBigUnmarked"]=21]="UnicodeBigUnmarked";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["UTF8"]=22]="UTF8";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ASCII"]=23]="ASCII";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Big5"]=24]="Big5";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["GB18030"]=25]="GB18030";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["EUC_KR"]=26]="EUC_KR";
    })(CharacterSetValueIdentifiers||(CharacterSetValueIdentifiers={}));
    /**
     *EncapsulatesaCharacterSetECI,accordingto"ExtendedChannelInterpretations"5.3.1.1
     *ofISO18004.
     *
     *@authorSeanOwen
     */
    classCharacterSetECI{
        constructor(valueIdentifier,valuesParam,name,...otherEncodingNames){
            this.valueIdentifier=valueIdentifier;
            this.name=name;
            if(typeofvaluesParam==='number'){
                this.values=Int32Array.from([valuesParam]);
            }
            else{
                this.values=valuesParam;
            }
            this.otherEncodingNames=otherEncodingNames;
            CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier,this);
            CharacterSetECI.NAME_TO_ECI.set(name,this);
            constvalues=this.values;
            for(leti=0,length=values.length;i!==length;i++){
                constv=values[i];
                CharacterSetECI.VALUES_TO_ECI.set(v,this);
            }
            for(constotherNameofotherEncodingNames){
                CharacterSetECI.NAME_TO_ECI.set(otherName,this);
            }
        }
        //CharacterSetECI(value:number/*int*/){
        //  this(newInt32Array{value})
        //}
        //CharacterSetECI(value:number/*int*/,String...otherEncodingNames){
        //  this.values=newInt32Array{value}
        //  this.otherEncodingNames=otherEncodingNames
        //}
        //CharacterSetECI(values:Int32Array,String...otherEncodingNames){
        //  this.values=values
        //  this.otherEncodingNames=otherEncodingNames
        //}
        getValueIdentifier(){
            returnthis.valueIdentifier;
        }
        getName(){
            returnthis.name;
        }
        getValue(){
            returnthis.values[0];
        }
        /**
         *@paramvaluecharactersetECIvalue
         *@return{@codeCharacterSetECI}representingECIofgivenvalue,ornullifitislegalbut
         *  unsupported
         *@throwsFormatExceptionifECIvalueisinvalid
         */
        staticgetCharacterSetECIByValue(value/*int*/){
            if(value<0||value>=900){
                thrownewFormatException('incorectvalue');
            }
            constcharacterSet=CharacterSetECI.VALUES_TO_ECI.get(value);
            if(undefined===characterSet){
                thrownewFormatException('incorectvalue');
            }
            returncharacterSet;
        }
        /**
         *@paramnamecharactersetECIencodingname
         *@returnCharacterSetECIrepresentingECIforcharacterencoding,ornullifitislegal
         *  butunsupported
         */
        staticgetCharacterSetECIByName(name){
            constcharacterSet=CharacterSetECI.NAME_TO_ECI.get(name);
            if(undefined===characterSet){
                thrownewFormatException('incorectvalue');
            }
            returncharacterSet;
        }
        equals(o){
            if(!(oinstanceofCharacterSetECI)){
                returnfalse;
            }
            constother=o;
            returnthis.getName()===other.getName();
        }
    }
    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI=newMap();
    CharacterSetECI.VALUES_TO_ECI=newMap();
    CharacterSetECI.NAME_TO_ECI=newMap();
    //EnumnameisaJavaencodingvalidforjava.langandjava.io
    //TYPESCRIPTPORT:changedthemainlabelforISOastheTextEncoderdidnotrecognizedthemintheformfromjava
    //(egISO8859_1mustbeISO88591orISO8859-1orISO-8859-1)
    //lateron:well,except16wichdoesnotworkwithISO885916sousedISO-8859-1formfordefault
    CharacterSetECI.Cp437=newCharacterSetECI(CharacterSetValueIdentifiers.Cp437,Int32Array.from([0,2]),'Cp437');
    CharacterSetECI.ISO8859_1=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1,Int32Array.from([1,3]),'ISO-8859-1','ISO88591','ISO8859_1');
    CharacterSetECI.ISO8859_2=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2,4,'ISO-8859-2','ISO88592','ISO8859_2');
    CharacterSetECI.ISO8859_3=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3,5,'ISO-8859-3','ISO88593','ISO8859_3');
    CharacterSetECI.ISO8859_4=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4,6,'ISO-8859-4','ISO88594','ISO8859_4');
    CharacterSetECI.ISO8859_5=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5,7,'ISO-8859-5','ISO88595','ISO8859_5');
    CharacterSetECI.ISO8859_6=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6,8,'ISO-8859-6','ISO88596','ISO8859_6');
    CharacterSetECI.ISO8859_7=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7,9,'ISO-8859-7','ISO88597','ISO8859_7');
    CharacterSetECI.ISO8859_8=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8,10,'ISO-8859-8','ISO88598','ISO8859_8');
    CharacterSetECI.ISO8859_9=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9,11,'ISO-8859-9','ISO88599','ISO8859_9');
    CharacterSetECI.ISO8859_10=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10,12,'ISO-8859-10','ISO885910','ISO8859_10');
    CharacterSetECI.ISO8859_11=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11,13,'ISO-8859-11','ISO885911','ISO8859_11');
    CharacterSetECI.ISO8859_13=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13,15,'ISO-8859-13','ISO885913','ISO8859_13');
    CharacterSetECI.ISO8859_14=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14,16,'ISO-8859-14','ISO885914','ISO8859_14');
    CharacterSetECI.ISO8859_15=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15,17,'ISO-8859-15','ISO885915','ISO8859_15');
    CharacterSetECI.ISO8859_16=newCharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16,18,'ISO-8859-16','ISO885916','ISO8859_16');
    CharacterSetECI.SJIS=newCharacterSetECI(CharacterSetValueIdentifiers.SJIS,20,'SJIS','Shift_JIS');
    CharacterSetECI.Cp1250=newCharacterSetECI(CharacterSetValueIdentifiers.Cp1250,21,'Cp1250','windows-1250');
    CharacterSetECI.Cp1251=newCharacterSetECI(CharacterSetValueIdentifiers.Cp1251,22,'Cp1251','windows-1251');
    CharacterSetECI.Cp1252=newCharacterSetECI(CharacterSetValueIdentifiers.Cp1252,23,'Cp1252','windows-1252');
    CharacterSetECI.Cp1256=newCharacterSetECI(CharacterSetValueIdentifiers.Cp1256,24,'Cp1256','windows-1256');
    CharacterSetECI.UnicodeBigUnmarked=newCharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked,25,'UnicodeBigUnmarked','UTF-16BE','UnicodeBig');
    CharacterSetECI.UTF8=newCharacterSetECI(CharacterSetValueIdentifiers.UTF8,26,'UTF8','UTF-8');
    CharacterSetECI.ASCII=newCharacterSetECI(CharacterSetValueIdentifiers.ASCII,Int32Array.from([27,170]),'ASCII','US-ASCII');
    CharacterSetECI.Big5=newCharacterSetECI(CharacterSetValueIdentifiers.Big5,28,'Big5');
    CharacterSetECI.GB18030=newCharacterSetECI(CharacterSetValueIdentifiers.GB18030,29,'GB18030','GB2312','EUC_CN','GBK');
    CharacterSetECI.EUC_KR=newCharacterSetECI(CharacterSetValueIdentifiers.EUC_KR,30,'EUC_KR','EUC-KR');

    /**
     *CustomErrorclassoftypeException.
     */
    classUnsupportedOperationExceptionextendsException{
    }
    UnsupportedOperationException.kind='UnsupportedOperationException';

    /**
     *Responsibleforen/decodingstrings.
     */
    classStringEncoding{
        /**
         *DecodessomeUint8Arraytoastringformat.
         */
        staticdecode(bytes,encoding){
            constencodingName=this.encodingName(encoding);
            if(this.customDecoder){
                returnthis.customDecoder(bytes,encodingName);
            }
            //Increasesbrowsersupport.
            if(typeofTextDecoder==='undefined'||this.shouldDecodeOnFallback(encodingName)){
                returnthis.decodeFallback(bytes,encodingName);
            }
            returnnewTextDecoder(encodingName).decode(bytes);
        }
        /**
         *Checksifthedecodingmethodshouldusethefallbackfordecoding
         *onceNodeTextDecoderdoesn'tsupportallencodingformats.
         *
         *@paramencodingName
         */
        staticshouldDecodeOnFallback(encodingName){
            return!StringEncoding.isBrowser()&&encodingName==='ISO-8859-1';
        }
        /**
         *EncodessomestringintoaUint8Array.
         */
        staticencode(s,encoding){
            constencodingName=this.encodingName(encoding);
            if(this.customEncoder){
                returnthis.customEncoder(s,encodingName);
            }
            //Increasesbrowsersupport.
            if(typeofTextEncoder==='undefined'){
                returnthis.encodeFallback(s);
            }
            //TextEncoderonlyencodestoUTF8bydefaultasspecifiedbyencoding.spec.whatwg.org
            returnnewTextEncoder().encode(s);
        }
        staticisBrowser(){
            return(typeofwindow!=='undefined'&&{}.toString.call(window)==='[objectWindow]');
        }
        /**
         *Returnsthestringvaluefromsomeencodingcharacterset.
         */
        staticencodingName(encoding){
            returntypeofencoding==='string'
                ?encoding
                :encoding.getName();
        }
        /**
         *Returnscharactersetfromsomeencodingcharacterset.
         */
        staticencodingCharacterSet(encoding){
            if(encodinginstanceofCharacterSetECI){
                returnencoding;
            }
            returnCharacterSetECI.getCharacterSetECIByName(encoding);
        }
        /**
         *Runsafallbackforthenativedecodingfuncion.
         */
        staticdecodeFallback(bytes,encoding){
            constcharacterSet=this.encodingCharacterSet(encoding);
            if(StringEncoding.isDecodeFallbackSupported(characterSet)){
                lets='';
                for(leti=0,length=bytes.length;i<length;i++){
                    leth=bytes[i].toString(16);
                    if(h.length<2){
                        h='0'+h;
                    }
                    s+='%'+h;
                }
                returndecodeURIComponent(s);
            }
            if(characterSet.equals(CharacterSetECI.UnicodeBigUnmarked)){
                returnString.fromCharCode.apply(null,newUint16Array(bytes.buffer));
            }
            thrownewUnsupportedOperationException(`Encoding${this.encodingName(encoding)}notsupportedbyfallback.`);
        }
        staticisDecodeFallbackSupported(characterSet){
            returncharacterSet.equals(CharacterSetECI.UTF8)||
                characterSet.equals(CharacterSetECI.ISO8859_1)||
                characterSet.equals(CharacterSetECI.ASCII);
        }
        /**
         *Runsafallbackforthenativeencodingfuncion.
         *
         *@seehttps://stackoverflow.com/a/17192845/4367683
         */
        staticencodeFallback(s){
            constencodedURIstring=btoa(unescape(encodeURIComponent(s)));
            constcharList=encodedURIstring.split('');
            constuintArray=[];
            for(leti=0;i<charList.length;i++){
                uintArray.push(charList[i].charCodeAt(0));
            }
            returnnewUint8Array(uintArray);
        }
    }

    /*
     *Copyright(C)2010ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *Commonstring-relatedfunctions.
     *
     *@authorSeanOwen
     *@authorAlexDupre
     */
    classStringUtils{
        //SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING)||
        //EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);
        staticcastAsNonUtf8Char(code,encoding=null){
            //ISO8859-1istheJavadefaultasUTF-8isJavaScripts
            //youcanseethismethodasaJavaversionofString.fromCharCode
            conste=encoding?encoding.getName():this.ISO88591;
            //usepassedformat(fromCharCodewillreturnUTF8encoding)
            returnStringEncoding.decode(newUint8Array([code]),e);
        }
        /**
         *@parambytesbytesencodingastring,whoseencodingshouldbeguessed
         *@paramhintsdecodehintsifapplicable
         *@returnnameofguessedencoding;atthemomentwillonlyguessoneof:
         * {@link#SHIFT_JIS},{@link#UTF8},{@link#ISO88591},ortheplatform
         * defaultencodingifnoneofthesecanpossiblybecorrect
         */
        staticguessEncoding(bytes,hints){
            if(hints!==null&&hints!==undefined&&undefined!==hints.get(DecodeHintType$1.CHARACTER_SET)){
                returnhints.get(DecodeHintType$1.CHARACTER_SET).toString();
            }
            //Fornow,merelytriestodistinguishISO-8859-1,UTF-8andShift_JIS,
            //whichshouldbebyfarthemostcommonencodings.
            constlength=bytes.length;
            letcanBeISO88591=true;
            letcanBeShiftJIS=true;
            letcanBeUTF8=true;
            letutf8BytesLeft=0;
            //intutf8LowChars=0
            letutf2BytesChars=0;
            letutf3BytesChars=0;
            letutf4BytesChars=0;
            letsjisBytesLeft=0;
            //intsjisLowChars=0
            letsjisKatakanaChars=0;
            //intsjisDoubleBytesChars=0
            letsjisCurKatakanaWordLength=0;
            letsjisCurDoubleBytesWordLength=0;
            letsjisMaxKatakanaWordLength=0;
            letsjisMaxDoubleBytesWordLength=0;
            //intisoLowChars=0
            //intisoHighChars=0
            letisoHighOther=0;
            constutf8bom=bytes.length>3&&
                bytes[0]===/*(byte)*/0xEF&&
                bytes[1]===/*(byte)*/0xBB&&
                bytes[2]===/*(byte)*/0xBF;
            for(leti=0;i<length&&(canBeISO88591||canBeShiftJIS||canBeUTF8);i++){
                constvalue=bytes[i]&0xFF;
                //UTF-8stuff
                if(canBeUTF8){
                    if(utf8BytesLeft>0){
                        if((value&0x80)===0){
                            canBeUTF8=false;
                        }
                        else{
                            utf8BytesLeft--;
                        }
                    }
                    elseif((value&0x80)!==0){
                        if((value&0x40)===0){
                            canBeUTF8=false;
                        }
                        else{
                            utf8BytesLeft++;
                            if((value&0x20)===0){
                                utf2BytesChars++;
                            }
                            else{
                                utf8BytesLeft++;
                                if((value&0x10)===0){
                                    utf3BytesChars++;
                                }
                                else{
                                    utf8BytesLeft++;
                                    if((value&0x08)===0){
                                        utf4BytesChars++;
                                    }
                                    else{
                                        canBeUTF8=false;
                                    }
                                }
                            }
                        }
                    }//else{
                    //utf8LowChars++
                    //}
                }
                //ISO-8859-1stuff
                if(canBeISO88591){
                    if(value>0x7F&&value<0xA0){
                        canBeISO88591=false;
                    }
                    elseif(value>0x9F){
                        if(value<0xC0||value===0xD7||value===0xF7){
                            isoHighOther++;
                        }//else{
                        //isoHighChars++
                        //}
                    }//else{
                    //isoLowChars++
                    //}
                }
                //Shift_JISstuff
                if(canBeShiftJIS){
                    if(sjisBytesLeft>0){
                        if(value<0x40||value===0x7F||value>0xFC){
                            canBeShiftJIS=false;
                        }
                        else{
                            sjisBytesLeft--;
                        }
                    }
                    elseif(value===0x80||value===0xA0||value>0xEF){
                        canBeShiftJIS=false;
                    }
                    elseif(value>0xA0&&value<0xE0){
                        sjisKatakanaChars++;
                        sjisCurDoubleBytesWordLength=0;
                        sjisCurKatakanaWordLength++;
                        if(sjisCurKatakanaWordLength>sjisMaxKatakanaWordLength){
                            sjisMaxKatakanaWordLength=sjisCurKatakanaWordLength;
                        }
                    }
                    elseif(value>0x7F){
                        sjisBytesLeft++;
                        //sjisDoubleBytesChars++
                        sjisCurKatakanaWordLength=0;
                        sjisCurDoubleBytesWordLength++;
                        if(sjisCurDoubleBytesWordLength>sjisMaxDoubleBytesWordLength){
                            sjisMaxDoubleBytesWordLength=sjisCurDoubleBytesWordLength;
                        }
                    }
                    else{
                        //sjisLowChars++
                        sjisCurKatakanaWordLength=0;
                        sjisCurDoubleBytesWordLength=0;
                    }
                }
            }
            if(canBeUTF8&&utf8BytesLeft>0){
                canBeUTF8=false;
            }
            if(canBeShiftJIS&&sjisBytesLeft>0){
                canBeShiftJIS=false;
            }
            //Easy--ifthereisBOMoratleast1validnot-singlebytecharacter(andnoevidenceitcan'tbeUTF-8),done
            if(canBeUTF8&&(utf8bom||utf2BytesChars+utf3BytesChars+utf4BytesChars>0)){
                returnStringUtils.UTF8;
            }
            //Easy--ifassumingShift_JISoratleast3validconsecutivenot-asciicharacters(andnoevidenceitcan'tbe),done
            if(canBeShiftJIS&&(StringUtils.ASSUME_SHIFT_JIS||sjisMaxKatakanaWordLength>=3||sjisMaxDoubleBytesWordLength>=3)){
                returnStringUtils.SHIFT_JIS;
            }
            //DistinguishingShift_JISandISO-8859-1canbealittletoughforshortwords.Thecrudeheuristicis:
            //-Ifwesaw
            //  -onlytwoconsecutivekatakanacharsinthewholetext,or
            //  -atleast10%ofbytesthatcouldbe"upper"not-alphanumericLatin1,
            //-thenweconcludeShift_JIS,elseISO-8859-1
            if(canBeISO88591&&canBeShiftJIS){
                return(sjisMaxKatakanaWordLength===2&&sjisKatakanaChars===2)||isoHighOther*10>=length
                    ?StringUtils.SHIFT_JIS:StringUtils.ISO88591;
            }
            //Otherwise,tryinorderISO-8859-1,ShiftJIS,UTF-8andfallbacktodefaultplatformencoding
            if(canBeISO88591){
                returnStringUtils.ISO88591;
            }
            if(canBeShiftJIS){
                returnStringUtils.SHIFT_JIS;
            }
            if(canBeUTF8){
                returnStringUtils.UTF8;
            }
            //Otherwise,wetakeawildguesswithplatformencoding
            returnStringUtils.PLATFORM_DEFAULT_ENCODING;
        }
        /**
         *
         *@seehttps://stackoverflow.com/a/13439711/4367683
         *
         *@paramappendThenewstringtoappend.
         *@paramargsArgumetsvaluestobeformated.
         */
        staticformat(append,...args){
            leti=-1;
            functioncallback(exp,p0,p1,p2,p3,p4){
                if(exp==='%%')
                    return'%';
                if(args[++i]===undefined)
                    returnundefined;
                exp=p2?parseInt(p2.substr(1)):undefined;
                letbase=p3?parseInt(p3.substr(1)):undefined;
                letval;
                switch(p4){
                    case's':
                        val=args[i];
                        break;
                    case'c':
                        val=args[i][0];
                        break;
                    case'f':
                        val=parseFloat(args[i]).toFixed(exp);
                        break;
                    case'p':
                        val=parseFloat(args[i]).toPrecision(exp);
                        break;
                    case'e':
                        val=parseFloat(args[i]).toExponential(exp);
                        break;
                    case'x':
                        val=parseInt(args[i]).toString(base?base:16);
                        break;
                    case'd':
                        val=parseFloat(parseInt(args[i],base?base:10).toPrecision(exp)).toFixed(0);
                        break;
                }
                val=typeofval==='object'?JSON.stringify(val):(+val).toString(base);
                letsize=parseInt(p1);/*paddingsize*/
                letch=p1&&(p1[0]+'')==='0'?'0':'';/*isnull?*/
                while(val.length<size)
                    val=p0!==undefined?val+ch:ch+val;/*isminus?*/
                returnval;
            }
            letregex=/%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
            returnappend.replace(regex,callback);
        }
        /**
         *
         */
        staticgetBytes(str,encoding){
            returnStringEncoding.encode(str,encoding);
        }
        /**
         *Returnsthecharcodeatthespecifiedindexoratindexzero.
         */
        staticgetCharCode(str,index=0){
            returnstr.charCodeAt(index);
        }
        /**
         *Returnscharforgivencharcode
         */
        staticgetCharAt(charCode){
            returnString.fromCharCode(charCode);
        }
    }
    StringUtils.SHIFT_JIS=CharacterSetECI.SJIS.getName();//"SJIS"
    StringUtils.GB2312='GB2312';
    StringUtils.ISO88591=CharacterSetECI.ISO8859_1.getName();//"ISO8859_1"
    StringUtils.EUC_JP='EUC_JP';
    StringUtils.UTF8=CharacterSetECI.UTF8.getName();//"UTF8"
    StringUtils.PLATFORM_DEFAULT_ENCODING=StringUtils.UTF8;//"UTF8"//Charset.defaultCharset().name()
    StringUtils.ASSUME_SHIFT_JIS=false;

    classStringBuilder{
        constructor(value=''){
            this.value=value;
        }
        enableDecoding(encoding){
            this.encoding=encoding;
            returnthis;
        }
        append(s){
            if(typeofs==='string'){
                this.value+=s.toString();
            }
            elseif(this.encoding){
                //usepassedformat(fromCharCodewillreturnUTF8encoding)
                this.value+=StringUtils.castAsNonUtf8Char(s,this.encoding);
            }
            else{
                //correctlyconvertsfromUTF-8,butnototherencodings
                this.value+=String.fromCharCode(s);
            }
            returnthis;
        }
        appendChars(str,offset,len){
            for(leti=offset;offset<offset+len;i++){
                this.append(str[i]);
            }
            returnthis;
        }
        length(){
            returnthis.value.length;
        }
        charAt(n){
            returnthis.value.charAt(n);
        }
        deleteCharAt(n){
            this.value=this.value.substr(0,n)+this.value.substring(n+1);
        }
        setCharAt(n,c){
            this.value=this.value.substr(0,n)+c+this.value.substr(n+1);
        }
        substring(start,end){
            returnthis.value.substring(start,end);
        }
        /**
         *@notehelpermethodforRSSExpanded
         */
        setLengthToZero(){
            this.value='';
        }
        toString(){
            returnthis.value;
        }
        insert(n,c){
            this.value=this.value.substr(0,n)+c+this.value.substr(n+c.length);
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Representsa2Dmatrixofbits.Infunctionargumentsbelow,andthroughoutthecommon
     *module,xisthecolumnposition,andyistherowposition.Theorderingisalwaysx,y.
     *Theoriginisatthetop-left.</p>
     *
     *<p>Internallythebitsarerepresentedina1-Darrayof32-bitints.However,eachrowbegins
     *withanewint.ThisisdoneintentionallysothatwecancopyoutarowintoaBitArrayvery
     *efficiently.</p>
     *
     *<p>Theorderingofbitsisrow-major.Withineachint,theleastsignificantbitsareusedfirst,
     *meaningtheyrepresentlowerxvalues.ThisiscompatiblewithBitArray'simplementation.</p>
     *
     *@authorSeanOwen
     *@authordswitkin@google.com(DanielSwitkin)
     */
    classBitMatrix/*implementsCloneable*/{
        /**
         *Createsanemptysquare{@linkBitMatrix}.
         *
         *@paramdimensionheightandwidth
         */
        //publicconstructor(dimension:number/*int*/){
        //  this(dimension,dimension)
        //}
        /**
         *Createsanempty{@linkBitMatrix}.
         *
         *@paramwidthbitmatrixwidth
         *@paramheightbitmatrixheight
         */
        //publicconstructor(width:number/*int*/,height:number/*int*/){
        //  if(width<1||height<1){
        //    thrownewIllegalArgumentException("Bothdimensionsmustbegreaterthan0")
        //  }
        //  this.width=width
        //  this.height=height
        //  this.rowSize=(width+31)/32
        //  bits=newint[rowSize*height];
        //}
        constructor(width/*int*/,height/*int*/,rowSize/*int*/,bits){
            this.width=width;
            this.height=height;
            this.rowSize=rowSize;
            this.bits=bits;
            if(undefined===height||null===height){
                height=width;
            }
            this.height=height;
            if(width<1||height<1){
                thrownewIllegalArgumentException('Bothdimensionsmustbegreaterthan0');
            }
            if(undefined===rowSize||null===rowSize){
                rowSize=Math.floor((width+31)/32);
            }
            this.rowSize=rowSize;
            if(undefined===bits||null===bits){
                this.bits=newInt32Array(this.rowSize*this.height);
            }
        }
        /**
         *Interpretsa2Darrayofbooleansasa{@linkBitMatrix},where"true"meansan"on"bit.
         *
         *@functionparse
         *@paramimagebitsoftheimage,asarow-major2Darray.Elementsarearraysrepresentingrows
         *@return{@linkBitMatrix}representationofimage
         */
        staticparseFromBooleanArray(image){
            constheight=image.length;
            constwidth=image[0].length;
            constbits=newBitMatrix(width,height);
            for(leti=0;i<height;i++){
                constimageI=image[i];
                for(letj=0;j<width;j++){
                    if(imageI[j]){
                        bits.set(j,i);
                    }
                }
            }
            returnbits;
        }
        /**
         *
         *@functionparse
         *@paramstringRepresentation
         *@paramsetString
         *@paramunsetString
         */
        staticparseFromString(stringRepresentation,setString,unsetString){
            if(stringRepresentation===null){
                thrownewIllegalArgumentException('stringRepresentationcannotbenull');
            }
            constbits=newArray(stringRepresentation.length);
            letbitsPos=0;
            letrowStartPos=0;
            letrowLength=-1;
            letnRows=0;
            letpos=0;
            while(pos<stringRepresentation.length){
                if(stringRepresentation.charAt(pos)==='\n'||
                    stringRepresentation.charAt(pos)==='\r'){
                    if(bitsPos>rowStartPos){
                        if(rowLength===-1){
                            rowLength=bitsPos-rowStartPos;
                        }
                        elseif(bitsPos-rowStartPos!==rowLength){
                            thrownewIllegalArgumentException('rowlengthsdonotmatch');
                        }
                        rowStartPos=bitsPos;
                        nRows++;
                    }
                    pos++;
                }
                elseif(stringRepresentation.substring(pos,pos+setString.length)===setString){
                    pos+=setString.length;
                    bits[bitsPos]=true;
                    bitsPos++;
                }
                elseif(stringRepresentation.substring(pos,pos+unsetString.length)===unsetString){
                    pos+=unsetString.length;
                    bits[bitsPos]=false;
                    bitsPos++;
                }
                else{
                    thrownewIllegalArgumentException('illegalcharacterencountered:'+stringRepresentation.substring(pos));
                }
            }
            //noEOLatend?
            if(bitsPos>rowStartPos){
                if(rowLength===-1){
                    rowLength=bitsPos-rowStartPos;
                }
                elseif(bitsPos-rowStartPos!==rowLength){
                    thrownewIllegalArgumentException('rowlengthsdonotmatch');
                }
                nRows++;
            }
            constmatrix=newBitMatrix(rowLength,nRows);
            for(leti=0;i<bitsPos;i++){
                if(bits[i]){
                    matrix.set(Math.floor(i%rowLength),Math.floor(i/rowLength));
                }
            }
            returnmatrix;
        }
        /**
         *<p>Getstherequestedbit,wheretruemeansblack.</p>
         *
         *@paramxThehorizontalcomponent(i.e.whichcolumn)
         *@paramyTheverticalcomponent(i.e.whichrow)
         *@returnvalueofgivenbitinmatrix
         */
        get(x/*int*/,y/*int*/){
            constoffset=y*this.rowSize+Math.floor(x/32);
            return((this.bits[offset]>>>(x&0x1f))&1)!==0;
        }
        /**
         *<p>Setsthegivenbittotrue.</p>
         *
         *@paramxThehorizontalcomponent(i.e.whichcolumn)
         *@paramyTheverticalcomponent(i.e.whichrow)
         */
        set(x/*int*/,y/*int*/){
            constoffset=y*this.rowSize+Math.floor(x/32);
            this.bits[offset]|=(1<<(x&0x1f))&0xFFFFFFFF;
        }
        unset(x/*int*/,y/*int*/){
            constoffset=y*this.rowSize+Math.floor(x/32);
            this.bits[offset]&=~((1<<(x&0x1f))&0xFFFFFFFF);
        }
        /**
         *<p>Flipsthegivenbit.</p>
         *
         *@paramxThehorizontalcomponent(i.e.whichcolumn)
         *@paramyTheverticalcomponent(i.e.whichrow)
         */
        flip(x/*int*/,y/*int*/){
            constoffset=y*this.rowSize+Math.floor(x/32);
            this.bits[offset]^=((1<<(x&0x1f))&0xFFFFFFFF);
        }
        /**
         *Exclusive-or(XOR):Flipthebitinthis{@codeBitMatrix}ifthecorresponding
         *maskbitisset.
         *
         *@parammaskXORmask
         */
        xor(mask){
            if(this.width!==mask.getWidth()||this.height!==mask.getHeight()
                ||this.rowSize!==mask.getRowSize()){
                thrownewIllegalArgumentException('inputmatrixdimensionsdonotmatch');
            }
            constrowArray=newBitArray(Math.floor(this.width/32)+1);
            constrowSize=this.rowSize;
            constbits=this.bits;
            for(lety=0,height=this.height;y<height;y++){
                constoffset=y*rowSize;
                constrow=mask.getRow(y,rowArray).getBitArray();
                for(letx=0;x<rowSize;x++){
                    bits[offset+x]^=row[x];
                }
            }
        }
        /**
         *Clearsallbits(setstofalse).
         */
        clear(){
            constbits=this.bits;
            constmax=bits.length;
            for(leti=0;i<max;i++){
                bits[i]=0;
            }
        }
        /**
         *<p>Setsasquareregionofthebitmatrixtotrue.</p>
         *
         *@paramleftThehorizontalpositiontobeginat(inclusive)
         *@paramtopTheverticalpositiontobeginat(inclusive)
         *@paramwidthThewidthoftheregion
         *@paramheightTheheightoftheregion
         */
        setRegion(left/*int*/,top/*int*/,width/*int*/,height/*int*/){
            if(top<0||left<0){
                thrownewIllegalArgumentException('Leftandtopmustbenonnegative');
            }
            if(height<1||width<1){
                thrownewIllegalArgumentException('Heightandwidthmustbeatleast1');
            }
            constright=left+width;
            constbottom=top+height;
            if(bottom>this.height||right>this.width){
                thrownewIllegalArgumentException('Theregionmustfitinsidethematrix');
            }
            constrowSize=this.rowSize;
            constbits=this.bits;
            for(lety=top;y<bottom;y++){
                constoffset=y*rowSize;
                for(letx=left;x<right;x++){
                    bits[offset+Math.floor(x/32)]|=((1<<(x&0x1f))&0xFFFFFFFF);
                }
            }
        }
        /**
         *AfastmethodtoretrieveonerowofdatafromthematrixasaBitArray.
         *
         *@paramyTherowtoretrieve
         *@paramrowAnoptionalcaller-allocatedBitArray,willbeallocatedifnullortoosmall
         *@returnTheresultingBitArray-thisreferenceshouldalwaysbeusedevenwhenpassing
         *        yourownrow
         */
        getRow(y/*int*/,row){
            if(row===null||row===undefined||row.getSize()<this.width){
                row=newBitArray(this.width);
            }
            else{
                row.clear();
            }
            constrowSize=this.rowSize;
            constbits=this.bits;
            constoffset=y*rowSize;
            for(letx=0;x<rowSize;x++){
                row.setBulk(x*32,bits[offset+x]);
            }
            returnrow;
        }
        /**
         *@paramyrowtoset
         *@paramrow{@linkBitArray}tocopyfrom
         */
        setRow(y/*int*/,row){
            System.arraycopy(row.getBitArray(),0,this.bits,y*this.rowSize,this.rowSize);
        }
        /**
         *Modifiesthis{@codeBitMatrix}torepresentthesamebutrotated180degrees
         */
        rotate180(){
            constwidth=this.getWidth();
            constheight=this.getHeight();
            lettopRow=newBitArray(width);
            letbottomRow=newBitArray(width);
            for(leti=0,length=Math.floor((height+1)/2);i<length;i++){
                topRow=this.getRow(i,topRow);
                bottomRow=this.getRow(height-1-i,bottomRow);
                topRow.reverse();
                bottomRow.reverse();
                this.setRow(i,bottomRow);
                this.setRow(height-1-i,topRow);
            }
        }
        /**
         *Thisisusefulindetectingtheenclosingrectangleofa'pure'barcode.
         *
         *@return{@codeleft,top,width,height}enclosingrectangleofall1bits,ornullifitisallwhite
         */
        getEnclosingRectangle(){
            constwidth=this.width;
            constheight=this.height;
            constrowSize=this.rowSize;
            constbits=this.bits;
            letleft=width;
            lettop=height;
            letright=-1;
            letbottom=-1;
            for(lety=0;y<height;y++){
                for(letx32=0;x32<rowSize;x32++){
                    consttheBits=bits[y*rowSize+x32];
                    if(theBits!==0){
                        if(y<top){
                            top=y;
                        }
                        if(y>bottom){
                            bottom=y;
                        }
                        if(x32*32<left){
                            letbit=0;
                            while(((theBits<<(31-bit))&0xFFFFFFFF)===0){
                                bit++;
                            }
                            if((x32*32+bit)<left){
                                left=x32*32+bit;
                            }
                        }
                        if(x32*32+31>right){
                            letbit=31;
                            while((theBits>>>bit)===0){
                                bit--;
                            }
                            if((x32*32+bit)>right){
                                right=x32*32+bit;
                            }
                        }
                    }
                }
            }
            if(right<left||bottom<top){
                returnnull;
            }
            returnInt32Array.from([left,top,right-left+1,bottom-top+1]);
        }
        /**
         *Thisisusefulindetectingacornerofa'pure'barcode.
         *
         *@return{@codex,y}coordinateoftop-left-most1bit,ornullifitisallwhite
         */
        getTopLeftOnBit(){
            constrowSize=this.rowSize;
            constbits=this.bits;
            letbitsOffset=0;
            while(bitsOffset<bits.length&&bits[bitsOffset]===0){
                bitsOffset++;
            }
            if(bitsOffset===bits.length){
                returnnull;
            }
            consty=bitsOffset/rowSize;
            letx=(bitsOffset%rowSize)*32;
            consttheBits=bits[bitsOffset];
            letbit=0;
            while(((theBits<<(31-bit))&0xFFFFFFFF)===0){
                bit++;
            }
            x+=bit;
            returnInt32Array.from([x,y]);
        }
        getBottomRightOnBit(){
            constrowSize=this.rowSize;
            constbits=this.bits;
            letbitsOffset=bits.length-1;
            while(bitsOffset>=0&&bits[bitsOffset]===0){
                bitsOffset--;
            }
            if(bitsOffset<0){
                returnnull;
            }
            consty=Math.floor(bitsOffset/rowSize);
            letx=Math.floor(bitsOffset%rowSize)*32;
            consttheBits=bits[bitsOffset];
            letbit=31;
            while((theBits>>>bit)===0){
                bit--;
            }
            x+=bit;
            returnInt32Array.from([x,y]);
        }
        /**
         *@returnThewidthofthematrix
         */
        getWidth(){
            returnthis.width;
        }
        /**
         *@returnTheheightofthematrix
         */
        getHeight(){
            returnthis.height;
        }
        /**
         *@returnTherowsizeofthematrix
         */
        getRowSize(){
            returnthis.rowSize;
        }
        /*@Override*/
        equals(o){
            if(!(oinstanceofBitMatrix)){
                returnfalse;
            }
            constother=o;
            returnthis.width===other.width&&this.height===other.height&&this.rowSize===other.rowSize&&
                Arrays.equals(this.bits,other.bits);
        }
        /*@Override*/
        hashCode(){
            lethash=this.width;
            hash=31*hash+this.width;
            hash=31*hash+this.height;
            hash=31*hash+this.rowSize;
            hash=31*hash+Arrays.hashCode(this.bits);
            returnhash;
        }
        /**
         *@returnstringrepresentationusing"X"forsetand""forunsetbits
         */
        /*@Override*/
        //publictoString():string{
        //  returntoString(":"X," ")
        //}
        /**
         *@paramsetStringrepresentationofasetbit
         *@paramunsetStringrepresentationofanunsetbit
         *@returnstringrepresentationofentirematrixutilizinggivenstrings
         */
        //publictoString(setString:string="X",unsetString:string=" "):string{
        //  returnthis.buildToString(setString,unsetString,"\n")
        //}
        /**
         *@paramsetStringrepresentationofasetbit
         *@paramunsetStringrepresentationofanunsetbit
         *@paramlineSeparatornewlinecharacterinstringrepresentation
         *@returnstringrepresentationofentirematrixutilizinggivenstringsandlineseparator
         *@deprecatedcall{@link#toString(String,String)}only,whichuses\nlineseparatoralways
         */
        //@Deprecated
        toString(setString='X',unsetString=' ',lineSeparator='\n'){
            returnthis.buildToString(setString,unsetString,lineSeparator);
        }
        buildToString(setString,unsetString,lineSeparator){
            letresult=newStringBuilder();
            //result.append(lineSeparator);
            for(lety=0,height=this.height;y<height;y++){
                for(letx=0,width=this.width;x<width;x++){
                    result.append(this.get(x,y)?setString:unsetString);
                }
                result.append(lineSeparator);
            }
            returnresult.toString();
        }
        /*@Override*/
        clone(){
            returnnewBitMatrix(this.width,this.height,this.rowSize,this.bits.slice());
        }
    }

    /**
     *CustomErrorclassoftypeException.
     */
    classNotFoundExceptionextendsException{
        staticgetNotFoundInstance(){
            returnnewNotFoundException();
        }
    }
    NotFoundException.kind='NotFoundException';

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *ThisBinarizerimplementationusestheoldZXingglobalhistogramapproach.Itissuitable
     *forlow-endmobiledeviceswhichdon'thaveenoughCPUormemorytousealocalthresholding
     *algorithm.However,becauseitpicksaglobalblackpoint,itcannothandledifficultshadows
     *andgradients.
     *
     *FastermobiledevicesandalldesktopapplicationsshouldprobablyuseHybridBinarizerinstead.
     *
     *@authordswitkin@google.com(DanielSwitkin)
     *@authorSeanOwen
     */
    classGlobalHistogramBinarizerextendsBinarizer{
        constructor(source){
            super(source);
            this.luminances=GlobalHistogramBinarizer.EMPTY;
            this.buckets=newInt32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);
        }
        //Appliessimplesharpeningtotherowdatatoimproveperformanceofthe1DReaders.
        /*@Override*/
        getBlackRow(y/*int*/,row){
            constsource=this.getLuminanceSource();
            constwidth=source.getWidth();
            if(row===undefined||row===null||row.getSize()<width){
                row=newBitArray(width);
            }
            else{
                row.clear();
            }
            this.initArrays(width);
            constlocalLuminances=source.getRow(y,this.luminances);
            constlocalBuckets=this.buckets;
            for(letx=0;x<width;x++){
                localBuckets[(localLuminances[x]&0xff)>>GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
            }
            constblackPoint=GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
            if(width<3){
                //Specialcaseforverysmallimages
                for(letx=0;x<width;x++){
                    if((localLuminances[x]&0xff)<blackPoint){
                        row.set(x);
                    }
                }
            }
            else{
                letleft=localLuminances[0]&0xff;
                letcenter=localLuminances[1]&0xff;
                for(letx=1;x<width-1;x++){
                    constright=localLuminances[x+1]&0xff;
                    //Asimple-14-1boxfilterwithaweightof2.
                    if(((center*4)-left-right)/2<blackPoint){
                        row.set(x);
                    }
                    left=center;
                    center=right;
                }
            }
            returnrow;
        }
        //Doesnotsharpenthedata,asthiscallisintendedtoonlybeusedby2DReaders.
        /*@Override*/
        getBlackMatrix(){
            constsource=this.getLuminanceSource();
            constwidth=source.getWidth();
            constheight=source.getHeight();
            constmatrix=newBitMatrix(width,height);
            //Quicklycalculatesthehistogrambysamplingfourrowsfromtheimage.Thisprovedtobe
            //morerobustontheblackboxteststhansamplingadiagonalasweusedtodo.
            this.initArrays(width);
            constlocalBuckets=this.buckets;
            for(lety=1;y<5;y++){
                constrow=Math.floor((height*y)/5);
                constlocalLuminances=source.getRow(row,this.luminances);
                constright=Math.floor((width*4)/5);
                for(letx=Math.floor(width/5);x<right;x++){
                    constpixel=localLuminances[x]&0xff;
                    localBuckets[pixel>>GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
                }
            }
            constblackPoint=GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
            //Wedelayreadingtheentireimageluminanceuntiltheblackpointestimationsucceeds.
            //Althoughweendupreadingfourrowstwice,itisconsistentwithourmottoof
            //"failquickly"whichisnecessaryforcontinuousscanning.
            constlocalLuminances=source.getMatrix();
            for(lety=0;y<height;y++){
                constoffset=y*width;
                for(letx=0;x<width;x++){
                    constpixel=localLuminances[offset+x]&0xff;
                    if(pixel<blackPoint){
                        matrix.set(x,y);
                    }
                }
            }
            returnmatrix;
        }
        /*@Override*/
        createBinarizer(source){
            returnnewGlobalHistogramBinarizer(source);
        }
        initArrays(luminanceSize/*int*/){
            if(this.luminances.length<luminanceSize){
                this.luminances=newUint8ClampedArray(luminanceSize);
            }
            constbuckets=this.buckets;
            for(letx=0;x<GlobalHistogramBinarizer.LUMINANCE_BUCKETS;x++){
                buckets[x]=0;
            }
        }
        staticestimateBlackPoint(buckets){
            //Findthetallestpeakinthehistogram.
            constnumBuckets=buckets.length;
            letmaxBucketCount=0;
            letfirstPeak=0;
            letfirstPeakSize=0;
            for(letx=0;x<numBuckets;x++){
                if(buckets[x]>firstPeakSize){
                    firstPeak=x;
                    firstPeakSize=buckets[x];
                }
                if(buckets[x]>maxBucketCount){
                    maxBucketCount=buckets[x];
                }
            }
            //Findthesecond-tallestpeakwhichissomewhatfarfromthetallestpeak.
            letsecondPeak=0;
            letsecondPeakScore=0;
            for(letx=0;x<numBuckets;x++){
                constdistanceToBiggest=x-firstPeak;
                //Encouragemoredistantsecondpeaksbymultiplyingbysquareofdistance.
                constscore=buckets[x]*distanceToBiggest*distanceToBiggest;
                if(score>secondPeakScore){
                    secondPeak=x;
                    secondPeakScore=score;
                }
            }
            //MakesurefirstPeakcorrespondstotheblackpeak.
            if(firstPeak>secondPeak){
                consttemp=firstPeak;
                firstPeak=secondPeak;
                secondPeak=temp;
            }
            //Ifthereistoolittlecontrastintheimagetopickameaningfulblackpoint,throwrather
            //thanwastetimetryingtodecodetheimage,andriskfalsepositives.
            if(secondPeak-firstPeak<=numBuckets/16){
                thrownewNotFoundException();
            }
            //Findavalleybetweenthemthatislowandclosertothewhitepeak.
            letbestValley=secondPeak-1;
            letbestValleyScore=-1;
            for(letx=secondPeak-1;x>firstPeak;x--){
                constfromFirst=x-firstPeak;
                constscore=fromFirst*fromFirst*(secondPeak-x)*(maxBucketCount-buckets[x]);
                if(score>bestValleyScore){
                    bestValley=x;
                    bestValleyScore=score;
                }
            }
            returnbestValley<<GlobalHistogramBinarizer.LUMINANCE_SHIFT;
        }
    }
    GlobalHistogramBinarizer.LUMINANCE_BITS=5;
    GlobalHistogramBinarizer.LUMINANCE_SHIFT=8-GlobalHistogramBinarizer.LUMINANCE_BITS;
    GlobalHistogramBinarizer.LUMINANCE_BUCKETS=1<<GlobalHistogramBinarizer.LUMINANCE_BITS;
    GlobalHistogramBinarizer.EMPTY=Uint8ClampedArray.from([0]);

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *Thisclassimplementsalocalthresholdingalgorithm,whichwhileslowerthanthe
     *GlobalHistogramBinarizer,isfairlyefficientforwhatitdoes.Itisdesignedfor
     *highfrequencyimagesofbarcodeswithblackdataonwhitebackgrounds.Forthisapplication,
     *itdoesamuchbetterjobthanaglobalblackpointwithsevereshadowsandgradients.
     *Howeverittendstoproduceartifactsonlowerfrequencyimagesandisthereforenot
     *agoodgeneralpurposebinarizerforusesoutsideZXing.
     *
     *ThisclassextendsGlobalHistogramBinarizer,usingtheolderhistogramapproachfor1Dreaders,
     *andthenewerlocalapproachfor2Dreaders.1Ddecodingusingaper-rowhistogramisalready
     *inherentlylocal,andonlyfailsforhorizontalgradients.Wecanrevisitthatproblemlater,
     *butfornowitwasnotawintouselocalblocksfor1D.
     *
     *ThisBinarizeristhedefaultfortheunittestsandtherecommendedclassforlibraryusers.
     *
     *@authordswitkin@google.com(DanielSwitkin)
     */
    classHybridBinarizerextendsGlobalHistogramBinarizer{
        constructor(source){
            super(source);
            this.matrix=null;
        }
        /**
         *CalculatesthefinalBitMatrixonceforallrequests.Thiscouldbecalledoncefromthe
         *constructorinstead,buttherearesomeadvantagestodoingitlazily,suchasmaking
         *profilingeasier,andnotdoingheavyliftingwhencallersdon'texpectit.
         */
        /*@Override*/
        getBlackMatrix(){
            if(this.matrix!==null){
                returnthis.matrix;
            }
            constsource=this.getLuminanceSource();
            constwidth=source.getWidth();
            constheight=source.getHeight();
            if(width>=HybridBinarizer.MINIMUM_DIMENSION&&height>=HybridBinarizer.MINIMUM_DIMENSION){
                constluminances=source.getMatrix();
                letsubWidth=width>>HybridBinarizer.BLOCK_SIZE_POWER;
                if((width&HybridBinarizer.BLOCK_SIZE_MASK)!==0){
                    subWidth++;
                }
                letsubHeight=height>>HybridBinarizer.BLOCK_SIZE_POWER;
                if((height&HybridBinarizer.BLOCK_SIZE_MASK)!==0){
                    subHeight++;
                }
                constblackPoints=HybridBinarizer.calculateBlackPoints(luminances,subWidth,subHeight,width,height);
                constnewMatrix=newBitMatrix(width,height);
                HybridBinarizer.calculateThresholdForBlock(luminances,subWidth,subHeight,width,height,blackPoints,newMatrix);
                this.matrix=newMatrix;
            }
            else{
                //Iftheimageistoosmall,fallbacktotheglobalhistogramapproach.
                this.matrix=super.getBlackMatrix();
            }
            returnthis.matrix;
        }
        /*@Override*/
        createBinarizer(source){
            returnnewHybridBinarizer(source);
        }
        /**
         *Foreachblockintheimage,calculatetheaverageblackpointusinga5x5grid
         *oftheblocksaroundit.Alsohandlesthecornercases(fractionalblocksarecomputedbased
         *onthelastpixelsintherow/columnwhicharealsousedinthepreviousblock).
         */
        staticcalculateThresholdForBlock(luminances,subWidth/*int*/,subHeight/*int*/,width/*int*/,height/*int*/,blackPoints,matrix){
            constmaxYOffset=height-HybridBinarizer.BLOCK_SIZE;
            constmaxXOffset=width-HybridBinarizer.BLOCK_SIZE;
            for(lety=0;y<subHeight;y++){
                letyoffset=y<<HybridBinarizer.BLOCK_SIZE_POWER;
                if(yoffset>maxYOffset){
                    yoffset=maxYOffset;
                }
                consttop=HybridBinarizer.cap(y,2,subHeight-3);
                for(letx=0;x<subWidth;x++){
                    letxoffset=x<<HybridBinarizer.BLOCK_SIZE_POWER;
                    if(xoffset>maxXOffset){
                        xoffset=maxXOffset;
                    }
                    constleft=HybridBinarizer.cap(x,2,subWidth-3);
                    letsum=0;
                    for(letz=-2;z<=2;z++){
                        constblackRow=blackPoints[top+z];
                        sum+=blackRow[left-2]+blackRow[left-1]+blackRow[left]+blackRow[left+1]+blackRow[left+2];
                    }
                    constaverage=sum/25;
                    HybridBinarizer.thresholdBlock(luminances,xoffset,yoffset,average,width,matrix);
                }
            }
        }
        staticcap(value/*int*/,min/*int*/,max/*int*/){
            returnvalue<min?min:value>max?max:value;
        }
        /**
         *Appliesasinglethresholdtoablockofpixels.
         */
        staticthresholdBlock(luminances,xoffset/*int*/,yoffset/*int*/,threshold/*int*/,stride/*int*/,matrix){
            for(lety=0,offset=yoffset*stride+xoffset;y<HybridBinarizer.BLOCK_SIZE;y++,offset+=stride){
                for(letx=0;x<HybridBinarizer.BLOCK_SIZE;x++){
                    //Comparisonneedstobe<=sothatblack==0pixelsareblackevenifthethresholdis0.
                    if((luminances[offset+x]&0xFF)<=threshold){
                        matrix.set(xoffset+x,yoffset+y);
                    }
                }
            }
        }
        /**
         *Calculatesasingleblackpointforeachblockofpixelsandsavesitaway.
         *Seethefollowingthreadforadiscussionofthisalgorithm:
         * http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0
         */
        staticcalculateBlackPoints(luminances,subWidth/*int*/,subHeight/*int*/,width/*int*/,height/*int*/){
            constmaxYOffset=height-HybridBinarizer.BLOCK_SIZE;
            constmaxXOffset=width-HybridBinarizer.BLOCK_SIZE;
            //tslint:disable-next-line:whitespace
            constblackPoints=newArray(subHeight);//subWidth
            for(lety=0;y<subHeight;y++){
                blackPoints[y]=newInt32Array(subWidth);
                letyoffset=y<<HybridBinarizer.BLOCK_SIZE_POWER;
                if(yoffset>maxYOffset){
                    yoffset=maxYOffset;
                }
                for(letx=0;x<subWidth;x++){
                    letxoffset=x<<HybridBinarizer.BLOCK_SIZE_POWER;
                    if(xoffset>maxXOffset){
                        xoffset=maxXOffset;
                    }
                    letsum=0;
                    letmin=0xFF;
                    letmax=0;
                    for(letyy=0,offset=yoffset*width+xoffset;yy<HybridBinarizer.BLOCK_SIZE;yy++,offset+=width){
                        for(letxx=0;xx<HybridBinarizer.BLOCK_SIZE;xx++){
                            constpixel=luminances[offset+xx]&0xFF;
                            sum+=pixel;
                            //stilllookingforgoodcontrast
                            if(pixel<min){
                                min=pixel;
                            }
                            if(pixel>max){
                                max=pixel;
                            }
                        }
                        //short-circuitmin/maxtestsoncedynamicrangeismet
                        if(max-min>HybridBinarizer.MIN_DYNAMIC_RANGE){
                            //finishtherestoftherowsquickly
                            for(yy++,offset+=width;yy<HybridBinarizer.BLOCK_SIZE;yy++,offset+=width){
                                for(letxx=0;xx<HybridBinarizer.BLOCK_SIZE;xx++){
                                    sum+=luminances[offset+xx]&0xFF;
                                }
                            }
                        }
                    }
                    //Thedefaultestimateistheaverageofthevaluesintheblock.
                    letaverage=sum>>(HybridBinarizer.BLOCK_SIZE_POWER*2);
                    if(max-min<=HybridBinarizer.MIN_DYNAMIC_RANGE){
                        //Ifvariationwithintheblockislow,assumethisisablockwithonlylightoronly
                        //darkpixels.Inthatcasewedonotwanttousetheaverage,asitwoulddividethis
                        //lowcontrastareaintoblackandwhitepixels,essentiallycreatingdataoutofnoise.
                        //
                        //Thedefaultassumptionisthattheblockislight/background.Sincenoestimatefor
                        //thelevelofdarkpixelsexistslocally,usehalftheminfortheblock.
                        average=min/2;
                        if(y>0&&x>0){
                            //Correctthe"whitebackground"assumptionforblocksthathaveneighborsbycomparing
                            //thepixelsinthisblocktothepreviouslycalculatedblackpoints.Thisisbasedon
                            //thefactthatdarkbarcodesymbologyisalwayssurroundedbysomeamountoflight
                            //backgroundforwhichreasonableblackpointestimatesweremade.Thebpestimatedat
                            //theboundariesisusedfortheinterior.
                            //The(min<bp)isarbitrarybutworksbetterthanotherheuristicsthatweretried.
                            constaverageNeighborBlackPoint=(blackPoints[y-1][x]+(2*blackPoints[y][x-1])+blackPoints[y-1][x-1])/4;
                            if(min<averageNeighborBlackPoint){
                                average=averageNeighborBlackPoint;
                            }
                        }
                    }
                    blackPoints[y][x]=average;
                }
            }
            returnblackPoints;
        }
    }
    //Thisclassuses5x5blockstocomputelocalluminance,whereeachblockis8x8pixels.
    //Sothisisthesmallestdimensionineachaxiswecanaccept.
    HybridBinarizer.BLOCK_SIZE_POWER=3;
    HybridBinarizer.BLOCK_SIZE=1<<HybridBinarizer.BLOCK_SIZE_POWER;//...0100...00
    HybridBinarizer.BLOCK_SIZE_MASK=HybridBinarizer.BLOCK_SIZE-1;//...0011...11
    HybridBinarizer.MINIMUM_DIMENSION=HybridBinarizer.BLOCK_SIZE*5;
    HybridBinarizer.MIN_DYNAMIC_RANGE=24;

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*namespacecom.google.zxing{*/
    /**
     *Thepurposeofthisclasshierarchyistoabstractdifferentbitmapimplementationsacross
     *platformsintoastandardinterfaceforrequestinggreyscaleluminancevalues.Theinterface
     *onlyprovidesimmutablemethods;thereforecropandrotationcreatecopies.Thisistoensure
     *thatoneReaderdoesnotmodifytheoriginalluminancesourceandleaveitinanunknownstate
     *forotherReadersinthechain.
     *
     *@authordswitkin@google.com(DanielSwitkin)
     */
    classLuminanceSource{
        constructor(width/*int*/,height/*int*/){
            this.width=width;
            this.height=height;
        }
        /**
         *@returnThewidthofthebitmap.
         */
        getWidth(){
            returnthis.width;
        }
        /**
         *@returnTheheightofthebitmap.
         */
        getHeight(){
            returnthis.height;
        }
        /**
         *@returnWhetherthissubclasssupportscropping.
         */
        isCropSupported(){
            returnfalse;
        }
        /**
         *Returnsanewobjectwithcroppedimagedata.Implementationsmaykeepareferencetothe
         *originaldataratherthanacopy.OnlycallableifisCropSupported()istrue.
         *
         *@paramleftTheleftcoordinate,whichmustbein[0,getWidth())
         *@paramtopThetopcoordinate,whichmustbein[0,getHeight())
         *@paramwidthThewidthoftherectangletocrop.
         *@paramheightTheheightoftherectangletocrop.
         *@returnAcroppedversionofthisobject.
         */
        crop(left/*int*/,top/*int*/,width/*int*/,height/*int*/){
            thrownewUnsupportedOperationException('Thisluminancesourcedoesnotsupportcropping.');
        }
        /**
         *@returnWhetherthissubclasssupportscounter-clockwiserotation.
         */
        isRotateSupported(){
            returnfalse;
        }
        /**
         *Returnsanewobjectwithrotatedimagedataby90degreescounterclockwise.
         *Onlycallableif{@link#isRotateSupported()}istrue.
         *
         *@returnArotatedversionofthisobject.
         */
        rotateCounterClockwise(){
            thrownewUnsupportedOperationException('Thisluminancesourcedoesnotsupportrotationby90degrees.');
        }
        /**
         *Returnsanewobjectwithrotatedimagedataby45degreescounterclockwise.
         *Onlycallableif{@link#isRotateSupported()}istrue.
         *
         *@returnArotatedversionofthisobject.
         */
        rotateCounterClockwise45(){
            thrownewUnsupportedOperationException('Thisluminancesourcedoesnotsupportrotationby45degrees.');
        }
        /*@Override*/
        toString(){
            constrow=newUint8ClampedArray(this.width);
            letresult=newStringBuilder();
            for(lety=0;y<this.height;y++){
                constsourceRow=this.getRow(y,row);
                for(letx=0;x<this.width;x++){
                    constluminance=sourceRow[x]&0xFF;
                    letc;
                    if(luminance<0x40){
                        c='#';
                    }
                    elseif(luminance<0x80){
                        c='+';
                    }
                    elseif(luminance<0xC0){
                        c='.';
                    }
                    else{
                        c='';
                    }
                    result.append(c);
                }
                result.append('\n');
            }
            returnresult.toString();
        }
    }

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*namespacecom.google.zxing{*/
    /**
     *Awrapperimplementationof{@linkLuminanceSource}whichinvertstheluminancesitreturns--blackbecomes
     *whiteandviceversa,andeachvaluebecomes(255-value).
     *
     *@authorSeanOwen
     */
    classInvertedLuminanceSourceextendsLuminanceSource{
        constructor(delegate){
            super(delegate.getWidth(),delegate.getHeight());
            this.delegate=delegate;
        }
        /*@Override*/
        getRow(y/*int*/,row){
            constsourceRow=this.delegate.getRow(y,row);
            constwidth=this.getWidth();
            for(leti=0;i<width;i++){
                sourceRow[i]=/*(byte)*/(255-(sourceRow[i]&0xFF));
            }
            returnsourceRow;
        }
        /*@Override*/
        getMatrix(){
            constmatrix=this.delegate.getMatrix();
            constlength=this.getWidth()*this.getHeight();
            constinvertedMatrix=newUint8ClampedArray(length);
            for(leti=0;i<length;i++){
                invertedMatrix[i]=/*(byte)*/(255-(matrix[i]&0xFF));
            }
            returninvertedMatrix;
        }
        /*@Override*/
        isCropSupported(){
            returnthis.delegate.isCropSupported();
        }
        /*@Override*/
        crop(left/*int*/,top/*int*/,width/*int*/,height/*int*/){
            returnnewInvertedLuminanceSource(this.delegate.crop(left,top,width,height));
        }
        /*@Override*/
        isRotateSupported(){
            returnthis.delegate.isRotateSupported();
        }
        /**
         *@returnoriginaldelegate{@linkLuminanceSource}sinceinvertundoesitself
         */
        /*@Override*/
        invert(){
            returnthis.delegate;
        }
        /*@Override*/
        rotateCounterClockwise(){
            returnnewInvertedLuminanceSource(this.delegate.rotateCounterClockwise());
        }
        /*@Override*/
        rotateCounterClockwise45(){
            returnnewInvertedLuminanceSource(this.delegate.rotateCounterClockwise45());
        }
    }

    /**
     *@deprecatedMovingto@zxing/browser
     */
    classHTMLCanvasElementLuminanceSourceextendsLuminanceSource{
        constructor(canvas){
            super(canvas.width,canvas.height);
            this.canvas=canvas;
            this.tempCanvasElement=null;
            this.buffer=HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);
        }
        staticmakeBufferFromCanvasImageData(canvas){
            constimageData=canvas.getContext('2d').getImageData(0,0,canvas.width,canvas.height);
            returnHTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data,canvas.width,canvas.height);
        }
        statictoGrayscaleBuffer(imageBuffer,width,height){
            constgrayscaleBuffer=newUint8ClampedArray(width*height);
            for(leti=0,j=0,length=imageBuffer.length;i<length;i+=4,j++){
                letgray;
                constalpha=imageBuffer[i+3];
                //Thecoloroffully-transparentpixelsisirrelevant.Theyareoften,technically,fully-transparent
                //black(0alpha,andthen0RGB).Theyareoftenused,ofcourseasthe"white"areaina
                //barcodeimage.Forceanysuchpixeltobewhite:
                if(alpha===0){
                    gray=0xFF;
                }
                else{
                    constpixelR=imageBuffer[i];
                    constpixelG=imageBuffer[i+1];
                    constpixelB=imageBuffer[i+2];
                    //.299R+0.587G+0.114B(YUV/YIQforPALandNTSC),
                    //(306*R)>>10isapproximatelyequaltoR*0.299,andsoon.
                    //0x200>>10is0.5,itimplementsrounding.
                    gray=(306*pixelR+
                        601*pixelG+
                        117*pixelB+
                        0x200)>>10;
                }
                grayscaleBuffer[j]=gray;
            }
            returngrayscaleBuffer;
        }
        getRow(y/*int*/,row){
            if(y<0||y>=this.getHeight()){
                thrownewIllegalArgumentException('Requestedrowisoutsidetheimage:'+y);
            }
            constwidth=this.getWidth();
            conststart=y*width;
            if(row===null){
                row=this.buffer.slice(start,start+width);
            }
            else{
                if(row.length<width){
                    row=newUint8ClampedArray(width);
                }
                //Theunderlyingrasterofimageconsistsofbyteswiththeluminancevalues
                //TODO:canavoidset/slice?
                row.set(this.buffer.slice(start,start+width));
            }
            returnrow;
        }
        getMatrix(){
            returnthis.buffer;
        }
        isCropSupported(){
            returntrue;
        }
        crop(left/*int*/,top/*int*/,width/*int*/,height/*int*/){
            super.crop(left,top,width,height);
            returnthis;
        }
        /**
         *Thisisalwaystrue,sincetheimageisagray-scaleimage.
         *
         *@returntrue
         */
        isRotateSupported(){
            returntrue;
        }
        rotateCounterClockwise(){
            this.rotate(-90);
            returnthis;
        }
        rotateCounterClockwise45(){
            this.rotate(-45);
            returnthis;
        }
        getTempCanvasElement(){
            if(null===this.tempCanvasElement){
                consttempCanvasElement=this.canvas.ownerDocument.createElement('canvas');
                tempCanvasElement.width=this.canvas.width;
                tempCanvasElement.height=this.canvas.height;
                this.tempCanvasElement=tempCanvasElement;
            }
            returnthis.tempCanvasElement;
        }
        rotate(angle){
            consttempCanvasElement=this.getTempCanvasElement();
            consttempContext=tempCanvasElement.getContext('2d');
            constangleRadians=angle*HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;
            //Calculateandsetnewdimensionsfortempcanvas
            constwidth=this.canvas.width;
            constheight=this.canvas.height;
            constnewWidth=Math.ceil(Math.abs(Math.cos(angleRadians))*width+Math.abs(Math.sin(angleRadians))*height);
            constnewHeight=Math.ceil(Math.abs(Math.sin(angleRadians))*width+Math.abs(Math.cos(angleRadians))*height);
            tempCanvasElement.width=newWidth;
            tempCanvasElement.height=newHeight;
            //Drawatcenteroftempcanvastopreventclippingofimagedata
            tempContext.translate(newWidth/2,newHeight/2);
            tempContext.rotate(angleRadians);
            tempContext.drawImage(this.canvas,width/-2,height/-2);
            this.buffer=HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);
            returnthis;
        }
        invert(){
            returnnewInvertedLuminanceSource(this);
        }
    }
    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS=Math.PI/180;

    /**
     *@deprecatedMovingto@zxing/browser
     *
     *Videoinputdevicemetadatacontainingtheidandlabelofthedeviceifavailable.
     */
    classVideoInputDevice{
        /**
         *CreatesaninstanceofVideoInputDevice.
         *
         *@param{string}deviceIdthevideoinputdeviceid
         *@param{string}labelthelabelofthedeviceifavailable
         */
        constructor(deviceId,label,groupId){
            this.deviceId=deviceId;
            this.label=label;
            /**@inheritdoc*/
            this.kind='videoinput';
            this.groupId=groupId||undefined;
        }
        /**@inheritdoc*/
        toJSON(){
            return{
                kind:this.kind,
                groupId:this.groupId,
                deviceId:this.deviceId,
                label:this.label,
            };
        }
    }

    var__awaiter=((globalThis||global||self||window||undefined)&&(globalThis||global||self||window||undefined).__awaiter)||function(thisArg,_arguments,P,generator){
        functionadopt(value){returnvalueinstanceofP?value:newP(function(resolve){resolve(value);});}
        returnnew(P||(P=Promise))(function(resolve,reject){
            functionfulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}
            functionrejected(value){try{step(generator["throw"](value));}catch(e){reject(e);}}
            functionstep(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}
            step((generator=generator.apply(thisArg,_arguments||[])).next());
        });
    };
    /**
     *@deprecatedMovingto@zxing/browser
     *
     *Baseclassforbrowsercodereader.
     */
    classBrowserCodeReader{
        /**
         *CreatesaninstanceofBrowserCodeReader.
         *@param{Reader}readerThereaderinstancetodecodethebarcode
         *@param{number}[timeBetweenScansMillis=500]thetimedelaybetweensubsequentsuccessfuldecodetries
         *
         *@memberOfBrowserCodeReader
         */
        constructor(reader,timeBetweenScansMillis=500,_hints){
            this.reader=reader;
            this.timeBetweenScansMillis=timeBetweenScansMillis;
            this._hints=_hints;
            /**
             *Thiswillbreaktheloop.
             */
            this._stopContinuousDecode=false;
            /**
             *Thiswillbreaktheloop.
             */
            this._stopAsyncDecode=false;
            /**
             *Delaytimebetweendecodeattemptsmadebythescanner.
             */
            this._timeBetweenDecodingAttempts=0;
        }
        /**
         *Ifnavigatorispresent.
         */
        gethasNavigator(){
            returntypeofnavigator!=='undefined';
        }
        /**
         *IfmediaDevicesundernavigatorissupported.
         */
        getisMediaDevicesSuported(){
            returnthis.hasNavigator&&!!navigator.mediaDevices;
        }
        /**
         *IfenumerateDevicesundernavigatorissupported.
         */
        getcanEnumerateDevices(){
            return!!(this.isMediaDevicesSuported&&navigator.mediaDevices.enumerateDevices);
        }
        /**Timebetweentwodecodingtriesinmilliseconds.*/
        gettimeBetweenDecodingAttempts(){
            returnthis._timeBetweenDecodingAttempts;
        }
        /**
         *Changethetimespanthedecoderwaitsbetweentwodecodingtries.
         *
         *@param{number}millisTimebetweentwodecodingtriesinmilliseconds.
         */
        settimeBetweenDecodingAttempts(millis){
            this._timeBetweenDecodingAttempts=millis<0?0:millis;
        }
        /**
         *Setsthehints.
         */
        sethints(hints){
            this._hints=hints||null;
        }
        /**
         *Setsthehints.
         */
        gethints(){
            returnthis._hints;
        }
        /**
         *Listsalltheavailablevideoinputdevices.
         */
        listVideoInputDevices(){
            return__awaiter(this,void0,void0,function*(){
                if(!this.hasNavigator){
                    thrownewError('Can\'tenumeratedevices,navigatorisnotpresent.');
                }
                if(!this.canEnumerateDevices){
                    thrownewError('Can\'tenumeratedevices,methodnotsupported.');
                }
                constdevices=yieldnavigator.mediaDevices.enumerateDevices();
                constvideoDevices=[];
                for(constdeviceofdevices){
                    constkind=device.kind==='video'?'videoinput':device.kind;
                    if(kind!=='videoinput'){
                        continue;
                    }
                    constdeviceId=device.deviceId||device.id;
                    constlabel=device.label||`Videodevice${videoDevices.length+1}`;
                    constgroupId=device.groupId;
                    constvideoDevice={deviceId,label,kind,groupId};
                    videoDevices.push(videoDevice);
                }
                returnvideoDevices;
            });
        }
        /**
         *Obtainthelistofavailabledeviceswithtype'videoinput'.
         *
         *@returns{Promise<VideoInputDevice[]>}anarrayofavailablevideoinputdevices
         *
         *@memberOfBrowserCodeReader
         *
         *@deprecatedUse`listVideoInputDevices`instead.
         */
        getVideoInputDevices(){
            return__awaiter(this,void0,void0,function*(){
                constdevices=yieldthis.listVideoInputDevices();
                returndevices.map(d=>newVideoInputDevice(d.deviceId,d.label));
            });
        }
        /**
         *Let'syoufindadeviceusingit'sId.
         */
        findDeviceById(deviceId){
            return__awaiter(this,void0,void0,function*(){
                constdevices=yieldthis.listVideoInputDevices();
                if(!devices){
                    returnnull;
                }
                returndevices.find(x=>x.deviceId===deviceId);
            });
        }
        /**
         *DecodesthebarcodefromthedevicespecifiedbydeviceIdwhileshowingthevideointhespecifiedvideoelement.
         *
         *@paramdeviceIdtheidofoneofthedevicesobtainedaftercallinggetVideoInputDevices.Canbeundefined,inthiscaseitwilldecodefromoneoftheavailabledevices,prefferingthemaincamera(environmentfacing)ifavailable.
         *@paramvideothevideoelementinpagewheretoshowthevideowhiledecoding.CanbeeitheranelementidordirectlyanHTMLVideoElement.Canbeundefined,inwhichcasenovideowillbeshown.
         *@returnsThedecodingresult.
         *
         *@memberOfBrowserCodeReader
         *
         *@deprecatedUse`decodeOnceFromVideoDevice`instead.
         */
        decodeFromInputVideoDevice(deviceId,videoSource){
            return__awaiter(this,void0,void0,function*(){
                returnyieldthis.decodeOnceFromVideoDevice(deviceId,videoSource);
            });
        }
        /**
         *Inoneattempt,triestodecodethebarcodefromthedevicespecifiedbydeviceIdwhileshowingthevideointhespecifiedvideoelement.
         *
         *@paramdeviceIdtheidofoneofthedevicesobtainedaftercallinggetVideoInputDevices.Canbeundefined,inthiscaseitwilldecodefromoneoftheavailabledevices,prefferingthemaincamera(environmentfacing)ifavailable.
         *@paramvideothevideoelementinpagewheretoshowthevideowhiledecoding.CanbeeitheranelementidordirectlyanHTMLVideoElement.Canbeundefined,inwhichcasenovideowillbeshown.
         *@returnsThedecodingresult.
         *
         *@memberOfBrowserCodeReader
         */
        decodeOnceFromVideoDevice(deviceId,videoSource){
            return__awaiter(this,void0,void0,function*(){
                this.reset();
                letvideoConstraints;
                if(!deviceId){
                    videoConstraints={facingMode:'environment'};
                }
                else{
                    videoConstraints={deviceId:{exact:deviceId}};
                }
                constconstraints={video:videoConstraints};
                returnyieldthis.decodeOnceFromConstraints(constraints,videoSource);
            });
        }
        /**
         *Inoneattempt,triestodecodethebarcodefromastreamobtainedfromthegivenconstraintswhileshowingthevideointhespecifiedvideoelement.
         *
         *@paramconstraintsthemediastreamconstraintstogetsvalidmediastreamtodecodefrom
         *@paramvideothevideoelementinpagewheretoshowthevideowhiledecoding.CanbeeitheranelementidordirectlyanHTMLVideoElement.Canbeundefined,inwhichcasenovideowillbeshown.
         *@returnsThedecodingresult.
         *
         *@memberOfBrowserCodeReader
         */
        decodeOnceFromConstraints(constraints,videoSource){
            return__awaiter(this,void0,void0,function*(){
                conststream=yieldnavigator.mediaDevices.getUserMedia(constraints);
                returnyieldthis.decodeOnceFromStream(stream,videoSource);
            });
        }
        /**
         *Inoneattempt,triestodecodethebarcodefromastreamobtainedfromthegivenconstraintswhileshowingthevideointhespecifiedvideoelement.
         *
         *@param{MediaStream}[constraints]themediastreamconstraintstogetsvalidmediastreamtodecodefrom
         *@param{string|HTMLVideoElement}[video]thevideoelementinpagewheretoshowthevideowhiledecoding.CanbeeitheranelementidordirectlyanHTMLVideoElement.Canbeundefined,inwhichcasenovideowillbeshown.
         *@returns{Promise<Result>}Thedecodingresult.
         *
         *@memberOfBrowserCodeReader
         */
        decodeOnceFromStream(stream,videoSource){
            return__awaiter(this,void0,void0,function*(){
                this.reset();
                constvideo=yieldthis.attachStreamToVideo(stream,videoSource);
                constresult=yieldthis.decodeOnce(video);
                returnresult;
            });
        }
        /**
         *Continuouslydecodesthebarcodefromthedevicespecifiedbydevicewhileshowingthevideointhespecifiedvideoelement.
         *
         *@param{string|null}[deviceId]theidofoneofthedevicesobtainedaftercallinggetVideoInputDevices.Canbeundefined,inthiscaseitwilldecodefromoneoftheavailabledevices,prefferingthemaincamera(environmentfacing)ifavailable.
         *@param{string|HTMLVideoElement|null}[video]thevideoelementinpagewheretoshowthevideowhiledecoding.CanbeeitheranelementidordirectlyanHTMLVideoElement.Canbeundefined,inwhichcasenovideowillbeshown.
         *@returns{Promise<void>}
         *
         *@memberOfBrowserCodeReader
         *
         *@deprecatedUse`decodeFromVideoDevice`instead.
         */
        decodeFromInputVideoDeviceContinuously(deviceId,videoSource,callbackFn){
            return__awaiter(this,void0,void0,function*(){
                returnyieldthis.decodeFromVideoDevice(deviceId,videoSource,callbackFn);
            });
        }
        /**
         *Continuouslytriestodecodethebarcodefromthedevicespecifiedbydevicewhileshowingthevideointhespecifiedvideoelement.
         *
         *@param{string|null}[deviceId]theidofoneofthedevicesobtainedaftercallinggetVideoInputDevices.Canbeundefined,inthiscaseitwilldecodefromoneoftheavailabledevices,prefferingthemaincamera(environmentfacing)ifavailable.
         *@param{string|HTMLVideoElement|null}[video]thevideoelementinpagewheretoshowthevideowhiledecoding.CanbeeitheranelementidordirectlyanHTMLVideoElement.Canbeundefined,inwhichcasenovideowillbeshown.
         *@returns{Promise<void>}
         *
         *@memberOfBrowserCodeReader
         */
        decodeFromVideoDevice(deviceId,videoSource,callbackFn){
            return__awaiter(this,void0,void0,function*(){
                letvideoConstraints;
                if(!deviceId){
                    videoConstraints={facingMode:'environment'};
                }
                else{
                    videoConstraints={deviceId:{exact:deviceId}};
                }
                constconstraints={video:videoConstraints};
                returnyieldthis.decodeFromConstraints(constraints,videoSource,callbackFn);
            });
        }
        /**
         *Continuouslytriestodecodethebarcodefromastreamobtainedfromthegivenconstraintswhileshowingthevideointhespecifiedvideoelement.
         *
         *@param{MediaStream}[constraints]themediastreamconstraintstogetsvalidmediastreamtodecodefrom
         *@param{string|HTMLVideoElement}[video]thevideoelementinpagewheretoshowthevideowhiledecoding.CanbeeitheranelementidordirectlyanHTMLVideoElement.Canbeundefined,inwhichcasenovideowillbeshown.
         *@returns{Promise<Result>}Thedecodingresult.
         *
         *@memberOfBrowserCodeReader
         */
        decodeFromConstraints(constraints,videoSource,callbackFn){
            return__awaiter(this,void0,void0,function*(){
                conststream=yieldnavigator.mediaDevices.getUserMedia(constraints);
                returnyieldthis.decodeFromStream(stream,videoSource,callbackFn);
            });
        }
        /**
         *Inoneattempt,triestodecodethebarcodefromastreamobtainedfromthegivenconstraintswhileshowingthevideointhespecifiedvideoelement.
         *
         *@param{MediaStream}[constraints]themediastreamconstraintstogetsvalidmediastreamtodecodefrom
         *@param{string|HTMLVideoElement}[video]thevideoelementinpagewheretoshowthevideowhiledecoding.CanbeeitheranelementidordirectlyanHTMLVideoElement.Canbeundefined,inwhichcasenovideowillbeshown.
         *@returns{Promise<Result>}Thedecodingresult.
         *
         *@memberOfBrowserCodeReader
         */
        decodeFromStream(stream,videoSource,callbackFn){
            return__awaiter(this,void0,void0,function*(){
                this.reset();
                constvideo=yieldthis.attachStreamToVideo(stream,videoSource);
                returnyieldthis.decodeContinuously(video,callbackFn);
            });
        }
        /**
         *Breaksthedecodingloop.
         */
        stopAsyncDecode(){
            this._stopAsyncDecode=true;
        }
        /**
         *Breaksthedecodingloop.
         */
        stopContinuousDecode(){
            this._stopContinuousDecode=true;
        }
        /**
         *Setsthenewstreamandrequestanewdecoding-with-delay.
         *
         *@paramstreamThestreamtobeshowninthevideoelement.
         *@paramdecodeFnAcallbackforthedecodemethod.
         */
        attachStreamToVideo(stream,videoSource){
            return__awaiter(this,void0,void0,function*(){
                constvideoElement=this.prepareVideoElement(videoSource);
                this.addVideoSource(videoElement,stream);
                this.videoElement=videoElement;
                this.stream=stream;
                yieldthis.playVideoOnLoadAsync(videoElement);
                returnvideoElement;
            });
        }
        /**
         *
         *@paramvideoElement
         */
        playVideoOnLoadAsync(videoElement){
            returnnewPromise((resolve,reject)=>this.playVideoOnLoad(videoElement,()=>resolve()));
        }
        /**
         *BindslistenersandcallbackstothevideoElement.
         *
         *@paramelement
         *@paramcallbackFn
         */
        playVideoOnLoad(element,callbackFn){
            this.videoEndedListener=()=>this.stopStreams();
            this.videoCanPlayListener=()=>this.tryPlayVideo(element);
            element.addEventListener('ended',this.videoEndedListener);
            element.addEventListener('canplay',this.videoCanPlayListener);
            element.addEventListener('playing',callbackFn);
            //ifcanplaywasalreadyfired,wewon'tknowwhentoplay,sojustgiveitatry
            this.tryPlayVideo(element);
        }
        /**
         *Checksifthegivenvideoelementiscurrentlyplaying.
         */
        isVideoPlaying(video){
            returnvideo.currentTime>0&&!video.paused&&!video.ended&&video.readyState>2;
        }
        /**
         *Justtriestoplaythevideoandlogsanyerrors.
         *Theplaycallisonlymadeisthevideoisnotalreadyplaying.
         */
        tryPlayVideo(videoElement){
            return__awaiter(this,void0,void0,function*(){
                if(this.isVideoPlaying(videoElement)){
                    console.warn('Tryingtoplayvideothatisalreadyplaying.');
                    return;
                }
                try{
                    yieldvideoElement.play();
                }
                catch(_a){
                    console.warn('Itwasnotpossibletoplaythevideo.');
                }
            });
        }
        /**
         *Searchesandvalidatesamediaelement.
         */
        getMediaElement(mediaElementId,type){
            constmediaElement=document.getElementById(mediaElementId);
            if(!mediaElement){
                thrownewArgumentException(`elementwithid'${mediaElementId}'notfound`);
            }
            if(mediaElement.nodeName.toLowerCase()!==type.toLowerCase()){
                thrownewArgumentException(`elementwithid'${mediaElementId}'mustbean${type}element`);
            }
            returnmediaElement;
        }
        /**
         *Decodesthebarcodefromanimage.
         *
         *@param{(string|HTMLImageElement)}[source]Theimageelementthatcanbeeitheranelementidortheelementitself.CanbeundefinedinwhichcasethedecodingwillbedonefromtheimageUrlparameter.
         *@param{string}[url]
         *@returns{Promise<Result>}Thedecodingresult.
         *
         *@memberOfBrowserCodeReader
         */
        decodeFromImage(source,url){
            if(!source&&!url){
                thrownewArgumentException('eitherimageElementwithasrcsetoranurlmustbeprovided');
            }
            if(url&&!source){
                returnthis.decodeFromImageUrl(url);
            }
            returnthis.decodeFromImageElement(source);
        }
        /**
         *Decodesthebarcodefromavideo.
         *
         *@param{(string|HTMLImageElement)}[source]Theimageelementthatcanbeeitheranelementidortheelementitself.CanbeundefinedinwhichcasethedecodingwillbedonefromtheimageUrlparameter.
         *@param{string}[url]
         *@returns{Promise<Result>}Thedecodingresult.
         *
         *@memberOfBrowserCodeReader
         */
        decodeFromVideo(source,url){
            if(!source&&!url){
                thrownewArgumentException('EitheranelementwithasrcsetoranURLmustbeprovided');
            }
            if(url&&!source){
                returnthis.decodeFromVideoUrl(url);
            }
            returnthis.decodeFromVideoElement(source);
        }
        /**
         *Decodescontinuouslythebarcodefromavideo.
         *
         *@param{(string|HTMLImageElement)}[source]Theimageelementthatcanbeeitheranelementidortheelementitself.CanbeundefinedinwhichcasethedecodingwillbedonefromtheimageUrlparameter.
         *@param{string}[url]
         *@returns{Promise<Result>}Thedecodingresult.
         *
         *@memberOfBrowserCodeReader
         *
         *@experimental
         */
        decodeFromVideoContinuously(source,url,callbackFn){
            if(undefined===source&&undefined===url){
                thrownewArgumentException('EitheranelementwithasrcsetoranURLmustbeprovided');
            }
            if(url&&!source){
                returnthis.decodeFromVideoUrlContinuously(url,callbackFn);
            }
            returnthis.decodeFromVideoElementContinuously(source,callbackFn);
        }
        /**
         *DecodessomethingfromanimageHTMLelement.
         */
        decodeFromImageElement(source){
            if(!source){
                thrownewArgumentException('Animageelementmustbeprovided.');
            }
            this.reset();
            constelement=this.prepareImageElement(source);
            this.imageElement=element;
            lettask;
            if(this.isImageLoaded(element)){
                task=this.decodeOnce(element,false,true);
            }
            else{
                task=this._decodeOnLoadImage(element);
            }
            returntask;
        }
        /**
         *DecodessomethingfromanimageHTMLelement.
         */
        decodeFromVideoElement(source){
            constelement=this._decodeFromVideoElementSetup(source);
            returnthis._decodeOnLoadVideo(element);
        }
        /**
         *DecodessomethingfromanimageHTMLelement.
         */
        decodeFromVideoElementContinuously(source,callbackFn){
            constelement=this._decodeFromVideoElementSetup(source);
            returnthis._decodeOnLoadVideoContinuously(element,callbackFn);
        }
        /**
         *Setsupthevideosourcesoitcanbedecodedwhenloaded.
         *
         *@paramsourceThevideosourceelement.
         */
        _decodeFromVideoElementSetup(source){
            if(!source){
                thrownewArgumentException('Avideoelementmustbeprovided.');
            }
            this.reset();
            constelement=this.prepareVideoElement(source);
            //definesthevideoelementbeforestartsdecoding
            this.videoElement=element;
            returnelement;
        }
        /**
         *DecodesanimagefromaURL.
         */
        decodeFromImageUrl(url){
            if(!url){
                thrownewArgumentException('AnURLmustbeprovided.');
            }
            this.reset();
            constelement=this.prepareImageElement();
            this.imageElement=element;
            constdecodeTask=this._decodeOnLoadImage(element);
            element.src=url;
            returndecodeTask;
        }
        /**
         *DecodesanimagefromaURL.
         */
        decodeFromVideoUrl(url){
            if(!url){
                thrownewArgumentException('AnURLmustbeprovided.');
            }
            this.reset();
            //createsanewelement
            constelement=this.prepareVideoElement();
            constdecodeTask=this.decodeFromVideoElement(element);
            element.src=url;
            returndecodeTask;
        }
        /**
         *DecodesanimagefromaURL.
         *
         *@experimental
         */
        decodeFromVideoUrlContinuously(url,callbackFn){
            if(!url){
                thrownewArgumentException('AnURLmustbeprovided.');
            }
            this.reset();
            //createsanewelement
            constelement=this.prepareVideoElement();
            constdecodeTask=this.decodeFromVideoElementContinuously(element,callbackFn);
            element.src=url;
            returndecodeTask;
        }
        _decodeOnLoadImage(element){
            returnnewPromise((resolve,reject)=>{
                this.imageLoadedListener=()=>this.decodeOnce(element,false,true).then(resolve,reject);
                element.addEventListener('load',this.imageLoadedListener);
            });
        }
        _decodeOnLoadVideo(videoElement){
            return__awaiter(this,void0,void0,function*(){
                //playsthevideo
                yieldthis.playVideoOnLoadAsync(videoElement);
                //startsdecodingafterplayedthevideo
                returnyieldthis.decodeOnce(videoElement);
            });
        }
        _decodeOnLoadVideoContinuously(videoElement,callbackFn){
            return__awaiter(this,void0,void0,function*(){
                //playsthevideo
                yieldthis.playVideoOnLoadAsync(videoElement);
                //startsdecodingafterplayedthevideo
                this.decodeContinuously(videoElement,callbackFn);
            });
        }
        isImageLoaded(img){
            //Duringtheonloadevent,IEcorrectlyidentifiesanyimagesthat
            //weren’tdownloadedasnotcomplete.Othersshouldtoo.Gecko-based
            //browsersactlikeNS4inthattheyreportthisincorrectly.
            if(!img.complete){
                returnfalse;
            }
            //However,theydohavetwoveryusefulproperties:naturalWidthand
            //naturalHeight.Thesegivethetruesizeoftheimage.Ifitfailed
            //toload,eitheroftheseshouldbezero.
            if(img.naturalWidth===0){
                returnfalse;
            }
            //Nootherwayofchecking:assumeit’sok.
            returntrue;
        }
        prepareImageElement(imageSource){
            letimageElement;
            if(typeofimageSource==='undefined'){
                imageElement=document.createElement('img');
                imageElement.width=200;
                imageElement.height=200;
            }
            if(typeofimageSource==='string'){
                imageElement=this.getMediaElement(imageSource,'img');
            }
            if(imageSourceinstanceofHTMLImageElement){
                imageElement=imageSource;
            }
            returnimageElement;
        }
        /**
         *SetsaHTMLVideoElementforscanningorcreatesanewone.
         *
         *@paramvideoSourceTheHTMLVideoElementtobeset.
         */
        prepareVideoElement(videoSource){
            letvideoElement;
            if(!videoSource&&typeofdocument!=='undefined'){
                videoElement=document.createElement('video');
                videoElement.width=200;
                videoElement.height=200;
            }
            if(typeofvideoSource==='string'){
                videoElement=this.getMediaElement(videoSource,'video');
            }
            if(videoSourceinstanceofHTMLVideoElement){
                videoElement=videoSource;
            }
            //NeededforiOS11
            videoElement.setAttribute('autoplay','true');
            videoElement.setAttribute('muted','true');
            videoElement.setAttribute('playsinline','true');
            returnvideoElement;
        }
        /**
         *Triestodecodefromthevideoinputuntilitfindssomevalue.
         */
        decodeOnce(element,retryIfNotFound=true,retryIfChecksumOrFormatError=true){
            this._stopAsyncDecode=false;
            constloop=(resolve,reject)=>{
                if(this._stopAsyncDecode){
                    reject(newNotFoundException('Videostreamhasendedbeforeanycodecouldbedetected.'));
                    this._stopAsyncDecode=undefined;
                    return;
                }
                try{
                    constresult=this.decode(element);
                    resolve(result);
                }
                catch(e){
                    constifNotFound=retryIfNotFound&&einstanceofNotFoundException;
                    constisChecksumOrFormatError=einstanceofChecksumException||einstanceofFormatException;
                    constifChecksumOrFormat=isChecksumOrFormatError&&retryIfChecksumOrFormatError;
                    if(ifNotFound||ifChecksumOrFormat){
                        //tryingagain
                        returnsetTimeout(loop,this._timeBetweenDecodingAttempts,resolve,reject);
                    }
                    reject(e);
                }
            };
            returnnewPromise((resolve,reject)=>loop(resolve,reject));
        }
        /**
         *Continuouslydecodesfromvideoinput.
         */
        decodeContinuously(element,callbackFn){
            this._stopContinuousDecode=false;
            constloop=()=>{
                if(this._stopContinuousDecode){
                    this._stopContinuousDecode=undefined;
                    return;
                }
                try{
                    constresult=this.decode(element);
                    callbackFn(result,null);
                    setTimeout(loop,this.timeBetweenScansMillis);
                }
                catch(e){
                    callbackFn(null,e);
                    constisChecksumOrFormatError=einstanceofChecksumException||einstanceofFormatException;
                    constisNotFound=einstanceofNotFoundException;
                    if(isChecksumOrFormatError||isNotFound){
                        //tryingagain
                        setTimeout(loop,this._timeBetweenDecodingAttempts);
                    }
                }
            };
            loop();
        }
        /**
         *GetstheBinaryBitmapforya!(anddecodesit)
         */
        decode(element){
            //getbinarybitmapfordecodefunction
            constbinaryBitmap=this.createBinaryBitmap(element);
            returnthis.decodeBitmap(binaryBitmap);
        }
        /**
         *CreatesabinaryBitmapbasedinsomeimagesource.
         *
         *@parammediaElementHTMLelementcontainingdrawableimagesource.
         */
        createBinaryBitmap(mediaElement){
            constctx=this.getCaptureCanvasContext(mediaElement);
            this.drawImageOnCanvas(ctx,mediaElement);
            constcanvas=this.getCaptureCanvas(mediaElement);
            constluminanceSource=newHTMLCanvasElementLuminanceSource(canvas);
            consthybridBinarizer=newHybridBinarizer(luminanceSource);
            returnnewBinaryBitmap(hybridBinarizer);
        }
        /**
         *
         */
        getCaptureCanvasContext(mediaElement){
            if(!this.captureCanvasContext){
                constelem=this.getCaptureCanvas(mediaElement);
                constctx=elem.getContext('2d');
                this.captureCanvasContext=ctx;
            }
            returnthis.captureCanvasContext;
        }
        /**
         *
         */
        getCaptureCanvas(mediaElement){
            if(!this.captureCanvas){
                constelem=this.createCaptureCanvas(mediaElement);
                this.captureCanvas=elem;
            }
            returnthis.captureCanvas;
        }
        /**
         *Ovewritingthisallowsyoutomanipulatethesnapshotimageinanywayyouwantbeforedecode.
         */
        drawImageOnCanvas(canvasElementContext,srcElement){
            canvasElementContext.drawImage(srcElement,0,0);
        }
        /**
         *Calltheencapsulatedreadersdecode
         */
        decodeBitmap(binaryBitmap){
            returnthis.reader.decode(binaryBitmap,this._hints);
        }
        /**
         *🖌Preparesthecanvasforcaptureandscanframes.
         */
        createCaptureCanvas(mediaElement){
            if(typeofdocument==='undefined'){
                this._destroyCaptureCanvas();
                returnnull;
            }
            constcanvasElement=document.createElement('canvas');
            letwidth;
            letheight;
            if(typeofmediaElement!=='undefined'){
                if(mediaElementinstanceofHTMLVideoElement){
                    width=mediaElement.videoWidth;
                    height=mediaElement.videoHeight;
                }
                elseif(mediaElementinstanceofHTMLImageElement){
                    width=mediaElement.naturalWidth||mediaElement.width;
                    height=mediaElement.naturalHeight||mediaElement.height;
                }
            }
            canvasElement.style.width=width+'px';
            canvasElement.style.height=height+'px';
            canvasElement.width=width;
            canvasElement.height=height;
            returncanvasElement;
        }
        /**
         *Stopsthecontinuousscanandcleansthestream.
         */
        stopStreams(){
            if(this.stream){
                this.stream.getVideoTracks().forEach(t=>t.stop());
                this.stream=undefined;
            }
            if(this._stopAsyncDecode===false){
                this.stopAsyncDecode();
            }
            if(this._stopContinuousDecode===false){
                this.stopContinuousDecode();
            }
        }
        /**
         *Resetsthecodereadertotheinitialstate.Cancelsanyongoingbarcodescanningfromvideoorcamera.
         *
         *@memberOfBrowserCodeReader
         */
        reset(){
            //stopsthecamera,previewandscan🔴
            this.stopStreams();
            //cleanandforgetaboutHTMLelements
            this._destroyVideoElement();
            this._destroyImageElement();
            this._destroyCaptureCanvas();
        }
        _destroyVideoElement(){
            if(!this.videoElement){
                return;
            }
            //firstgivesfreedontotheelement🕊
            if(typeofthis.videoEndedListener!=='undefined'){
                this.videoElement.removeEventListener('ended',this.videoEndedListener);
            }
            if(typeofthis.videoPlayingEventListener!=='undefined'){
                this.videoElement.removeEventListener('playing',this.videoPlayingEventListener);
            }
            if(typeofthis.videoCanPlayListener!=='undefined'){
                this.videoElement.removeEventListener('loadedmetadata',this.videoCanPlayListener);
            }
            //thenforgetsaboutthatelement😢
            this.cleanVideoSource(this.videoElement);
            this.videoElement=undefined;
        }
        _destroyImageElement(){
            if(!this.imageElement){
                return;
            }
            //firstgivesfreedontotheelement🕊
            if(undefined!==this.imageLoadedListener){
                this.imageElement.removeEventListener('load',this.imageLoadedListener);
            }
            //thenforgetaboutthatelement😢
            this.imageElement.src=undefined;
            this.imageElement.removeAttribute('src');
            this.imageElement=undefined;
        }
        /**
         *Cleanscanvasreferences🖌
         */
        _destroyCaptureCanvas(){
            //thenforgetaboutthatelement😢
            this.captureCanvasContext=undefined;
            this.captureCanvas=undefined;
        }
        /**
         *DefineswhatthevideoElementsrcwillbe.
         *
         *@paramvideoElement
         *@paramstream
         */
        addVideoSource(videoElement,stream){
            //Olderbrowsersmaynothave`srcObject`
            try{
                //@noteThrowsExceptionifinterruptedbyanewloadedrequest
                videoElement.srcObject=stream;
            }
            catch(err){
                //@noteAvoidusingthisinnewbrowsers,asitisgoingaway.
                videoElement.src=URL.createObjectURL(stream);
            }
        }
        /**
         *UnbindsaHTMLvideosrcproperty.
         *
         *@paramvideoElement
         */
        cleanVideoSource(videoElement){
            try{
                videoElement.srcObject=null;
            }
            catch(err){
                videoElement.src='';
            }
            this.videoElement.removeAttribute('src');
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Encapsulatestheresultofdecodingabarcodewithinanimage.</p>
     *
     *@authorSeanOwen
     */
    classResult{
        //publicconstructor(privatetext:string,
        //              Uint8ArrayrawBytes,
        //              ResultPoconstresultPoints:Int32Array,
        //              BarcodeFormatformat){
        //  this(text,rawBytes,resultPoints,format,System.currentTimeMillis())
        //}
        //publicconstructor(text:string,
        //              Uint8ArrayrawBytes,
        //              ResultPoconstresultPoints:Int32Array,
        //              BarcodeFormatformat,
        //              longtimestamp){
        //  this(text,rawBytes,rawBytes==null?0:8*rawBytes.length,
        //       resultPoints,format,timestamp)
        //}
        constructor(text,rawBytes,numBits=rawBytes==null?0:8*rawBytes.length,resultPoints,format,timestamp=System.currentTimeMillis()){
            this.text=text;
            this.rawBytes=rawBytes;
            this.numBits=numBits;
            this.resultPoints=resultPoints;
            this.format=format;
            this.timestamp=timestamp;
            this.text=text;
            this.rawBytes=rawBytes;
            if(undefined===numBits||null===numBits){
                this.numBits=(rawBytes===null||rawBytes===undefined)?0:8*rawBytes.length;
            }
            else{
                this.numBits=numBits;
            }
            this.resultPoints=resultPoints;
            this.format=format;
            this.resultMetadata=null;
            if(undefined===timestamp||null===timestamp){
                this.timestamp=System.currentTimeMillis();
            }
            else{
                this.timestamp=timestamp;
            }
        }
        /**
         *@returnrawtextencodedbythebarcode
         */
        getText(){
            returnthis.text;
        }
        /**
         *@returnrawbytesencodedbythebarcode,ifapplicable,otherwise{@codenull}
         */
        getRawBytes(){
            returnthis.rawBytes;
        }
        /**
         *@returnhowmanybitsof{@link#getRawBytes()}arevalid;typically8timesitslength
         *@since3.3.0
         */
        getNumBits(){
            returnthis.numBits;
        }
        /**
         *@returnpointsrelatedtothebarcodeintheimage.Thesearetypicallypoints
         *        identifyingfinderpatternsorthecornersofthebarcode.Theexactmeaningis
         *        specifictothetypeofbarcodethatwasdecoded.
         */
        getResultPoints(){
            returnthis.resultPoints;
        }
        /**
         *@return{@linkBarcodeFormat}representingtheformatofthebarcodethatwasdecoded
         */
        getBarcodeFormat(){
            returnthis.format;
        }
        /**
         *@return{@linkMap}mapping{@linkResultMetadataType}keystovalues.Maybe
         *  {@codenull}.Thiscontainsoptionalmetadataaboutwhatwasdetectedaboutthebarcode,
         *  likeorientation.
         */
        getResultMetadata(){
            returnthis.resultMetadata;
        }
        putMetadata(type,value){
            if(this.resultMetadata===null){
                this.resultMetadata=newMap();
            }
            this.resultMetadata.set(type,value);
        }
        putAllMetadata(metadata){
            if(metadata!==null){
                if(this.resultMetadata===null){
                    this.resultMetadata=metadata;
                }
                else{
                    this.resultMetadata=newMap(metadata);
                }
            }
        }
        addResultPoints(newPoints){
            constoldPoints=this.resultPoints;
            if(oldPoints===null){
                this.resultPoints=newPoints;
            }
            elseif(newPoints!==null&&newPoints.length>0){
                constallPoints=newArray(oldPoints.length+newPoints.length);
                System.arraycopy(oldPoints,0,allPoints,0,oldPoints.length);
                System.arraycopy(newPoints,0,allPoints,oldPoints.length,newPoints.length);
                this.resultPoints=allPoints;
            }
        }
        getTimestamp(){
            returnthis.timestamp;
        }
        /*@Override*/
        toString(){
            returnthis.text;
        }
    }

    /*
     *DirectporttoTypeScriptofZXingbyAdrianToșcă
     */
    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*namespacecom.google.zxing{*/
    /**
     *Enumeratesbarcodeformatsknowntothispackage.Pleasekeepalphabetized.
     *
     *@authorSeanOwen
     */
    varBarcodeFormat;
    (function(BarcodeFormat){
        /**Aztec2Dbarcodeformat.*/
        BarcodeFormat[BarcodeFormat["AZTEC"]=0]="AZTEC";
        /**CODABAR1Dformat.*/
        BarcodeFormat[BarcodeFormat["CODABAR"]=1]="CODABAR";
        /**Code391Dformat.*/
        BarcodeFormat[BarcodeFormat["CODE_39"]=2]="CODE_39";
        /**Code931Dformat.*/
        BarcodeFormat[BarcodeFormat["CODE_93"]=3]="CODE_93";
        /**Code1281Dformat.*/
        BarcodeFormat[BarcodeFormat["CODE_128"]=4]="CODE_128";
        /**DataMatrix2Dbarcodeformat.*/
        BarcodeFormat[BarcodeFormat["DATA_MATRIX"]=5]="DATA_MATRIX";
        /**EAN-81Dformat.*/
        BarcodeFormat[BarcodeFormat["EAN_8"]=6]="EAN_8";
        /**EAN-131Dformat.*/
        BarcodeFormat[BarcodeFormat["EAN_13"]=7]="EAN_13";
        /**ITF(InterleavedTwoofFive)1Dformat.*/
        BarcodeFormat[BarcodeFormat["ITF"]=8]="ITF";
        /**MaxiCode2Dbarcodeformat.*/
        BarcodeFormat[BarcodeFormat["MAXICODE"]=9]="MAXICODE";
        /**PDF417format.*/
        BarcodeFormat[BarcodeFormat["PDF_417"]=10]="PDF_417";
        /**QRCode2Dbarcodeformat.*/
        BarcodeFormat[BarcodeFormat["QR_CODE"]=11]="QR_CODE";
        /**RSS14*/
        BarcodeFormat[BarcodeFormat["RSS_14"]=12]="RSS_14";
        /**RSSEXPANDED*/
        BarcodeFormat[BarcodeFormat["RSS_EXPANDED"]=13]="RSS_EXPANDED";
        /**UPC-A1Dformat.*/
        BarcodeFormat[BarcodeFormat["UPC_A"]=14]="UPC_A";
        /**UPC-E1Dformat.*/
        BarcodeFormat[BarcodeFormat["UPC_E"]=15]="UPC_E";
        /**UPC/EANextensionformat.Notastand-aloneformat.*/
        BarcodeFormat[BarcodeFormat["UPC_EAN_EXTENSION"]=16]="UPC_EAN_EXTENSION";
    })(BarcodeFormat||(BarcodeFormat={}));
    varBarcodeFormat$1=BarcodeFormat;

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*namespacecom.google.zxing{*/
    /**
     *Representssometypeofmetadataabouttheresultofthedecodingthatthedecoder
     *wishestocommunicatebacktothecaller.
     *
     *@authorSeanOwen
     */
    varResultMetadataType;
    (function(ResultMetadataType){
        /**
         *Unspecified,application-specificmetadata.Mapstoanunspecified{@linkObject}.
         */
        ResultMetadataType[ResultMetadataType["OTHER"]=0]="OTHER";
        /**
         *Denotesthelikelyapproximateorientationofthebarcodeintheimage.Thisvalue
         *isgivenasdegreesrotatedclockwisefromthenormal,uprightorientation.
         *Forexamplea1Dbarcodewhichwasfoundbyreadingtop-to-bottomwouldbe
         *saidtohaveorientation"90".Thiskeymapstoan{@linkInteger}whose
         *valueisintherange[0,360).
         */
        ResultMetadataType[ResultMetadataType["ORIENTATION"]=1]="ORIENTATION";
        /**
         *<p>2Dbarcodeformatstypicallyencodetext,butallowforasortof'bytemode'
         *whichissometimesusedtoencodebinarydata.While{@linkResult}makesavailable
         *thecompleterawbytesinthebarcodefortheseformats,itdoesnotofferthebytes
         *fromthebytesegmentsalone.</p>
         *
         *<p>Thismapstoa{@linkjava.util.List}ofbytearrayscorrespondingtothe
         *rawbytesinthebytesegmentsinthebarcode,inorder.</p>
         */
        ResultMetadataType[ResultMetadataType["BYTE_SEGMENTS"]=2]="BYTE_SEGMENTS";
        /**
         *Errorcorrectionlevelused,ifapplicable.Thevaluetypedependsonthe
         *format,butistypicallyaString.
         */
        ResultMetadataType[ResultMetadataType["ERROR_CORRECTION_LEVEL"]=3]="ERROR_CORRECTION_LEVEL";
        /**
         *Forsomeperiodicals,indicatestheissuenumberasan{@linkInteger}.
         */
        ResultMetadataType[ResultMetadataType["ISSUE_NUMBER"]=4]="ISSUE_NUMBER";
        /**
         *Forsomeproducts,indicatesthesuggestedretailpriceinthebarcodeasa
         *formatted{@linkString}.
         */
        ResultMetadataType[ResultMetadataType["SUGGESTED_PRICE"]=5]="SUGGESTED_PRICE";
        /**
         *Forsomeproducts,thepossiblecountryofmanufactureasa{@linkString}denotingthe
         *ISOcountrycode.Somemaptomultiplepossiblecountries,like"US/CA".
         */
        ResultMetadataType[ResultMetadataType["POSSIBLE_COUNTRY"]=6]="POSSIBLE_COUNTRY";
        /**
         *Forsomeproducts,theextensiontext
         */
        ResultMetadataType[ResultMetadataType["UPC_EAN_EXTENSION"]=7]="UPC_EAN_EXTENSION";
        /**
         *PDF417-specificmetadata
         */
        ResultMetadataType[ResultMetadataType["PDF417_EXTRA_METADATA"]=8]="PDF417_EXTRA_METADATA";
        /**
         *Ifthecodeformatsupportsstructuredappendandthecurrentscannedcodeispartofonethenthe
         *sequencenumberisgivenwithit.
         */
        ResultMetadataType[ResultMetadataType["STRUCTURED_APPEND_SEQUENCE"]=9]="STRUCTURED_APPEND_SEQUENCE";
        /**
         *Ifthecodeformatsupportsstructuredappendandthecurrentscannedcodeispartofonethenthe
         *parityisgivenwithit.
         */
        ResultMetadataType[ResultMetadataType["STRUCTURED_APPEND_PARITY"]=10]="STRUCTURED_APPEND_PARITY";
    })(ResultMetadataType||(ResultMetadataType={}));
    varResultMetadataType$1=ResultMetadataType;

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*namespacecom.google.zxing.common{*/
    /*importjava.util.List;*/
    /**
     *<p>Encapsulatestheresultofdecodingamatrixofbits.Thistypically
     *appliesto2Dbarcodeformats.Fornowitcontainstherawbytesobtained,
     *aswellasaStringinterpretationofthosebytes,ifapplicable.</p>
     *
     *@authorSeanOwen
     */
    classDecoderResult{
        //publicconstructor(rawBytes:Uint8Array,
        //                     text:string,
        //                     List<Uint8Array>byteSegments,
        //                     StringecLevel){
        //  this(rawBytes,text,byteSegments,ecLevel,-1,-1)
        //}
        constructor(rawBytes,text,byteSegments,ecLevel,structuredAppendSequenceNumber=-1,structuredAppendParity=-1){
            this.rawBytes=rawBytes;
            this.text=text;
            this.byteSegments=byteSegments;
            this.ecLevel=ecLevel;
            this.structuredAppendSequenceNumber=structuredAppendSequenceNumber;
            this.structuredAppendParity=structuredAppendParity;
            this.numBits=(rawBytes===undefined||rawBytes===null)?0:8*rawBytes.length;
        }
        /**
         *@returnrawbytesrepresentingtheresult,or{@codenull}ifnotapplicable
         */
        getRawBytes(){
            returnthis.rawBytes;
        }
        /**
         *@returnhowmanybitsof{@link#getRawBytes()}arevalid;typically8timesitslength
         *@since3.3.0
         */
        getNumBits(){
            returnthis.numBits;
        }
        /**
         *@paramnumBitsoverridesthenumberofbitsthatarevalidin{@link#getRawBytes()}
         *@since3.3.0
         */
        setNumBits(numBits/*int*/){
            this.numBits=numBits;
        }
        /**
         *@returntextrepresentationoftheresult
         */
        getText(){
            returnthis.text;
        }
        /**
         *@returnlistofbytesegmentsintheresult,or{@codenull}ifnotapplicable
         */
        getByteSegments(){
            returnthis.byteSegments;
        }
        /**
         *@returnnameoferrorcorrectionlevelused,or{@codenull}ifnotapplicable
         */
        getECLevel(){
            returnthis.ecLevel;
        }
        /**
         *@returnnumberoferrorscorrected,or{@codenull}ifnotapplicable
         */
        getErrorsCorrected(){
            returnthis.errorsCorrected;
        }
        setErrorsCorrected(errorsCorrected/*Integer*/){
            this.errorsCorrected=errorsCorrected;
        }
        /**
         *@returnnumberoferasurescorrected,or{@codenull}ifnotapplicable
         */
        getErasures(){
            returnthis.erasures;
        }
        setErasures(erasures/*Integer*/){
            this.erasures=erasures;
        }
        /**
         *@returnarbitraryadditionalmetadata
         */
        getOther(){
            returnthis.other;
        }
        setOther(other){
            this.other=other;
        }
        hasStructuredAppend(){
            returnthis.structuredAppendParity>=0&&this.structuredAppendSequenceNumber>=0;
        }
        getStructuredAppendParity(){
            returnthis.structuredAppendParity;
        }
        getStructuredAppendSequenceNumber(){
            returnthis.structuredAppendSequenceNumber;
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Thisclasscontainsutilitymethodsforperformingmathematicaloperationsover
     *theGaloisFields.Operationsuseagivenprimitivepolynomialincalculations.</p>
     *
     *<p>Throughoutthispackage,elementsoftheGFarerepresentedasan{@codeint}
     *forconvenienceandspeed(butatthecostofmemory).
     *</p>
     *
     *@authorSeanOwen
     *@authorDavidOlivier
     */
    classAbstractGenericGF{
        /**
         *@return2tothepowerofainGF(size)
         */
        exp(a){
            returnthis.expTable[a];
        }
        /**
         *@returnbase2logofainGF(size)
         */
        log(a/*int*/){
            if(a===0){
                thrownewIllegalArgumentException();
            }
            returnthis.logTable[a];
        }
        /**
         *Implementsbothadditionandsubtraction--theyarethesameinGF(size).
         *
         *@returnsum/differenceofaandb
         */
        staticaddOrSubtract(a/*int*/,b/*int*/){
            returna^b;
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>RepresentsapolynomialwhosecoefficientsareelementsofaGF.
     *Instancesofthisclassareimmutable.</p>
     *
     *<p>MuchcreditisduetoWilliamRucklidgesinceportionsofthiscodeareanindirect
     *portofhisC++Reed-Solomonimplementation.</p>
     *
     *@authorSeanOwen
     */
    classGenericGFPoly{
        /**
         *@paramfieldthe{@linkGenericGF}instancerepresentingthefieldtouse
         *toperformcomputations
         *@paramcoefficientscoefficientsasintsrepresentingelementsofGF(size),arranged
         *frommostsignificant(highest-powerterm)coefficienttoleastsignificant
         *@throwsIllegalArgumentExceptionifargumentisnullorempty,
         *orifleadingcoefficientis0andthisisnota
         *constantpolynomial(thatis,itisnotthemonomial"0")
         */
        constructor(field,coefficients){
            if(coefficients.length===0){
                thrownewIllegalArgumentException();
            }
            this.field=field;
            constcoefficientsLength=coefficients.length;
            if(coefficientsLength>1&&coefficients[0]===0){
                //Leadingtermmustbenon-zeroforanythingexcepttheconstantpolynomial"0"
                letfirstNonZero=1;
                while(firstNonZero<coefficientsLength&&coefficients[firstNonZero]===0){
                    firstNonZero++;
                }
                if(firstNonZero===coefficientsLength){
                    this.coefficients=Int32Array.from([0]);
                }
                else{
                    this.coefficients=newInt32Array(coefficientsLength-firstNonZero);
                    System.arraycopy(coefficients,firstNonZero,this.coefficients,0,this.coefficients.length);
                }
            }
            else{
                this.coefficients=coefficients;
            }
        }
        getCoefficients(){
            returnthis.coefficients;
        }
        /**
         *@returndegreeofthispolynomial
         */
        getDegree(){
            returnthis.coefficients.length-1;
        }
        /**
         *@returntrueiffthispolynomialisthemonomial"0"
         */
        isZero(){
            returnthis.coefficients[0]===0;
        }
        /**
         *@returncoefficientofx^degreeterminthispolynomial
         */
        getCoefficient(degree/*int*/){
            returnthis.coefficients[this.coefficients.length-1-degree];
        }
        /**
         *@returnevaluationofthispolynomialatagivenpoint
         */
        evaluateAt(a/*int*/){
            if(a===0){
                //Justreturnthex^0coefficient
                returnthis.getCoefficient(0);
            }
            constcoefficients=this.coefficients;
            letresult;
            if(a===1){
                //Justthesumofthecoefficients
                result=0;
                for(leti=0,length=coefficients.length;i!==length;i++){
                    constcoefficient=coefficients[i];
                    result=AbstractGenericGF.addOrSubtract(result,coefficient);
                }
                returnresult;
            }
            result=coefficients[0];
            constsize=coefficients.length;
            constfield=this.field;
            for(leti=1;i<size;i++){
                result=AbstractGenericGF.addOrSubtract(field.multiply(a,result),coefficients[i]);
            }
            returnresult;
        }
        addOrSubtract(other){
            if(!this.field.equals(other.field)){
                thrownewIllegalArgumentException('GenericGFPolysdonothavesameGenericGFfield');
            }
            if(this.isZero()){
                returnother;
            }
            if(other.isZero()){
                returnthis;
            }
            letsmallerCoefficients=this.coefficients;
            letlargerCoefficients=other.coefficients;
            if(smallerCoefficients.length>largerCoefficients.length){
                consttemp=smallerCoefficients;
                smallerCoefficients=largerCoefficients;
                largerCoefficients=temp;
            }
            letsumDiff=newInt32Array(largerCoefficients.length);
            constlengthDiff=largerCoefficients.length-smallerCoefficients.length;
            //Copyhigh-ordertermsonlyfoundinhigher-degreepolynomial'scoefficients
            System.arraycopy(largerCoefficients,0,sumDiff,0,lengthDiff);
            for(leti=lengthDiff;i<largerCoefficients.length;i++){
                sumDiff[i]=AbstractGenericGF.addOrSubtract(smallerCoefficients[i-lengthDiff],largerCoefficients[i]);
            }
            returnnewGenericGFPoly(this.field,sumDiff);
        }
        multiply(other){
            if(!this.field.equals(other.field)){
                thrownewIllegalArgumentException('GenericGFPolysdonothavesameGenericGFfield');
            }
            if(this.isZero()||other.isZero()){
                returnthis.field.getZero();
            }
            constaCoefficients=this.coefficients;
            constaLength=aCoefficients.length;
            constbCoefficients=other.coefficients;
            constbLength=bCoefficients.length;
            constproduct=newInt32Array(aLength+bLength-1);
            constfield=this.field;
            for(leti=0;i<aLength;i++){
                constaCoeff=aCoefficients[i];
                for(letj=0;j<bLength;j++){
                    product[i+j]=AbstractGenericGF.addOrSubtract(product[i+j],field.multiply(aCoeff,bCoefficients[j]));
                }
            }
            returnnewGenericGFPoly(field,product);
        }
        multiplyScalar(scalar/*int*/){
            if(scalar===0){
                returnthis.field.getZero();
            }
            if(scalar===1){
                returnthis;
            }
            constsize=this.coefficients.length;
            constfield=this.field;
            constproduct=newInt32Array(size);
            constcoefficients=this.coefficients;
            for(leti=0;i<size;i++){
                product[i]=field.multiply(coefficients[i],scalar);
            }
            returnnewGenericGFPoly(field,product);
        }
        multiplyByMonomial(degree/*int*/,coefficient/*int*/){
            if(degree<0){
                thrownewIllegalArgumentException();
            }
            if(coefficient===0){
                returnthis.field.getZero();
            }
            constcoefficients=this.coefficients;
            constsize=coefficients.length;
            constproduct=newInt32Array(size+degree);
            constfield=this.field;
            for(leti=0;i<size;i++){
                product[i]=field.multiply(coefficients[i],coefficient);
            }
            returnnewGenericGFPoly(field,product);
        }
        divide(other){
            if(!this.field.equals(other.field)){
                thrownewIllegalArgumentException('GenericGFPolysdonothavesameGenericGFfield');
            }
            if(other.isZero()){
                thrownewIllegalArgumentException('Divideby0');
            }
            constfield=this.field;
            letquotient=field.getZero();
            letremainder=this;
            constdenominatorLeadingTerm=other.getCoefficient(other.getDegree());
            constinverseDenominatorLeadingTerm=field.inverse(denominatorLeadingTerm);
            while(remainder.getDegree()>=other.getDegree()&&!remainder.isZero()){
                constdegreeDifference=remainder.getDegree()-other.getDegree();
                constscale=field.multiply(remainder.getCoefficient(remainder.getDegree()),inverseDenominatorLeadingTerm);
                constterm=other.multiplyByMonomial(degreeDifference,scale);
                constiterationQuotient=field.buildMonomial(degreeDifference,scale);
                quotient=quotient.addOrSubtract(iterationQuotient);
                remainder=remainder.addOrSubtract(term);
            }
            return[quotient,remainder];
        }
        /*@Override*/
        toString(){
            letresult='';
            for(letdegree=this.getDegree();degree>=0;degree--){
                letcoefficient=this.getCoefficient(degree);
                if(coefficient!==0){
                    if(coefficient<0){
                        result+='-';
                        coefficient=-coefficient;
                    }
                    else{
                        if(result.length>0){
                            result+='+';
                        }
                    }
                    if(degree===0||coefficient!==1){
                        constalphaPower=this.field.log(coefficient);
                        if(alphaPower===0){
                            result+='1';
                        }
                        elseif(alphaPower===1){
                            result+='a';
                        }
                        else{
                            result+='a^';
                            result+=alphaPower;
                        }
                    }
                    if(degree!==0){
                        if(degree===1){
                            result+='x';
                        }
                        else{
                            result+='x^';
                            result+=degree;
                        }
                    }
                }
            }
            returnresult;
        }
    }

    /**
     *CustomErrorclassoftypeException.
     */
    classArithmeticExceptionextendsException{
    }
    ArithmeticException.kind='ArithmeticException';

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Thisclasscontainsutilitymethodsforperformingmathematicaloperationsover
     *theGaloisFields.Operationsuseagivenprimitivepolynomialincalculations.</p>
     *
     *<p>Throughoutthispackage,elementsoftheGFarerepresentedasan{@codeint}
     *forconvenienceandspeed(butatthecostofmemory).
     *</p>
     *
     *@authorSeanOwen
     *@authorDavidOlivier
     */
    classGenericGFextendsAbstractGenericGF{
        /**
         *CreatearepresentationofGF(size)usingthegivenprimitivepolynomial.
         *
         *@paramprimitiveirreduciblepolynomialwhosecoefficientsarerepresentedby
         * thebitsofanint,wheretheleast-significantbitrepresentstheconstant
         * coefficient
         *@paramsizethesizeofthefield
         *@parambthefactorbinthegeneratorpolynomialcanbe0-or1-based
         * (g(x)=(x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).
         * Inmostcasesitshouldbe1,butforQRcodeitis0.
         */
        constructor(primitive/*int*/,size/*int*/,generatorBase/*int*/){
            super();
            this.primitive=primitive;
            this.size=size;
            this.generatorBase=generatorBase;
            constexpTable=newInt32Array(size);
            letx=1;
            for(leti=0;i<size;i++){
                expTable[i]=x;
                x*=2;//we'reassumingthegeneratoralphais2
                if(x>=size){
                    x^=primitive;
                    x&=size-1;
                }
            }
            this.expTable=expTable;
            constlogTable=newInt32Array(size);
            for(leti=0;i<size-1;i++){
                logTable[expTable[i]]=i;
            }
            this.logTable=logTable;
            //logTable[0]==0butthisshouldneverbeused
            this.zero=newGenericGFPoly(this,Int32Array.from([0]));
            this.one=newGenericGFPoly(this,Int32Array.from([1]));
        }
        getZero(){
            returnthis.zero;
        }
        getOne(){
            returnthis.one;
        }
        /**
         *@returnthemonomialrepresentingcoefficient*x^degree
         */
        buildMonomial(degree/*int*/,coefficient/*int*/){
            if(degree<0){
                thrownewIllegalArgumentException();
            }
            if(coefficient===0){
                returnthis.zero;
            }
            constcoefficients=newInt32Array(degree+1);
            coefficients[0]=coefficient;
            returnnewGenericGFPoly(this,coefficients);
        }
        /**
         *@returnmultiplicativeinverseofa
         */
        inverse(a/*int*/){
            if(a===0){
                thrownewArithmeticException();
            }
            returnthis.expTable[this.size-this.logTable[a]-1];
        }
        /**
         *@returnproductofaandbinGF(size)
         */
        multiply(a/*int*/,b/*int*/){
            if(a===0||b===0){
                return0;
            }
            returnthis.expTable[(this.logTable[a]+this.logTable[b])%(this.size-1)];
        }
        getSize(){
            returnthis.size;
        }
        getGeneratorBase(){
            returnthis.generatorBase;
        }
        /*@Override*/
        toString(){
            return('GF(0x'+Integer.toHexString(this.primitive)+','+this.size+')');
        }
        equals(o){
            returno===this;
        }
    }
    GenericGF.AZTEC_DATA_12=newGenericGF(0x1069,4096,1);//x^12+x^6+x^5+x^3+1
    GenericGF.AZTEC_DATA_10=newGenericGF(0x409,1024,1);//x^10+x^3+1
    GenericGF.AZTEC_DATA_6=newGenericGF(0x43,64,1);//x^6+x+1
    GenericGF.AZTEC_PARAM=newGenericGF(0x13,16,1);//x^4+x+1
    GenericGF.QR_CODE_FIELD_256=newGenericGF(0x011d,256,0);//x^8+x^4+x^3+x^2+1
    GenericGF.DATA_MATRIX_FIELD_256=newGenericGF(0x012d,256,1);//x^8+x^5+x^3+x^2+1
    GenericGF.AZTEC_DATA_8=GenericGF.DATA_MATRIX_FIELD_256;
    GenericGF.MAXICODE_FIELD_64=GenericGF.AZTEC_DATA_6;

    /**
     *CustomErrorclassoftypeException.
     */
    classReedSolomonExceptionextendsException{
    }
    ReedSolomonException.kind='ReedSolomonException';

    /**
     *CustomErrorclassoftypeException.
     */
    classIllegalStateExceptionextendsException{
    }
    IllegalStateException.kind='IllegalStateException';

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>ImplementsReed-Solomondecoding,asthenameimplies.</p>
     *
     *<p>Thealgorithmwillnotbeexplainedhere,butthefollowingreferenceswerehelpful
     *increatingthisimplementation:</p>
     *
     *<ul>
     *<li>BruceMaggs.
     *<ahref="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps">
     *"DecodingReed-SolomonCodes"</a>(seediscussionofForney'sFormula)</li>
     *<li>J.I.Hall.<ahref="www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf">
     *"Chapter5.GeneralizedReed-SolomonCodes"</a>
     *(seediscussionofEuclideanalgorithm)</li>
     *</ul>
     *
     *<p>MuchcreditisduetoWilliamRucklidgesinceportionsofthiscodeareanindirect
     *portofhisC++Reed-Solomonimplementation.</p>
     *
     *@authorSeanOwen
     *@authorWilliamRucklidge
     *@authorsanfordsquires
     */
    classReedSolomonDecoder{
        constructor(field){
            this.field=field;
        }
        /**
         *<p>Decodesgivensetofreceivedcodewords,whichincludebothdataanderror-correction
         *codewords.Really,thismeansitusesReed-Solomontodetectandcorrecterrors,in-place,
         *intheinput.</p>
         *
         *@paramreceiveddataanderror-correctioncodewords
         *@paramtwoSnumberoferror-correctioncodewordsavailable
         *@throwsReedSolomonExceptionifdecodingfailsforanyreason
         */
        decode(received,twoS/*int*/){
            constfield=this.field;
            constpoly=newGenericGFPoly(field,received);
            constsyndromeCoefficients=newInt32Array(twoS);
            letnoError=true;
            for(leti=0;i<twoS;i++){
                constevalResult=poly.evaluateAt(field.exp(i+field.getGeneratorBase()));
                syndromeCoefficients[syndromeCoefficients.length-1-i]=evalResult;
                if(evalResult!==0){
                    noError=false;
                }
            }
            if(noError){
                return;
            }
            constsyndrome=newGenericGFPoly(field,syndromeCoefficients);
            constsigmaOmega=this.runEuclideanAlgorithm(field.buildMonomial(twoS,1),syndrome,twoS);
            constsigma=sigmaOmega[0];
            constomega=sigmaOmega[1];
            consterrorLocations=this.findErrorLocations(sigma);
            consterrorMagnitudes=this.findErrorMagnitudes(omega,errorLocations);
            for(leti=0;i<errorLocations.length;i++){
                constposition=received.length-1-field.log(errorLocations[i]);
                if(position<0){
                    thrownewReedSolomonException('Baderrorlocation');
                }
                received[position]=GenericGF.addOrSubtract(received[position],errorMagnitudes[i]);
            }
        }
        runEuclideanAlgorithm(a,b,R/*int*/){
            //Assumea'sdegreeis>=b's
            if(a.getDegree()<b.getDegree()){
                consttemp=a;
                a=b;
                b=temp;
            }
            constfield=this.field;
            letrLast=a;
            letr=b;
            lettLast=field.getZero();
            lett=field.getOne();
            //RunEuclideanalgorithmuntilr'sdegreeislessthanR/2
            while(r.getDegree()>=(R/2|0)){
                letrLastLast=rLast;
                lettLastLast=tLast;
                rLast=r;
                tLast=t;
                //DividerLastLastbyrLast,withquotientinqandremainderinr
                if(rLast.isZero()){
                    //Oops,Euclideanalgorithmalreadyterminated?
                    thrownewReedSolomonException('r_{i-1}waszero');
                }
                r=rLastLast;
                letq=field.getZero();
                constdenominatorLeadingTerm=rLast.getCoefficient(rLast.getDegree());
                constdltInverse=field.inverse(denominatorLeadingTerm);
                while(r.getDegree()>=rLast.getDegree()&&!r.isZero()){
                    constdegreeDiff=r.getDegree()-rLast.getDegree();
                    constscale=field.multiply(r.getCoefficient(r.getDegree()),dltInverse);
                    q=q.addOrSubtract(field.buildMonomial(degreeDiff,scale));
                    r=r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff,scale));
                }
                t=q.multiply(tLast).addOrSubtract(tLastLast);
                if(r.getDegree()>=rLast.getDegree()){
                    thrownewIllegalStateException('Divisionalgorithmfailedtoreducepolynomial?');
                }
            }
            constsigmaTildeAtZero=t.getCoefficient(0);
            if(sigmaTildeAtZero===0){
                thrownewReedSolomonException('sigmaTilde(0)waszero');
            }
            constinverse=field.inverse(sigmaTildeAtZero);
            constsigma=t.multiplyScalar(inverse);
            constomega=r.multiplyScalar(inverse);
            return[sigma,omega];
        }
        findErrorLocations(errorLocator){
            //ThisisadirectapplicationofChien'ssearch
            constnumErrors=errorLocator.getDegree();
            if(numErrors===1){//shortcut
                returnInt32Array.from([errorLocator.getCoefficient(1)]);
            }
            constresult=newInt32Array(numErrors);
            lete=0;
            constfield=this.field;
            for(leti=1;i<field.getSize()&&e<numErrors;i++){
                if(errorLocator.evaluateAt(i)===0){
                    result[e]=field.inverse(i);
                    e++;
                }
            }
            if(e!==numErrors){
                thrownewReedSolomonException('Errorlocatordegreedoesnotmatchnumberofroots');
            }
            returnresult;
        }
        findErrorMagnitudes(errorEvaluator,errorLocations){
            //ThisisdirectlyapplyingForney'sFormula
            consts=errorLocations.length;
            constresult=newInt32Array(s);
            constfield=this.field;
            for(leti=0;i<s;i++){
                constxiInverse=field.inverse(errorLocations[i]);
                letdenominator=1;
                for(letj=0;j<s;j++){
                    if(i!==j){
                        //denominator=field.multiply(denominator,
                        //   GenericGF.addOrSubtract(1,field.multiply(errorLocations[j],xiInverse)))
                        //AboveshouldworkbutfailsonsomeAppleandLinuxJDKsduetoaHotspotbug.
                        //Belowisafunny-lookingworkaroundfromStevenParkes
                        constterm=field.multiply(errorLocations[j],xiInverse);
                        consttermPlus1=(term&0x1)===0?term|1:term&~1;
                        denominator=field.multiply(denominator,termPlus1);
                    }
                }
                result[i]=field.multiply(errorEvaluator.evaluateAt(xiInverse),field.inverse(denominator));
                if(field.getGeneratorBase()!==0){
                    result[i]=field.multiply(result[i],xiInverse);
                }
            }
            returnresult;
        }
    }

    /*
     *Copyright2010ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    //importjava.util.Arrays;
    varTable;
    (function(Table){
        Table[Table["UPPER"]=0]="UPPER";
        Table[Table["LOWER"]=1]="LOWER";
        Table[Table["MIXED"]=2]="MIXED";
        Table[Table["DIGIT"]=3]="DIGIT";
        Table[Table["PUNCT"]=4]="PUNCT";
        Table[Table["BINARY"]=5]="BINARY";
    })(Table||(Table={}));
    /**
     *<p>ThemainclasswhichimplementsAztecCodedecoding--asopposedtolocatingandextracting
     *theAztecCodefromanimage.</p>
     *
     *@authorDavidOlivier
     */
    classDecoder{
        decode(detectorResult){
            this.ddata=detectorResult;
            letmatrix=detectorResult.getBits();
            letrawbits=this.extractBits(matrix);
            letcorrectedBits=this.correctBits(rawbits);
            letrawBytes=Decoder.convertBoolArrayToByteArray(correctedBits);
            letresult=Decoder.getEncodedData(correctedBits);
            letdecoderResult=newDecoderResult(rawBytes,result,null,null);
            decoderResult.setNumBits(correctedBits.length);
            returndecoderResult;
        }
        //Thismethodisusedfortestingthehigh-levelencoder
        statichighLevelDecode(correctedBits){
            returnthis.getEncodedData(correctedBits);
        }
        /**
         *Getsthestringencodedintheazteccodebits
         *
         *@returnthedecodedstring
         */
        staticgetEncodedData(correctedBits){
            letendIndex=correctedBits.length;
            letlatchTable=Table.UPPER;//tablemostrecentlylatchedto
            letshiftTable=Table.UPPER;//tabletouseforthenextread
            letresult='';
            letindex=0;
            while(index<endIndex){
                if(shiftTable===Table.BINARY){
                    if(endIndex-index<5){
                        break;
                    }
                    letlength=Decoder.readCode(correctedBits,index,5);
                    index+=5;
                    if(length===0){
                        if(endIndex-index<11){
                            break;
                        }
                        length=Decoder.readCode(correctedBits,index,11)+31;
                        index+=11;
                    }
                    for(letcharCount=0;charCount<length;charCount++){
                        if(endIndex-index<8){
                            index=endIndex;//Forceouterlooptoexit
                            break;
                        }
                        constcode=Decoder.readCode(correctedBits,index,8);
                        result+=/*(char)*/StringUtils.castAsNonUtf8Char(code);
                        index+=8;
                    }
                    //Gobacktowhatevermodewehadbeenin
                    shiftTable=latchTable;
                }
                else{
                    letsize=shiftTable===Table.DIGIT?4:5;
                    if(endIndex-index<size){
                        break;
                    }
                    letcode=Decoder.readCode(correctedBits,index,size);
                    index+=size;
                    letstr=Decoder.getCharacter(shiftTable,code);
                    if(str.startsWith('CTRL_')){
                        //Tablechanges
                        //ISO/IEC24778:2008prescribesendingashiftsequenceinthemodefromwhichitwasinvoked.
                        //That'sincludingwhenthatmodeisashift.
                        //Ourtestcasedlusbs.pngforissue#642exercisesthat.
                        latchTable=shiftTable;//Latchthecurrentmode,soastoreturntoUpperafterU/SB/S
                        shiftTable=Decoder.getTable(str.charAt(5));
                        if(str.charAt(6)==='L'){
                            latchTable=shiftTable;
                        }
                    }
                    else{
                        result+=str;
                        //Gobacktowhatevermodewehadbeenin
                        shiftTable=latchTable;
                    }
                }
            }
            returnresult;
        }
        /**
         *getsthetablecorrespondingtothecharpassed
         */
        staticgetTable(t){
            switch(t){
                case'L':
                    returnTable.LOWER;
                case'P':
                    returnTable.PUNCT;
                case'M':
                    returnTable.MIXED;
                case'D':
                    returnTable.DIGIT;
                case'B':
                    returnTable.BINARY;
                case'U':
                default:
                    returnTable.UPPER;
            }
        }
        /**
         *Getsthecharacter(orstring)correspondingtothepassedcodeinthegiventable
         *
         *@paramtablethetableused
         *@paramcodethecodeofthecharacter
         */
        staticgetCharacter(table,code){
            switch(table){
                caseTable.UPPER:
                    returnDecoder.UPPER_TABLE[code];
                caseTable.LOWER:
                    returnDecoder.LOWER_TABLE[code];
                caseTable.MIXED:
                    returnDecoder.MIXED_TABLE[code];
                caseTable.PUNCT:
                    returnDecoder.PUNCT_TABLE[code];
                caseTable.DIGIT:
                    returnDecoder.DIGIT_TABLE[code];
                default:
                    //Shouldnotreachhere.
                    thrownewIllegalStateException('Badtable');
            }
        }
        /**
         *<p>PerformsRSerrorcorrectiononanarrayofbits.</p>
         *
         *@returnthecorrectedarray
         *@throwsFormatExceptioniftheinputcontainstoomanyerrors
         */
        correctBits(rawbits){
            letgf;
            letcodewordSize;
            if(this.ddata.getNbLayers()<=2){
                codewordSize=6;
                gf=GenericGF.AZTEC_DATA_6;
            }
            elseif(this.ddata.getNbLayers()<=8){
                codewordSize=8;
                gf=GenericGF.AZTEC_DATA_8;
            }
            elseif(this.ddata.getNbLayers()<=22){
                codewordSize=10;
                gf=GenericGF.AZTEC_DATA_10;
            }
            else{
                codewordSize=12;
                gf=GenericGF.AZTEC_DATA_12;
            }
            letnumDataCodewords=this.ddata.getNbDatablocks();
            letnumCodewords=rawbits.length/codewordSize;
            if(numCodewords<numDataCodewords){
                thrownewFormatException();
            }
            letoffset=rawbits.length%codewordSize;
            letdataWords=newInt32Array(numCodewords);
            for(leti=0;i<numCodewords;i++,offset+=codewordSize){
                dataWords[i]=Decoder.readCode(rawbits,offset,codewordSize);
            }
            try{
                letrsDecoder=newReedSolomonDecoder(gf);
                rsDecoder.decode(dataWords,numCodewords-numDataCodewords);
            }
            catch(ex){
                thrownewFormatException(ex);
            }
            //Nowperformtheunstuffingoperation.
            //First,counthowmanybitsaregoingtobethrownoutasstuffing
            letmask=(1<<codewordSize)-1;
            letstuffedBits=0;
            for(leti=0;i<numDataCodewords;i++){
                letdataWord=dataWords[i];
                if(dataWord===0||dataWord===mask){
                    thrownewFormatException();
                }
                elseif(dataWord===1||dataWord===mask-1){
                    stuffedBits++;
                }
            }
            //Now,actuallyunpackthebitsandremovethestuffing
            letcorrectedBits=newArray(numDataCodewords*codewordSize-stuffedBits);
            letindex=0;
            for(leti=0;i<numDataCodewords;i++){
                letdataWord=dataWords[i];
                if(dataWord===1||dataWord===mask-1){
                    //nextcodewordSize-1bitsareallzerosorallones
                    correctedBits.fill(dataWord>1,index,index+codewordSize-1);
                    //Arrays.fill(correctedBits,index,index+codewordSize-1,dataWord>1);
                    index+=codewordSize-1;
                }
                else{
                    for(letbit=codewordSize-1;bit>=0;--bit){
                        correctedBits[index++]=(dataWord&(1<<bit))!==0;
                    }
                }
            }
            returncorrectedBits;
        }
        /**
         *GetsthearrayofbitsfromanAztecCodematrix
         *
         *@returnthearrayofbits
         */
        extractBits(matrix){
            letcompact=this.ddata.isCompact();
            letlayers=this.ddata.getNbLayers();
            letbaseMatrixSize=(compact?11:14)+layers*4;//notincludingalignmentlines
            letalignmentMap=newInt32Array(baseMatrixSize);
            letrawbits=newArray(this.totalBitsInLayer(layers,compact));
            if(compact){
                for(leti=0;i<alignmentMap.length;i++){
                    alignmentMap[i]=i;
                }
            }
            else{
                letmatrixSize=baseMatrixSize+1+2*Integer.truncDivision((Integer.truncDivision(baseMatrixSize,2)-1),15);
                letorigCenter=baseMatrixSize/2;
                letcenter=Integer.truncDivision(matrixSize,2);
                for(leti=0;i<origCenter;i++){
                    letnewOffset=i+Integer.truncDivision(i,15);
                    alignmentMap[origCenter-i-1]=center-newOffset-1;
                    alignmentMap[origCenter+i]=center+newOffset+1;
                }
            }
            for(leti=0,rowOffset=0;i<layers;i++){
                letrowSize=(layers-i)*4+(compact?9:12);
                //Thetop-leftmostpointofthislayeris<low,low>(notincludingalignmentlines)
                letlow=i*2;
                //Thebottom-rightmostpointofthislayeris<high,high>(notincludingalignmentlines)
                lethigh=baseMatrixSize-1-low;
                //Wepullbitsfromthetwo2xrowSizecolumnsandtworowSizex2rows
                for(letj=0;j<rowSize;j++){
                    letcolumnOffset=j*2;
                    for(letk=0;k<2;k++){
                        //leftcolumn
                        rawbits[rowOffset+columnOffset+k]=
                            matrix.get(alignmentMap[low+k],alignmentMap[low+j]);
                        //bottomrow
                        rawbits[rowOffset+2*rowSize+columnOffset+k]=
                            matrix.get(alignmentMap[low+j],alignmentMap[high-k]);
                        //rightcolumn
                        rawbits[rowOffset+4*rowSize+columnOffset+k]=
                            matrix.get(alignmentMap[high-k],alignmentMap[high-j]);
                        //toprow
                        rawbits[rowOffset+6*rowSize+columnOffset+k]=
                            matrix.get(alignmentMap[high-j],alignmentMap[low+k]);
                    }
                }
                rowOffset+=rowSize*8;
            }
            returnrawbits;
        }
        /**
         *Readsacodeofgivenlengthandatgivenindexinanarrayofbits
         */
        staticreadCode(rawbits,startIndex,length){
            letres=0;
            for(leti=startIndex;i<startIndex+length;i++){
                res<<=1;
                if(rawbits[i]){
                    res|=0x01;
                }
            }
            returnres;
        }
        /**
         *Readsacodeoflength8inanarrayofbits,paddingwithzeros
         */
        staticreadByte(rawbits,startIndex){
            letn=rawbits.length-startIndex;
            if(n>=8){
                returnDecoder.readCode(rawbits,startIndex,8);
            }
            returnDecoder.readCode(rawbits,startIndex,n)<<(8-n);
        }
        /**
         *Packsabitarrayintobytes,mostsignificantbitfirst
         */
        staticconvertBoolArrayToByteArray(boolArr){
            letbyteArr=newUint8Array((boolArr.length+7)/8);
            for(leti=0;i<byteArr.length;i++){
                byteArr[i]=Decoder.readByte(boolArr,8*i);
            }
            returnbyteArr;
        }
        totalBitsInLayer(layers,compact){
            return((compact?88:112)+16*layers)*layers;
        }
    }
    Decoder.UPPER_TABLE=[
        'CTRL_PS','','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P',
        'Q','R','S','T','U','V','W','X','Y','Z','CTRL_LL','CTRL_ML','CTRL_DL','CTRL_BS'
    ];
    Decoder.LOWER_TABLE=[
        'CTRL_PS','','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',
        'q','r','s','t','u','v','w','x','y','z','CTRL_US','CTRL_ML','CTRL_DL','CTRL_BS'
    ];
    Decoder.MIXED_TABLE=[
        //Moduleparsefailed:Octalliteralinstrictmode(50:29)
        //sonumberstringwerescaped
        'CTRL_PS','','\\1','\\2','\\3','\\4','\\5','\\6','\\7','\b','\t','\n',
        '\\13','\f','\r','\\33','\\34','\\35','\\36','\\37','@','\\','^','_',
        '`','|','~','\\177','CTRL_LL','CTRL_UL','CTRL_PL','CTRL_BS'
    ];
    Decoder.PUNCT_TABLE=[
        '','\r','\r\n','.',',',':','!','"','#','$','%','&','\'','(',')',
        '*','+',',','-','.','/',':',';','<','=','>','?','[',']','{','}','CTRL_UL'
    ];
    Decoder.DIGIT_TABLE=[
        'CTRL_PS','','0','1','2','3','4','5','6','7','8','9',',','.','CTRL_UL','CTRL_US'
    ];

    /*
     *Copyright2012ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*namespacecom.google.zxing.common.detector{*/
    /**
     *Generalmath-relatedandnumericutilityfunctions.
     */
    classMathUtils{
        constructor(){}
        /**
         *Endsupbeingabitfasterthan{@linkMath#round(float)}.Thismerelyroundsits
         *argumenttothenearestint,wherex.5roundsuptox+1.Semanticsofthisshortcut
         *differslightlyfrom{@linkMath#round(float)}inthathalfroundsdownfornegative
         *values.-2.5roundsto-3,not-2.Forpurposeshereitmakesnodifference.
         *
         *@paramdrealvaluetoround
         *@returnnearest{@codeint}
         */
        staticround(d/*float*/){
            if(NaN===d)
                return0;
            if(d<=Number.MIN_SAFE_INTEGER)
                returnNumber.MIN_SAFE_INTEGER;
            if(d>=Number.MAX_SAFE_INTEGER)
                returnNumber.MAX_SAFE_INTEGER;
            return/*(int)*/(d+(d<0.0?-0.5:0.5))|0;
        }
        //TYPESCRIPTPORT:mayberemoveroundmethodandcalldirectlyMath.round,itlookslikeitdoesn'tmakesenseforjs
        /**
         *@paramaXpointAxcoordinate
         *@paramaYpointAycoordinate
         *@parambXpointBxcoordinate
         *@parambYpointBycoordinate
         *@returnEuclideandistancebetweenpointsAandB
         */
        staticdistance(aX/*float|int*/,aY/*float|int*/,bX/*float|int*/,bY/*float|int*/){
            constxDiff=aX-bX;
            constyDiff=aY-bY;
            return/*(float)*/Math.sqrt(xDiff*xDiff+yDiff*yDiff);
        }
        /**
         *@paramaXpointAxcoordinate
         *@paramaYpointAycoordinate
         *@parambXpointBxcoordinate
         *@parambYpointBycoordinate
         *@returnEuclideandistancebetweenpointsAandB
         */
        //publicstaticdistance(aX:number/*int*/,aY:number/*int*/,bX:number/*int*/,bY:number/*int*/):float{
        //  constxDiff=aX-bX
        //  constyDiff=aY-bY
        //  return(float)Math.sqrt(xDiff*xDiff+yDiff*yDiff);
        //}
        /**
         *@paramarrayvaluestosum
         *@returnsumofvaluesinarray
         */
        staticsum(array){
            letcount=0;
            for(leti=0,length=array.length;i!==length;i++){
                consta=array[i];
                count+=a;
            }
            returncount;
        }
    }

    /**
     *PonyfillforJava'sFloatclass.
     */
    classFloat{
        /**
         *SincTShasnodifferencebetweenintandfloat,there'sallnumbers,
         *thisisusedonlytopolyfillJavacode.
         */
        staticfloatToIntBits(f){
            returnf;
        }
    }
    /**
     *ThefloatmaxvalueinJSisthenumbermaxvalue.
     */
    Float.MAX_VALUE=Number.MAX_SAFE_INTEGER;

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Encapsulatesapointofinterestinanimagecontainingabarcode.Typically,this
     *wouldbethelocationofafinderpatternorthecornerofthebarcode,forexample.</p>
     *
     *@authorSeanOwen
     */
    classResultPoint{
        constructor(x,y){
            this.x=x;
            this.y=y;
        }
        getX(){
            returnthis.x;
        }
        getY(){
            returnthis.y;
        }
        /*@Override*/
        equals(other){
            if(otherinstanceofResultPoint){
                constotherPoint=other;
                returnthis.x===otherPoint.x&&this.y===otherPoint.y;
            }
            returnfalse;
        }
        /*@Override*/
        hashCode(){
            return31*Float.floatToIntBits(this.x)+Float.floatToIntBits(this.y);
        }
        /*@Override*/
        toString(){
            return'('+this.x+','+this.y+')';
        }
        /**
         *OrdersanarrayofthreeResultPointsinanorder[A,B,C]suchthatABislessthanAC
         *andBCislessthanAC,andtheanglebetweenBCandBAislessthan180degrees.
         *
         *@parampatternsarrayofthree{@codeResultPoint}toorder
         */
        staticorderBestPatterns(patterns){
            //Finddistancesbetweenpatterncenters
            constzeroOneDistance=this.distance(patterns[0],patterns[1]);
            constoneTwoDistance=this.distance(patterns[1],patterns[2]);
            constzeroTwoDistance=this.distance(patterns[0],patterns[2]);
            letpointA;
            letpointB;
            letpointC;
            //AssumeoneclosesttoothertwoisB;AandCwilljustbeguessesatfirst
            if(oneTwoDistance>=zeroOneDistance&&oneTwoDistance>=zeroTwoDistance){
                pointB=patterns[0];
                pointA=patterns[1];
                pointC=patterns[2];
            }
            elseif(zeroTwoDistance>=oneTwoDistance&&zeroTwoDistance>=zeroOneDistance){
                pointB=patterns[1];
                pointA=patterns[0];
                pointC=patterns[2];
            }
            else{
                pointB=patterns[2];
                pointA=patterns[0];
                pointC=patterns[1];
            }
            //UsecrossproducttofigureoutwhetherAandCarecorrectorflipped.
            //ThisaskswhetherBCxBAhasapositivezcomponent,whichisthearrangement
            //wewantforA,B,C.Ifit'snegative,thenwe'vegotitflippedaroundand
            //shouldswapAandC.
            if(this.crossProductZ(pointA,pointB,pointC)<0.0){
                consttemp=pointA;
                pointA=pointC;
                pointC=temp;
            }
            patterns[0]=pointA;
            patterns[1]=pointB;
            patterns[2]=pointC;
        }
        /**
         *@parampattern1firstpattern
         *@parampattern2secondpattern
         *@returndistancebetweentwopoints
         */
        staticdistance(pattern1,pattern2){
            returnMathUtils.distance(pattern1.x,pattern1.y,pattern2.x,pattern2.y);
        }
        /**
         *ReturnsthezcomponentofthecrossproductbetweenvectorsBCandBA.
         */
        staticcrossProductZ(pointA,pointB,pointC){
            constbX=pointB.x;
            constbY=pointB.y;
            return((pointC.x-bX)*(pointA.y-bY))-((pointC.y-bY)*(pointA.x-bX));
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Encapsulatestheresultofdetectingabarcodeinanimage.Thisincludestheraw
     *matrixofblack/whitepixelscorrespondingtothebarcode,andpossiblypointsofinterest
     *intheimage,likethelocationoffinderpatternsorcornersofthebarcodeintheimage.</p>
     *
     *@authorSeanOwen
     */
    classDetectorResult{
        constructor(bits,points){
            this.bits=bits;
            this.points=points;
        }
        getBits(){
            returnthis.bits;
        }
        getPoints(){
            returnthis.points;
        }
    }

    /*
     *Copyright2010ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Extends{@linkDetectorResult}withmoreinformationspecifictotheAztecformat,
     *likethenumberoflayersandwhetherit'scompact.</p>
     *
     *@authorSeanOwen
     */
    classAztecDetectorResultextendsDetectorResult{
        constructor(bits,points,compact,nbDatablocks,nbLayers){
            super(bits,points);
            this.compact=compact;
            this.nbDatablocks=nbDatablocks;
            this.nbLayers=nbLayers;
        }
        getNbLayers(){
            returnthis.nbLayers;
        }
        getNbDatablocks(){
            returnthis.nbDatablocks;
        }
        isCompact(){
            returnthis.compact;
        }
    }

    /*
     *Copyright2010ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>
     *Detectsacandidatebarcode-likerectangularregionwithinanimage.It
     *startsaroundthecenteroftheimage,increasesthesizeofthecandidate
     *regionuntilitfindsawhiterectangularregion.Bykeepingtrackofthe
     *lastblackpointsitencountered,itdeterminesthecornersofthebarcode.
     *</p>
     *
     *@authorDavidOlivier
     */
    classWhiteRectangleDetector{
        //publicconstructor(privateimage:BitMatrix)/*throwsNotFoundException*/{
        //  this(image,INIT_SIZE,image.getWidth()/2,image.getHeight()/2)
        //}
        /**
         *@paramimagebarcodeimagetofindarectanglein
         *@paraminitSizeinitialsizeofsearchareaaroundcenter
         *@paramxxpositionofsearchcenter
         *@paramyypositionofsearchcenter
         *@throwsNotFoundExceptionifimageistoosmalltoaccommodate{@codeinitSize}
         */
        constructor(image,initSize/*int*/,x/*int*/,y/*int*/){
            this.image=image;
            this.height=image.getHeight();
            this.width=image.getWidth();
            if(undefined===initSize||null===initSize){
                initSize=WhiteRectangleDetector.INIT_SIZE;
            }
            if(undefined===x||null===x){
                x=image.getWidth()/2|0;
            }
            if(undefined===y||null===y){
                y=image.getHeight()/2|0;
            }
            consthalfsize=initSize/2|0;
            this.leftInit=x-halfsize;
            this.rightInit=x+halfsize;
            this.upInit=y-halfsize;
            this.downInit=y+halfsize;
            if(this.upInit<0||this.leftInit<0||this.downInit>=this.height||this.rightInit>=this.width){
                thrownewNotFoundException();
            }
        }
        /**
         *<p>
         *Detectsacandidatebarcode-likerectangularregionwithinanimage.It
         *startsaroundthecenteroftheimage,increasesthesizeofthecandidate
         *regionuntilitfindsawhiterectangularregion.
         *</p>
         *
         *@return{@linkResultPoint}[]describingthecornersoftherectangular
         *        region.Thefirstandlastpointsareopposedonthediagonal,as
         *        arethesecondandthird.Thefirstpointwillbethetopmost
         *        pointandthelast,thebottommost.Thesecondpointwillbe
         *        leftmostandthethird,therightmost
         *@throwsNotFoundExceptionifnoDataMatrixCodecanbefound
         */
        detect(){
            letleft=this.leftInit;
            letright=this.rightInit;
            letup=this.upInit;
            letdown=this.downInit;
            letsizeExceeded=false;
            letaBlackPointFoundOnBorder=true;
            letatLeastOneBlackPointFoundOnBorder=false;
            letatLeastOneBlackPointFoundOnRight=false;
            letatLeastOneBlackPointFoundOnBottom=false;
            letatLeastOneBlackPointFoundOnLeft=false;
            letatLeastOneBlackPointFoundOnTop=false;
            constwidth=this.width;
            constheight=this.height;
            while(aBlackPointFoundOnBorder){
                aBlackPointFoundOnBorder=false;
                //.....
                //.  |
                //.....
                letrightBorderNotWhite=true;
                while((rightBorderNotWhite||!atLeastOneBlackPointFoundOnRight)&&right<width){
                    rightBorderNotWhite=this.containsBlackPoint(up,down,right,false);
                    if(rightBorderNotWhite){
                        right++;
                        aBlackPointFoundOnBorder=true;
                        atLeastOneBlackPointFoundOnRight=true;
                    }
                    elseif(!atLeastOneBlackPointFoundOnRight){
                        right++;
                    }
                }
                if(right>=width){
                    sizeExceeded=true;
                    break;
                }
                //.....
                //.  .
                //.___.
                letbottomBorderNotWhite=true;
                while((bottomBorderNotWhite||!atLeastOneBlackPointFoundOnBottom)&&down<height){
                    bottomBorderNotWhite=this.containsBlackPoint(left,right,down,true);
                    if(bottomBorderNotWhite){
                        down++;
                        aBlackPointFoundOnBorder=true;
                        atLeastOneBlackPointFoundOnBottom=true;
                    }
                    elseif(!atLeastOneBlackPointFoundOnBottom){
                        down++;
                    }
                }
                if(down>=height){
                    sizeExceeded=true;
                    break;
                }
                //.....
                //|  .
                //.....
                letleftBorderNotWhite=true;
                while((leftBorderNotWhite||!atLeastOneBlackPointFoundOnLeft)&&left>=0){
                    leftBorderNotWhite=this.containsBlackPoint(up,down,left,false);
                    if(leftBorderNotWhite){
                        left--;
                        aBlackPointFoundOnBorder=true;
                        atLeastOneBlackPointFoundOnLeft=true;
                    }
                    elseif(!atLeastOneBlackPointFoundOnLeft){
                        left--;
                    }
                }
                if(left<0){
                    sizeExceeded=true;
                    break;
                }
                //.___.
                //.  .
                //.....
                lettopBorderNotWhite=true;
                while((topBorderNotWhite||!atLeastOneBlackPointFoundOnTop)&&up>=0){
                    topBorderNotWhite=this.containsBlackPoint(left,right,up,true);
                    if(topBorderNotWhite){
                        up--;
                        aBlackPointFoundOnBorder=true;
                        atLeastOneBlackPointFoundOnTop=true;
                    }
                    elseif(!atLeastOneBlackPointFoundOnTop){
                        up--;
                    }
                }
                if(up<0){
                    sizeExceeded=true;
                    break;
                }
                if(aBlackPointFoundOnBorder){
                    atLeastOneBlackPointFoundOnBorder=true;
                }
            }
            if(!sizeExceeded&&atLeastOneBlackPointFoundOnBorder){
                constmaxSize=right-left;
                letz=null;
                for(leti=1;z===null&&i<maxSize;i++){
                    z=this.getBlackPointOnSegment(left,down-i,left+i,down);
                }
                if(z==null){
                    thrownewNotFoundException();
                }
                lett=null;
                //godownright
                for(leti=1;t===null&&i<maxSize;i++){
                    t=this.getBlackPointOnSegment(left,up+i,left+i,up);
                }
                if(t==null){
                    thrownewNotFoundException();
                }
                letx=null;
                //godownleft
                for(leti=1;x===null&&i<maxSize;i++){
                    x=this.getBlackPointOnSegment(right,up+i,right-i,up);
                }
                if(x==null){
                    thrownewNotFoundException();
                }
                lety=null;
                //goupleft
                for(leti=1;y===null&&i<maxSize;i++){
                    y=this.getBlackPointOnSegment(right,down-i,right-i,down);
                }
                if(y==null){
                    thrownewNotFoundException();
                }
                returnthis.centerEdges(y,z,x,t);
            }
            else{
                thrownewNotFoundException();
            }
        }
        getBlackPointOnSegment(aX/*float*/,aY/*float*/,bX/*float*/,bY/*float*/){
            constdist=MathUtils.round(MathUtils.distance(aX,aY,bX,bY));
            constxStep=(bX-aX)/dist;
            constyStep=(bY-aY)/dist;
            constimage=this.image;
            for(leti=0;i<dist;i++){
                constx=MathUtils.round(aX+i*xStep);
                consty=MathUtils.round(aY+i*yStep);
                if(image.get(x,y)){
                    returnnewResultPoint(x,y);
                }
            }
            returnnull;
        }
        /**
         *recentersthepointsofaconstantdistancetowardsthecenter
         *
         *@paramybottommostpoint
         *@paramzleftmostpoint
         *@paramxrightmostpoint
         *@paramttopmostpoint
         *@return{@linkResultPoint}[]describingthecornersoftherectangular
         *        region.Thefirstandlastpointsareopposedonthediagonal,as
         *        arethesecondandthird.Thefirstpointwillbethetopmost
         *        pointandthelast,thebottommost.Thesecondpointwillbe
         *        leftmostandthethird,therightmost
         */
        centerEdges(y,z,x,t){
            //
            //      t           t
            // z                     x
            //       x   OR   z
            //  y                   y
            //
            constyi=y.getX();
            constyj=y.getY();
            constzi=z.getX();
            constzj=z.getY();
            constxi=x.getX();
            constxj=x.getY();
            constti=t.getX();
            consttj=t.getY();
            constCORR=WhiteRectangleDetector.CORR;
            if(yi<this.width/2.0){
                return[
                    newResultPoint(ti-CORR,tj+CORR),
                    newResultPoint(zi+CORR,zj+CORR),
                    newResultPoint(xi-CORR,xj-CORR),
                    newResultPoint(yi+CORR,yj-CORR)
                ];
            }
            else{
                return[
                    newResultPoint(ti+CORR,tj+CORR),
                    newResultPoint(zi+CORR,zj-CORR),
                    newResultPoint(xi-CORR,xj+CORR),
                    newResultPoint(yi-CORR,yj-CORR)
                ];
            }
        }
        /**
         *Determineswhetherasegmentcontainsablackpoint
         *
         *@parama         minvalueofthescannedcoordinate
         *@paramb         maxvalueofthescannedcoordinate
         *@paramfixed     valueoffixedcoordinate
         *@paramhorizontalsettotrueifscanmustbehorizontal,falseifvertical
         *@returntrueifablackpointhasbeenfound,elsefalse.
         */
        containsBlackPoint(a/*int*/,b/*int*/,fixed/*int*/,horizontal){
            constimage=this.image;
            if(horizontal){
                for(letx=a;x<=b;x++){
                    if(image.get(x,fixed)){
                        returntrue;
                    }
                }
            }
            else{
                for(lety=a;y<=b;y++){
                    if(image.get(fixed,y)){
                        returntrue;
                    }
                }
            }
            returnfalse;
        }
    }
    WhiteRectangleDetector.INIT_SIZE=10;
    WhiteRectangleDetector.CORR=1;

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *Implementationsofthisclasscan,givenlocationsoffinderpatternsforaQRcodeinan
     *image,sampletherightpointsintheimagetoreconstructtheQRcode,accountingfor
     *perspectivedistortion.Itisabstractedsinceitisrelativelyexpensiveandshouldbeallowed
     *totakeadvantageofplatform-specificoptimizedimplementations,likeSun'sJavaAdvanced
     *Imaginglibrary,butwhichmaynotbeavailableinotherenvironmentssuchasJ2ME,andvice
     *versa.
     *
     *Theimplementationusedcanbecontrolledbycalling{@link#setGridSampler(GridSampler)}
     *withaninstanceofaclasswhichimplementsthisinterface.
     *
     *@authorSeanOwen
     */
    classGridSampler{
        /**
         *<p>Checksasetofpointsthathavebeentransformedtosamplepointsonanimageagainst
         *theimage'sdimensionstoseeifthepointareevenwithintheimage.</p>
         *
         *<p>Thismethodwillactually"nudge"theendpointsbackontotheimageiftheyarefoundtobe
         *barely(lessthan1pixel)offtheimage.Thisaccountsforimperfectdetectionoffinder
         *patternsinanimagewheretheQRCoderunsallthewaytotheimageborder.</p>
         *
         *<p>Forefficiency,themethodwillcheckpointsfromeitherendofthelineuntiloneisfound
         *tobewithintheimage.Becausethesetofpointsareassumedtobelinear,thisisvalid.</p>
         *
         *@paramimageimageintowhichthepointsshouldmap
         *@parampointsactualpointsinx1,y1,...,xn,ynform
         *@throwsNotFoundExceptionifanendpointisliesoutsidetheimageboundaries
         */
        staticcheckAndNudgePoints(image,points){
            constwidth=image.getWidth();
            constheight=image.getHeight();
            //CheckandnudgepointsfromstartuntilweseesomethatareOK:
            letnudged=true;
            for(letoffset=0;offset<points.length&&nudged;offset+=2){
                constx=Math.floor(points[offset]);
                consty=Math.floor(points[offset+1]);
                if(x<-1||x>width||y<-1||y>height){
                    thrownewNotFoundException();
                }
                nudged=false;
                if(x===-1){
                    points[offset]=0.0;
                    nudged=true;
                }
                elseif(x===width){
                    points[offset]=width-1;
                    nudged=true;
                }
                if(y===-1){
                    points[offset+1]=0.0;
                    nudged=true;
                }
                elseif(y===height){
                    points[offset+1]=height-1;
                    nudged=true;
                }
            }
            //Checkandnudgepointsfromend:
            nudged=true;
            for(letoffset=points.length-2;offset>=0&&nudged;offset-=2){
                constx=Math.floor(points[offset]);
                consty=Math.floor(points[offset+1]);
                if(x<-1||x>width||y<-1||y>height){
                    thrownewNotFoundException();
                }
                nudged=false;
                if(x===-1){
                    points[offset]=0.0;
                    nudged=true;
                }
                elseif(x===width){
                    points[offset]=width-1;
                    nudged=true;
                }
                if(y===-1){
                    points[offset+1]=0.0;
                    nudged=true;
                }
                elseif(y===height){
                    points[offset+1]=height-1;
                    nudged=true;
                }
            }
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*namespacecom.google.zxing.common{*/
    /**
     *<p>Thisclassimplementsaperspectivetransformintwodimensions.Givenfoursourceandfour
     *destinationpoints,itwillcomputethetransformationimpliedbetweenthem.Thecodeisbased
     *directlyuponsection3.4.2ofGeorgeWolberg's"DigitalImageWarping";seepages54-56.</p>
     *
     *@authorSeanOwen
     */
    classPerspectiveTransform{
        constructor(a11/*float*/,a21/*float*/,a31/*float*/,a12/*float*/,a22/*float*/,a32/*float*/,a13/*float*/,a23/*float*/,a33/*float*/){
            this.a11=a11;
            this.a21=a21;
            this.a31=a31;
            this.a12=a12;
            this.a22=a22;
            this.a32=a32;
            this.a13=a13;
            this.a23=a23;
            this.a33=a33;
        }
        staticquadrilateralToQuadrilateral(x0/*float*/,y0/*float*/,x1/*float*/,y1/*float*/,x2/*float*/,y2/*float*/,x3/*float*/,y3/*float*/,x0p/*float*/,y0p/*float*/,x1p/*float*/,y1p/*float*/,x2p/*float*/,y2p/*float*/,x3p/*float*/,y3p/*float*/){
            constqToS=PerspectiveTransform.quadrilateralToSquare(x0,y0,x1,y1,x2,y2,x3,y3);
            constsToQ=PerspectiveTransform.squareToQuadrilateral(x0p,y0p,x1p,y1p,x2p,y2p,x3p,y3p);
            returnsToQ.times(qToS);
        }
        transformPoints(points){
            constmax=points.length;
            consta11=this.a11;
            consta12=this.a12;
            consta13=this.a13;
            consta21=this.a21;
            consta22=this.a22;
            consta23=this.a23;
            consta31=this.a31;
            consta32=this.a32;
            consta33=this.a33;
            for(leti=0;i<max;i+=2){
                constx=points[i];
                consty=points[i+1];
                constdenominator=a13*x+a23*y+a33;
                points[i]=(a11*x+a21*y+a31)/denominator;
                points[i+1]=(a12*x+a22*y+a32)/denominator;
            }
        }
        transformPointsWithValues(xValues,yValues){
            consta11=this.a11;
            consta12=this.a12;
            consta13=this.a13;
            consta21=this.a21;
            consta22=this.a22;
            consta23=this.a23;
            consta31=this.a31;
            consta32=this.a32;
            consta33=this.a33;
            constn=xValues.length;
            for(leti=0;i<n;i++){
                constx=xValues[i];
                consty=yValues[i];
                constdenominator=a13*x+a23*y+a33;
                xValues[i]=(a11*x+a21*y+a31)/denominator;
                yValues[i]=(a12*x+a22*y+a32)/denominator;
            }
        }
        staticsquareToQuadrilateral(x0/*float*/,y0/*float*/,x1/*float*/,y1/*float*/,x2/*float*/,y2/*float*/,x3/*float*/,y3/*float*/){
            constdx3=x0-x1+x2-x3;
            constdy3=y0-y1+y2-y3;
            if(dx3===0.0&&dy3===0.0){
                //Affine
                returnnewPerspectiveTransform(x1-x0,x2-x1,x0,y1-y0,y2-y1,y0,0.0,0.0,1.0);
            }
            else{
                constdx1=x1-x2;
                constdx2=x3-x2;
                constdy1=y1-y2;
                constdy2=y3-y2;
                constdenominator=dx1*dy2-dx2*dy1;
                consta13=(dx3*dy2-dx2*dy3)/denominator;
                consta23=(dx1*dy3-dx3*dy1)/denominator;
                returnnewPerspectiveTransform(x1-x0+a13*x1,x3-x0+a23*x3,x0,y1-y0+a13*y1,y3-y0+a23*y3,y0,a13,a23,1.0);
            }
        }
        staticquadrilateralToSquare(x0/*float*/,y0/*float*/,x1/*float*/,y1/*float*/,x2/*float*/,y2/*float*/,x3/*float*/,y3/*float*/){
            //Here,theadjointservesastheinverse:
            returnPerspectiveTransform.squareToQuadrilateral(x0,y0,x1,y1,x2,y2,x3,y3).buildAdjoint();
        }
        buildAdjoint(){
            //Adjointisthetransposeofthecofactormatrix:
            returnnewPerspectiveTransform(this.a22*this.a33-this.a23*this.a32,this.a23*this.a31-this.a21*this.a33,this.a21*this.a32-this.a22*this.a31,this.a13*this.a32-this.a12*this.a33,this.a11*this.a33-this.a13*this.a31,this.a12*this.a31-this.a11*this.a32,this.a12*this.a23-this.a13*this.a22,this.a13*this.a21-this.a11*this.a23,this.a11*this.a22-this.a12*this.a21);
        }
        times(other){
            returnnewPerspectiveTransform(this.a11*other.a11+this.a21*other.a12+this.a31*other.a13,this.a11*other.a21+this.a21*other.a22+this.a31*other.a23,this.a11*other.a31+this.a21*other.a32+this.a31*other.a33,this.a12*other.a11+this.a22*other.a12+this.a32*other.a13,this.a12*other.a21+this.a22*other.a22+this.a32*other.a23,this.a12*other.a31+this.a22*other.a32+this.a32*other.a33,this.a13*other.a11+this.a23*other.a12+this.a33*other.a13,this.a13*other.a21+this.a23*other.a22+this.a33*other.a23,this.a13*other.a31+this.a23*other.a32+this.a33*other.a33);
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *@authorSeanOwen
     */
    classDefaultGridSamplerextendsGridSampler{
        /*@Override*/
        sampleGrid(image,dimensionX/*int*/,dimensionY/*int*/,p1ToX/*float*/,p1ToY/*float*/,p2ToX/*float*/,p2ToY/*float*/,p3ToX/*float*/,p3ToY/*float*/,p4ToX/*float*/,p4ToY/*float*/,p1FromX/*float*/,p1FromY/*float*/,p2FromX/*float*/,p2FromY/*float*/,p3FromX/*float*/,p3FromY/*float*/,p4FromX/*float*/,p4FromY/*float*/){
            consttransform=PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX,p1ToY,p2ToX,p2ToY,p3ToX,p3ToY,p4ToX,p4ToY,p1FromX,p1FromY,p2FromX,p2FromY,p3FromX,p3FromY,p4FromX,p4FromY);
            returnthis.sampleGridWithTransform(image,dimensionX,dimensionY,transform);
        }
        /*@Override*/
        sampleGridWithTransform(image,dimensionX/*int*/,dimensionY/*int*/,transform){
            if(dimensionX<=0||dimensionY<=0){
                thrownewNotFoundException();
            }
            constbits=newBitMatrix(dimensionX,dimensionY);
            constpoints=newFloat32Array(2*dimensionX);
            for(lety=0;y<dimensionY;y++){
                constmax=points.length;
                constiValue=y+0.5;
                for(letx=0;x<max;x+=2){
                    points[x]=(x/2)+0.5;
                    points[x+1]=iValue;
                }
                transform.transformPoints(points);
                //Quickchecktoseeifpointstransformedtosomethinginsidetheimage
                //sufficienttochecktheendpoints
                GridSampler.checkAndNudgePoints(image,points);
                try{
                    for(letx=0;x<max;x+=2){
                        if(image.get(Math.floor(points[x]),Math.floor(points[x+1]))){
                            //Black(-ish)pixel
                            bits.set(x/2,y);
                        }
                    }
                }
                catch(aioobe/*:ArrayIndexOutOfBoundsException*/){
                    //Thisfeelswrong,but,sometimesifthefinderpatternsaremisidentified,theresulting
                    //transformgets"twisted"suchthatitmapsastraightlineofpointstoasetofpoints
                    //whoseendpointsareinbounds,butothersarenot.Thereisprobablysomemathematical
                    //waytodetectthisaboutthetransformationthatIdon'tknowyet.
                    //Thisresultsinanuglyruntimeexceptiondespiteourcleverchecksabove--can'thave
                    //that.Wecouldcheckeachpoint'scoordinatesbutthatfeelsduplicative.Wesettlefor
                    //catchingandwrappingArrayIndexOutOfBoundsException.
                    thrownewNotFoundException();
                }
            }
            returnbits;
        }
    }

    classGridSamplerInstance{
        /**
         *SetstheimplementationofGridSamplerusedbythelibrary.Oneglobal
         *instanceisstored,whichmaysoundproblematic.But,theimplementationprovided
         *oughttobeappropriatefortheentireplatform,andallusesofthislibrary
         *inthewholelifetimeoftheJVM.Forinstance,anAndroidactivitycanswapin
         *animplementationthattakesadvantageofnativeplatformlibraries.
         *
         *@paramnewGridSamplerTheplatform-specificobjecttoinstall.
         */
        staticsetGridSampler(newGridSampler){
            GridSamplerInstance.gridSampler=newGridSampler;
        }
        /**
         *@returnthecurrentimplementationofGridSampler
         */
        staticgetInstance(){
            returnGridSamplerInstance.gridSampler;
        }
    }
    GridSamplerInstance.gridSampler=newDefaultGridSampler();

    /*
     *Copyright2010ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    classPoint{
        constructor(x,y){
            this.x=x;
            this.y=y;
        }
        toResultPoint(){
            returnnewResultPoint(this.getX(),this.getY());
        }
        getX(){
            returnthis.x;
        }
        getY(){
            returnthis.y;
        }
    }
    /**
     *EncapsulateslogicthatcandetectanAztecCodeinanimage,eveniftheAztecCode
     *isrotatedorskewed,orpartiallyobscured.
     *
     *@authorDavidOlivier
     *@authorFrankYellin
     */
    classDetector{
        constructor(image){
            this.EXPECTED_CORNER_BITS=newInt32Array([
                0xee0,
                0x1dc,
                0x83b,
                0x707,
            ]);
            this.image=image;
        }
        detect(){
            returnthis.detectMirror(false);
        }
        /**
         *DetectsanAztecCodeinanimage.
         *
         *@paramisMirroriftrue,imageisamirror-imageoforiginal
         *@return{@linkAztecDetectorResult}encapsulatingresultsofdetectinganAztecCode
         *@throwsNotFoundExceptionifnoAztecCodecanbefound
         */
        detectMirror(isMirror){
            //1.Getthecenteroftheaztecmatrix
            letpCenter=this.getMatrixCenter();
            //2.Getthecenterpointsofthefourdiagonalpointsjustoutsidethebull'seye
            // [topRight,bottomRight,bottomLeft,topLeft]
            letbullsEyeCorners=this.getBullsEyeCorners(pCenter);
            if(isMirror){
                lettemp=bullsEyeCorners[0];
                bullsEyeCorners[0]=bullsEyeCorners[2];
                bullsEyeCorners[2]=temp;
            }
            //3.Getthesizeofthematrixandotherparametersfromthebull'seye
            this.extractParameters(bullsEyeCorners);
            //4.Samplethegrid
            letbits=this.sampleGrid(this.image,bullsEyeCorners[this.shift%4],bullsEyeCorners[(this.shift+1)%4],bullsEyeCorners[(this.shift+2)%4],bullsEyeCorners[(this.shift+3)%4]);
            //5.Getthecornersofthematrix.
            letcorners=this.getMatrixCornerPoints(bullsEyeCorners);
            returnnewAztecDetectorResult(bits,corners,this.compact,this.nbDataBlocks,this.nbLayers);
        }
        /**
         *Extractsthenumberofdatalayersanddatablocksfromthelayeraroundthebull'seye.
         *
         *@parambullsEyeCornersthearrayofbull'seyecorners
         *@throwsNotFoundExceptionincaseoftoomanyerrorsorinvalidparameters
         */
        extractParameters(bullsEyeCorners){
            if(!this.isValidPoint(bullsEyeCorners[0])||!this.isValidPoint(bullsEyeCorners[1])||
                !this.isValidPoint(bullsEyeCorners[2])||!this.isValidPoint(bullsEyeCorners[3])){
                thrownewNotFoundException();
            }
            letlength=2*this.nbCenterLayers;
            //Getthebitsaroundthebull'seye
            letsides=newInt32Array([
                this.sampleLine(bullsEyeCorners[0],bullsEyeCorners[1],length),
                this.sampleLine(bullsEyeCorners[1],bullsEyeCorners[2],length),
                this.sampleLine(bullsEyeCorners[2],bullsEyeCorners[3],length),
                this.sampleLine(bullsEyeCorners[3],bullsEyeCorners[0],length)//Top
            ]);
            //bullsEyeCorners[shift]isthecornerofthebulls'eyethathasthree
            //orientationmarks.
            //sides[shift]istherow/columnthatgoesfromthecornerwiththree
            //orientationmarkstothecornerwithtwo.
            this.shift=this.getRotation(sides,length);
            //Flattentheparameterbitsintoasingle28-or40-bitlong
            letparameterData=0;
            for(leti=0;i<4;i++){
                letside=sides[(this.shift+i)%4];
                if(this.compact){
                    //Eachsideoftheform..XXXXXXX.whereXsareparameterdata
                    parameterData<<=7;
                    parameterData+=(side>>1)&0x7F;
                }
                else{
                    //Eachsideoftheform..XXXXX.XXXXX.whereXsareparameterdata
                    parameterData<<=10;
                    parameterData+=((side>>2)&(0x1f<<5))+((side>>1)&0x1F);
                }
            }
            //CorrectsparameterdatausingRS. Returnsjustthedataportion
            //withouttheerrorcorrection.
            letcorrectedData=this.getCorrectedParameterData(parameterData,this.compact);
            if(this.compact){
                //8bits: 2bitslayersand6bitsdatablocks
                this.nbLayers=(correctedData>>6)+1;
                this.nbDataBlocks=(correctedData&0x3F)+1;
            }
            else{
                //16bits: 5bitslayersand11bitsdatablocks
                this.nbLayers=(correctedData>>11)+1;
                this.nbDataBlocks=(correctedData&0x7FF)+1;
            }
        }
        getRotation(sides,length){
            //Inanormalpattern,weexpecttoSee
            //  **   .*            D      A
            //  *     *
            //
            //  .     *
            //  ..   ..            C      B
            //
            //Grabthe3bitsfromeachofthesidestheformthelocatorpatternandconcatenate
            //intoa12-bitinteger. StartwiththebitatA
            letcornerBits=0;
            sides.forEach((side,idx,arr)=>{
                //XX......XwhereX'sareorientationmarks
                lett=((side>>(length-2))<<1)+(side&1);
                cornerBits=(cornerBits<<3)+t;
            });
            //for(varsideinsides){
            //    //XX......XwhereX'sareorientationmarks
            //    vart=((side>>(length-2))<<1)+(side&1);
            //    cornerBits=(cornerBits<<3)+t;
            //}
            //Movthebottombittothetop,sothatthethreebitsofthelocatorpatternatAare
            //together. cornerBitsisnow:
            // 3orientationbitsatA||3orientationbitsatB||...||3orientationbitsatD
            cornerBits=((cornerBits&1)<<11)+(cornerBits>>1);
            //TheresultshiftindicateswhichelementofBullsEyeCorners[]goesintothetop-left
            //corner.SincethefourrotationvalueshaveaHammingdistanceof8,we
            //caneasilytoleratetwoerrors.
            for(letshift=0;shift<4;shift++){
                if(Integer.bitCount(cornerBits^this.EXPECTED_CORNER_BITS[shift])<=2){
                    returnshift;
                }
            }
            thrownewNotFoundException();
        }
        /**
         *CorrectstheparameterbitsusingReed-Solomonalgorithm.
         *
         *@paramparameterDataparameterbits
         *@paramcompacttrueifthisisacompactAzteccode
         *@throwsNotFoundExceptionifthearraycontainstoomanyerrors
         */
        getCorrectedParameterData(parameterData,compact){
            letnumCodewords;
            letnumDataCodewords;
            if(compact){
                numCodewords=7;
                numDataCodewords=2;
            }
            else{
                numCodewords=10;
                numDataCodewords=4;
            }
            letnumECCodewords=numCodewords-numDataCodewords;
            letparameterWords=newInt32Array(numCodewords);
            for(leti=numCodewords-1;i>=0;--i){
                parameterWords[i]=parameterData&0xF;
                parameterData>>=4;
            }
            try{
                letrsDecoder=newReedSolomonDecoder(GenericGF.AZTEC_PARAM);
                rsDecoder.decode(parameterWords,numECCodewords);
            }
            catch(ignored){
                thrownewNotFoundException();
            }
            //Tosstheerrorcorrection. Justreturnthedataasaninteger
            letresult=0;
            for(leti=0;i<numDataCodewords;i++){
                result=(result<<4)+parameterWords[i];
            }
            returnresult;
        }
        /**
         *Findsthecornersofabull-eyecenteredonthepassedpoint.
         *Thisreturnsthecentersofthediagonalpointsjustoutsidethebull'seye
         *Returns[topRight,bottomRight,bottomLeft,topLeft]
         *
         *@parampCenterCenterpoint
         *@returnThecornersofthebull-eye
         *@throwsNotFoundExceptionIfnovalidbull-eyecanbefound
         */
        getBullsEyeCorners(pCenter){
            letpina=pCenter;
            letpinb=pCenter;
            letpinc=pCenter;
            letpind=pCenter;
            letcolor=true;
            for(this.nbCenterLayers=1;this.nbCenterLayers<9;this.nbCenterLayers++){
                letpouta=this.getFirstDifferent(pina,color,1,-1);
                letpoutb=this.getFirstDifferent(pinb,color,1,1);
                letpoutc=this.getFirstDifferent(pinc,color,-1,1);
                letpoutd=this.getFirstDifferent(pind,color,-1,-1);
                //d     a
                //
                //c     b
                if(this.nbCenterLayers>2){
                    letq=(this.distancePoint(poutd,pouta)*this.nbCenterLayers)/(this.distancePoint(pind,pina)*(this.nbCenterLayers+2));
                    if(q<0.75||q>1.25||!this.isWhiteOrBlackRectangle(pouta,poutb,poutc,poutd)){
                        break;
                    }
                }
                pina=pouta;
                pinb=poutb;
                pinc=poutc;
                pind=poutd;
                color=!color;
            }
            if(this.nbCenterLayers!==5&&this.nbCenterLayers!==7){
                thrownewNotFoundException();
            }
            this.compact=this.nbCenterLayers===5;
            //Expandthesquareby.5pixelineachdirectionsothatwe'reontheborder
            //betweenthewhitesquareandtheblacksquare
            letpinax=newResultPoint(pina.getX()+0.5,pina.getY()-0.5);
            letpinbx=newResultPoint(pinb.getX()+0.5,pinb.getY()+0.5);
            letpincx=newResultPoint(pinc.getX()-0.5,pinc.getY()+0.5);
            letpindx=newResultPoint(pind.getX()-0.5,pind.getY()-0.5);
            //Expandthesquaresothatitscornersarethecentersofthepoints
            //justoutsidethebull'seye.
            returnthis.expandSquare([pinax,pinbx,pincx,pindx],2*this.nbCenterLayers-3,2*this.nbCenterLayers);
        }
        /**
         *FindsacandidatecenterpointofanAzteccodefromanimage
         *
         *@returnthecenterpoint
         */
        getMatrixCenter(){
            letpointA;
            letpointB;
            letpointC;
            letpointD;
            //Getawhiterectanglethatcanbetheborderofthematrixincenterbull'seyeor
            try{
                letcornerPoints=newWhiteRectangleDetector(this.image).detect();
                pointA=cornerPoints[0];
                pointB=cornerPoints[1];
                pointC=cornerPoints[2];
                pointD=cornerPoints[3];
            }
            catch(e){
                //Thisexceptioncanbeincasetheinitialrectangleiswhite
                //Inthatcase,surelyinthebull'seye,wetrytoexpandtherectangle.
                letcx=this.image.getWidth()/2;
                letcy=this.image.getHeight()/2;
                pointA=this.getFirstDifferent(newPoint(cx+7,cy-7),false,1,-1).toResultPoint();
                pointB=this.getFirstDifferent(newPoint(cx+7,cy+7),false,1,1).toResultPoint();
                pointC=this.getFirstDifferent(newPoint(cx-7,cy+7),false,-1,1).toResultPoint();
                pointD=this.getFirstDifferent(newPoint(cx-7,cy-7),false,-1,-1).toResultPoint();
            }
            //Computethecenteroftherectangle
            letcx=MathUtils.round((pointA.getX()+pointD.getX()+pointB.getX()+pointC.getX())/4.0);
            letcy=MathUtils.round((pointA.getY()+pointD.getY()+pointB.getY()+pointC.getY())/4.0);
            //Redeterminethewhiterectanglestartingfrompreviouslycomputedcenter.
            //Thiswillensurethatweendupwithawhiterectangleincenterbull'seye
            //inordertocomputeamoreaccuratecenter.
            try{
                letcornerPoints=newWhiteRectangleDetector(this.image,15,cx,cy).detect();
                pointA=cornerPoints[0];
                pointB=cornerPoints[1];
                pointC=cornerPoints[2];
                pointD=cornerPoints[3];
            }
            catch(e){
                //Thisexceptioncanbeincasetheinitialrectangleiswhite
                //Inthatcasewetrytoexpandtherectangle.
                pointA=this.getFirstDifferent(newPoint(cx+7,cy-7),false,1,-1).toResultPoint();
                pointB=this.getFirstDifferent(newPoint(cx+7,cy+7),false,1,1).toResultPoint();
                pointC=this.getFirstDifferent(newPoint(cx-7,cy+7),false,-1,1).toResultPoint();
                pointD=this.getFirstDifferent(newPoint(cx-7,cy-7),false,-1,-1).toResultPoint();
            }
            //Recomputethecenteroftherectangle
            cx=MathUtils.round((pointA.getX()+pointD.getX()+pointB.getX()+pointC.getX())/4.0);
            cy=MathUtils.round((pointA.getY()+pointD.getY()+pointB.getY()+pointC.getY())/4.0);
            returnnewPoint(cx,cy);
        }
        /**
         *GetstheAzteccodecornersfromthebull'seyecornersandtheparameters.
         *
         *@parambullsEyeCornersthearrayofbull'seyecorners
         *@returnthearrayofazteccodecorners
         */
        getMatrixCornerPoints(bullsEyeCorners){
            returnthis.expandSquare(bullsEyeCorners,2*this.nbCenterLayers,this.getDimension());
        }
        /**
         *CreatesaBitMatrixbysamplingtheprovidedimage.
         *topLeft,topRight,bottomRight,andbottomLeftarethecentersofthesquaresonthe
         *diagonaljustoutsidethebull'seye.
         */
        sampleGrid(image,topLeft,topRight,bottomRight,bottomLeft){
            letsampler=GridSamplerInstance.getInstance();
            letdimension=this.getDimension();
            letlow=dimension/2-this.nbCenterLayers;
            lethigh=dimension/2+this.nbCenterLayers;
            returnsampler.sampleGrid(image,dimension,dimension,low,low,//topleft
            high,low,//topright
            high,high,//bottomright
            low,high,//bottomleft
            topLeft.getX(),topLeft.getY(),topRight.getX(),topRight.getY(),bottomRight.getX(),bottomRight.getY(),bottomLeft.getX(),bottomLeft.getY());
        }
        /**
         *Samplesaline.
         *
         *@paramp1  startpoint(inclusive)
         *@paramp2  endpoint(exclusive)
         *@paramsizenumberofbits
         *@returnthearrayofbitsasanint(firstbitishigh-orderbitofresult)
         */
        sampleLine(p1,p2,size){
            letresult=0;
            letd=this.distanceResultPoint(p1,p2);
            letmoduleSize=d/size;
            letpx=p1.getX();
            letpy=p1.getY();
            letdx=moduleSize*(p2.getX()-p1.getX())/d;
            letdy=moduleSize*(p2.getY()-p1.getY())/d;
            for(leti=0;i<size;i++){
                if(this.image.get(MathUtils.round(px+i*dx),MathUtils.round(py+i*dy))){
                    result|=1<<(size-i-1);
                }
            }
            returnresult;
        }
        /**
         *@returntrueiftheborderoftherectanglepassedinparameteriscompoundofwhitepointsonly
         *        orblackpointsonly
         */
        isWhiteOrBlackRectangle(p1,p2,p3,p4){
            letcorr=3;
            p1=newPoint(p1.getX()-corr,p1.getY()+corr);
            p2=newPoint(p2.getX()-corr,p2.getY()-corr);
            p3=newPoint(p3.getX()+corr,p3.getY()-corr);
            p4=newPoint(p4.getX()+corr,p4.getY()+corr);
            letcInit=this.getColor(p4,p1);
            if(cInit===0){
                returnfalse;
            }
            letc=this.getColor(p1,p2);
            if(c!==cInit){
                returnfalse;
            }
            c=this.getColor(p2,p3);
            if(c!==cInit){
                returnfalse;
            }
            c=this.getColor(p3,p4);
            returnc===cInit;
        }
        /**
         *Getsthecolorofasegment
         *
         *@return1ifsegmentmorethan90%black,-1ifsegmentismorethan90%white,0else
         */
        getColor(p1,p2){
            letd=this.distancePoint(p1,p2);
            letdx=(p2.getX()-p1.getX())/d;
            letdy=(p2.getY()-p1.getY())/d;
            leterror=0;
            letpx=p1.getX();
            letpy=p1.getY();
            letcolorModel=this.image.get(p1.getX(),p1.getY());
            letiMax=Math.ceil(d);
            for(leti=0;i<iMax;i++){
                px+=dx;
                py+=dy;
                if(this.image.get(MathUtils.round(px),MathUtils.round(py))!==colorModel){
                    error++;
                }
            }
            leterrRatio=error/d;
            if(errRatio>0.1&&errRatio<0.9){
                return0;
            }
            return(errRatio<=0.1)===colorModel?1:-1;
        }
        /**
         *Getsthecoordinateofthefirstpointwithadifferentcolorinthegivendirection
         */
        getFirstDifferent(init,color,dx,dy){
            letx=init.getX()+dx;
            lety=init.getY()+dy;
            while(this.isValid(x,y)&&this.image.get(x,y)===color){
                x+=dx;
                y+=dy;
            }
            x-=dx;
            y-=dy;
            while(this.isValid(x,y)&&this.image.get(x,y)===color){
                x+=dx;
            }
            x-=dx;
            while(this.isValid(x,y)&&this.image.get(x,y)===color){
                y+=dy;
            }
            y-=dy;
            returnnewPoint(x,y);
        }
        /**
         *Expandthesquarerepresentedbythecornerpointsbypushingoutequallyinalldirections
         *
         *@paramcornerPointsthecornersofthesquare,whichhasthebull'seyeatitscenter
         *@paramoldSidetheoriginallengthofthesideofthesquareinthetargetbitmatrix
         *@paramnewSidethenewlengthofthesizeofthesquareinthetargetbitmatrix
         *@returnthecornersoftheexpandedsquare
         */
        expandSquare(cornerPoints,oldSide,newSide){
            letratio=newSide/(2.0*oldSide);
            letdx=cornerPoints[0].getX()-cornerPoints[2].getX();
            letdy=cornerPoints[0].getY()-cornerPoints[2].getY();
            letcenterx=(cornerPoints[0].getX()+cornerPoints[2].getX())/2.0;
            letcentery=(cornerPoints[0].getY()+cornerPoints[2].getY())/2.0;
            letresult0=newResultPoint(centerx+ratio*dx,centery+ratio*dy);
            letresult2=newResultPoint(centerx-ratio*dx,centery-ratio*dy);
            dx=cornerPoints[1].getX()-cornerPoints[3].getX();
            dy=cornerPoints[1].getY()-cornerPoints[3].getY();
            centerx=(cornerPoints[1].getX()+cornerPoints[3].getX())/2.0;
            centery=(cornerPoints[1].getY()+cornerPoints[3].getY())/2.0;
            letresult1=newResultPoint(centerx+ratio*dx,centery+ratio*dy);
            letresult3=newResultPoint(centerx-ratio*dx,centery-ratio*dy);
            letresults=[result0,result1,result2,result3];
            returnresults;
        }
        isValid(x,y){
            returnx>=0&&x<this.image.getWidth()&&y>0&&y<this.image.getHeight();
        }
        isValidPoint(point){
            letx=MathUtils.round(point.getX());
            lety=MathUtils.round(point.getY());
            returnthis.isValid(x,y);
        }
        distancePoint(a,b){
            returnMathUtils.distance(a.getX(),a.getY(),b.getX(),b.getY());
        }
        distanceResultPoint(a,b){
            returnMathUtils.distance(a.getX(),a.getY(),b.getX(),b.getY());
        }
        getDimension(){
            if(this.compact){
                return4*this.nbLayers+11;
            }
            if(this.nbLayers<=4){
                return4*this.nbLayers+15;
            }
            return4*this.nbLayers+2*(Integer.truncDivision((this.nbLayers-4),8)+1)+15;
        }
    }

    /*
     *Copyright2010ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    //importjava.util.List;
    //importjava.util.Map;
    /**
     *ThisimplementationcandetectanddecodeAzteccodesinanimage.
     *
     *@authorDavidOlivier
     */
    classAztecReader{
        /**
         *LocatesanddecodesaDataMatrixcodeinanimage.
         *
         *@returnaStringrepresentingthecontentencodedbytheDataMatrixcode
         *@throwsNotFoundExceptionifaDataMatrixcodecannotbefound
         *@throwsFormatExceptionifaDataMatrixcodecannotbedecoded
         */
        decode(image,hints=null){
            letexception=null;
            letdetector=newDetector(image.getBlackMatrix());
            letpoints=null;
            letdecoderResult=null;
            try{
                letdetectorResult=detector.detectMirror(false);
                points=detectorResult.getPoints();
                this.reportFoundResultPoints(hints,points);
                decoderResult=newDecoder().decode(detectorResult);
            }
            catch(e){
                exception=e;
            }
            if(decoderResult==null){
                try{
                    letdetectorResult=detector.detectMirror(true);
                    points=detectorResult.getPoints();
                    this.reportFoundResultPoints(hints,points);
                    decoderResult=newDecoder().decode(detectorResult);
                }
                catch(e){
                    if(exception!=null){
                        throwexception;
                    }
                    throwe;
                }
            }
            letresult=newResult(decoderResult.getText(),decoderResult.getRawBytes(),decoderResult.getNumBits(),points,BarcodeFormat$1.AZTEC,System.currentTimeMillis());
            letbyteSegments=decoderResult.getByteSegments();
            if(byteSegments!=null){
                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS,byteSegments);
            }
            letecLevel=decoderResult.getECLevel();
            if(ecLevel!=null){
                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL,ecLevel);
            }
            returnresult;
        }
        reportFoundResultPoints(hints,points){
            if(hints!=null){
                letrpcb=hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
                if(rpcb!=null){
                    points.forEach((point,idx,arr)=>{
                        rpcb.foundPossibleResultPoint(point);
                    });
                }
            }
        }
        //@Override
        reset(){
            //donothing
        }
    }

    /**
     *AztecCodereadertousefrombrowser.
     *
     *@classBrowserAztecCodeReader
     *@extends{BrowserCodeReader}
     */
    classBrowserAztecCodeReaderextendsBrowserCodeReader{
        /**
         *CreatesaninstanceofBrowserAztecCodeReader.
         *@param{number}[timeBetweenScansMillis=500]thetimedelaybetweensubsequentdecodetries
         *
         *@memberOfBrowserAztecCodeReader
         */
        constructor(timeBetweenScansMillis=500){
            super(newAztecReader(),timeBetweenScansMillis);
        }
    }

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *Encapsulatesfunctionalityandimplementationthatiscommontoallfamilies
     *ofone-dimensionalbarcodes.
     *
     *@authordswitkin@google.com(DanielSwitkin)
     *@authorSeanOwen
     */
    classOneDReader{
        /*
        @Override
        publicResultdecode(BinaryBitmapimage)throwsNotFoundException,FormatException{
          returndecode(image,null);
        }
        */
        //Notethatwedon'ttryrotationwithoutthetryharderflag,evenifrotationwassupported.
        //@Override
        decode(image,hints){
            try{
                returnthis.doDecode(image,hints);
            }
            catch(nfe){
                consttryHarder=hints&&(hints.get(DecodeHintType$1.TRY_HARDER)===true);
                if(tryHarder&&image.isRotateSupported()){
                    constrotatedImage=image.rotateCounterClockwise();
                    constresult=this.doDecode(rotatedImage,hints);
                    //Recordthatwefounditrotated90degreesCCW/270degreesCW
                    constmetadata=result.getResultMetadata();
                    letorientation=270;
                    if(metadata!==null&&(metadata.get(ResultMetadataType$1.ORIENTATION)===true)){
                        //ButifwefounditreversedindoDecode(),addinthatresulthere:
                        orientation=(orientation+metadata.get(ResultMetadataType$1.ORIENTATION)%360);
                    }
                    result.putMetadata(ResultMetadataType$1.ORIENTATION,orientation);
                    //Updateresultpoints
                    constpoints=result.getResultPoints();
                    if(points!==null){
                        constheight=rotatedImage.getHeight();
                        for(leti=0;i<points.length;i++){
                            points[i]=newResultPoint(height-points[i].getY()-1,points[i].getX());
                        }
                    }
                    returnresult;
                }
                else{
                    thrownewNotFoundException();
                }
            }
        }
        //@Override
        reset(){
            //donothing
        }
        /**
         *We'regoingtoexaminerowsfromthemiddleoutward,searchingalternatelyaboveandbelowthe
         *middle,andfartherouteachtime.rowStepisthenumberofrowsbetweeneachsuccessive
         *attemptaboveandbelowthemiddle.Sowe'dscanrowmiddle,thenmiddle-rowStep,then
         *middle+rowStep,thenmiddle-(2*rowStep),etc.
         *rowStepisbiggerastheimageistaller,butisalwaysatleast1.We'vesomewhatarbitrarily
         *decidedthatmovingupanddownbyabout1/16oftheimageisprettygood;wetrymoreofthe
         *imageif"tryingharder".
         *
         *@paramimageTheimagetodecode
         *@paramhintsAnyhintsthatwererequested
         *@returnThecontentsofthedecodedbarcode
         *@throwsNotFoundExceptionAnyspontaneouserrorswhichoccur
         */
        doDecode(image,hints){
            constwidth=image.getWidth();
            constheight=image.getHeight();
            letrow=newBitArray(width);
            consttryHarder=hints&&(hints.get(DecodeHintType$1.TRY_HARDER)===true);
            constrowStep=Math.max(1,height>>(tryHarder?8:5));
            letmaxLines;
            if(tryHarder){
                maxLines=height;//Lookatthewholeimage,notjustthecenter
            }
            else{
                maxLines=15;//15rowsspaced1/32apartisroughlythemiddlehalfoftheimage
            }
            constmiddle=Math.trunc(height/2);
            for(letx=0;x<maxLines;x++){
                //Scanningfromthemiddleout.Determinewhichrowwe'relookingatnext:
                constrowStepsAboveOrBelow=Math.trunc((x+1)/2);
                constisAbove=(x&0x01)===0;//i.e.isxeven?
                constrowNumber=middle+rowStep*(isAbove?rowStepsAboveOrBelow:-rowStepsAboveOrBelow);
                if(rowNumber<0||rowNumber>=height){
                    //Oops,ifwerunoffthetoporbottom,stop
                    break;
                }
                //Estimateblackpointforthisrowandloadit:
                try{
                    row=image.getBlackRow(rowNumber,row);
                }
                catch(ignored){
                    continue;
                }
                //WhilewehavetheimagedatainaBitArray,it'sfairlycheaptoreverseitinplaceto
                //handledecodingupsidedownbarcodes.
                for(letattempt=0;attempt<2;attempt++){
                    if(attempt===1){//tryingagain?
                        row.reverse();//reversetherowandcontinue
                        //Thismeanswewillonlyeverdrawresultpoints*once*inthelifeofthismethod
                        //sincewewanttoavoiddrawingthewrongpointsafterflippingtherow,and,
                        //don'twanttoclutterwithnoisefromeverysinglerowscan--justthescans
                        //thatstartonthecenterline.
                        if(hints&&(hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK)===true)){
                            constnewHints=newMap();
                            hints.forEach((hint,key)=>newHints.set(key,hint));
                            newHints.delete(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
                            hints=newHints;
                        }
                    }
                    try{
                        //Lookforabarcode
                        constresult=this.decodeRow(rowNumber,row,hints);
                        //Wefoundourbarcode
                        if(attempt===1){
                            //Butitwasupsidedown,sonotethat
                            result.putMetadata(ResultMetadataType$1.ORIENTATION,180);
                            //Andremembertofliptheresultpointshorizontally.
                            constpoints=result.getResultPoints();
                            if(points!==null){
                                points[0]=newResultPoint(width-points[0].getX()-1,points[0].getY());
                                points[1]=newResultPoint(width-points[1].getX()-1,points[1].getY());
                            }
                        }
                        returnresult;
                    }
                    catch(re){
                        //continue--justcouldn'tdecodethisrow
                    }
                }
            }
            thrownewNotFoundException();
        }
        /**
         *Recordsthesizeofsuccessiverunsofwhiteandblackpixelsinarow,startingatagivenpoint.
         *Thevaluesarerecordedinthegivenarray,andthenumberofrunsrecordedisequaltothesize
         *ofthearray.Iftherowstartsonawhitepixelatthegivenstartpoint,thenthefirstcount
         *recordedistherunofwhitepixelsstartingfromthatpoint;likewiseitisthecountofarun
         *ofblackpixelsiftherowbeginonablackpixelsatthatpoint.
         *
         *@paramrowrowtocountfrom
         *@paramstartoffsetintorowtostartat
         *@paramcountersarrayintowhichtorecordcounts
         *@throwsNotFoundExceptionifcounterscannotbefilledentirelyfromrowbeforerunningout
         * ofpixels
         */
        staticrecordPattern(row,start,counters){
            constnumCounters=counters.length;
            for(letindex=0;index<numCounters;index++)
                counters[index]=0;
            constend=row.getSize();
            if(start>=end){
                thrownewNotFoundException();
            }
            letisWhite=!row.get(start);
            letcounterPosition=0;
            leti=start;
            while(i<end){
                if(row.get(i)!==isWhite){
                    counters[counterPosition]++;
                }
                else{
                    if(++counterPosition===numCounters){
                        break;
                    }
                    else{
                        counters[counterPosition]=1;
                        isWhite=!isWhite;
                    }
                }
                i++;
            }
            //Ifwereadfullythelastsectionofpixelsandfilledupourcounters--orfilled
            //thelastcounterbutranoffthesideoftheimage,OK.Otherwise,aproblem.
            if(!(counterPosition===numCounters||(counterPosition===numCounters-1&&i===end))){
                thrownewNotFoundException();
            }
        }
        staticrecordPatternInReverse(row,start,counters){
            //ThiscouldbemoreefficientIguess
            letnumTransitionsLeft=counters.length;
            letlast=row.get(start);
            while(start>0&&numTransitionsLeft>=0){
                if(row.get(--start)!==last){
                    numTransitionsLeft--;
                    last=!last;
                }
            }
            if(numTransitionsLeft>=0){
                thrownewNotFoundException();
            }
            OneDReader.recordPattern(row,start+1,counters);
        }
        /**
         *Determineshowcloselyasetofobservedcountsofrunsofblack/whitevaluesmatchesagiven
         *targetpattern.Thisisreportedastheratioofthetotalvariancefromtheexpectedpattern
         *proportionsacrossallpatternelements,tothelengthofthepattern.
         *
         *@paramcountersobservedcounters
         *@parampatternexpectedpattern
         *@parammaxIndividualVarianceThemostanycountercandifferbeforewegiveup
         *@returnratiooftotalvariancebetweencountersandpatterncomparedtototalpatternsize
         */
        staticpatternMatchVariance(counters,pattern,maxIndividualVariance){
            constnumCounters=counters.length;
            lettotal=0;
            letpatternLength=0;
            for(leti=0;i<numCounters;i++){
                total+=counters[i];
                patternLength+=pattern[i];
            }
            if(total<patternLength){
                //Ifwedon'tevenhaveonepixelperunitofbarwidth,assumethisistoosmall
                //toreliablymatch,sofail:
                returnNumber.POSITIVE_INFINITY;
            }
            constunitBarWidth=total/patternLength;
            maxIndividualVariance*=unitBarWidth;
            lettotalVariance=0.0;
            for(letx=0;x<numCounters;x++){
                constcounter=counters[x];
                constscaledPattern=pattern[x]*unitBarWidth;
                constvariance=counter>scaledPattern?counter-scaledPattern:scaledPattern-counter;
                if(variance>maxIndividualVariance){
                    returnNumber.POSITIVE_INFINITY;
                }
                totalVariance+=variance;
            }
            returntotalVariance/total;
        }
    }

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>DecodesCode128barcodes.</p>
     *
     *@authorSeanOwen
     */
    classCode128ReaderextendsOneDReader{
        staticfindStartPattern(row){
            constwidth=row.getSize();
            constrowOffset=row.getNextSet(0);
            letcounterPosition=0;
            letcounters=Int32Array.from([0,0,0,0,0,0]);
            letpatternStart=rowOffset;
            letisWhite=false;
            constpatternLength=6;
            for(leti=rowOffset;i<width;i++){
                if(row.get(i)!==isWhite){
                    counters[counterPosition]++;
                }
                else{
                    if(counterPosition===(patternLength-1)){
                        letbestVariance=Code128Reader.MAX_AVG_VARIANCE;
                        letbestMatch=-1;
                        for(letstartCode=Code128Reader.CODE_START_A;startCode<=Code128Reader.CODE_START_C;startCode++){
                            constvariance=OneDReader.patternMatchVariance(counters,Code128Reader.CODE_PATTERNS[startCode],Code128Reader.MAX_INDIVIDUAL_VARIANCE);
                            if(variance<bestVariance){
                                bestVariance=variance;
                                bestMatch=startCode;
                            }
                        }
                        //Lookforwhitespacebeforestartpattern,>=50%ofwidthofstartpattern
                        if(bestMatch>=0&&
                            row.isRange(Math.max(0,patternStart-(i-patternStart)/2),patternStart,false)){
                            returnInt32Array.from([patternStart,i,bestMatch]);
                        }
                        patternStart+=counters[0]+counters[1];
                        counters=counters.slice(2,counters.length-1);
                        counters[counterPosition-1]=0;
                        counters[counterPosition]=0;
                        counterPosition--;
                    }
                    else{
                        counterPosition++;
                    }
                    counters[counterPosition]=1;
                    isWhite=!isWhite;
                }
            }
            thrownewNotFoundException();
        }
        staticdecodeCode(row,counters,rowOffset){
            OneDReader.recordPattern(row,rowOffset,counters);
            letbestVariance=Code128Reader.MAX_AVG_VARIANCE;//worstvariancewe'llaccept
            letbestMatch=-1;
            for(letd=0;d<Code128Reader.CODE_PATTERNS.length;d++){
                constpattern=Code128Reader.CODE_PATTERNS[d];
                constvariance=this.patternMatchVariance(counters,pattern,Code128Reader.MAX_INDIVIDUAL_VARIANCE);
                if(variance<bestVariance){
                    bestVariance=variance;
                    bestMatch=d;
                }
            }
            //TODOWe'reoverlookingthefactthattheSTOPpatternhas7values,not6.
            if(bestMatch>=0){
                returnbestMatch;
            }
            else{
                thrownewNotFoundException();
            }
        }
        decodeRow(rowNumber,row,hints){
            constconvertFNC1=hints&&(hints.get(DecodeHintType$1.ASSUME_GS1)===true);
            conststartPatternInfo=Code128Reader.findStartPattern(row);
            conststartCode=startPatternInfo[2];
            letcurrentRawCodesIndex=0;
            constrawCodes=newUint8Array(20);
            rawCodes[currentRawCodesIndex++]=startCode;
            letcodeSet;
            switch(startCode){
                caseCode128Reader.CODE_START_A:
                    codeSet=Code128Reader.CODE_CODE_A;
                    break;
                caseCode128Reader.CODE_START_B:
                    codeSet=Code128Reader.CODE_CODE_B;
                    break;
                caseCode128Reader.CODE_START_C:
                    codeSet=Code128Reader.CODE_CODE_C;
                    break;
                default:
                    thrownewFormatException();
            }
            letdone=false;
            letisNextShifted=false;
            letresult='';
            letlastStart=startPatternInfo[0];
            letnextStart=startPatternInfo[1];
            constcounters=Int32Array.from([0,0,0,0,0,0]);
            letlastCode=0;
            letcode=0;
            letchecksumTotal=startCode;
            letmultiplier=0;
            letlastCharacterWasPrintable=true;
            letupperMode=false;
            letshiftUpperMode=false;
            while(!done){
                constunshift=isNextShifted;
                isNextShifted=false;
                //Saveofflastcode
                lastCode=code;
                //Decodeanothercodefromimage
                code=Code128Reader.decodeCode(row,counters,nextStart);
                rawCodes[currentRawCodesIndex++]=code;
                //Rememberwhetherthelastcodewasprintableornot(excludingCODE_STOP)
                if(code!==Code128Reader.CODE_STOP){
                    lastCharacterWasPrintable=true;
                }
                //Addtochecksumcomputation(ifnotCODE_STOPofcourse)
                if(code!==Code128Reader.CODE_STOP){
                    multiplier++;
                    checksumTotal+=multiplier*code;
                }
                //Advancetowherethenextcodewilltostart
                lastStart=nextStart;
                nextStart+=counters.reduce((previous,current)=>previous+current,0);
                //Takecareofillegalstartcodes
                switch(code){
                    caseCode128Reader.CODE_START_A:
                    caseCode128Reader.CODE_START_B:
                    caseCode128Reader.CODE_START_C:
                        thrownewFormatException();
                }
                switch(codeSet){
                    caseCode128Reader.CODE_CODE_A:
                        if(code<64){
                            if(shiftUpperMode===upperMode){
                                result+=String.fromCharCode((''.charCodeAt(0)+code));
                            }
                            else{
                                result+=String.fromCharCode((''.charCodeAt(0)+code+128));
                            }
                            shiftUpperMode=false;
                        }
                        elseif(code<96){
                            if(shiftUpperMode===upperMode){
                                result+=String.fromCharCode((code-64));
                            }
                            else{
                                result+=String.fromCharCode((code+64));
                            }
                            shiftUpperMode=false;
                        }
                        else{
                            //Don'tletCODE_STOP,whichalwaysappears,affectwhetherwhetherwethinkthelast
                            //codewasprintableornot.
                            if(code!==Code128Reader.CODE_STOP){
                                lastCharacterWasPrintable=false;
                            }
                            switch(code){
                                caseCode128Reader.CODE_FNC_1:
                                    if(convertFNC1){
                                        if(result.length===0){
                                            //GS1specification5.4.3.7.and5.4.6.4.Ifthefirstcharafterthestartcode
                                            //isFNC1thenthisisGS1-128.Weaddthesymbologyidentifier.
                                            result+=']C1';
                                        }
                                        else{
                                            //GS1specification5.4.7.5.EverysubsequentFNC1isreturnedasASCII29(GS)
                                            result+=String.fromCharCode(29);
                                        }
                                    }
                                    break;
                                caseCode128Reader.CODE_FNC_2:
                                caseCode128Reader.CODE_FNC_3:
                                    //donothing?
                                    break;
                                caseCode128Reader.CODE_FNC_4_A:
                                    if(!upperMode&&shiftUpperMode){
                                        upperMode=true;
                                        shiftUpperMode=false;
                                    }
                                    elseif(upperMode&&shiftUpperMode){
                                        upperMode=false;
                                        shiftUpperMode=false;
                                    }
                                    else{
                                        shiftUpperMode=true;
                                    }
                                    break;
                                caseCode128Reader.CODE_SHIFT:
                                    isNextShifted=true;
                                    codeSet=Code128Reader.CODE_CODE_B;
                                    break;
                                caseCode128Reader.CODE_CODE_B:
                                    codeSet=Code128Reader.CODE_CODE_B;
                                    break;
                                caseCode128Reader.CODE_CODE_C:
                                    codeSet=Code128Reader.CODE_CODE_C;
                                    break;
                                caseCode128Reader.CODE_STOP:
                                    done=true;
                                    break;
                            }
                        }
                        break;
                    caseCode128Reader.CODE_CODE_B:
                        if(code<96){
                            if(shiftUpperMode===upperMode){
                                result+=String.fromCharCode((''.charCodeAt(0)+code));
                            }
                            else{
                                result+=String.fromCharCode((''.charCodeAt(0)+code+128));
                            }
                            shiftUpperMode=false;
                        }
                        else{
                            if(code!==Code128Reader.CODE_STOP){
                                lastCharacterWasPrintable=false;
                            }
                            switch(code){
                                caseCode128Reader.CODE_FNC_1:
                                    if(convertFNC1){
                                        if(result.length===0){
                                            //GS1specification5.4.3.7.and5.4.6.4.Ifthefirstcharafterthestartcode
                                            //isFNC1thenthisisGS1-128.Weaddthesymbologyidentifier.
                                            result+=']C1';
                                        }
                                        else{
                                            //GS1specification5.4.7.5.EverysubsequentFNC1isreturnedasASCII29(GS)
                                            result+=String.fromCharCode(29);
                                        }
                                    }
                                    break;
                                caseCode128Reader.CODE_FNC_2:
                                caseCode128Reader.CODE_FNC_3:
                                    //donothing?
                                    break;
                                caseCode128Reader.CODE_FNC_4_B:
                                    if(!upperMode&&shiftUpperMode){
                                        upperMode=true;
                                        shiftUpperMode=false;
                                    }
                                    elseif(upperMode&&shiftUpperMode){
                                        upperMode=false;
                                        shiftUpperMode=false;
                                    }
                                    else{
                                        shiftUpperMode=true;
                                    }
                                    break;
                                caseCode128Reader.CODE_SHIFT:
                                    isNextShifted=true;
                                    codeSet=Code128Reader.CODE_CODE_A;
                                    break;
                                caseCode128Reader.CODE_CODE_A:
                                    codeSet=Code128Reader.CODE_CODE_A;
                                    break;
                                caseCode128Reader.CODE_CODE_C:
                                    codeSet=Code128Reader.CODE_CODE_C;
                                    break;
                                caseCode128Reader.CODE_STOP:
                                    done=true;
                                    break;
                            }
                        }
                        break;
                    caseCode128Reader.CODE_CODE_C:
                        if(code<100){
                            if(code<10){
                                result+='0';
                            }
                            result+=code;
                        }
                        else{
                            if(code!==Code128Reader.CODE_STOP){
                                lastCharacterWasPrintable=false;
                            }
                            switch(code){
                                caseCode128Reader.CODE_FNC_1:
                                    if(convertFNC1){
                                        if(result.length===0){
                                            //GS1specification5.4.3.7.and5.4.6.4.Ifthefirstcharafterthestartcode
                                            //isFNC1thenthisisGS1-128.Weaddthesymbologyidentifier.
                                            result+=']C1';
                                        }
                                        else{
                                            //GS1specification5.4.7.5.EverysubsequentFNC1isreturnedasASCII29(GS)
                                            result+=String.fromCharCode(29);
                                        }
                                    }
                                    break;
                                caseCode128Reader.CODE_CODE_A:
                                    codeSet=Code128Reader.CODE_CODE_A;
                                    break;
                                caseCode128Reader.CODE_CODE_B:
                                    codeSet=Code128Reader.CODE_CODE_B;
                                    break;
                                caseCode128Reader.CODE_STOP:
                                    done=true;
                                    break;
                            }
                        }
                        break;
                }
                //Unshiftbacktoanothercodesetifwewereshifted
                if(unshift){
                    codeSet=codeSet===Code128Reader.CODE_CODE_A?Code128Reader.CODE_CODE_B:Code128Reader.CODE_CODE_A;
                }
            }
            constlastPatternSize=nextStart-lastStart;
            //Checkforamplewhitespacefollowingpattern,but,todothiswefirstneedtorememberthat
            //wefudgeddecodingCODE_STOPsinceitactuallyhas7bars,not6.Thereisablackbarleft
            //toreadoff.Wouldbeslightlybettertoproperlyread.Herewejustskipit:
            nextStart=row.getNextUnset(nextStart);
            if(!row.isRange(nextStart,Math.min(row.getSize(),nextStart+(nextStart-lastStart)/2),false)){
                thrownewNotFoundException();
            }
            //Pulloutfromsumthevalueofthepenultimatecheckcode
            checksumTotal-=multiplier*lastCode;
            //lastCodeisthechecksumthen:
            if(checksumTotal%103!==lastCode){
                thrownewChecksumException();
            }
            //Needtopulloutthecheckdigitsfromstring
            constresultLength=result.length;
            if(resultLength===0){
                //falsepositive
                thrownewNotFoundException();
            }
            //Onlybotheriftheresulthadatleastonecharacter,andifthechecksumdigithappenedto
            //beaprintablecharacter.Ifitwasjustinterpretedasacontrolcode,nothingtoremove.
            if(resultLength>0&&lastCharacterWasPrintable){
                if(codeSet===Code128Reader.CODE_CODE_C){
                    result=result.substring(0,resultLength-2);
                }
                else{
                    result=result.substring(0,resultLength-1);
                }
            }
            constleft=(startPatternInfo[1]+startPatternInfo[0])/2.0;
            constright=lastStart+lastPatternSize/2.0;
            constrawCodesSize=rawCodes.length;
            constrawBytes=newUint8Array(rawCodesSize);
            for(leti=0;i<rawCodesSize;i++){
                rawBytes[i]=rawCodes[i];
            }
            constpoints=[newResultPoint(left,rowNumber),newResultPoint(right,rowNumber)];
            returnnewResult(result,rawBytes,0,points,BarcodeFormat$1.CODE_128,newDate().getTime());
        }
    }
    Code128Reader.CODE_PATTERNS=[
        Int32Array.from([2,1,2,2,2,2]),
        Int32Array.from([2,2,2,1,2,2]),
        Int32Array.from([2,2,2,2,2,1]),
        Int32Array.from([1,2,1,2,2,3]),
        Int32Array.from([1,2,1,3,2,2]),
        Int32Array.from([1,3,1,2,2,2]),
        Int32Array.from([1,2,2,2,1,3]),
        Int32Array.from([1,2,2,3,1,2]),
        Int32Array.from([1,3,2,2,1,2]),
        Int32Array.from([2,2,1,2,1,3]),
        Int32Array.from([2,2,1,3,1,2]),
        Int32Array.from([2,3,1,2,1,2]),
        Int32Array.from([1,1,2,2,3,2]),
        Int32Array.from([1,2,2,1,3,2]),
        Int32Array.from([1,2,2,2,3,1]),
        Int32Array.from([1,1,3,2,2,2]),
        Int32Array.from([1,2,3,1,2,2]),
        Int32Array.from([1,2,3,2,2,1]),
        Int32Array.from([2,2,3,2,1,1]),
        Int32Array.from([2,2,1,1,3,2]),
        Int32Array.from([2,2,1,2,3,1]),
        Int32Array.from([2,1,3,2,1,2]),
        Int32Array.from([2,2,3,1,1,2]),
        Int32Array.from([3,1,2,1,3,1]),
        Int32Array.from([3,1,1,2,2,2]),
        Int32Array.from([3,2,1,1,2,2]),
        Int32Array.from([3,2,1,2,2,1]),
        Int32Array.from([3,1,2,2,1,2]),
        Int32Array.from([3,2,2,1,1,2]),
        Int32Array.from([3,2,2,2,1,1]),
        Int32Array.from([2,1,2,1,2,3]),
        Int32Array.from([2,1,2,3,2,1]),
        Int32Array.from([2,3,2,1,2,1]),
        Int32Array.from([1,1,1,3,2,3]),
        Int32Array.from([1,3,1,1,2,3]),
        Int32Array.from([1,3,1,3,2,1]),
        Int32Array.from([1,1,2,3,1,3]),
        Int32Array.from([1,3,2,1,1,3]),
        Int32Array.from([1,3,2,3,1,1]),
        Int32Array.from([2,1,1,3,1,3]),
        Int32Array.from([2,3,1,1,1,3]),
        Int32Array.from([2,3,1,3,1,1]),
        Int32Array.from([1,1,2,1,3,3]),
        Int32Array.from([1,1,2,3,3,1]),
        Int32Array.from([1,3,2,1,3,1]),
        Int32Array.from([1,1,3,1,2,3]),
        Int32Array.from([1,1,3,3,2,1]),
        Int32Array.from([1,3,3,1,2,1]),
        Int32Array.from([3,1,3,1,2,1]),
        Int32Array.from([2,1,1,3,3,1]),
        Int32Array.from([2,3,1,1,3,1]),
        Int32Array.from([2,1,3,1,1,3]),
        Int32Array.from([2,1,3,3,1,1]),
        Int32Array.from([2,1,3,1,3,1]),
        Int32Array.from([3,1,1,1,2,3]),
        Int32Array.from([3,1,1,3,2,1]),
        Int32Array.from([3,3,1,1,2,1]),
        Int32Array.from([3,1,2,1,1,3]),
        Int32Array.from([3,1,2,3,1,1]),
        Int32Array.from([3,3,2,1,1,1]),
        Int32Array.from([3,1,4,1,1,1]),
        Int32Array.from([2,2,1,4,1,1]),
        Int32Array.from([4,3,1,1,1,1]),
        Int32Array.from([1,1,1,2,2,4]),
        Int32Array.from([1,1,1,4,2,2]),
        Int32Array.from([1,2,1,1,2,4]),
        Int32Array.from([1,2,1,4,2,1]),
        Int32Array.from([1,4,1,1,2,2]),
        Int32Array.from([1,4,1,2,2,1]),
        Int32Array.from([1,1,2,2,1,4]),
        Int32Array.from([1,1,2,4,1,2]),
        Int32Array.from([1,2,2,1,1,4]),
        Int32Array.from([1,2,2,4,1,1]),
        Int32Array.from([1,4,2,1,1,2]),
        Int32Array.from([1,4,2,2,1,1]),
        Int32Array.from([2,4,1,2,1,1]),
        Int32Array.from([2,2,1,1,1,4]),
        Int32Array.from([4,1,3,1,1,1]),
        Int32Array.from([2,4,1,1,1,2]),
        Int32Array.from([1,3,4,1,1,1]),
        Int32Array.from([1,1,1,2,4,2]),
        Int32Array.from([1,2,1,1,4,2]),
        Int32Array.from([1,2,1,2,4,1]),
        Int32Array.from([1,1,4,2,1,2]),
        Int32Array.from([1,2,4,1,1,2]),
        Int32Array.from([1,2,4,2,1,1]),
        Int32Array.from([4,1,1,2,1,2]),
        Int32Array.from([4,2,1,1,1,2]),
        Int32Array.from([4,2,1,2,1,1]),
        Int32Array.from([2,1,2,1,4,1]),
        Int32Array.from([2,1,4,1,2,1]),
        Int32Array.from([4,1,2,1,2,1]),
        Int32Array.from([1,1,1,1,4,3]),
        Int32Array.from([1,1,1,3,4,1]),
        Int32Array.from([1,3,1,1,4,1]),
        Int32Array.from([1,1,4,1,1,3]),
        Int32Array.from([1,1,4,3,1,1]),
        Int32Array.from([4,1,1,1,1,3]),
        Int32Array.from([4,1,1,3,1,1]),
        Int32Array.from([1,1,3,1,4,1]),
        Int32Array.from([1,1,4,1,3,1]),
        Int32Array.from([3,1,1,1,4,1]),
        Int32Array.from([4,1,1,1,3,1]),
        Int32Array.from([2,1,1,4,1,2]),
        Int32Array.from([2,1,1,2,1,4]),
        Int32Array.from([2,1,1,2,3,2]),
        Int32Array.from([2,3,3,1,1,1,2]),
    ];
    Code128Reader.MAX_AVG_VARIANCE=0.25;
    Code128Reader.MAX_INDIVIDUAL_VARIANCE=0.7;
    Code128Reader.CODE_SHIFT=98;
    Code128Reader.CODE_CODE_C=99;
    Code128Reader.CODE_CODE_B=100;
    Code128Reader.CODE_CODE_A=101;
    Code128Reader.CODE_FNC_1=102;
    Code128Reader.CODE_FNC_2=97;
    Code128Reader.CODE_FNC_3=96;
    Code128Reader.CODE_FNC_4_A=101;
    Code128Reader.CODE_FNC_4_B=100;
    Code128Reader.CODE_START_A=103;
    Code128Reader.CODE_START_B=104;
    Code128Reader.CODE_START_C=105;
    Code128Reader.CODE_STOP=106;

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>DecodesCode39barcodes.Supports"FullASCIICode39"ifUSE_CODE_39_EXTENDED_MODEisset.</p>
     *
     *@authorSeanOwen
     *@seeCode93Reader
     */
    classCode39ReaderextendsOneDReader{
        /**
         *Createsareaderthatassumesallencodeddataisdata,anddoesnottreatthefinal
         *characterasacheckdigit.Itwillnotdecoded"extendedCode39"sequences.
         */
        //publicCode39Reader(){
        //  this(false);
        //}
        /**
         *Createsareaderthatcanbeconfiguredtocheckthelastcharacterasacheckdigit.
         *Itwillnotdecoded"extendedCode39"sequences.
         *
         *@paramusingCheckDigitiftrue,treatthelastdatacharacterasacheckdigit,not
         *data,andverifythatthechecksumpasses.
         */
        //publicCode39Reader(booleanusingCheckDigit){
        //  this(usingCheckDigit,false);
        //}
        /**
         *Createsareaderthatcanbeconfiguredtocheckthelastcharacterasacheckdigit,
         *oroptionallyattempttodecode"extendedCode39"sequencesthatareusedtoencode
         *thefullASCIIcharacterset.
         *
         *@paramusingCheckDigitiftrue,treatthelastdatacharacterasacheckdigit,not
         *data,andverifythatthechecksumpasses.
         *@paramextendedModeiftrue,willattempttodecodeextendedCode39sequencesinthe
         *text.
         */
        constructor(usingCheckDigit=false,extendedMode=false){
            super();
            this.usingCheckDigit=usingCheckDigit;
            this.extendedMode=extendedMode;
            this.decodeRowResult='';
            this.counters=newInt32Array(9);
        }
        decodeRow(rowNumber,row,hints){
            lettheCounters=this.counters;
            theCounters.fill(0);
            this.decodeRowResult='';
            letstart=Code39Reader.findAsteriskPattern(row,theCounters);
            //Readoffwhitespace
            letnextStart=row.getNextSet(start[1]);
            letend=row.getSize();
            letdecodedChar;
            letlastStart;
            do{
                Code39Reader.recordPattern(row,nextStart,theCounters);
                letpattern=Code39Reader.toNarrowWidePattern(theCounters);
                if(pattern<0){
                    thrownewNotFoundException();
                }
                decodedChar=Code39Reader.patternToChar(pattern);
                this.decodeRowResult+=decodedChar;
                lastStart=nextStart;
                for(letcounteroftheCounters){
                    nextStart+=counter;
                }
                //Readoffwhitespace
                nextStart=row.getNextSet(nextStart);
            }while(decodedChar!=='*');
            this.decodeRowResult=this.decodeRowResult.substring(0,this.decodeRowResult.length-1);//removeasterisk
            //Lookforwhitespaceafterpattern:
            letlastPatternSize=0;
            for(letcounteroftheCounters){
                lastPatternSize+=counter;
            }
            letwhiteSpaceAfterEnd=nextStart-lastStart-lastPatternSize;
            //If50%oflastpatternsize,followinglastpattern,isnotwhitespace,fail
            //(butifit'swhitespacetotheveryendoftheimage,that'sOK)
            if(nextStart!==end&&(whiteSpaceAfterEnd*2)<lastPatternSize){
                thrownewNotFoundException();
            }
            if(this.usingCheckDigit){
                letmax=this.decodeRowResult.length-1;
                lettotal=0;
                for(leti=0;i<max;i++){
                    total+=Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));
                }
                if(this.decodeRowResult.charAt(max)!==Code39Reader.ALPHABET_STRING.charAt(total%43)){
                    thrownewChecksumException();
                }
                this.decodeRowResult=this.decodeRowResult.substring(0,max);
            }
            if(this.decodeRowResult.length===0){
                //falsepositive
                thrownewNotFoundException();
            }
            letresultString;
            if(this.extendedMode){
                resultString=Code39Reader.decodeExtended(this.decodeRowResult);
            }
            else{
                resultString=this.decodeRowResult;
            }
            letleft=(start[1]+start[0])/2.0;
            letright=lastStart+lastPatternSize/2.0;
            returnnewResult(resultString,null,0,[newResultPoint(left,rowNumber),newResultPoint(right,rowNumber)],BarcodeFormat$1.CODE_39,newDate().getTime());
        }
        staticfindAsteriskPattern(row,counters){
            letwidth=row.getSize();
            letrowOffset=row.getNextSet(0);
            letcounterPosition=0;
            letpatternStart=rowOffset;
            letisWhite=false;
            letpatternLength=counters.length;
            for(leti=rowOffset;i<width;i++){
                if(row.get(i)!==isWhite){
                    counters[counterPosition]++;
                }
                else{
                    if(counterPosition===patternLength-1){
                        //Lookforwhitespacebeforestartpattern,>=50%ofwidthofstartpattern
                        if(this.toNarrowWidePattern(counters)===Code39Reader.ASTERISK_ENCODING&&
                            row.isRange(Math.max(0,patternStart-Math.floor((i-patternStart)/2)),patternStart,false)){
                            return[patternStart,i];
                        }
                        patternStart+=counters[0]+counters[1];
                        counters.copyWithin(0,2,2+counterPosition-1);
                        counters[counterPosition-1]=0;
                        counters[counterPosition]=0;
                        counterPosition--;
                    }
                    else{
                        counterPosition++;
                    }
                    counters[counterPosition]=1;
                    isWhite=!isWhite;
                }
            }
            thrownewNotFoundException();
        }
        //Forefficiency,returns-1onfailure.Notthrowingheresavedasmanyas700exceptions
        //perimagewhenusingsomeofourblackboximages.
        statictoNarrowWidePattern(counters){
            letnumCounters=counters.length;
            letmaxNarrowCounter=0;
            letwideCounters;
            do{
                letminCounter=0x7fffffff;
                for(letcounterofcounters){
                    if(counter<minCounter&&counter>maxNarrowCounter){
                        minCounter=counter;
                    }
                }
                maxNarrowCounter=minCounter;
                wideCounters=0;
                lettotalWideCountersWidth=0;
                letpattern=0;
                for(leti=0;i<numCounters;i++){
                    letcounter=counters[i];
                    if(counter>maxNarrowCounter){
                        pattern|=1<<(numCounters-1-i);
                        wideCounters++;
                        totalWideCountersWidth+=counter;
                    }
                }
                if(wideCounters===3){
                    //Found3widecounters,butaretheycloseenoughinwidth?
                    //Wecanperformacheap,conservativechecktoseeifanyindividual
                    //counterismorethan1.5timestheaverage:
                    for(leti=0;i<numCounters&&wideCounters>0;i++){
                        letcounter=counters[i];
                        if(counter>maxNarrowCounter){
                            wideCounters--;
                            //totalWideCountersWidth=3*average,sothischecksifcounter>=3/2*average
                            if((counter*2)>=totalWideCountersWidth){
                                return-1;
                            }
                        }
                    }
                    returnpattern;
                }
            }while(wideCounters>3);
            return-1;
        }
        staticpatternToChar(pattern){
            for(leti=0;i<Code39Reader.CHARACTER_ENCODINGS.length;i++){
                if(Code39Reader.CHARACTER_ENCODINGS[i]===pattern){
                    returnCode39Reader.ALPHABET_STRING.charAt(i);
                }
            }
            if(pattern===Code39Reader.ASTERISK_ENCODING){
                return'*';
            }
            thrownewNotFoundException();
        }
        staticdecodeExtended(encoded){
            letlength=encoded.length;
            letdecoded='';
            for(leti=0;i<length;i++){
                letc=encoded.charAt(i);
                if(c==='+'||c==='$'||c==='%'||c==='/'){
                    letnext=encoded.charAt(i+1);
                    letdecodedChar='\0';
                    switch(c){
                        case'+':
                            //+Ato+Zmaptoatoz
                            if(next>='A'&&next<='Z'){
                                decodedChar=String.fromCharCode(next.charCodeAt(0)+32);
                            }
                            else{
                                thrownewFormatException();
                            }
                            break;
                        case'$':
                            //$Ato$ZmaptocontrolcodesSHtoSB
                            if(next>='A'&&next<='Z'){
                                decodedChar=String.fromCharCode(next.charCodeAt(0)-64);
                            }
                            else{
                                thrownewFormatException();
                            }
                            break;
                        case'%':
                            //%Ato%EmaptocontrolcodesESCtoUS
                            if(next>='A'&&next<='E'){
                                decodedChar=String.fromCharCode(next.charCodeAt(0)-38);
                            }
                            elseif(next>='F'&&next<='J'){
                                decodedChar=String.fromCharCode(next.charCodeAt(0)-11);
                            }
                            elseif(next>='K'&&next<='O'){
                                decodedChar=String.fromCharCode(next.charCodeAt(0)+16);
                            }
                            elseif(next>='P'&&next<='T'){
                                decodedChar=String.fromCharCode(next.charCodeAt(0)+43);
                            }
                            elseif(next==='U'){
                                decodedChar='\0';
                            }
                            elseif(next==='V'){
                                decodedChar='@';
                            }
                            elseif(next==='W'){
                                decodedChar='`';
                            }
                            elseif(next==='X'||next==='Y'||next==='Z'){
                                decodedChar='\x7f';
                            }
                            else{
                                thrownewFormatException();
                            }
                            break;
                        case'/':
                            ///Ato/Omapto!to,and/Zmapsto:
                            if(next>='A'&&next<='O'){
                                decodedChar=String.fromCharCode(next.charCodeAt(0)-32);
                            }
                            elseif(next==='Z'){
                                decodedChar=':';
                            }
                            else{
                                thrownewFormatException();
                            }
                            break;
                    }
                    decoded+=decodedChar;
                    //bumpupiagainsincewereadtwocharacters
                    i++;
                }
                else{
                    decoded+=c;
                }
            }
            returndecoded;
        }
    }
    Code39Reader.ALPHABET_STRING='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-.$/+%';
    /**
     *Theserepresenttheencodingsofcharacters,aspatternsofwideandnarrowbars.
     *The9least-significantbitsofeachintcorrespondtothepatternofwideandnarrow,
     *with1srepresenting"wide"and0srepresentingnarrow.
     */
    Code39Reader.CHARACTER_ENCODINGS=[
        0x034,0x121,0x061,0x160,0x031,0x130,0x070,0x025,0x124,0x064,
        0x109,0x049,0x148,0x019,0x118,0x058,0x00D,0x10C,0x04C,0x01C,
        0x103,0x043,0x142,0x013,0x112,0x052,0x007,0x106,0x046,0x016,
        0x181,0x0C1,0x1C0,0x091,0x190,0x0D0,0x085,0x184,0x0C4,0x0A8,
        0x0A2,0x08A,0x02A///-%
    ];
    Code39Reader.ASTERISK_ENCODING=0x094;

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>DecodesITFbarcodes.</p>
     *
     *@authorTjieco
     */
    classITFReaderextendsOneDReader{
        constructor(){
            //privatestaticW=3;//Pixelwidthofa3xwideline
            //privatestaticw=2;//Pixelwidthofa2xwideline
            //privatestaticN=1;//Pixedwidthofanarrowline
            super(...arguments);
            //Storestheactualnarrowlinewidthoftheimagebeingdecoded.
            this.narrowLineWidth=-1;
        }
        //SeeITFWriter.PATTERNS
        /*

        /!**
         *PatternsofWide/Narrowlinestoindicateeachdigit
         *!/
        */
        decodeRow(rowNumber,row,hints){
            //FindoutwheretheMiddlesection(payload)starts&ends
            letstartRange=this.decodeStart(row);
            letendRange=this.decodeEnd(row);
            letresult=newStringBuilder();
            ITFReader.decodeMiddle(row,startRange[1],endRange[0],result);
            letresultString=result.toString();
            letallowedLengths=null;
            if(hints!=null){
                allowedLengths=hints.get(DecodeHintType$1.ALLOWED_LENGTHS);
            }
            if(allowedLengths==null){
                allowedLengths=ITFReader.DEFAULT_ALLOWED_LENGTHS;
            }
            //Toavoidfalsepositiveswith2Dbarcodes(andotherpatterns),make
            //anassumptionthatthedecodedstringmustbea'standard'lengthifit'sshort
            letlength=resultString.length;
            letlengthOK=false;
            letmaxAllowedLength=0;
            for(letvalueofallowedLengths){
                if(length===value){
                    lengthOK=true;
                    break;
                }
                if(value>maxAllowedLength){
                    maxAllowedLength=value;
                }
            }
            if(!lengthOK&&length>maxAllowedLength){
                lengthOK=true;
            }
            if(!lengthOK){
                thrownewFormatException();
            }
            constpoints=[newResultPoint(startRange[1],rowNumber),newResultPoint(endRange[0],rowNumber)];
            letresultReturn=newResult(resultString,null,//nonaturalbyterepresentationforthesebarcodes
            0,points,BarcodeFormat$1.ITF,newDate().getTime());
            returnresultReturn;
        }
        /*
        /!**
         *@paramrow         rowofblack/whitevaluestosearch
         *@parampayloadStartoffsetofstartpattern
         *@paramresultString{@linkStringBuilder}toappenddecodedcharsto
         *@throwsNotFoundExceptionifdecodingcouldnotcompletesuccessfully
         *!/*/
        staticdecodeMiddle(row,payloadStart,payloadEnd,resultString){
            //Digitsareinterleavedinpairs-5blacklinesforonedigit,andthe
            //5
            //interleavedwhitelinesfortheseconddigit.
            //Therefore,needtoscan10linesandthen
            //splittheseintotwoarrays
            letcounterDigitPair=newInt32Array(10);//10
            letcounterBlack=newInt32Array(5);//5
            letcounterWhite=newInt32Array(5);//5
            counterDigitPair.fill(0);
            counterBlack.fill(0);
            counterWhite.fill(0);
            while(payloadStart<payloadEnd){
                //Get10runsofblack/white.
                OneDReader.recordPattern(row,payloadStart,counterDigitPair);
                //Splitthemintoeacharray
                for(letk=0;k<5;k++){
                    lettwoK=2*k;
                    counterBlack[k]=counterDigitPair[twoK];
                    counterWhite[k]=counterDigitPair[twoK+1];
                }
                letbestMatch=ITFReader.decodeDigit(counterBlack);
                resultString.append(bestMatch.toString());
                bestMatch=this.decodeDigit(counterWhite);
                resultString.append(bestMatch.toString());
                counterDigitPair.forEach(function(counterDigit){
                    payloadStart+=counterDigit;
                });
            }
        }
        /*/!**
         *Identifywherethestartofthemiddle/payloadsectionstarts.
         *
         *@paramrowrowofblack/whitevaluestosearch
         *@returnArray,containingindexofstartof'startblock'andendof
         *        'startblock'
         *!/*/
        decodeStart(row){
            letendStart=ITFReader.skipWhiteSpace(row);
            letstartPattern=ITFReader.findGuardPattern(row,endStart,ITFReader.START_PATTERN);
            //Determinethewidthofanarrowlineinpixels.Wecandothisby
            //gettingthewidthofthestartpatternanddividingby4becauseits
            //madeupof4narrowlines.
            this.narrowLineWidth=(startPattern[1]-startPattern[0])/4;
            this.validateQuietZone(row,startPattern[0]);
            returnstartPattern;
        }
        /*/!**
         *Thestart&endpatternsmustbepre/postfixedbyaquietzone.This
         *zonemustbeatleast10timesthewidthofanarrowline. Scanbackuntil
         *weeithergettothestartofthebarcodeormatchthenecessarynumberof
         *quietzonepixels.
         *
         *Note:Itsassumedtherowisreversedwhenusingthismethodtofind
         *quietzoneaftertheendpattern.
         *
         *ref:http://www.barcode-1.net/i25code.html
         *
         *@paramrowbitarrayrepresentingthescannedbarcode.
         *@paramstartPatternindexintorowofthestartorendpattern.
         *@throwsNotFoundExceptionifthequietzonecannotbefound
         *!/*/
        validateQuietZone(row,startPattern){
            letquietCount=this.narrowLineWidth*10;//expecttofindthismanypixelsofquietzone
            //iftherearenotsomanypixelatalllet'stryasmanyaspossible
            quietCount=quietCount<startPattern?quietCount:startPattern;
            for(leti=startPattern-1;quietCount>0&&i>=0;i--){
                if(row.get(i)){
                    break;
                }
                quietCount--;
            }
            if(quietCount!==0){
                //Unabletofindthenecessarynumberofquietzonepixels.
                thrownewNotFoundException();
            }
        }
        /*
        /!**
         *Skipallwhitespaceuntilwegettothefirstblackline.
         *
         *@paramrowrowofblack/whitevaluestosearch
         *@returnindexofthefirstblackline.
         *@throwsNotFoundExceptionThrowsexceptionifnoblacklinesarefoundintherow
         *!/*/
        staticskipWhiteSpace(row){
            constwidth=row.getSize();
            constendStart=row.getNextSet(0);
            if(endStart===width){
                thrownewNotFoundException();
            }
            returnendStart;
        }
        /*/!**
         *Identifywheretheendofthemiddle/payloadsectionends.
         *
         *@paramrowrowofblack/whitevaluestosearch
         *@returnArray,containingindexofstartof'endblock'andendof'end
         *        block'
         *!/*/
        decodeEnd(row){
            //Forconvenience,reversetherowandthen
            //searchfrom'thestart'fortheendblock
            row.reverse();
            try{
                letendStart=ITFReader.skipWhiteSpace(row);
                letendPattern;
                try{
                    endPattern=ITFReader.findGuardPattern(row,endStart,ITFReader.END_PATTERN_REVERSED[0]);
                }
                catch(error){
                    if(errorinstanceofNotFoundException){
                        endPattern=ITFReader.findGuardPattern(row,endStart,ITFReader.END_PATTERN_REVERSED[1]);
                    }
                }
                //Thestart&endpatternsmustbepre/postfixedbyaquietzone.This
                //zonemustbeatleast10timesthewidthofanarrowline.
                //ref:http://www.barcode-1.net/i25code.html
                this.validateQuietZone(row,endPattern[0]);
                //Nowrecalculatetheindicesofwherethe'endblock'starts&stopsto
                //accommodate
                //thereversednatureofthesearch
                lettemp=endPattern[0];
                endPattern[0]=row.getSize()-endPattern[1];
                endPattern[1]=row.getSize()-temp;
                returnendPattern;
            }
            finally{
                //Puttherowbacktherightway.
                row.reverse();
            }
        }
        /*
        /!**
         *@paramrow      rowofblack/whitevaluestosearch
         *@paramrowOffsetpositiontostartsearch
         *@parampattern  patternofcountsofnumberofblackandwhitepixelsthatare
         *                 beingsearchedforasapattern
         *@returnstart/endhorizontaloffsetofguardpattern,asanarrayoftwo
         *        ints
         *@throwsNotFoundExceptionifpatternisnotfound
         *!/*/
        staticfindGuardPattern(row,rowOffset,pattern){
            letpatternLength=pattern.length;
            letcounters=newInt32Array(patternLength);
            letwidth=row.getSize();
            letisWhite=false;
            letcounterPosition=0;
            letpatternStart=rowOffset;
            counters.fill(0);
            for(letx=rowOffset;x<width;x++){
                if(row.get(x)!==isWhite){
                    counters[counterPosition]++;
                }
                else{
                    if(counterPosition===patternLength-1){
                        if(OneDReader.patternMatchVariance(counters,pattern,ITFReader.MAX_INDIVIDUAL_VARIANCE)<ITFReader.MAX_AVG_VARIANCE){
                            return[patternStart,x];
                        }
                        patternStart+=counters[0]+counters[1];
                        System.arraycopy(counters,2,counters,0,counterPosition-1);
                        counters[counterPosition-1]=0;
                        counters[counterPosition]=0;
                        counterPosition--;
                    }
                    else{
                        counterPosition++;
                    }
                    counters[counterPosition]=1;
                    isWhite=!isWhite;
                }
            }
            thrownewNotFoundException();
        }
        /*/!**
         *AttemptstodecodeasequenceofITFblack/whitelinesintosingle
         *digit.
         *
         *@paramcountersthecountsofrunsofobservedblack/white/black/...values
         *@returnThedecodeddigit
         *@throwsNotFoundExceptionifdigitcannotbedecoded
         *!/*/
        staticdecodeDigit(counters){
            letbestVariance=ITFReader.MAX_AVG_VARIANCE;//worstvariancewe'llaccept
            letbestMatch=-1;
            letmax=ITFReader.PATTERNS.length;
            for(leti=0;i<max;i++){
                letpattern=ITFReader.PATTERNS[i];
                letvariance=OneDReader.patternMatchVariance(counters,pattern,ITFReader.MAX_INDIVIDUAL_VARIANCE);
                if(variance<bestVariance){
                    bestVariance=variance;
                    bestMatch=i;
                }
                elseif(variance===bestVariance){
                    //ifwefindasecond'bestmatch'withthesamevariance,wecannotreliablyreporttohaveasuitablematch
                    bestMatch=-1;
                }
            }
            if(bestMatch>=0){
                returnbestMatch%10;
            }
            else{
                thrownewNotFoundException();
            }
        }
    }
    ITFReader.PATTERNS=[
        Int32Array.from([1,1,2,2,1]),
        Int32Array.from([2,1,1,1,2]),
        Int32Array.from([1,2,1,1,2]),
        Int32Array.from([2,2,1,1,1]),
        Int32Array.from([1,1,2,1,2]),
        Int32Array.from([2,1,2,1,1]),
        Int32Array.from([1,2,2,1,1]),
        Int32Array.from([1,1,1,2,2]),
        Int32Array.from([2,1,1,2,1]),
        Int32Array.from([1,2,1,2,1]),
        Int32Array.from([1,1,3,3,1]),
        Int32Array.from([3,1,1,1,3]),
        Int32Array.from([1,3,1,1,3]),
        Int32Array.from([3,3,1,1,1]),
        Int32Array.from([1,1,3,1,3]),
        Int32Array.from([3,1,3,1,1]),
        Int32Array.from([1,3,3,1,1]),
        Int32Array.from([1,1,1,3,3]),
        Int32Array.from([3,1,1,3,1]),
        Int32Array.from([1,3,1,3,1])//9
    ];
    ITFReader.MAX_AVG_VARIANCE=0.38;
    ITFReader.MAX_INDIVIDUAL_VARIANCE=0.5;
    /*/!**ValidITFlengths.Anythinglongerthanthelargestvalueisalsoallowed.*!/*/
    ITFReader.DEFAULT_ALLOWED_LENGTHS=[6,8,10,12,14];
    /*/!**
     *Start/endguardpattern.
     *
     *Note:Theendpatternisreversedbecausetherowisreversedbefore
     *searchingfortheEND_PATTERN
     *!/*/
    ITFReader.START_PATTERN=Int32Array.from([1,1,1,1]);
    ITFReader.END_PATTERN_REVERSED=[
        Int32Array.from([1,1,2]),
        Int32Array.from([1,1,3])//3x
    ];

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>EncapsulatesfunctionalityandimplementationthatiscommontoUPCandEANfamilies
     *ofone-dimensionalbarcodes.</p>
     *
     *@authordswitkin@google.com(DanielSwitkin)
     *@authorSeanOwen
     *@authoralasdair@google.com(AlasdairMackintosh)
     */
    classAbstractUPCEANReaderextendsOneDReader{
        constructor(){
            super(...arguments);
            this.decodeRowStringBuffer='';
        }
        //privatefinalUPCEANExtensionSupportextensionReader;
        //privatefinalEANManufacturerOrgSupporteanManSupport;
        /*
        protectedUPCEANReader(){
            decodeRowStringBuffer=newStringBuilder(20);
            extensionReader=newUPCEANExtensionSupport();
            eanManSupport=newEANManufacturerOrgSupport();
        }
        */
        staticfindStartGuardPattern(row){
            letfoundStart=false;
            letstartRange;
            letnextStart=0;
            letcounters=Int32Array.from([0,0,0]);
            while(!foundStart){
                counters=Int32Array.from([0,0,0]);
                startRange=AbstractUPCEANReader.findGuardPattern(row,nextStart,false,this.START_END_PATTERN,counters);
                letstart=startRange[0];
                nextStart=startRange[1];
                letquietStart=start-(nextStart-start);
                if(quietStart>=0){
                    foundStart=row.isRange(quietStart,start,false);
                }
            }
            returnstartRange;
        }
        staticcheckChecksum(s){
            returnAbstractUPCEANReader.checkStandardUPCEANChecksum(s);
        }
        staticcheckStandardUPCEANChecksum(s){
            letlength=s.length;
            if(length===0)
                returnfalse;
            letcheck=parseInt(s.charAt(length-1),10);
            returnAbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0,length-1))===check;
        }
        staticgetStandardUPCEANChecksum(s){
            letlength=s.length;
            letsum=0;
            for(leti=length-1;i>=0;i-=2){
                letdigit=s.charAt(i).charCodeAt(0)-'0'.charCodeAt(0);
                if(digit<0||digit>9){
                    thrownewFormatException();
                }
                sum+=digit;
            }
            sum*=3;
            for(leti=length-2;i>=0;i-=2){
                letdigit=s.charAt(i).charCodeAt(0)-'0'.charCodeAt(0);
                if(digit<0||digit>9){
                    thrownewFormatException();
                }
                sum+=digit;
            }
            return(1000-sum)%10;
        }
        staticdecodeEnd(row,endStart){
            returnAbstractUPCEANReader.findGuardPattern(row,endStart,false,AbstractUPCEANReader.START_END_PATTERN,newInt32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));
        }
        /**
         *@throwsNotFoundException
         */
        staticfindGuardPatternWithoutCounters(row,rowOffset,whiteFirst,pattern){
            returnthis.findGuardPattern(row,rowOffset,whiteFirst,pattern,newInt32Array(pattern.length));
        }
        /**
         *@paramrowrowofblack/whitevaluestosearch
         *@paramrowOffsetpositiontostartsearch
         *@paramwhiteFirstiftrue,indicatesthatthepatternspecifieswhite/black/white/...
         *pixelcounts,otherwise,itisinterpretedasblack/white/black/...
         *@parampatternpatternofcountsofnumberofblackandwhitepixelsthatarebeing
         *searchedforasapattern
         *@paramcountersarrayofcounters,aslongaspattern,tore-use
         *@returnstart/endhorizontaloffsetofguardpattern,asanarrayoftwoints
         *@throwsNotFoundExceptionifpatternisnotfound
         */
        staticfindGuardPattern(row,rowOffset,whiteFirst,pattern,counters){
            letwidth=row.getSize();
            rowOffset=whiteFirst?row.getNextUnset(rowOffset):row.getNextSet(rowOffset);
            letcounterPosition=0;
            letpatternStart=rowOffset;
            letpatternLength=pattern.length;
            letisWhite=whiteFirst;
            for(letx=rowOffset;x<width;x++){
                if(row.get(x)!==isWhite){
                    counters[counterPosition]++;
                }
                else{
                    if(counterPosition===patternLength-1){
                        if(OneDReader.patternMatchVariance(counters,pattern,AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE)<AbstractUPCEANReader.MAX_AVG_VARIANCE){
                            returnInt32Array.from([patternStart,x]);
                        }
                        patternStart+=counters[0]+counters[1];
                        letslice=counters.slice(2,counters.length-1);
                        for(leti=0;i<counterPosition-1;i++){
                            counters[i]=slice[i];
                        }
                        counters[counterPosition-1]=0;
                        counters[counterPosition]=0;
                        counterPosition--;
                    }
                    else{
                        counterPosition++;
                    }
                    counters[counterPosition]=1;
                    isWhite=!isWhite;
                }
            }
            thrownewNotFoundException();
        }
        staticdecodeDigit(row,counters,rowOffset,patterns){
            this.recordPattern(row,rowOffset,counters);
            letbestVariance=this.MAX_AVG_VARIANCE;
            letbestMatch=-1;
            letmax=patterns.length;
            for(leti=0;i<max;i++){
                letpattern=patterns[i];
                letvariance=OneDReader.patternMatchVariance(counters,pattern,AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);
                if(variance<bestVariance){
                    bestVariance=variance;
                    bestMatch=i;
                }
            }
            if(bestMatch>=0){
                returnbestMatch;
            }
            else{
                thrownewNotFoundException();
            }
        }
    }
    //Thesetwovaluesarecriticalfordetermininghowpermissivethedecodingwillbe.
    //We'vearrivedatthesevaluesthroughalotoftrialanderror.Settingthemanyhigher
    //letsfalsepositivescreepinquickly.
    AbstractUPCEANReader.MAX_AVG_VARIANCE=0.48;
    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE=0.7;
    /**
     *Start/endguardpattern.
     */
    AbstractUPCEANReader.START_END_PATTERN=Int32Array.from([1,1,1]);
    /**
     *PatternmarkingthemiddleofaUPC/EANpattern,separatingthetwohalves.
     */
    AbstractUPCEANReader.MIDDLE_PATTERN=Int32Array.from([1,1,1,1,1]);
    /**
     *endguardpattern.
     */
    AbstractUPCEANReader.END_PATTERN=Int32Array.from([1,1,1,1,1,1]);
    /**
     *"Odd",or"L"patternsusedtoencodeUPC/EANdigits.
     */
    AbstractUPCEANReader.L_PATTERNS=[
        Int32Array.from([3,2,1,1]),
        Int32Array.from([2,2,2,1]),
        Int32Array.from([2,1,2,2]),
        Int32Array.from([1,4,1,1]),
        Int32Array.from([1,1,3,2]),
        Int32Array.from([1,2,3,1]),
        Int32Array.from([1,1,1,4]),
        Int32Array.from([1,3,1,2]),
        Int32Array.from([1,2,1,3]),
        Int32Array.from([3,1,1,2]),
    ];

    /*
     *Copyright(C)2010ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *@seeUPCEANExtension2Support
     */
    classUPCEANExtension5Support{
        constructor(){
            this.CHECK_DIGIT_ENCODINGS=[0x18,0x14,0x12,0x11,0x0C,0x06,0x03,0x0A,0x09,0x05];
            this.decodeMiddleCounters=Int32Array.from([0,0,0,0]);
            this.decodeRowStringBuffer='';
        }
        decodeRow(rowNumber,row,extensionStartRange){
            letresult=this.decodeRowStringBuffer;
            letend=this.decodeMiddle(row,extensionStartRange,result);
            letresultString=result.toString();
            letextensionData=UPCEANExtension5Support.parseExtensionString(resultString);
            letresultPoints=[
                newResultPoint((extensionStartRange[0]+extensionStartRange[1])/2.0,rowNumber),
                newResultPoint(end,rowNumber)
            ];
            letextensionResult=newResult(resultString,null,0,resultPoints,BarcodeFormat$1.UPC_EAN_EXTENSION,newDate().getTime());
            if(extensionData!=null){
                extensionResult.putAllMetadata(extensionData);
            }
            returnextensionResult;
        }
        decodeMiddle(row,startRange,resultString){
            letcounters=this.decodeMiddleCounters;
            counters[0]=0;
            counters[1]=0;
            counters[2]=0;
            counters[3]=0;
            letend=row.getSize();
            letrowOffset=startRange[1];
            letlgPatternFound=0;
            for(letx=0;x<5&&rowOffset<end;x++){
                letbestMatch=AbstractUPCEANReader.decodeDigit(row,counters,rowOffset,AbstractUPCEANReader.L_AND_G_PATTERNS);
                resultString+=String.fromCharCode(('0'.charCodeAt(0)+bestMatch%10));
                for(letcounterofcounters){
                    rowOffset+=counter;
                }
                if(bestMatch>=10){
                    lgPatternFound|=1<<(4-x);
                }
                if(x!==4){
                    //Readoffseparatorifnotlast
                    rowOffset=row.getNextSet(rowOffset);
                    rowOffset=row.getNextUnset(rowOffset);
                }
            }
            if(resultString.length!==5){
                thrownewNotFoundException();
            }
            letcheckDigit=this.determineCheckDigit(lgPatternFound);
            if(UPCEANExtension5Support.extensionChecksum(resultString.toString())!==checkDigit){
                thrownewNotFoundException();
            }
            returnrowOffset;
        }
        staticextensionChecksum(s){
            letlength=s.length;
            letsum=0;
            for(leti=length-2;i>=0;i-=2){
                sum+=s.charAt(i).charCodeAt(0)-'0'.charCodeAt(0);
            }
            sum*=3;
            for(leti=length-1;i>=0;i-=2){
                sum+=s.charAt(i).charCodeAt(0)-'0'.charCodeAt(0);
            }
            sum*=3;
            returnsum%10;
        }
        determineCheckDigit(lgPatternFound){
            for(letd=0;d<10;d++){
                if(lgPatternFound===this.CHECK_DIGIT_ENCODINGS[d]){
                    returnd;
                }
            }
            thrownewNotFoundException();
        }
        staticparseExtensionString(raw){
            if(raw.length!==5){
                returnnull;
            }
            letvalue=UPCEANExtension5Support.parseExtension5String(raw);
            if(value==null){
                returnnull;
            }
            returnnewMap([[ResultMetadataType$1.SUGGESTED_PRICE,value]]);
        }
        staticparseExtension5String(raw){
            letcurrency;
            switch(raw.charAt(0)){
                case'0':
                    currency='£';
                    break;
                case'5':
                    currency='$';
                    break;
                case'9':
                    //Reference:http://www.jollytech.com
                    switch(raw){
                        case'90000':
                            //Nosuggestedretailprice
                            returnnull;
                        case'99991':
                            //Complementary
                            return'0.00';
                        case'99990':
                            return'Used';
                    }
                    //Otherwise...unknowncurrency?
                    currency='';
                    break;
                default:
                    currency='';
                    break;
            }
            letrawAmount=parseInt(raw.substring(1));
            letunitsString=(rawAmount/100).toString();
            lethundredths=rawAmount%100;
            lethundredthsString=hundredths<10?'0'+hundredths:hundredths.toString();//fixme
            returncurrency+unitsString+'.'+hundredthsString;
        }
    }

    /*
     *Copyright(C)2012ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *@seeUPCEANExtension5Support
     */
    classUPCEANExtension2Support{
        constructor(){
            this.decodeMiddleCounters=Int32Array.from([0,0,0,0]);
            this.decodeRowStringBuffer='';
        }
        decodeRow(rowNumber,row,extensionStartRange){
            letresult=this.decodeRowStringBuffer;
            letend=this.decodeMiddle(row,extensionStartRange,result);
            letresultString=result.toString();
            letextensionData=UPCEANExtension2Support.parseExtensionString(resultString);
            letresultPoints=[
                newResultPoint((extensionStartRange[0]+extensionStartRange[1])/2.0,rowNumber),
                newResultPoint(end,rowNumber)
            ];
            letextensionResult=newResult(resultString,null,0,resultPoints,BarcodeFormat$1.UPC_EAN_EXTENSION,newDate().getTime());
            if(extensionData!=null){
                extensionResult.putAllMetadata(extensionData);
            }
            returnextensionResult;
        }
        decodeMiddle(row,startRange,resultString){
            letcounters=this.decodeMiddleCounters;
            counters[0]=0;
            counters[1]=0;
            counters[2]=0;
            counters[3]=0;
            letend=row.getSize();
            letrowOffset=startRange[1];
            letcheckParity=0;
            for(letx=0;x<2&&rowOffset<end;x++){
                letbestMatch=AbstractUPCEANReader.decodeDigit(row,counters,rowOffset,AbstractUPCEANReader.L_AND_G_PATTERNS);
                resultString+=String.fromCharCode(('0'.charCodeAt(0)+bestMatch%10));
                for(letcounterofcounters){
                    rowOffset+=counter;
                }
                if(bestMatch>=10){
                    checkParity|=1<<(1-x);
                }
                if(x!==1){
                    //Readoffseparatorifnotlast
                    rowOffset=row.getNextSet(rowOffset);
                    rowOffset=row.getNextUnset(rowOffset);
                }
            }
            if(resultString.length!==2){
                thrownewNotFoundException();
            }
            if(parseInt(resultString.toString())%4!==checkParity){
                thrownewNotFoundException();
            }
            returnrowOffset;
        }
        staticparseExtensionString(raw){
            if(raw.length!==2){
                returnnull;
            }
            returnnewMap([[ResultMetadataType$1.ISSUE_NUMBER,parseInt(raw)]]);
        }
    }

    /*
     *Copyright(C)2010ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    classUPCEANExtensionSupport{
        staticdecodeRow(rowNumber,row,rowOffset){
            letextensionStartRange=AbstractUPCEANReader.findGuardPattern(row,rowOffset,false,this.EXTENSION_START_PATTERN,newInt32Array(this.EXTENSION_START_PATTERN.length).fill(0));
            try{
                //returnnull;
                letfiveSupport=newUPCEANExtension5Support();
                returnfiveSupport.decodeRow(rowNumber,row,extensionStartRange);
            }
            catch(err){
                //returnnull;
                lettwoSupport=newUPCEANExtension2Support();
                returntwoSupport.decodeRow(rowNumber,row,extensionStartRange);
            }
        }
    }
    UPCEANExtensionSupport.EXTENSION_START_PATTERN=Int32Array.from([1,1,2]);

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>EncapsulatesfunctionalityandimplementationthatiscommontoUPCandEANfamilies
     *ofone-dimensionalbarcodes.</p>
     *
     *@authordswitkin@google.com(DanielSwitkin)
     *@authorSeanOwen
     *@authoralasdair@google.com(AlasdairMackintosh)
     */
    classUPCEANReaderextendsAbstractUPCEANReader{
        constructor(){
            super();
            this.decodeRowStringBuffer='';
            UPCEANReader.L_AND_G_PATTERNS=UPCEANReader.L_PATTERNS.map(arr=>Int32Array.from(arr));
            for(leti=10;i<20;i++){
                letwidths=UPCEANReader.L_PATTERNS[i-10];
                letreversedWidths=newInt32Array(widths.length);
                for(letj=0;j<widths.length;j++){
                    reversedWidths[j]=widths[widths.length-j-1];
                }
                UPCEANReader.L_AND_G_PATTERNS[i]=reversedWidths;
            }
        }
        decodeRow(rowNumber,row,hints){
            letstartGuardRange=UPCEANReader.findStartGuardPattern(row);
            letresultPointCallback=hints==null?null:hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
            if(resultPointCallback!=null){
                constresultPoint=newResultPoint((startGuardRange[0]+startGuardRange[1])/2.0,rowNumber);
                resultPointCallback.foundPossibleResultPoint(resultPoint);
            }
            letbudello=this.decodeMiddle(row,startGuardRange,this.decodeRowStringBuffer);
            letendStart=budello.rowOffset;
            letresult=budello.resultString;
            if(resultPointCallback!=null){
                constresultPoint=newResultPoint(endStart,rowNumber);
                resultPointCallback.foundPossibleResultPoint(resultPoint);
            }
            letendRange=UPCEANReader.decodeEnd(row,endStart);
            if(resultPointCallback!=null){
                constresultPoint=newResultPoint((endRange[0]+endRange[1])/2.0,rowNumber);
                resultPointCallback.foundPossibleResultPoint(resultPoint);
            }
            //Makesurethereisaquietzoneatleastasbigastheendpatternafterthebarcode.The
            //specmightwantmorewhitespace,butinpracticethisisthemaximumwecancounton.
            letend=endRange[1];
            letquietEnd=end+(end-endRange[0]);
            if(quietEnd>=row.getSize()||!row.isRange(end,quietEnd,false)){
                thrownewNotFoundException();
            }
            letresultString=result.toString();
            //UPC/EANshouldneverbelessthan8charsanyway
            if(resultString.length<8){
                thrownewFormatException();
            }
            if(!UPCEANReader.checkChecksum(resultString)){
                thrownewChecksumException();
            }
            letleft=(startGuardRange[1]+startGuardRange[0])/2.0;
            letright=(endRange[1]+endRange[0])/2.0;
            letformat=this.getBarcodeFormat();
            letresultPoint=[newResultPoint(left,rowNumber),newResultPoint(right,rowNumber)];
            letdecodeResult=newResult(resultString,null,0,resultPoint,format,newDate().getTime());
            letextensionLength=0;
            try{
                letextensionResult=UPCEANExtensionSupport.decodeRow(rowNumber,row,endRange[1]);
                decodeResult.putMetadata(ResultMetadataType$1.UPC_EAN_EXTENSION,extensionResult.getText());
                decodeResult.putAllMetadata(extensionResult.getResultMetadata());
                decodeResult.addResultPoints(extensionResult.getResultPoints());
                extensionLength=extensionResult.getText().length;
            }
            catch(err){
            }
            letallowedExtensions=hints==null?null:hints.get(DecodeHintType$1.ALLOWED_EAN_EXTENSIONS);
            if(allowedExtensions!=null){
                letvalid=false;
                for(letlengthinallowedExtensions){
                    if(extensionLength.toString()===length){//checkme
                        valid=true;
                        break;
                    }
                }
                if(!valid){
                    thrownewNotFoundException();
                }
            }
            if(format===BarcodeFormat$1.EAN_13||format===BarcodeFormat$1.UPC_A);
            returndecodeResult;
        }
        staticcheckChecksum(s){
            returnUPCEANReader.checkStandardUPCEANChecksum(s);
        }
        staticcheckStandardUPCEANChecksum(s){
            letlength=s.length;
            if(length===0)
                returnfalse;
            letcheck=parseInt(s.charAt(length-1),10);
            returnUPCEANReader.getStandardUPCEANChecksum(s.substring(0,length-1))===check;
        }
        staticgetStandardUPCEANChecksum(s){
            letlength=s.length;
            letsum=0;
            for(leti=length-1;i>=0;i-=2){
                letdigit=s.charAt(i).charCodeAt(0)-'0'.charCodeAt(0);
                if(digit<0||digit>9){
                    thrownewFormatException();
                }
                sum+=digit;
            }
            sum*=3;
            for(leti=length-2;i>=0;i-=2){
                letdigit=s.charAt(i).charCodeAt(0)-'0'.charCodeAt(0);
                if(digit<0||digit>9){
                    thrownewFormatException();
                }
                sum+=digit;
            }
            return(1000-sum)%10;
        }
        staticdecodeEnd(row,endStart){
            returnUPCEANReader.findGuardPattern(row,endStart,false,UPCEANReader.START_END_PATTERN,newInt32Array(UPCEANReader.START_END_PATTERN.length).fill(0));
        }
    }

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>ImplementsdecodingoftheEAN-13format.</p>
     *
     *@authordswitkin@google.com(DanielSwitkin)
     *@authorSeanOwen
     *@authoralasdair@google.com(AlasdairMackintosh)
     */
    classEAN13ReaderextendsUPCEANReader{
        constructor(){
            super();
            this.decodeMiddleCounters=Int32Array.from([0,0,0,0]);
        }
        decodeMiddle(row,startRange,resultString){
            letcounters=this.decodeMiddleCounters;
            counters[0]=0;
            counters[1]=0;
            counters[2]=0;
            counters[3]=0;
            letend=row.getSize();
            letrowOffset=startRange[1];
            letlgPatternFound=0;
            for(letx=0;x<6&&rowOffset<end;x++){
                letbestMatch=UPCEANReader.decodeDigit(row,counters,rowOffset,UPCEANReader.L_AND_G_PATTERNS);
                resultString+=String.fromCharCode(('0'.charCodeAt(0)+bestMatch%10));
                for(letcounterofcounters){
                    rowOffset+=counter;
                }
                if(bestMatch>=10){
                    lgPatternFound|=1<<(5-x);
                }
            }
            resultString=EAN13Reader.determineFirstDigit(resultString,lgPatternFound);
            letmiddleRange=UPCEANReader.findGuardPattern(row,rowOffset,true,UPCEANReader.MIDDLE_PATTERN,newInt32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));
            rowOffset=middleRange[1];
            for(letx=0;x<6&&rowOffset<end;x++){
                letbestMatch=UPCEANReader.decodeDigit(row,counters,rowOffset,UPCEANReader.L_PATTERNS);
                resultString+=String.fromCharCode(('0'.charCodeAt(0)+bestMatch));
                for(letcounterofcounters){
                    rowOffset+=counter;
                }
            }
            return{rowOffset,resultString};
        }
        getBarcodeFormat(){
            returnBarcodeFormat$1.EAN_13;
        }
        staticdetermineFirstDigit(resultString,lgPatternFound){
            for(letd=0;d<10;d++){
                if(lgPatternFound===this.FIRST_DIGIT_ENCODINGS[d]){
                    resultString=String.fromCharCode(('0'.charCodeAt(0)+d))+resultString;
                    returnresultString;
                }
            }
            thrownewNotFoundException();
        }
    }
    EAN13Reader.FIRST_DIGIT_ENCODINGS=[0x00,0x0B,0x0D,0xE,0x13,0x19,0x1C,0x15,0x16,0x1A];

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>ImplementsdecodingoftheEAN-8format.</p>
     *
     *@authorSeanOwen
     */
    classEAN8ReaderextendsUPCEANReader{
        constructor(){
            super();
            this.decodeMiddleCounters=Int32Array.from([0,0,0,0]);
        }
        decodeMiddle(row,startRange,resultString){
            constcounters=this.decodeMiddleCounters;
            counters[0]=0;
            counters[1]=0;
            counters[2]=0;
            counters[3]=0;
            letend=row.getSize();
            letrowOffset=startRange[1];
            for(letx=0;x<4&&rowOffset<end;x++){
                letbestMatch=UPCEANReader.decodeDigit(row,counters,rowOffset,UPCEANReader.L_PATTERNS);
                resultString+=String.fromCharCode(('0'.charCodeAt(0)+bestMatch));
                for(letcounterofcounters){
                    rowOffset+=counter;
                }
            }
            letmiddleRange=UPCEANReader.findGuardPattern(row,rowOffset,true,UPCEANReader.MIDDLE_PATTERN,newInt32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));
            rowOffset=middleRange[1];
            for(letx=0;x<4&&rowOffset<end;x++){
                letbestMatch=UPCEANReader.decodeDigit(row,counters,rowOffset,UPCEANReader.L_PATTERNS);
                resultString+=String.fromCharCode(('0'.charCodeAt(0)+bestMatch));
                for(letcounterofcounters){
                    rowOffset+=counter;
                }
            }
            return{rowOffset,resultString};
        }
        getBarcodeFormat(){
            returnBarcodeFormat$1.EAN_8;
        }
    }

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *Encapsulatesfunctionalityandimplementationthatiscommontoallfamilies
     *ofone-dimensionalbarcodes.
     *
     *@authordswitkin@google.com(DanielSwitkin)
     *@authorSeanOwen
     *@authorsam2332(SamRudloff)
     *
     *@sourcehttps://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCAReader.java
     *
     *@experimental
     */
    classUPCAReaderextendsUPCEANReader{
        constructor(){
            super(...arguments);
            this.ean13Reader=newEAN13Reader();
        }
        //@Override
        getBarcodeFormat(){
            returnBarcodeFormat$1.UPC_A;
        }
        //Notethatwedon'ttryrotationwithoutthetryharderflag,evenifrotationwassupported.
        //@Override
        decode(image,hints){
            returnthis.maybeReturnResult(this.ean13Reader.decode(image));
        }
        //@Override
        decodeRow(rowNumber,row,hints){
            returnthis.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber,row,hints));
        }
        //@Override
        decodeMiddle(row,startRange,resultString){
            returnthis.ean13Reader.decodeMiddle(row,startRange,resultString);
        }
        maybeReturnResult(result){
            lettext=result.getText();
            if(text.charAt(0)==='0'){
                letupcaResult=newResult(text.substring(1),null,null,result.getResultPoints(),BarcodeFormat$1.UPC_A);
                if(result.getResultMetadata()!=null){
                    upcaResult.putAllMetadata(result.getResultMetadata());
                }
                returnupcaResult;
            }
            else{
                thrownewNotFoundException();
            }
        }
        reset(){
            this.ean13Reader.reset();
        }
    }

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    //packagecom.google.zxing.oned;
    //importcom.google.zxing.BarcodeFormat;
    //importcom.google.zxing.FormatException;
    //importcom.google.zxing.NotFoundException;
    //importcom.google.zxing.common.BitArray;
    /**
     *<p>ImplementsdecodingoftheUPC-Eformat.</p>
     *<p><ahref="http://www.barcodeisland.com/upce.phtml">This</a>isagreatreferencefor
     *UPC-Einformation.</p>
     *
     *@authorSeanOwen
     *
     *@sourcehttps://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCEReader.java
     *
     *@experimental
     */
    /*final*/classUPCEReaderextendsUPCEANReader{
        constructor(){
            super();
            this.decodeMiddleCounters=newInt32Array(4);
        }
        /**
         *@throwsNotFoundException
         */
        //@Override
        decodeMiddle(row,startRange,result){
            constcounters=this.decodeMiddleCounters.map(x=>x);
            counters[0]=0;
            counters[1]=0;
            counters[2]=0;
            counters[3]=0;
            constend=row.getSize();
            letrowOffset=startRange[1];
            letlgPatternFound=0;
            for(letx=0;x<6&&rowOffset<end;x++){
                constbestMatch=UPCEReader.decodeDigit(row,counters,rowOffset,UPCEReader.L_AND_G_PATTERNS);
                result+=String.fromCharCode(('0'.charCodeAt(0)+bestMatch%10));
                for(letcounterofcounters){
                    rowOffset+=counter;
                }
                if(bestMatch>=10){
                    lgPatternFound|=1<<(5-x);
                }
            }
            UPCEReader.determineNumSysAndCheckDigit(newStringBuilder(result),lgPatternFound);
            returnrowOffset;
        }
        /**
         *@throwsNotFoundException
         */
        //@Override
        decodeEnd(row,endStart){
            returnUPCEReader.findGuardPatternWithoutCounters(row,endStart,true,UPCEReader.MIDDLE_END_PATTERN);
        }
        /**
         *@throwsFormatException
         */
        //@Override
        checkChecksum(s){
            returnUPCEANReader.checkChecksum(UPCEReader.convertUPCEtoUPCA(s));
        }
        /**
         *@throwsNotFoundException
         */
        staticdetermineNumSysAndCheckDigit(resultString,lgPatternFound){
            for(letnumSys=0;numSys<=1;numSys++){
                for(letd=0;d<10;d++){
                    if(lgPatternFound===this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d]){
                        resultString.insert(0,/*(char)*/('0'+numSys));
                        resultString.append(/*(char)*/('0'+d));
                        return;
                    }
                }
            }
            throwNotFoundException.getNotFoundInstance();
        }
        //@Override
        getBarcodeFormat(){
            returnBarcodeFormat$1.UPC_E;
        }
        /**
         *ExpandsaUPC-Evaluebackintoitsfull,equivalentUPC-Acodevalue.
         *
         *@paramupceUPC-Ecodeasstringofdigits
         *@returnequivalentUPC-Acodeasstringofdigits
         */
        staticconvertUPCEtoUPCA(upce){
            //thefollowinglineisequivalenttoupce.getChars(1,7,upceChars,0);
            constupceChars=upce.slice(1,7).split('').map(x=>x.charCodeAt(0));
            constresult=newStringBuilder(/*12*/);
            result.append(upce.charAt(0));
            letlastChar=upceChars[5];
            switch(lastChar){
                case0:
                case1:
                case2:
                    result.appendChars(upceChars,0,2);
                    result.append(lastChar);
                    result.append('0000');
                    result.appendChars(upceChars,2,3);
                    break;
                case3:
                    result.appendChars(upceChars,0,3);
                    result.append('00000');
                    result.appendChars(upceChars,3,2);
                    break;
                case4:
                    result.appendChars(upceChars,0,4);
                    result.append('00000');
                    result.append(upceChars[4]);
                    break;
                default:
                    result.appendChars(upceChars,0,5);
                    result.append('0000');
                    result.append(lastChar);
                    break;
            }
            //Onlyappendcheckdigitinconversionifsupplied
            if(upce.length>=8){
                result.append(upce.charAt(7));
            }
            returnresult.toString();
        }
    }
    /**
     *Thepatternthatmarksthemiddle,andend,ofaUPC-Epattern.
     *Thereisno"secondhalf"toaUPC-Ebarcode.
     */
    UPCEReader.MIDDLE_END_PATTERN=Int32Array.from([1,1,1,1,1,1]);
    //ForanUPC-Ebarcode,thefinaldigitisrepresentedbytheparitiesused
    //toencodethemiddlesixdigits,accordingtothetablebelow.
    //
    //               Parityofnext6digits
    //   Digit  0    1    2    3    4    5
    //      0   Even  Even EvenOdd Odd  Odd
    //      1   Even  Even Odd EvenOdd  Odd
    //      2   Even  Even Odd Odd Even Odd
    //      3   Even  Even Odd Odd Odd  Even
    //      4   Even  Odd  EvenEvenOdd  Odd
    //      5   Even  Odd  Odd EvenEven Odd
    //      6   Even  Odd  Odd Odd Even Even
    //      7   Even  Odd  EvenOdd Even Odd
    //      8   Even  Odd  EvenOdd Odd  Even
    //      9   Even  Odd  Odd EvenOdd  Even
    //
    //Theencodingisrepresentedbythefollowingarray,whichisabitpattern
    //usingOdd=0andEven=1.Forexample,5isrepresentedby:
    //
    //             OddEvenEvenOddOddEven
    //inbinary:
    //               0   1   1  0  0   1  ==0x19
    //
    /**
     *See{@link#L_AND_G_PATTERNS};thesevaluessimilarlyrepresentpatternsof
     *even-oddparityencodingsofdigitsthatimplyboththenumbersystem(0or1)
     *used,andthecheckdigit.
     */
    UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS=[
        Int32Array.from([0x38,0x34,0x32,0x31,0x2C,0x26,0x23,0x2A,0x29,0x25]),
        Int32Array.from([0x07,0x0B,0x0D,0x0E,0x13,0x19,0x1C,0x15,0x16,0x1]),
    ];

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>AreaderthatcanreadallavailableUPC/EANformats.Ifacallerwantstotryto
     *readallsuchformats,itismostefficienttousethisimplementationratherthaninvoke
     *individualreaders.</p>
     *
     *@authorSeanOwen
     */
    classMultiFormatUPCEANReaderextendsOneDReader{
        constructor(hints){
            super();
            letpossibleFormats=hints==null?null:hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
            letreaders=[];
            if(possibleFormats!=null){
                if(possibleFormats.indexOf(BarcodeFormat$1.EAN_13)>-1){
                    readers.push(newEAN13Reader());
                }
                elseif(possibleFormats.indexOf(BarcodeFormat$1.UPC_A)>-1){
                    readers.push(newUPCAReader());
                }
                if(possibleFormats.indexOf(BarcodeFormat$1.EAN_8)>-1){
                    readers.push(newEAN8Reader());
                }
                if(possibleFormats.indexOf(BarcodeFormat$1.UPC_E)>-1){
                    readers.push(newUPCEReader());
                }
            }
            if(readers.length===0){
                readers.push(newEAN13Reader());
                //UPC-AiscoveredbyEAN-13
                readers.push(newEAN8Reader());
                readers.push(newUPCEReader());
            }
            this.readers=readers;
        }
        decodeRow(rowNumber,row,hints){
            for(letreaderofthis.readers){
                try{
                    //constresult:Result=reader.decodeRow(rowNumber,row,startGuardPattern,hints);
                    constresult=reader.decodeRow(rowNumber,row,hints);
                    //Specialcase:a12-digitcodeencodedinUPC-Aisidenticaltoa"0"
                    //followedbythose12digitsencodedasEAN-13.Eachwillrecognizesuchacode,
                    //UPC-Aasa12-digitstringandEAN-13asa13-digitstringstartingwith"0".
                    //Individuallythesearecorrectandtheirreaderswillbothreadsuchacode
                    //andcorrectlycallitEAN-13,orUPC-A,respectively.
                    //
                    //Inthiscase,ifwe'vebeenlookingforbothtypes,we'dliketocallit
                    //aUPC-Acode.ButforefficiencyweonlyruntheEAN-13decodertoalsoread
                    //UPC-A.Sowespecialcaseithere,andconvertanEAN-13resulttoaUPC-A
                    //resultifappropriate.
                    //
                    //But,don'treturnUPC-AifUPC-Awasnotarequestedformat!
                    constean13MayBeUPCA=result.getBarcodeFormat()===BarcodeFormat$1.EAN_13&&
                        result.getText().charAt(0)==='0';
                    //@SuppressWarnings("unchecked")
                    constpossibleFormats=hints==null?null:hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
                    constcanReturnUPCA=possibleFormats==null||possibleFormats.includes(BarcodeFormat$1.UPC_A);
                    if(ean13MayBeUPCA&&canReturnUPCA){
                        constrawBytes=result.getRawBytes();
                        //Transferthemetadataacross
                        constresultUPCA=newResult(result.getText().substring(1),rawBytes,rawBytes.length,result.getResultPoints(),BarcodeFormat$1.UPC_A);
                        resultUPCA.putAllMetadata(result.getResultMetadata());
                        returnresultUPCA;
                    }
                    returnresult;
                }
                catch(err){
                    //continue;
                }
            }
            thrownewNotFoundException();
        }
        reset(){
            for(letreaderofthis.readers){
                reader.reset();
            }
        }
    }

    //importIntegerfrom'../../util/Integer';
    //importFloatfrom'../../util/Float';
    classAbstractRSSReaderextendsOneDReader{
        constructor(){
            super();
            this.decodeFinderCounters=newInt32Array(4);
            this.dataCharacterCounters=newInt32Array(8);
            this.oddRoundingErrors=newArray(4);
            this.evenRoundingErrors=newArray(4);
            this.oddCounts=newArray(this.dataCharacterCounters.length/2);
            this.evenCounts=newArray(this.dataCharacterCounters.length/2);
        }
        getDecodeFinderCounters(){
            returnthis.decodeFinderCounters;
        }
        getDataCharacterCounters(){
            returnthis.dataCharacterCounters;
        }
        getOddRoundingErrors(){
            returnthis.oddRoundingErrors;
        }
        getEvenRoundingErrors(){
            returnthis.evenRoundingErrors;
        }
        getOddCounts(){
            returnthis.oddCounts;
        }
        getEvenCounts(){
            returnthis.evenCounts;
        }
        parseFinderValue(counters,finderPatterns){
            for(letvalue=0;value<finderPatterns.length;value++){
                if(OneDReader.patternMatchVariance(counters,finderPatterns[value],AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE)<AbstractRSSReader.MAX_AVG_VARIANCE){
                    returnvalue;
                }
            }
            thrownewNotFoundException();
        }
        /**
         *@paramarrayvaluestosum
         *@returnsumofvalues
         *@deprecatedcall{@linkMathUtils#sum(int[])}
         */
        staticcount(array){
            returnMathUtils.sum(newInt32Array(array));
        }
        staticincrement(array,errors){
            letindex=0;
            letbiggestError=errors[0];
            for(leti=1;i<array.length;i++){
                if(errors[i]>biggestError){
                    biggestError=errors[i];
                    index=i;
                }
            }
            array[index]++;
        }
        staticdecrement(array,errors){
            letindex=0;
            letbiggestError=errors[0];
            for(leti=1;i<array.length;i++){
                if(errors[i]<biggestError){
                    biggestError=errors[i];
                    index=i;
                }
            }
            array[index]--;
        }
        staticisFinderPattern(counters){
            letfirstTwoSum=counters[0]+counters[1];
            letsum=firstTwoSum+counters[2]+counters[3];
            letratio=firstTwoSum/sum;
            if(ratio>=AbstractRSSReader.MIN_FINDER_PATTERN_RATIO&&ratio<=AbstractRSSReader.MAX_FINDER_PATTERN_RATIO){
                //passesratiotestinspec,butseeifthecountsareunreasonable
                letminCounter=Number.MAX_SAFE_INTEGER;
                letmaxCounter=Number.MIN_SAFE_INTEGER;
                for(letcounterofcounters){
                    if(counter>maxCounter){
                        maxCounter=counter;
                    }
                    if(counter<minCounter){
                        minCounter=counter;
                    }
                }
                returnmaxCounter<10*minCounter;
            }
            returnfalse;
        }
    }
    AbstractRSSReader.MAX_AVG_VARIANCE=0.2;
    AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE=0.45;
    AbstractRSSReader.MIN_FINDER_PATTERN_RATIO=9.5/12.0;
    AbstractRSSReader.MAX_FINDER_PATTERN_RATIO=12.5/14.0;

    classDataCharacter{
        constructor(value,checksumPortion){
            this.value=value;
            this.checksumPortion=checksumPortion;
        }
        getValue(){
            returnthis.value;
        }
        getChecksumPortion(){
            returnthis.checksumPortion;
        }
        toString(){
            returnthis.value+'('+this.checksumPortion+')';
        }
        equals(o){
            if(!(oinstanceofDataCharacter)){
                returnfalse;
            }
            constthat=o;
            returnthis.value===that.value&&this.checksumPortion===that.checksumPortion;
        }
        hashCode(){
            returnthis.value^this.checksumPortion;
        }
    }

    classFinderPattern{
        constructor(value,startEnd,start,end,rowNumber){
            this.value=value;
            this.startEnd=startEnd;
            this.value=value;
            this.startEnd=startEnd;
            this.resultPoints=newArray();
            this.resultPoints.push(newResultPoint(start,rowNumber));
            this.resultPoints.push(newResultPoint(end,rowNumber));
        }
        getValue(){
            returnthis.value;
        }
        getStartEnd(){
            returnthis.startEnd;
        }
        getResultPoints(){
            returnthis.resultPoints;
        }
        equals(o){
            if(!(oinstanceofFinderPattern)){
                returnfalse;
            }
            constthat=o;
            returnthis.value===that.value;
        }
        hashCode(){
            returnthis.value;
        }
    }

    /**
     *RSSutilfunctions.
     */
    classRSSUtils{
        constructor(){}
        staticgetRSSvalue(widths,maxWidth,noNarrow){
            letn=0;
            for(letwidthofwidths){
                n+=width;
            }
            letval=0;
            letnarrowMask=0;
            letelements=widths.length;
            for(letbar=0;bar<elements-1;bar++){
                letelmWidth;
                for(elmWidth=1,narrowMask|=1<<bar;elmWidth<widths[bar];elmWidth++,narrowMask&=~(1<<bar)){
                    letsubVal=RSSUtils.combins(n-elmWidth-1,elements-bar-2);
                    if(noNarrow&&(narrowMask===0)&&(n-elmWidth-(elements-bar-1)>=elements-bar-1)){
                        subVal-=RSSUtils.combins(n-elmWidth-(elements-bar),elements-bar-2);
                    }
                    if(elements-bar-1>1){
                        letlessVal=0;
                        for(letmxwElement=n-elmWidth-(elements-bar-2);mxwElement>maxWidth;mxwElement--){
                            lessVal+=RSSUtils.combins(n-elmWidth-mxwElement-1,elements-bar-3);
                        }
                        subVal-=lessVal*(elements-1-bar);
                    }
                    elseif(n-elmWidth>maxWidth){
                        subVal--;
                    }
                    val+=subVal;
                }
                n-=elmWidth;
            }
            returnval;
        }
        staticcombins(n,r){
            letmaxDenom;
            letminDenom;
            if(n-r>r){
                minDenom=r;
                maxDenom=n-r;
            }
            else{
                minDenom=n-r;
                maxDenom=r;
            }
            letval=1;
            letj=1;
            for(leti=n;i>maxDenom;i--){
                val*=i;
                if(j<=minDenom){
                    val/=j;
                    j++;
                }
            }
            while((j<=minDenom)){
                val/=j;
                j++;
            }
            returnval;
        }
    }

    classBitArrayBuilder{
        staticbuildBitArray(pairs){
            letcharNumber=(pairs.length*2)-1;
            if(pairs[pairs.length-1].getRightChar()==null){
                charNumber-=1;
            }
            letsize=12*charNumber;
            letbinary=newBitArray(size);
            letaccPos=0;
            letfirstPair=pairs[0];
            letfirstValue=firstPair.getRightChar().getValue();
            for(leti=11;i>=0;--i){
                if((firstValue&(1<<i))!=0){
                    binary.set(accPos);
                }
                accPos++;
            }
            for(leti=1;i<pairs.length;++i){
                letcurrentPair=pairs[i];
                letleftValue=currentPair.getLeftChar().getValue();
                for(letj=11;j>=0;--j){
                    if((leftValue&(1<<j))!=0){
                        binary.set(accPos);
                    }
                    accPos++;
                }
                if(currentPair.getRightChar()!=null){
                    letrightValue=currentPair.getRightChar().getValue();
                    for(letj=11;j>=0;--j){
                        if((rightValue&(1<<j))!=0){
                            binary.set(accPos);
                        }
                        accPos++;
                    }
                }
            }
            returnbinary;
        }
    }

    classBlockParsedResult{
        constructor(finished,decodedInformation){
            if(decodedInformation){
                this.decodedInformation=null;
            }
            else{
                this.finished=finished;
                this.decodedInformation=decodedInformation;
            }
        }
        getDecodedInformation(){
            returnthis.decodedInformation;
        }
        isFinished(){
            returnthis.finished;
        }
    }

    classDecodedObject{
        constructor(newPosition){
            this.newPosition=newPosition;
        }
        getNewPosition(){
            returnthis.newPosition;
        }
    }

    classDecodedCharextendsDecodedObject{
        constructor(newPosition,value){
            super(newPosition);
            this.value=value;
        }
        getValue(){
            returnthis.value;
        }
        isFNC1(){
            returnthis.value===DecodedChar.FNC1;
        }
    }
    DecodedChar.FNC1='$';

    classDecodedInformationextendsDecodedObject{
        constructor(newPosition,newString,remainingValue){
            super(newPosition);
            if(remainingValue){
                this.remaining=true;
                this.remainingValue=this.remainingValue;
            }
            else{
                this.remaining=false;
                this.remainingValue=0;
            }
            this.newString=newString;
        }
        getNewString(){
            returnthis.newString;
        }
        isRemaining(){
            returnthis.remaining;
        }
        getRemainingValue(){
            returnthis.remainingValue;
        }
    }

    classDecodedNumericextendsDecodedObject{
        constructor(newPosition,firstDigit,secondDigit){
            super(newPosition);
            if(firstDigit<0||firstDigit>10||secondDigit<0||secondDigit>10){
                thrownewFormatException();
            }
            this.firstDigit=firstDigit;
            this.secondDigit=secondDigit;
        }
        getFirstDigit(){
            returnthis.firstDigit;
        }
        getSecondDigit(){
            returnthis.secondDigit;
        }
        getValue(){
            returnthis.firstDigit*10+this.secondDigit;
        }
        isFirstDigitFNC1(){
            returnthis.firstDigit===DecodedNumeric.FNC1;
        }
        isSecondDigitFNC1(){
            returnthis.secondDigit===DecodedNumeric.FNC1;
        }
        isAnyFNC1(){
            returnthis.firstDigit===DecodedNumeric.FNC1||this.secondDigit===DecodedNumeric.FNC1;
        }
    }
    DecodedNumeric.FNC1=10;

    classFieldParser{
        constructor(){
        }
        staticparseFieldsInGeneralPurpose(rawInformation){
            if(!rawInformation){
                returnnull;
            }
            //Processing2-digitAIs
            if(rawInformation.length<2){
                thrownewNotFoundException();
            }
            letfirstTwoDigits=rawInformation.substring(0,2);
            for(letdataLengthofFieldParser.TWO_DIGIT_DATA_LENGTH){
                if(dataLength[0]===firstTwoDigits){
                    if(dataLength[1]===FieldParser.VARIABLE_LENGTH){
                        returnFieldParser.processVariableAI(2,dataLength[2],rawInformation);
                    }
                    returnFieldParser.processFixedAI(2,dataLength[1],rawInformation);
                }
            }
            if(rawInformation.length<3){
                thrownewNotFoundException();
            }
            letfirstThreeDigits=rawInformation.substring(0,3);
            for(letdataLengthofFieldParser.THREE_DIGIT_DATA_LENGTH){
                if(dataLength[0]===firstThreeDigits){
                    if(dataLength[1]===FieldParser.VARIABLE_LENGTH){
                        returnFieldParser.processVariableAI(3,dataLength[2],rawInformation);
                    }
                    returnFieldParser.processFixedAI(3,dataLength[1],rawInformation);
                }
            }
            for(letdataLengthofFieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH){
                if(dataLength[0]===firstThreeDigits){
                    if(dataLength[1]===FieldParser.VARIABLE_LENGTH){
                        returnFieldParser.processVariableAI(4,dataLength[2],rawInformation);
                    }
                    returnFieldParser.processFixedAI(4,dataLength[1],rawInformation);
                }
            }
            if(rawInformation.length<4){
                thrownewNotFoundException();
            }
            letfirstFourDigits=rawInformation.substring(0,4);
            for(letdataLengthofFieldParser.FOUR_DIGIT_DATA_LENGTH){
                if(dataLength[0]===firstFourDigits){
                    if(dataLength[1]===FieldParser.VARIABLE_LENGTH){
                        returnFieldParser.processVariableAI(4,dataLength[2],rawInformation);
                    }
                    returnFieldParser.processFixedAI(4,dataLength[1],rawInformation);
                }
            }
            thrownewNotFoundException();
        }
        staticprocessFixedAI(aiSize,fieldSize,rawInformation){
            if(rawInformation.length<aiSize){
                thrownewNotFoundException();
            }
            letai=rawInformation.substring(0,aiSize);
            if(rawInformation.length<aiSize+fieldSize){
                thrownewNotFoundException();
            }
            letfield=rawInformation.substring(aiSize,aiSize+fieldSize);
            letremaining=rawInformation.substring(aiSize+fieldSize);
            letresult='('+ai+')'+field;
            letparsedAI=FieldParser.parseFieldsInGeneralPurpose(remaining);
            returnparsedAI==null?result:result+parsedAI;
        }
        staticprocessVariableAI(aiSize,variableFieldSize,rawInformation){
            letai=rawInformation.substring(0,aiSize);
            letmaxSize;
            if(rawInformation.length<aiSize+variableFieldSize){
                maxSize=rawInformation.length;
            }
            else{
                maxSize=aiSize+variableFieldSize;
            }
            letfield=rawInformation.substring(aiSize,maxSize);
            letremaining=rawInformation.substring(maxSize);
            letresult='('+ai+')'+field;
            letparsedAI=FieldParser.parseFieldsInGeneralPurpose(remaining);
            returnparsedAI==null?result:result+parsedAI;
        }
    }
    FieldParser.VARIABLE_LENGTH=[];
    FieldParser.TWO_DIGIT_DATA_LENGTH=[
        ['00',18],
        ['01',14],
        ['02',14],
        ['10',FieldParser.VARIABLE_LENGTH,20],
        ['11',6],
        ['12',6],
        ['13',6],
        ['15',6],
        ['17',6],
        ['20',2],
        ['21',FieldParser.VARIABLE_LENGTH,20],
        ['22',FieldParser.VARIABLE_LENGTH,29],
        ['30',FieldParser.VARIABLE_LENGTH,8],
        ['37',FieldParser.VARIABLE_LENGTH,8],
        //internalcompanycodes
        ['90',FieldParser.VARIABLE_LENGTH,30],
        ['91',FieldParser.VARIABLE_LENGTH,30],
        ['92',FieldParser.VARIABLE_LENGTH,30],
        ['93',FieldParser.VARIABLE_LENGTH,30],
        ['94',FieldParser.VARIABLE_LENGTH,30],
        ['95',FieldParser.VARIABLE_LENGTH,30],
        ['96',FieldParser.VARIABLE_LENGTH,30],
        ['97',FieldParser.VARIABLE_LENGTH,3],
        ['98',FieldParser.VARIABLE_LENGTH,30],
        ['99',FieldParser.VARIABLE_LENGTH,30],
    ];
    FieldParser.THREE_DIGIT_DATA_LENGTH=[
        //Sameformatasabove
        ['240',FieldParser.VARIABLE_LENGTH,30],
        ['241',FieldParser.VARIABLE_LENGTH,30],
        ['242',FieldParser.VARIABLE_LENGTH,6],
        ['250',FieldParser.VARIABLE_LENGTH,30],
        ['251',FieldParser.VARIABLE_LENGTH,30],
        ['253',FieldParser.VARIABLE_LENGTH,17],
        ['254',FieldParser.VARIABLE_LENGTH,20],
        ['400',FieldParser.VARIABLE_LENGTH,30],
        ['401',FieldParser.VARIABLE_LENGTH,30],
        ['402',17],
        ['403',FieldParser.VARIABLE_LENGTH,30],
        ['410',13],
        ['411',13],
        ['412',13],
        ['413',13],
        ['414',13],
        ['420',FieldParser.VARIABLE_LENGTH,20],
        ['421',FieldParser.VARIABLE_LENGTH,15],
        ['422',3],
        ['423',FieldParser.VARIABLE_LENGTH,15],
        ['424',3],
        ['425',3],
        ['426',3],
    ];
    FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH=[
        //Sameformatasabove
        ['310',6],
        ['311',6],
        ['312',6],
        ['313',6],
        ['314',6],
        ['315',6],
        ['316',6],
        ['320',6],
        ['321',6],
        ['322',6],
        ['323',6],
        ['324',6],
        ['325',6],
        ['326',6],
        ['327',6],
        ['328',6],
        ['329',6],
        ['330',6],
        ['331',6],
        ['332',6],
        ['333',6],
        ['334',6],
        ['335',6],
        ['336',6],
        ['340',6],
        ['341',6],
        ['342',6],
        ['343',6],
        ['344',6],
        ['345',6],
        ['346',6],
        ['347',6],
        ['348',6],
        ['349',6],
        ['350',6],
        ['351',6],
        ['352',6],
        ['353',6],
        ['354',6],
        ['355',6],
        ['356',6],
        ['357',6],
        ['360',6],
        ['361',6],
        ['362',6],
        ['363',6],
        ['364',6],
        ['365',6],
        ['366',6],
        ['367',6],
        ['368',6],
        ['369',6],
        ['390',FieldParser.VARIABLE_LENGTH,15],
        ['391',FieldParser.VARIABLE_LENGTH,18],
        ['392',FieldParser.VARIABLE_LENGTH,15],
        ['393',FieldParser.VARIABLE_LENGTH,18],
        ['703',FieldParser.VARIABLE_LENGTH,30],
    ];
    FieldParser.FOUR_DIGIT_DATA_LENGTH=[
        //Sameformatasabove
        ['7001',13],
        ['7002',FieldParser.VARIABLE_LENGTH,30],
        ['7003',10],
        ['8001',14],
        ['8002',FieldParser.VARIABLE_LENGTH,20],
        ['8003',FieldParser.VARIABLE_LENGTH,30],
        ['8004',FieldParser.VARIABLE_LENGTH,30],
        ['8005',6],
        ['8006',18],
        ['8007',FieldParser.VARIABLE_LENGTH,30],
        ['8008',FieldParser.VARIABLE_LENGTH,12],
        ['8018',18],
        ['8020',FieldParser.VARIABLE_LENGTH,25],
        ['8100',6],
        ['8101',10],
        ['8102',2],
        ['8110',FieldParser.VARIABLE_LENGTH,70],
        ['8200',FieldParser.VARIABLE_LENGTH,70],
    ];

    classGeneralAppIdDecoder{
        constructor(information){
            this.buffer=newStringBuilder();
            this.information=information;
        }
        decodeAllCodes(buff,initialPosition){
            letcurrentPosition=initialPosition;
            letremaining=null;
            do{
                letinfo=this.decodeGeneralPurposeField(currentPosition,remaining);
                letparsedFields=FieldParser.parseFieldsInGeneralPurpose(info.getNewString());
                if(parsedFields!=null){
                    buff.append(parsedFields);
                }
                if(info.isRemaining()){
                    remaining=''+info.getRemainingValue();
                }
                else{
                    remaining=null;
                }
                if(currentPosition===info.getNewPosition()){//Nostepforward!
                    break;
                }
                currentPosition=info.getNewPosition();
            }while(true);
            returnbuff.toString();
        }
        isStillNumeric(pos){
            //It'snumericifitstillhas7positions
            //andoneofthefirst4bitsis"1".
            if(pos+7>this.information.getSize()){
                returnpos+4<=this.information.getSize();
            }
            for(leti=pos;i<pos+3;++i){
                if(this.information.get(i)){
                    returntrue;
                }
            }
            returnthis.information.get(pos+3);
        }
        decodeNumeric(pos){
            if(pos+7>this.information.getSize()){
                letnumeric=this.extractNumericValueFromBitArray(pos,4);
                if(numeric===0){
                    returnnewDecodedNumeric(this.information.getSize(),DecodedNumeric.FNC1,DecodedNumeric.FNC1);
                }
                returnnewDecodedNumeric(this.information.getSize(),numeric-1,DecodedNumeric.FNC1);
            }
            letnumeric=this.extractNumericValueFromBitArray(pos,7);
            letdigit1=(numeric-8)/11;
            letdigit2=(numeric-8)%11;
            returnnewDecodedNumeric(pos+7,digit1,digit2);
        }
        extractNumericValueFromBitArray(pos,bits){
            returnGeneralAppIdDecoder.extractNumericValueFromBitArray(this.information,pos,bits);
        }
        staticextractNumericValueFromBitArray(information,pos,bits){
            letvalue=0;
            for(leti=0;i<bits;++i){
                if(information.get(pos+i)){
                    value|=1<<(bits-i-1);
                }
            }
            returnvalue;
        }
        decodeGeneralPurposeField(pos,remaining){
            //this.buffer.setLength(0);
            this.buffer.setLengthToZero();
            if(remaining!=null){
                this.buffer.append(remaining);
            }
            this.current.setPosition(pos);
            letlastDecoded=this.parseBlocks();
            if(lastDecoded!=null&&lastDecoded.isRemaining()){
                returnnewDecodedInformation(this.current.getPosition(),this.buffer.toString(),lastDecoded.getRemainingValue());
            }
            returnnewDecodedInformation(this.current.getPosition(),this.buffer.toString());
        }
        parseBlocks(){
            letisFinished;
            letresult;
            do{
                letinitialPosition=this.current.getPosition();
                if(this.current.isAlpha()){
                    result=this.parseAlphaBlock();
                    isFinished=result.isFinished();
                }
                elseif(this.current.isIsoIec646()){
                    result=this.parseIsoIec646Block();
                    isFinished=result.isFinished();
                }
                else{//itmustbenumeric
                    result=this.parseNumericBlock();
                    isFinished=result.isFinished();
                }
                letpositionChanged=initialPosition!==this.current.getPosition();
                if(!positionChanged&&!isFinished){
                    break;
                }
            }while(!isFinished);
            returnresult.getDecodedInformation();
        }
        parseNumericBlock(){
            while(this.isStillNumeric(this.current.getPosition())){
                letnumeric=this.decodeNumeric(this.current.getPosition());
                this.current.setPosition(numeric.getNewPosition());
                if(numeric.isFirstDigitFNC1()){
                    letinformation;
                    if(numeric.isSecondDigitFNC1()){
                        information=newDecodedInformation(this.current.getPosition(),this.buffer.toString());
                    }
                    else{
                        information=newDecodedInformation(this.current.getPosition(),this.buffer.toString(),numeric.getSecondDigit());
                    }
                    returnnewBlockParsedResult(true,information);
                }
                this.buffer.append(numeric.getFirstDigit());
                if(numeric.isSecondDigitFNC1()){
                    letinformation=newDecodedInformation(this.current.getPosition(),this.buffer.toString());
                    returnnewBlockParsedResult(true,information);
                }
                this.buffer.append(numeric.getSecondDigit());
            }
            if(this.isNumericToAlphaNumericLatch(this.current.getPosition())){
                this.current.setAlpha();
                this.current.incrementPosition(4);
            }
            returnnewBlockParsedResult(false);
        }
        parseIsoIec646Block(){
            while(this.isStillIsoIec646(this.current.getPosition())){
                letiso=this.decodeIsoIec646(this.current.getPosition());
                this.current.setPosition(iso.getNewPosition());
                if(iso.isFNC1()){
                    letinformation=newDecodedInformation(this.current.getPosition(),this.buffer.toString());
                    returnnewBlockParsedResult(true,information);
                }
                this.buffer.append(iso.getValue());
            }
            if(this.isAlphaOr646ToNumericLatch(this.current.getPosition())){
                this.current.incrementPosition(3);
                this.current.setNumeric();
            }
            elseif(this.isAlphaTo646ToAlphaLatch(this.current.getPosition())){
                if(this.current.getPosition()+5<this.information.getSize()){
                    this.current.incrementPosition(5);
                }
                else{
                    this.current.setPosition(this.information.getSize());
                }
                this.current.setAlpha();
            }
            returnnewBlockParsedResult(false);
        }
        parseAlphaBlock(){
            while(this.isStillAlpha(this.current.getPosition())){
                letalpha=this.decodeAlphanumeric(this.current.getPosition());
                this.current.setPosition(alpha.getNewPosition());
                if(alpha.isFNC1()){
                    letinformation=newDecodedInformation(this.current.getPosition(),this.buffer.toString());
                    returnnewBlockParsedResult(true,information);//endofthecharblock
                }
                this.buffer.append(alpha.getValue());
            }
            if(this.isAlphaOr646ToNumericLatch(this.current.getPosition())){
                this.current.incrementPosition(3);
                this.current.setNumeric();
            }
            elseif(this.isAlphaTo646ToAlphaLatch(this.current.getPosition())){
                if(this.current.getPosition()+5<this.information.getSize()){
                    this.current.incrementPosition(5);
                }
                else{
                    this.current.setPosition(this.information.getSize());
                }
                this.current.setIsoIec646();
            }
            returnnewBlockParsedResult(false);
        }
        isStillIsoIec646(pos){
            if(pos+5>this.information.getSize()){
                returnfalse;
            }
            letfiveBitValue=this.extractNumericValueFromBitArray(pos,5);
            if(fiveBitValue>=5&&fiveBitValue<16){
                returntrue;
            }
            if(pos+7>this.information.getSize()){
                returnfalse;
            }
            letsevenBitValue=this.extractNumericValueFromBitArray(pos,7);
            if(sevenBitValue>=64&&sevenBitValue<116){
                returntrue;
            }
            if(pos+8>this.information.getSize()){
                returnfalse;
            }
            leteightBitValue=this.extractNumericValueFromBitArray(pos,8);
            returneightBitValue>=232&&eightBitValue<253;
        }
        decodeIsoIec646(pos){
            letfiveBitValue=this.extractNumericValueFromBitArray(pos,5);
            if(fiveBitValue===15){
                returnnewDecodedChar(pos+5,DecodedChar.FNC1);
            }
            if(fiveBitValue>=5&&fiveBitValue<15){
                returnnewDecodedChar(pos+5,('0'+(fiveBitValue-5)));
            }
            letsevenBitValue=this.extractNumericValueFromBitArray(pos,7);
            if(sevenBitValue>=64&&sevenBitValue<90){
                returnnewDecodedChar(pos+7,(''+(sevenBitValue+1)));
            }
            if(sevenBitValue>=90&&sevenBitValue<116){
                returnnewDecodedChar(pos+7,(''+(sevenBitValue+7)));
            }
            leteightBitValue=this.extractNumericValueFromBitArray(pos,8);
            letc;
            switch(eightBitValue){
                case232:
                    c='!';
                    break;
                case233:
                    c='"';
                    break;
                case234:
                    c='%';
                    break;
                case235:
                    c='&';
                    break;
                case236:
                    c='\'';
                    break;
                case237:
                    c='(';
                    break;
                case238:
                    c=')';
                    break;
                case239:
                    c='*';
                    break;
                case240:
                    c='+';
                    break;
                case241:
                    c=',';
                    break;
                case242:
                    c='-';
                    break;
                case243:
                    c='.';
                    break;
                case244:
                    c='/';
                    break;
                case245:
                    c=':';
                    break;
                case246:
                    c=';';
                    break;
                case247:
                    c='<';
                    break;
                case248:
                    c='=';
                    break;
                case249:
                    c='>';
                    break;
                case250:
                    c='?';
                    break;
                case251:
                    c='_';
                    break;
                case252:
                    c='';
                    break;
                default:
                    thrownewFormatException();
            }
            returnnewDecodedChar(pos+8,c);
        }
        isStillAlpha(pos){
            if(pos+5>this.information.getSize()){
                returnfalse;
            }
            //Wenowcheckifit'savalid5-bitvalue(0..9andFNC1)
            letfiveBitValue=this.extractNumericValueFromBitArray(pos,5);
            if(fiveBitValue>=5&&fiveBitValue<16){
                returntrue;
            }
            if(pos+6>this.information.getSize()){
                returnfalse;
            }
            letsixBitValue=this.extractNumericValueFromBitArray(pos,6);
            returnsixBitValue>=16&&sixBitValue<63;//63notincluded
        }
        decodeAlphanumeric(pos){
            letfiveBitValue=this.extractNumericValueFromBitArray(pos,5);
            if(fiveBitValue===15){
                returnnewDecodedChar(pos+5,DecodedChar.FNC1);
            }
            if(fiveBitValue>=5&&fiveBitValue<15){
                returnnewDecodedChar(pos+5,('0'+(fiveBitValue-5)));
            }
            letsixBitValue=this.extractNumericValueFromBitArray(pos,6);
            if(sixBitValue>=32&&sixBitValue<58){
                returnnewDecodedChar(pos+6,(''+(sixBitValue+33)));
            }
            letc;
            switch(sixBitValue){
                case58:
                    c='*';
                    break;
                case59:
                    c=',';
                    break;
                case60:
                    c='-';
                    break;
                case61:
                    c='.';
                    break;
                case62:
                    c='/';
                    break;
                default:
                    thrownewIllegalStateException('Decodinginvalidalphanumericvalue:'+sixBitValue);
            }
            returnnewDecodedChar(pos+6,c);
        }
        isAlphaTo646ToAlphaLatch(pos){
            if(pos+1>this.information.getSize()){
                returnfalse;
            }
            for(leti=0;i<5&&i+pos<this.information.getSize();++i){
                if(i===2){
                    if(!this.information.get(pos+2)){
                        returnfalse;
                    }
                }
                elseif(this.information.get(pos+i)){
                    returnfalse;
                }
            }
            returntrue;
        }
        isAlphaOr646ToNumericLatch(pos){
            //Nextisalphanumericifthereare3positionsandtheyareallzeros
            if(pos+3>this.information.getSize()){
                returnfalse;
            }
            for(leti=pos;i<pos+3;++i){
                if(this.information.get(i)){
                    returnfalse;
                }
            }
            returntrue;
        }
        isNumericToAlphaNumericLatch(pos){
            //Nextisalphanumericifthereare4positionsandtheyareallzeros,or
            //ifthereisasubsetofthisjustbeforetheendofthesymbol
            if(pos+1>this.information.getSize()){
                returnfalse;
            }
            for(leti=0;i<4&&i+pos<this.information.getSize();++i){
                if(this.information.get(pos+i)){
                    returnfalse;
                }
            }
            returntrue;
        }
    }

    classAbstractExpandedDecoder{
        constructor(information){
            this.information=information;
            this.generalDecoder=newGeneralAppIdDecoder(information);
        }
        getInformation(){
            returnthis.information;
        }
        getGeneralDecoder(){
            returnthis.generalDecoder;
        }
    }

    classAI01decoderextendsAbstractExpandedDecoder{
        constructor(information){
            super(information);
        }
        encodeCompressedGtin(buf,currentPos){
            buf.append('(01)');
            letinitialPosition=buf.length();
            buf.append('9');
            this.encodeCompressedGtinWithoutAI(buf,currentPos,initialPosition);
        }
        encodeCompressedGtinWithoutAI(buf,currentPos,initialBufferPosition){
            for(leti=0;i<4;++i){
                letcurrentBlock=this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos+10*i,10);
                if(currentBlock/100===0){
                    buf.append('0');
                }
                if(currentBlock/10===0){
                    buf.append('0');
                }
                buf.append(currentBlock);
            }
            AI01decoder.appendCheckDigit(buf,initialBufferPosition);
        }
        staticappendCheckDigit(buf,currentPos){
            letcheckDigit=0;
            for(leti=0;i<13;i++){
                //letdigit=buf.charAt(i+currentPos)-'0';
                //Tobechecked
                letdigit=buf.charAt(i+currentPos).charCodeAt(0)-'0'.charCodeAt(0);
                checkDigit+=(i&0x01)===0?3*digit:digit;
            }
            checkDigit=10-(checkDigit%10);
            if(checkDigit===10){
                checkDigit=0;
            }
            buf.append(checkDigit);
        }
    }
    AI01decoder.GTIN_SIZE=40;

    classAI01AndOtherAIsextendsAI01decoder{
        //thesecondoneistheencodationmethod,andtheothertwoareforthevariablelength
        constructor(information){
            super(information);
        }
        parseInformation(){
            letbuff=newStringBuilder();
            buff.append('(01)');
            letinitialGtinPosition=buff.length();
            letfirstGtinDigit=this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE,4);
            buff.append(firstGtinDigit);
            this.encodeCompressedGtinWithoutAI(buff,AI01AndOtherAIs.HEADER_SIZE+4,initialGtinPosition);
            returnthis.getGeneralDecoder().decodeAllCodes(buff,AI01AndOtherAIs.HEADER_SIZE+44);
        }
    }
    AI01AndOtherAIs.HEADER_SIZE=1+1+2;//firstbitencodesthelinkageflag,

    classAnyAIDecoderextendsAbstractExpandedDecoder{
        constructor(information){
            super(information);
        }
        parseInformation(){
            letbuf=newStringBuilder();
            returnthis.getGeneralDecoder().decodeAllCodes(buf,AnyAIDecoder.HEADER_SIZE);
        }
    }
    AnyAIDecoder.HEADER_SIZE=2+1+2;

    classAI01weightDecoderextendsAI01decoder{
        constructor(information){
            super(information);
        }
        encodeCompressedWeight(buf,currentPos,weightSize){
            letoriginalWeightNumeric=this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos,weightSize);
            this.addWeightCode(buf,originalWeightNumeric);
            letweightNumeric=this.checkWeight(originalWeightNumeric);
            letcurrentDivisor=100000;
            for(leti=0;i<5;++i){
                if(weightNumeric/currentDivisor===0){
                    buf.append('0');
                }
                currentDivisor/=10;
            }
            buf.append(weightNumeric);
        }
    }

    classAI013x0xDecoderextendsAI01weightDecoder{
        constructor(information){
            super(information);
        }
        parseInformation(){
            if(this.getInformation().getSize()!=AI013x0xDecoder.HEADER_SIZE+AI01weightDecoder.GTIN_SIZE+AI013x0xDecoder.WEIGHT_SIZE){
                thrownewNotFoundException();
            }
            letbuf=newStringBuilder();
            this.encodeCompressedGtin(buf,AI013x0xDecoder.HEADER_SIZE);
            this.encodeCompressedWeight(buf,AI013x0xDecoder.HEADER_SIZE+AI01weightDecoder.GTIN_SIZE,AI013x0xDecoder.WEIGHT_SIZE);
            returnbuf.toString();
        }
    }
    AI013x0xDecoder.HEADER_SIZE=4+1;
    AI013x0xDecoder.WEIGHT_SIZE=15;

    classAI013103decoderextendsAI013x0xDecoder{
        constructor(information){
            super(information);
        }
        addWeightCode(buf,weight){
            buf.append('(3103)');
        }
        checkWeight(weight){
            returnweight;
        }
    }

    classAI01320xDecoderextendsAI013x0xDecoder{
        constructor(information){
            super(information);
        }
        addWeightCode(buf,weight){
            if(weight<10000){
                buf.append('(3202)');
            }
            else{
                buf.append('(3203)');
            }
        }
        checkWeight(weight){
            if(weight<10000){
                returnweight;
            }
            returnweight-10000;
        }
    }

    classAI01392xDecoderextendsAI01decoder{
        constructor(information){
            super(information);
        }
        parseInformation(){
            if(this.getInformation().getSize()<AI01392xDecoder.HEADER_SIZE+AI01decoder.GTIN_SIZE){
                thrownewNotFoundException();
            }
            letbuf=newStringBuilder();
            this.encodeCompressedGtin(buf,AI01392xDecoder.HEADER_SIZE);
            letlastAIdigit=this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE+AI01decoder.GTIN_SIZE,AI01392xDecoder.LAST_DIGIT_SIZE);
            buf.append('(392');
            buf.append(lastAIdigit);
            buf.append(')');
            letdecodedInformation=this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE+AI01decoder.GTIN_SIZE+AI01392xDecoder.LAST_DIGIT_SIZE,null);
            buf.append(decodedInformation.getNewString());
            returnbuf.toString();
        }
    }
    AI01392xDecoder.HEADER_SIZE=5+1+2;
    AI01392xDecoder.LAST_DIGIT_SIZE=2;

    classAI01393xDecoderextendsAI01decoder{
        constructor(information){
            super(information);
        }
        parseInformation(){
            if(this.getInformation().getSize()<AI01393xDecoder.HEADER_SIZE+AI01decoder.GTIN_SIZE){
                thrownewNotFoundException();
            }
            letbuf=newStringBuilder();
            this.encodeCompressedGtin(buf,AI01393xDecoder.HEADER_SIZE);
            letlastAIdigit=this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE+AI01decoder.GTIN_SIZE,AI01393xDecoder.LAST_DIGIT_SIZE);
            buf.append('(393');
            buf.append(lastAIdigit);
            buf.append(')');
            letfirstThreeDigits=this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE+AI01decoder.GTIN_SIZE+AI01393xDecoder.LAST_DIGIT_SIZE,AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);
            if(firstThreeDigits/100==0){
                buf.append('0');
            }
            if(firstThreeDigits/10==0){
                buf.append('0');
            }
            buf.append(firstThreeDigits);
            letgeneralInformation=this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE+AI01decoder.GTIN_SIZE+AI01393xDecoder.LAST_DIGIT_SIZE+AI01393xDecoder.FIRST_THREE_DIGITS_SIZE,null);
            buf.append(generalInformation.getNewString());
            returnbuf.toString();
        }
    }
    AI01393xDecoder.HEADER_SIZE=5+1+2;
    AI01393xDecoder.LAST_DIGIT_SIZE=2;
    AI01393xDecoder.FIRST_THREE_DIGITS_SIZE=10;

    classAI013x0x1xDecoderextendsAI01weightDecoder{
        constructor(information,firstAIdigits,dateCode){
            super(information);
            this.dateCode=dateCode;
            this.firstAIdigits=firstAIdigits;
        }
        parseInformation(){
            if(this.getInformation().getSize()!=AI013x0x1xDecoder.HEADER_SIZE+AI013x0x1xDecoder.GTIN_SIZE+AI013x0x1xDecoder.WEIGHT_SIZE+AI013x0x1xDecoder.DATE_SIZE){
                thrownewNotFoundException();
            }
            letbuf=newStringBuilder();
            this.encodeCompressedGtin(buf,AI013x0x1xDecoder.HEADER_SIZE);
            this.encodeCompressedWeight(buf,AI013x0x1xDecoder.HEADER_SIZE+AI013x0x1xDecoder.GTIN_SIZE,AI013x0x1xDecoder.WEIGHT_SIZE);
            this.encodeCompressedDate(buf,AI013x0x1xDecoder.HEADER_SIZE+AI013x0x1xDecoder.GTIN_SIZE+AI013x0x1xDecoder.WEIGHT_SIZE);
            returnbuf.toString();
        }
        encodeCompressedDate(buf,currentPos){
            letnumericDate=this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos,AI013x0x1xDecoder.DATE_SIZE);
            if(numericDate==38400){
                return;
            }
            buf.append('(');
            buf.append(this.dateCode);
            buf.append(')');
            letday=numericDate%32;
            numericDate/=32;
            letmonth=numericDate%12+1;
            numericDate/=12;
            letyear=numericDate;
            if(year/10==0){
                buf.append('0');
            }
            buf.append(year);
            if(month/10==0){
                buf.append('0');
            }
            buf.append(month);
            if(day/10==0){
                buf.append('0');
            }
            buf.append(day);
        }
        addWeightCode(buf,weight){
            buf.append('(');
            buf.append(this.firstAIdigits);
            buf.append(weight/100000);
            buf.append(')');
        }
        checkWeight(weight){
            returnweight%100000;
        }
    }
    AI013x0x1xDecoder.HEADER_SIZE=7+1;
    AI013x0x1xDecoder.WEIGHT_SIZE=20;
    AI013x0x1xDecoder.DATE_SIZE=16;

    functioncreateDecoder(information){
        try{
            if(information.get(1)){
                returnnewAI01AndOtherAIs(information);
            }
            if(!information.get(2)){
                returnnewAnyAIDecoder(information);
            }
            letfourBitEncodationMethod=GeneralAppIdDecoder.extractNumericValueFromBitArray(information,1,4);
            switch(fourBitEncodationMethod){
                case4:returnnewAI013103decoder(information);
                case5:returnnewAI01320xDecoder(information);
            }
            letfiveBitEncodationMethod=GeneralAppIdDecoder.extractNumericValueFromBitArray(information,1,5);
            switch(fiveBitEncodationMethod){
                case12:returnnewAI01392xDecoder(information);
                case13:returnnewAI01393xDecoder(information);
            }
            letsevenBitEncodationMethod=GeneralAppIdDecoder.extractNumericValueFromBitArray(information,1,7);
            switch(sevenBitEncodationMethod){
                case56:returnnewAI013x0x1xDecoder(information,'310','11');
                case57:returnnewAI013x0x1xDecoder(information,'320','11');
                case58:returnnewAI013x0x1xDecoder(information,'310','13');
                case59:returnnewAI013x0x1xDecoder(information,'320','13');
                case60:returnnewAI013x0x1xDecoder(information,'310','15');
                case61:returnnewAI013x0x1xDecoder(information,'320','15');
                case62:returnnewAI013x0x1xDecoder(information,'310','17');
                case63:returnnewAI013x0x1xDecoder(information,'320','17');
            }
        }
        catch(e){
            console.log(e);
            thrownewIllegalStateException('unknowndecoder:'+information);
        }
    }

    classExpandedPair{
        constructor(leftChar,rightChar,finderPatter,mayBeLast){
            this.leftchar=leftChar;
            this.rightchar=rightChar;
            this.finderpattern=finderPatter;
            this.maybeLast=mayBeLast;
        }
        mayBeLast(){
            returnthis.maybeLast;
        }
        getLeftChar(){
            returnthis.leftchar;
        }
        getRightChar(){
            returnthis.rightchar;
        }
        getFinderPattern(){
            returnthis.finderpattern;
        }
        mustBeLast(){
            returnthis.rightchar==null;
        }
        toString(){
            return'['+this.leftchar+','+this.rightchar+':'+(this.finderpattern==null?'null':this.finderpattern.getValue())+']';
        }
        staticequals(o1,o2){
            if(!(o1instanceofExpandedPair)){
                returnfalse;
            }
            returnExpandedPair.equalsOrNull(o1.leftchar,o2.leftchar)&&
                ExpandedPair.equalsOrNull(o1.rightchar,o2.rightchar)&&
                ExpandedPair.equalsOrNull(o1.finderpattern,o2.finderpattern);
        }
        staticequalsOrNull(o1,o2){
            returno1===null?o2===null:ExpandedPair.equals(o1,o2);
        }
        hashCode(){
            //returnExpandedPair.hashNotNull(leftChar)^hashNotNull(rightChar)^hashNotNull(finderPattern);
            letvalue=this.leftchar.getValue()^this.rightchar.getValue()^this.finderpattern.getValue();
            returnvalue;
        }
    }

    classExpandedRow{
        constructor(pairs,rowNumber,wasReversed){
            this.pairs=pairs;
            this.rowNumber=rowNumber;
            this.wasReversed=wasReversed;
        }
        getPairs(){
            returnthis.pairs;
        }
        getRowNumber(){
            returnthis.rowNumber;
        }
        isReversed(){
            returnthis.wasReversed;
        }
        //checkimplementation
        isEquivalent(otherPairs){
            returnthis.checkEqualitity(this,otherPairs);
        }
        //@Override
        toString(){
            return'{'+this.pairs+'}';
        }
        /**
         *Tworowsareequaliftheycontainthesamepairsinthesameorder.
         */
        //@Override
        //checkimplementation
        equals(o1,o2){
            if(!(o1instanceofExpandedRow)){
                returnfalse;
            }
            returnthis.checkEqualitity(o1,o2)&&o1.wasReversed===o2.wasReversed;
        }
        checkEqualitity(pair1,pair2){
            if(!pair1||!pair2)
                return;
            letresult;
            pair1.forEach((e1,i)=>{
                pair2.forEach(e2=>{
                    if(e1.getLeftChar().getValue()===e2.getLeftChar().getValue()&&e1.getRightChar().getValue()===e2.getRightChar().getValue()&&e1.getFinderPatter().getValue()===e2.getFinderPatter().getValue()){
                        result=true;
                    }
                });
            });
            returnresult;
        }
    }

    //importjava.util.ArrayList;
    //importjava.util.Iterator;
    //importjava.util.List;
    //importjava.util.Map;
    //importjava.util.Collections;
    /**@experimental*/
    classRSSExpandedReaderextendsAbstractRSSReader{
        constructor(){
            super(...arguments);
            this.pairs=newArray(RSSExpandedReader.MAX_PAIRS);
            this.rows=newArray();
            this.startEnd=[2];
        }
        decodeRow(rowNumber,row,hints){
            //Rowscanstartwithevenpatternincaseinprevrowstherewhereoddnumberofpatters.
            //Soletstrytwice
            //this.pairs.clear();
            this.pairs.length=0;
            this.startFromEven=false;
            try{
                returnRSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber,row));
            }
            catch(e){
                //OK
                //console.log(e);
            }
            this.pairs.length=0;
            this.startFromEven=true;
            returnRSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber,row));
        }
        reset(){
            this.pairs.length=0;
            this.rows.length=0;
        }
        //Notprivatefortesting
        decodeRow2pairs(rowNumber,row){
            letdone=false;
            while(!done){
                try{
                    this.pairs.push(this.retrieveNextPair(row,this.pairs,rowNumber));
                }
                catch(error){
                    if(errorinstanceofNotFoundException){
                        if(!this.pairs.length){
                            thrownewNotFoundException();
                        }
                        //exitthisloopwhenretrieveNextPair()failsandthrows
                        done=true;
                    }
                }
            }
            //TODO:verifysequenceoffinderpatternsasincheckPairSequence()
            if(this.checkChecksum()){
                returnthis.pairs;
            }
            lettryStackedDecode;
            if(this.rows.length){
                tryStackedDecode=true;
            }
            else{
                tryStackedDecode=false;
            }
            //lettryStackedDecode=!this.rows.isEmpty();
            this.storeRow(rowNumber,false);//TODO:dealwithreversedrows
            if(tryStackedDecode){
                //Whentheimageis180-rotated,thenrowsaresortedinwrongdirection.
                //Trytwicewithboththedirections.
                letps=this.checkRowsBoolean(false);
                if(ps!=null){
                    returnps;
                }
                ps=this.checkRowsBoolean(true);
                if(ps!=null){
                    returnps;
                }
            }
            thrownewNotFoundException();
        }
        //NeedtoVerify
        checkRowsBoolean(reverse){
            //Limitnumberofrowswearechecking
            //Weuserecursivealgorithmwithpurecomplexityanddon'twantittotakeforever
            //Stackedbarcodecanhaveupto11rows,so25seemsreasonableenough
            if(this.rows.length>25){
                this.rows.length=0;//Wewillneverhaveachancetogetresult,soclearit
                returnnull;
            }
            this.pairs.length=0;
            if(reverse){
                this.rows=this.rows.reverse();
                //Collections.reverse(this.rows);
            }
            letps=null;
            try{
                ps=this.checkRows(newArray(),0);
            }
            catch(e){
                //OK
                console.log(e);
            }
            if(reverse){
                this.rows=this.rows.reverse();
                //Collections.reverse(this.rows);
            }
            returnps;
        }
        //Trytoconstructavalidrowssequence
        //Recursionisusedtoimplementbacktracking
        checkRows(collectedRows,currentRow){
            for(leti=currentRow;i<this.rows.length;i++){
                letrow=this.rows[i];
                this.pairs.length=0;
                for(letcollectedRowofcollectedRows){
                    this.pairs.push(collectedRow.getPairs());
                }
                this.pairs.push(row.getPairs());
                if(!RSSExpandedReader.isValidSequence(this.pairs)){
                    continue;
                }
                if(this.checkChecksum()){
                    returnthis.pairs;
                }
                letrs=newArray(collectedRows);
                rs.push(row);
                try{
                    //Recursion:trytoaddmorerows
                    returnthis.checkRows(rs,i+1);
                }
                catch(e){
                    //Wefailed,trythenextcandidate
                    console.log(e);
                }
            }
            thrownewNotFoundException();
        }
        //Whetherthepairsformavalidfindpatternsequence,
        //eithercompleteoraprefix
        staticisValidSequence(pairs){
            for(letsequenceofRSSExpandedReader.FINDER_PATTERN_SEQUENCES){
                if(pairs.length>sequence.length){
                    continue;
                }
                letstop=true;
                for(letj=0;j<pairs.length;j++){
                    if(pairs[j].getFinderPattern().getValue()!=sequence[j]){
                        stop=false;
                        break;
                    }
                }
                if(stop){
                    returntrue;
                }
            }
            returnfalse;
        }
        storeRow(rowNumber,wasReversed){
            //Discardifduplicateaboveorbelow;otherwiseinsertinorderbyrownumber.
            letinsertPos=0;
            letprevIsSame=false;
            letnextIsSame=false;
            while(insertPos<this.rows.length){
                leterow=this.rows[insertPos];
                if(erow.getRowNumber()>rowNumber){
                    nextIsSame=erow.isEquivalent(this.pairs);
                    break;
                }
                prevIsSame=erow.isEquivalent(this.pairs);
                insertPos++;
            }
            if(nextIsSame||prevIsSame){
                return;
            }
            //Whentherowwaspartiallydecoded(e.g.2pairsfoundinsteadof3),
            //itwillpreventusfromdetectingthebarcode.
            //Trytomergepartialrows
            //Checkwhethertherowispartofanallreadydetectedrow
            if(RSSExpandedReader.isPartialRow(this.pairs,this.rows)){
                return;
            }
            this.rows.push(insertPos,newExpandedRow(this.pairs,rowNumber,wasReversed));
            this.removePartialRows(this.pairs,this.rows);
        }
        //Removealltherowsthatcontainsonlyspecifiedpairs
        removePartialRows(pairs,rows){
            //for(Iterator<ExpandedRow>iterator=rows.iterator();iterator.hasNext();){
            //  ExpandedRowr=iterator.next();
            //  if(r.getPairs().size()==pairs.size()){
            //    continue;
            //  }
            //  booleanallFound=true;
            //  for(ExpandedPairp:r.getPairs()){
            //    booleanfound=false;
            //    for(ExpandedPairpp:pairs){
            //      if(p.equals(pp)){
            //        found=true;
            //        break;
            //      }
            //    }
            //    if(!found){
            //      allFound=false;
            //      break;
            //    }
            //  }
            //  if(allFound){
            //    //'pairs'containsallthepairsfromtherow'r'
            //    iterator.remove();
            //  }
            //}
            for(letrowofrows){
                if(row.getPairs().length===pairs.length){
                    continue;
                }
                for(letpofrow.getPairs()){
                    for(letppofpairs){
                        if(ExpandedPair.equals(p,pp)){
                            break;
                        }
                    }
                }
            }
        }
        //Returnstruewhenoneoftherowsalreadycontainsallthepairs
        staticisPartialRow(pairs,rows){
            for(letrofrows){
                letallFound=true;
                for(letpofpairs){
                    letfound=false;
                    for(letppofr.getPairs()){
                        if(p.equals(pp)){
                            found=true;
                            break;
                        }
                    }
                    if(!found){
                        allFound=false;
                        break;
                    }
                }
                if(allFound){
                    //therow'r'containallthepairsfrom'pairs'
                    returntrue;
                }
            }
            returnfalse;
        }
        //Onlyusedforunittesting
        getRows(){
            returnthis.rows;
        }
        //Notprivateforunittesting
        staticconstructResult(pairs){
            letbinary=BitArrayBuilder.buildBitArray(pairs);
            letdecoder=createDecoder(binary);
            letresultingString=decoder.parseInformation();
            letfirstPoints=pairs[0].getFinderPattern().getResultPoints();
            letlastPoints=pairs[pairs.length-1].getFinderPattern().getResultPoints();
            letpoints=[firstPoints[0],firstPoints[1],lastPoints[0],lastPoints[1]];
            returnnewResult(resultingString,null,null,points,BarcodeFormat$1.RSS_EXPANDED,null);
        }
        checkChecksum(){
            letfirstPair=this.pairs.get(0);
            letcheckCharacter=firstPair.getLeftChar();
            letfirstCharacter=firstPair.getRightChar();
            if(firstCharacter==null){
                returnfalse;
            }
            letchecksum=firstCharacter.getChecksumPortion();
            lets=2;
            for(leti=1;i<this.pairs.size();++i){
                letcurrentPair=this.pairs.get(i);
                checksum+=currentPair.getLeftChar().getChecksumPortion();
                s++;
                letcurrentRightChar=currentPair.getRightChar();
                if(currentRightChar!=null){
                    checksum+=currentRightChar.getChecksumPortion();
                    s++;
                }
            }
            checksum%=211;
            letcheckCharacterValue=211*(s-4)+checksum;
            returncheckCharacterValue==checkCharacter.getValue();
        }
        staticgetNextSecondBar(row,initialPos){
            letcurrentPos;
            if(row.get(initialPos)){
                currentPos=row.getNextUnset(initialPos);
                currentPos=row.getNextSet(currentPos);
            }
            else{
                currentPos=row.getNextSet(initialPos);
                currentPos=row.getNextUnset(currentPos);
            }
            returncurrentPos;
        }
        //notprivatefortesting
        retrieveNextPair(row,previousPairs,rowNumber){
            letisOddPattern=previousPairs.length%2==0;
            if(this.startFromEven){
                isOddPattern=!isOddPattern;
            }
            letpattern;
            letkeepFinding=true;
            letforcedOffset=-1;
            do{
                this.findNextPair(row,previousPairs,forcedOffset);
                pattern=this.parseFoundFinderPattern(row,rowNumber,isOddPattern);
                if(pattern==null){
                    forcedOffset=RSSExpandedReader.getNextSecondBar(row,this.startEnd[0]);
                }
                else{
                    keepFinding=false;
                }
            }while(keepFinding);
            //Whenstackedsymbolissplitovermultiplerows,there'snowaytoguessifthispaircanbelastornot.
            //booleanmayBeLast=checkPairSequence(previousPairs,pattern);
            letleftChar=this.decodeDataCharacter(row,pattern,isOddPattern,true);
            if(!this.isEmptyPair(previousPairs)&&previousPairs[previousPairs.length-1].mustBeLast()){
                thrownewNotFoundException();
            }
            letrightChar;
            try{
                rightChar=this.decodeDataCharacter(row,pattern,isOddPattern,false);
            }
            catch(e){
                rightChar=null;
                console.log(e);
            }
            returnnewExpandedPair(leftChar,rightChar,pattern,true);
        }
        isEmptyPair(pairs){
            if(pairs.length===0){
                returntrue;
            }
            returnfalse;
        }
        findNextPair(row,previousPairs,forcedOffset){
            letcounters=this.getDecodeFinderCounters();
            counters[0]=0;
            counters[1]=0;
            counters[2]=0;
            counters[3]=0;
            letwidth=row.getSize();
            letrowOffset;
            if(forcedOffset>=0){
                rowOffset=forcedOffset;
            }
            elseif(this.isEmptyPair(previousPairs)){
                rowOffset=0;
            }
            else{
                letlastPair=previousPairs[previousPairs.length-1];
                rowOffset=lastPair.getFinderPattern().getStartEnd()[1];
            }
            letsearchingEvenPair=previousPairs.length%2!=0;
            if(this.startFromEven){
                searchingEvenPair=!searchingEvenPair;
            }
            letisWhite=false;
            while(rowOffset<width){
                isWhite=!row.get(rowOffset);
                if(!isWhite){
                    break;
                }
                rowOffset++;
            }
            letcounterPosition=0;
            letpatternStart=rowOffset;
            for(letx=rowOffset;x<width;x++){
                if(row.get(x)!=isWhite){
                    counters[counterPosition]++;
                }
                else{
                    if(counterPosition==3){
                        if(searchingEvenPair){
                            RSSExpandedReader.reverseCounters(counters);
                        }
                        if(RSSExpandedReader.isFinderPattern(counters)){
                            this.startEnd[0]=patternStart;
                            this.startEnd[1]=x;
                            return;
                        }
                        if(searchingEvenPair){
                            RSSExpandedReader.reverseCounters(counters);
                        }
                        patternStart+=counters[0]+counters[1];
                        counters[0]=counters[2];
                        counters[1]=counters[3];
                        counters[2]=0;
                        counters[3]=0;
                        counterPosition--;
                    }
                    else{
                        counterPosition++;
                    }
                    counters[counterPosition]=1;
                    isWhite=!isWhite;
                }
            }
            thrownewNotFoundException();
        }
        staticreverseCounters(counters){
            letlength=counters.length;
            for(leti=0;i<length/2;++i){
                lettmp=counters[i];
                counters[i]=counters[length-i-1];
                counters[length-i-1]=tmp;
            }
        }
        parseFoundFinderPattern(row,rowNumber,oddPattern){
            //Actuallywefoundelements2-5.
            letfirstCounter;
            letstart;
            letend;
            if(oddPattern){
                //Ifpatternnumberisodd,weneedtolocateelement1*before*thecurrentblock.
                letfirstElementStart=this.startEnd[0]-1;
                //Locateelement1
                while(firstElementStart>=0&&!row.get(firstElementStart)){
                    firstElementStart--;
                }
                firstElementStart++;
                firstCounter=this.startEnd[0]-firstElementStart;
                start=firstElementStart;
                end=this.startEnd[1];
            }
            else{
                //Ifpatternnumberiseven,thepatternisreversed,soweneedtolocateelement1*after*thecurrentblock.
                start=this.startEnd[0];
                end=row.getNextUnset(this.startEnd[1]+1);
                firstCounter=end-this.startEnd[1];
            }
            //Make'counters'hold1-4
            letcounters=this.getDecodeFinderCounters();
            System.arraycopy(counters,0,counters,1,counters.length-1);
            counters[0]=firstCounter;
            letvalue;
            try{
                value=this.parseFinderValue(counters,RSSExpandedReader.FINDER_PATTERNS);
            }
            catch(e){
                returnnull;
            }
            //returnnewFinderPattern(value,newint[]{start,end},start,end,rowNumber});
            returnnewFinderPattern(value,[start,end],start,end,rowNumber);
        }
        decodeDataCharacter(row,pattern,isOddPattern,leftChar){
            letcounters=this.getDataCharacterCounters();
            for(letx=0;x<counters.length;x++){
                counters[x]=0;
            }
            if(leftChar){
                RSSExpandedReader.recordPatternInReverse(row,pattern.getStartEnd()[0],counters);
            }
            else{
                RSSExpandedReader.recordPattern(row,pattern.getStartEnd()[1],counters);
                //reverseit
                for(leti=0,j=counters.length-1;i<j;i++,j--){
                    lettemp=counters[i];
                    counters[i]=counters[j];
                    counters[j]=temp;
                }
            }//counters[]hasthepixelsofthemodule
            letnumModules=17;//leftandrightdatacharactershaveallthesamelength
            letelementWidth=MathUtils.sum(newInt32Array(counters))/numModules;
            //Sanitycheck:elementwidthforpatternandthecharactershouldmatch
            letexpectedElementWidth=(pattern.getStartEnd()[1]-pattern.getStartEnd()[0])/15.0;
            if(Math.abs(elementWidth-expectedElementWidth)/expectedElementWidth>0.3){
                thrownewNotFoundException();
            }
            letoddCounts=this.getOddCounts();
            letevenCounts=this.getEvenCounts();
            letoddRoundingErrors=this.getOddRoundingErrors();
            letevenRoundingErrors=this.getEvenRoundingErrors();
            for(leti=0;i<counters.length;i++){
                letvalue=1.0*counters[i]/elementWidth;
                letcount=value+0.5;//Round
                if(count<1){
                    if(value<0.3){
                        thrownewNotFoundException();
                    }
                    count=1;
                }
                elseif(count>8){
                    if(value>8.7){
                        thrownewNotFoundException();
                    }
                    count=8;
                }
                letoffset=i/2;
                if((i&0x01)==0){
                    oddCounts[offset]=count;
                    oddRoundingErrors[offset]=value-count;
                }
                else{
                    evenCounts[offset]=count;
                    evenRoundingErrors[offset]=value-count;
                }
            }
            this.adjustOddEvenCounts(numModules);
            letweightRowNumber=4*pattern.getValue()+(isOddPattern?0:2)+(leftChar?0:1)-1;
            letoddSum=0;
            letoddChecksumPortion=0;
            for(leti=oddCounts.length-1;i>=0;i--){
                if(RSSExpandedReader.isNotA1left(pattern,isOddPattern,leftChar)){
                    letweight=RSSExpandedReader.WEIGHTS[weightRowNumber][2*i];
                    oddChecksumPortion+=oddCounts[i]*weight;
                }
                oddSum+=oddCounts[i];
            }
            letevenChecksumPortion=0;
            //intevenSum=0;
            for(leti=evenCounts.length-1;i>=0;i--){
                if(RSSExpandedReader.isNotA1left(pattern,isOddPattern,leftChar)){
                    letweight=RSSExpandedReader.WEIGHTS[weightRowNumber][2*i+1];
                    evenChecksumPortion+=evenCounts[i]*weight;
                }
                //evenSum+=evenCounts[i];
            }
            letchecksumPortion=oddChecksumPortion+evenChecksumPortion;
            if((oddSum&0x01)!=0||oddSum>13||oddSum<4){
                thrownewNotFoundException();
            }
            letgroup=(13-oddSum)/2;
            letoddWidest=RSSExpandedReader.SYMBOL_WIDEST[group];
            letevenWidest=9-oddWidest;
            letvOdd=RSSUtils.getRSSvalue(oddCounts,oddWidest,true);
            letvEven=RSSUtils.getRSSvalue(evenCounts,evenWidest,false);
            lettEven=RSSExpandedReader.EVEN_TOTAL_SUBSET[group];
            letgSum=RSSExpandedReader.GSUM[group];
            letvalue=vOdd*tEven+vEven+gSum;
            returnnewDataCharacter(value,checksumPortion);
        }
        staticisNotA1left(pattern,isOddPattern,leftChar){
            //A1:pattern.getValueis0(A),andit'sanoddPattern,anditisaleftchar
            return!(pattern.getValue()==0&&isOddPattern&&leftChar);
        }
        adjustOddEvenCounts(numModules){
            letoddSum=MathUtils.sum(newInt32Array(this.getOddCounts()));
            letevenSum=MathUtils.sum(newInt32Array(this.getEvenCounts()));
            letincrementOdd=false;
            letdecrementOdd=false;
            if(oddSum>13){
                decrementOdd=true;
            }
            elseif(oddSum<4){
                incrementOdd=true;
            }
            letincrementEven=false;
            letdecrementEven=false;
            if(evenSum>13){
                decrementEven=true;
            }
            elseif(evenSum<4){
                incrementEven=true;
            }
            letmismatch=oddSum+evenSum-numModules;
            letoddParityBad=(oddSum&0x01)==1;
            letevenParityBad=(evenSum&0x01)==0;
            if(mismatch==1){
                if(oddParityBad){
                    if(evenParityBad){
                        thrownewNotFoundException();
                    }
                    decrementOdd=true;
                }
                else{
                    if(!evenParityBad){
                        thrownewNotFoundException();
                    }
                    decrementEven=true;
                }
            }
            elseif(mismatch==-1){
                if(oddParityBad){
                    if(evenParityBad){
                        thrownewNotFoundException();
                    }
                    incrementOdd=true;
                }
                else{
                    if(!evenParityBad){
                        thrownewNotFoundException();
                    }
                    incrementEven=true;
                }
            }
            elseif(mismatch==0){
                if(oddParityBad){
                    if(!evenParityBad){
                        thrownewNotFoundException();
                    }
                    //Bothbad
                    if(oddSum<evenSum){
                        incrementOdd=true;
                        decrementEven=true;
                    }
                    else{
                        decrementOdd=true;
                        incrementEven=true;
                    }
                }
                else{
                    if(evenParityBad){
                        thrownewNotFoundException();
                    }
                    //Nothingtodo!
                }
            }
            else{
                thrownewNotFoundException();
            }
            if(incrementOdd){
                if(decrementOdd){
                    thrownewNotFoundException();
                }
                RSSExpandedReader.increment(this.getOddCounts(),this.getOddRoundingErrors());
            }
            if(decrementOdd){
                RSSExpandedReader.decrement(this.getOddCounts(),this.getOddRoundingErrors());
            }
            if(incrementEven){
                if(decrementEven){
                    thrownewNotFoundException();
                }
                RSSExpandedReader.increment(this.getEvenCounts(),this.getOddRoundingErrors());
            }
            if(decrementEven){
                RSSExpandedReader.decrement(this.getEvenCounts(),this.getEvenRoundingErrors());
            }
        }
    }
    RSSExpandedReader.SYMBOL_WIDEST=[7,5,4,3,1];
    RSSExpandedReader.EVEN_TOTAL_SUBSET=[4,20,52,104,204];
    RSSExpandedReader.GSUM=[0,348,1388,2948,3988];
    RSSExpandedReader.FINDER_PATTERNS=[
        Int32Array.from([1,8,4,1]),
        Int32Array.from([3,6,4,1]),
        Int32Array.from([3,4,6,1]),
        Int32Array.from([3,2,8,1]),
        Int32Array.from([2,6,5,1]),
        Int32Array.from([2,2,9,1])//F
    ];
    RSSExpandedReader.WEIGHTS=[
        [1,3,9,27,81,32,96,77],
        [20,60,180,118,143,7,21,63],
        [189,145,13,39,117,140,209,205],
        [193,157,49,147,19,57,171,91],
        [62,186,136,197,169,85,44,132],
        [185,133,188,142,4,12,36,108],
        [113,128,173,97,80,29,87,50],
        [150,28,84,41,123,158,52,156],
        [46,138,203,187,139,206,196,166],
        [76,17,51,153,37,111,122,155],
        [43,129,176,106,107,110,119,146],
        [16,48,144,10,30,90,59,177],
        [109,116,137,200,178,112,125,164],
        [70,210,208,202,184,130,179,115],
        [134,191,151,31,93,68,204,190],
        [148,22,66,198,172,94,71,2],
        [6,18,54,162,64,192,154,40],
        [120,149,25,75,14,42,126,167],
        [79,26,78,23,69,207,199,175],
        [103,98,83,38,114,131,182,124],
        [161,61,183,127,170,88,53,159],
        [55,165,73,8,24,72,5,15],
        [45,135,194,160,58,174,100,89]
    ];
    RSSExpandedReader.FINDER_PAT_A=0;
    RSSExpandedReader.FINDER_PAT_B=1;
    RSSExpandedReader.FINDER_PAT_C=2;
    RSSExpandedReader.FINDER_PAT_D=3;
    RSSExpandedReader.FINDER_PAT_E=4;
    RSSExpandedReader.FINDER_PAT_F=5;
    RSSExpandedReader.FINDER_PATTERN_SEQUENCES=[
        [RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_A],
        [RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_B],
        [RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_C,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_D],
        [RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_E,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_D,RSSExpandedReader.FINDER_PAT_C],
        [RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_E,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_D,RSSExpandedReader.FINDER_PAT_D,RSSExpandedReader.FINDER_PAT_F],
        [RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_E,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_D,RSSExpandedReader.FINDER_PAT_E,RSSExpandedReader.FINDER_PAT_F,RSSExpandedReader.FINDER_PAT_F],
        [RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_C,RSSExpandedReader.FINDER_PAT_C,RSSExpandedReader.FINDER_PAT_D,RSSExpandedReader.FINDER_PAT_D],
        [RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_C,RSSExpandedReader.FINDER_PAT_C,RSSExpandedReader.FINDER_PAT_D,RSSExpandedReader.FINDER_PAT_E,RSSExpandedReader.FINDER_PAT_E],
        [RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_C,RSSExpandedReader.FINDER_PAT_C,RSSExpandedReader.FINDER_PAT_D,RSSExpandedReader.FINDER_PAT_E,RSSExpandedReader.FINDER_PAT_F,RSSExpandedReader.FINDER_PAT_F],
        [RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_A,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_B,RSSExpandedReader.FINDER_PAT_C,RSSExpandedReader.FINDER_PAT_D,RSSExpandedReader.FINDER_PAT_D,RSSExpandedReader.FINDER_PAT_E,RSSExpandedReader.FINDER_PAT_E,RSSExpandedReader.FINDER_PAT_F,RSSExpandedReader.FINDER_PAT_F],
    ];
    RSSExpandedReader.MAX_PAIRS=11;

    classPairextendsDataCharacter{
        constructor(value,checksumPortion,finderPattern){
            super(value,checksumPortion);
            this.count=0;
            this.finderPattern=finderPattern;
        }
        getFinderPattern(){
            returnthis.finderPattern;
        }
        getCount(){
            returnthis.count;
        }
        incrementCount(){
            this.count++;
        }
    }

    classRSS14ReaderextendsAbstractRSSReader{
        constructor(){
            super(...arguments);
            this.possibleLeftPairs=[];
            this.possibleRightPairs=[];
        }
        decodeRow(rowNumber,row,hints){
            constleftPair=this.decodePair(row,false,rowNumber,hints);
            RSS14Reader.addOrTally(this.possibleLeftPairs,leftPair);
            row.reverse();
            letrightPair=this.decodePair(row,true,rowNumber,hints);
            RSS14Reader.addOrTally(this.possibleRightPairs,rightPair);
            row.reverse();
            for(letleftofthis.possibleLeftPairs){
                if(left.getCount()>1){
                    for(letrightofthis.possibleRightPairs){
                        if(right.getCount()>1&&RSS14Reader.checkChecksum(left,right)){
                            returnRSS14Reader.constructResult(left,right);
                        }
                    }
                }
            }
            thrownewNotFoundException();
        }
        staticaddOrTally(possiblePairs,pair){
            if(pair==null){
                return;
            }
            letfound=false;
            for(letotherofpossiblePairs){
                if(other.getValue()===pair.getValue()){
                    other.incrementCount();
                    found=true;
                    break;
                }
            }
            if(!found){
                possiblePairs.push(pair);
            }
        }
        reset(){
            this.possibleLeftPairs.length=0;
            this.possibleRightPairs.length=0;
        }
        staticconstructResult(leftPair,rightPair){
            letsymbolValue=4537077*leftPair.getValue()+rightPair.getValue();
            lettext=newString(symbolValue).toString();
            letbuffer=newStringBuilder();
            for(leti=13-text.length;i>0;i--){
                buffer.append('0');
            }
            buffer.append(text);
            letcheckDigit=0;
            for(leti=0;i<13;i++){
                letdigit=buffer.charAt(i).charCodeAt(0)-'0'.charCodeAt(0);
                checkDigit+=((i&0x01)===0)?3*digit:digit;
            }
            checkDigit=10-(checkDigit%10);
            if(checkDigit===10){
                checkDigit=0;
            }
            buffer.append(checkDigit.toString());
            letleftPoints=leftPair.getFinderPattern().getResultPoints();
            letrightPoints=rightPair.getFinderPattern().getResultPoints();
            returnnewResult(buffer.toString(),null,0,[leftPoints[0],leftPoints[1],rightPoints[0],rightPoints[1]],BarcodeFormat$1.RSS_14,newDate().getTime());
        }
        staticcheckChecksum(leftPair,rightPair){
            letcheckValue=(leftPair.getChecksumPortion()+16*rightPair.getChecksumPortion())%79;
            lettargetCheckValue=9*leftPair.getFinderPattern().getValue()+rightPair.getFinderPattern().getValue();
            if(targetCheckValue>72){
                targetCheckValue--;
            }
            if(targetCheckValue>8){
                targetCheckValue--;
            }
            returncheckValue===targetCheckValue;
        }
        decodePair(row,right,rowNumber,hints){
            try{
                letstartEnd=this.findFinderPattern(row,right);
                letpattern=this.parseFoundFinderPattern(row,rowNumber,right,startEnd);
                letresultPointCallback=hints==null?null:hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
                if(resultPointCallback!=null){
                    letcenter=(startEnd[0]+startEnd[1])/2.0;
                    if(right){
                        //rowisactuallyreversed
                        center=row.getSize()-1-center;
                    }
                    resultPointCallback.foundPossibleResultPoint(newResultPoint(center,rowNumber));
                }
                letoutside=this.decodeDataCharacter(row,pattern,true);
                letinside=this.decodeDataCharacter(row,pattern,false);
                returnnewPair(1597*outside.getValue()+inside.getValue(),outside.getChecksumPortion()+4*inside.getChecksumPortion(),pattern);
            }
            catch(err){
                returnnull;
            }
        }
        decodeDataCharacter(row,pattern,outsideChar){
            letcounters=this.getDataCharacterCounters();
            for(letx=0;x<counters.length;x++){
                counters[x]=0;
            }
            if(outsideChar){
                OneDReader.recordPatternInReverse(row,pattern.getStartEnd()[0],counters);
            }
            else{
                OneDReader.recordPattern(row,pattern.getStartEnd()[1]+1,counters);
                //reverseit
                for(leti=0,j=counters.length-1;i<j;i++,j--){
                    lettemp=counters[i];
                    counters[i]=counters[j];
                    counters[j]=temp;
                }
            }
            letnumModules=outsideChar?16:15;
            letelementWidth=MathUtils.sum(newInt32Array(counters))/numModules;
            letoddCounts=this.getOddCounts();
            letevenCounts=this.getEvenCounts();
            letoddRoundingErrors=this.getOddRoundingErrors();
            letevenRoundingErrors=this.getEvenRoundingErrors();
            for(leti=0;i<counters.length;i++){
                letvalue=counters[i]/elementWidth;
                letcount=Math.floor(value+0.5);
                if(count<1){
                    count=1;
                }
                elseif(count>8){
                    count=8;
                }
                letoffset=Math.floor(i/2);
                if((i&0x01)===0){
                    oddCounts[offset]=count;
                    oddRoundingErrors[offset]=value-count;
                }
                else{
                    evenCounts[offset]=count;
                    evenRoundingErrors[offset]=value-count;
                }
            }
            this.adjustOddEvenCounts(outsideChar,numModules);
            letoddSum=0;
            letoddChecksumPortion=0;
            for(leti=oddCounts.length-1;i>=0;i--){
                oddChecksumPortion*=9;
                oddChecksumPortion+=oddCounts[i];
                oddSum+=oddCounts[i];
            }
            letevenChecksumPortion=0;
            letevenSum=0;
            for(leti=evenCounts.length-1;i>=0;i--){
                evenChecksumPortion*=9;
                evenChecksumPortion+=evenCounts[i];
                evenSum+=evenCounts[i];
            }
            letchecksumPortion=oddChecksumPortion+3*evenChecksumPortion;
            if(outsideChar){
                if((oddSum&0x01)!==0||oddSum>12||oddSum<4){
                    thrownewNotFoundException();
                }
                letgroup=(12-oddSum)/2;
                letoddWidest=RSS14Reader.OUTSIDE_ODD_WIDEST[group];
                letevenWidest=9-oddWidest;
                letvOdd=RSSUtils.getRSSvalue(oddCounts,oddWidest,false);
                letvEven=RSSUtils.getRSSvalue(evenCounts,evenWidest,true);
                lettEven=RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];
                letgSum=RSS14Reader.OUTSIDE_GSUM[group];
                returnnewDataCharacter(vOdd*tEven+vEven+gSum,checksumPortion);
            }
            else{
                if((evenSum&0x01)!==0||evenSum>10||evenSum<4){
                    thrownewNotFoundException();
                }
                letgroup=(10-evenSum)/2;
                letoddWidest=RSS14Reader.INSIDE_ODD_WIDEST[group];
                letevenWidest=9-oddWidest;
                letvOdd=RSSUtils.getRSSvalue(oddCounts,oddWidest,true);
                letvEven=RSSUtils.getRSSvalue(evenCounts,evenWidest,false);
                lettOdd=RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];
                letgSum=RSS14Reader.INSIDE_GSUM[group];
                returnnewDataCharacter(vEven*tOdd+vOdd+gSum,checksumPortion);
            }
        }
        findFinderPattern(row,rightFinderPattern){
            letcounters=this.getDecodeFinderCounters();
            counters[0]=0;
            counters[1]=0;
            counters[2]=0;
            counters[3]=0;
            letwidth=row.getSize();
            letisWhite=false;
            letrowOffset=0;
            while(rowOffset<width){
                isWhite=!row.get(rowOffset);
                if(rightFinderPattern===isWhite){
                    //Willencounterwhitefirstwhensearchingforrightfinderpattern
                    break;
                }
                rowOffset++;
            }
            letcounterPosition=0;
            letpatternStart=rowOffset;
            for(letx=rowOffset;x<width;x++){
                if(row.get(x)!==isWhite){
                    counters[counterPosition]++;
                }
                else{
                    if(counterPosition===3){
                        if(AbstractRSSReader.isFinderPattern(counters)){
                            return[patternStart,x];
                        }
                        patternStart+=counters[0]+counters[1];
                        counters[0]=counters[2];
                        counters[1]=counters[3];
                        counters[2]=0;
                        counters[3]=0;
                        counterPosition--;
                    }
                    else{
                        counterPosition++;
                    }
                    counters[counterPosition]=1;
                    isWhite=!isWhite;
                }
            }
            thrownewNotFoundException();
        }
        parseFoundFinderPattern(row,rowNumber,right,startEnd){
            //Actuallywefoundelements2-5
            letfirstIsBlack=row.get(startEnd[0]);
            letfirstElementStart=startEnd[0]-1;
            //Locateelement1
            while(firstElementStart>=0&&firstIsBlack!==row.get(firstElementStart)){
                firstElementStart--;
            }
            firstElementStart++;
            constfirstCounter=startEnd[0]-firstElementStart;
            //Make'counters'hold1-4
            constcounters=this.getDecodeFinderCounters();
            constcopy=newInt32Array(counters.length);
            System.arraycopy(counters,0,copy,1,counters.length-1);
            copy[0]=firstCounter;
            constvalue=this.parseFinderValue(copy,RSS14Reader.FINDER_PATTERNS);
            letstart=firstElementStart;
            letend=startEnd[1];
            if(right){
                //rowisactuallyreversed
                start=row.getSize()-1-start;
                end=row.getSize()-1-end;
            }
            returnnewFinderPattern(value,[firstElementStart,startEnd[1]],start,end,rowNumber);
        }
        adjustOddEvenCounts(outsideChar,numModules){
            letoddSum=MathUtils.sum(newInt32Array(this.getOddCounts()));
            letevenSum=MathUtils.sum(newInt32Array(this.getEvenCounts()));
            letincrementOdd=false;
            letdecrementOdd=false;
            letincrementEven=false;
            letdecrementEven=false;
            if(outsideChar){
                if(oddSum>12){
                    decrementOdd=true;
                }
                elseif(oddSum<4){
                    incrementOdd=true;
                }
                if(evenSum>12){
                    decrementEven=true;
                }
                elseif(evenSum<4){
                    incrementEven=true;
                }
            }
            else{
                if(oddSum>11){
                    decrementOdd=true;
                }
                elseif(oddSum<5){
                    incrementOdd=true;
                }
                if(evenSum>10){
                    decrementEven=true;
                }
                elseif(evenSum<4){
                    incrementEven=true;
                }
            }
            letmismatch=oddSum+evenSum-numModules;
            letoddParityBad=(oddSum&0x01)===(outsideChar?1:0);
            letevenParityBad=(evenSum&0x01)===1;
            if(mismatch===1){
                if(oddParityBad){
                    if(evenParityBad){
                        thrownewNotFoundException();
                    }
                    decrementOdd=true;
                }
                else{
                    if(!evenParityBad){
                        thrownewNotFoundException();
                    }
                    decrementEven=true;
                }
            }
            elseif(mismatch===-1){
                if(oddParityBad){
                    if(evenParityBad){
                        thrownewNotFoundException();
                    }
                    incrementOdd=true;
                }
                else{
                    if(!evenParityBad){
                        thrownewNotFoundException();
                    }
                    incrementEven=true;
                }
            }
            elseif(mismatch===0){
                if(oddParityBad){
                    if(!evenParityBad){
                        thrownewNotFoundException();
                    }
                    //Bothbad
                    if(oddSum<evenSum){
                        incrementOdd=true;
                        decrementEven=true;
                    }
                    else{
                        decrementOdd=true;
                        incrementEven=true;
                    }
                }
                else{
                    if(evenParityBad){
                        thrownewNotFoundException();
                    }
                    //Nothingtodo!
                }
            }
            else{
                thrownewNotFoundException();
            }
            if(incrementOdd){
                if(decrementOdd){
                    thrownewNotFoundException();
                }
                AbstractRSSReader.increment(this.getOddCounts(),this.getOddRoundingErrors());
            }
            if(decrementOdd){
                AbstractRSSReader.decrement(this.getOddCounts(),this.getOddRoundingErrors());
            }
            if(incrementEven){
                if(decrementEven){
                    thrownewNotFoundException();
                }
                AbstractRSSReader.increment(this.getEvenCounts(),this.getOddRoundingErrors());
            }
            if(decrementEven){
                AbstractRSSReader.decrement(this.getEvenCounts(),this.getEvenRoundingErrors());
            }
        }
    }
    RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET=[1,10,34,70,126];
    RSS14Reader.INSIDE_ODD_TOTAL_SUBSET=[4,20,48,81];
    RSS14Reader.OUTSIDE_GSUM=[0,161,961,2015,2715];
    RSS14Reader.INSIDE_GSUM=[0,336,1036,1516];
    RSS14Reader.OUTSIDE_ODD_WIDEST=[8,6,4,3,1];
    RSS14Reader.INSIDE_ODD_WIDEST=[2,4,6,8];
    RSS14Reader.FINDER_PATTERNS=[
        Int32Array.from([3,8,2,1]),
        Int32Array.from([3,5,5,1]),
        Int32Array.from([3,3,7,1]),
        Int32Array.from([3,1,9,1]),
        Int32Array.from([2,7,4,1]),
        Int32Array.from([2,5,6,1]),
        Int32Array.from([2,3,8,1]),
        Int32Array.from([1,5,7,1]),
        Int32Array.from([1,3,9,1]),
    ];

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *@authorDanielSwitkin<dswitkin@google.com>
     *@authorSeanOwen
     */
    classMultiFormatOneDReaderextendsOneDReader{
        constructor(hints){
            super();
            this.readers=[];
            constpossibleFormats=!hints?null:hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
            constuseCode39CheckDigit=hints&&hints.get(DecodeHintType$1.ASSUME_CODE_39_CHECK_DIGIT)!==undefined;
            if(possibleFormats){
                if(possibleFormats.includes(BarcodeFormat$1.EAN_13)||
                    possibleFormats.includes(BarcodeFormat$1.UPC_A)||
                    possibleFormats.includes(BarcodeFormat$1.EAN_8)||
                    possibleFormats.includes(BarcodeFormat$1.UPC_E)){
                    this.readers.push(newMultiFormatUPCEANReader(hints));
                }
                if(possibleFormats.includes(BarcodeFormat$1.CODE_39)){
                    this.readers.push(newCode39Reader(useCode39CheckDigit));
                }
                //if(possibleFormats.includes(BarcodeFormat.CODE_93)){
                //   this.readers.push(newCode93Reader());
                //}
                if(possibleFormats.includes(BarcodeFormat$1.CODE_128)){
                    this.readers.push(newCode128Reader());
                }
                if(possibleFormats.includes(BarcodeFormat$1.ITF)){
                    this.readers.push(newITFReader());
                }
                //if(possibleFormats.includes(BarcodeFormat.CODABAR)){
                //   this.readers.push(newCodaBarReader());
                //}
                if(possibleFormats.includes(BarcodeFormat$1.RSS_14)){
                    this.readers.push(newRSS14Reader());
                }
                if(possibleFormats.includes(BarcodeFormat$1.RSS_EXPANDED)){
                    console.warn('RSSExpandedreaderISNOTreadyforproductionyet!useatyourownrisk.');
                    this.readers.push(newRSSExpandedReader());
                }
            }
            if(this.readers.length===0){
                this.readers.push(newMultiFormatUPCEANReader(hints));
                this.readers.push(newCode39Reader());
                //this.readers.push(newCodaBarReader());
                //this.readers.push(newCode93Reader());
                this.readers.push(newMultiFormatUPCEANReader(hints));
                this.readers.push(newCode128Reader());
                this.readers.push(newITFReader());
                this.readers.push(newRSS14Reader());
                //this.readers.push(newRSSExpandedReader());
            }
        }
        //@Override
        decodeRow(rowNumber,row,hints){
            for(leti=0;i<this.readers.length;i++){
                try{
                    returnthis.readers[i].decodeRow(rowNumber,row,hints);
                }
                catch(re){
                    //continue
                }
            }
            thrownewNotFoundException();
        }
        //@Override
        reset(){
            this.readers.forEach(reader=>reader.reset());
        }
    }

    /**
     *@deprecatedMovingto@zxing/browser
     *
     *Barcodereaderreadertousefrombrowser.
     */
    classBrowserBarcodeReaderextendsBrowserCodeReader{
        /**
         *CreatesaninstanceofBrowserBarcodeReader.
         *@param{number}[timeBetweenScansMillis=500]thetimedelaybetweensubsequentdecodetries
         *@param{Map<DecodeHintType,any>}hints
         */
        constructor(timeBetweenScansMillis=500,hints){
            super(newMultiFormatOneDReader(hints),timeBetweenScansMillis,hints);
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Encapsulatesasetoferror-correctionblocksinonesymbolversion.Mostversionswill
     *useblocksofdifferingsizeswithinoneversion,so,thisencapsulatestheparametersfor
     *eachsetofblocks.Italsoholdsthenumberoferror-correctioncodewordsperblocksinceit
     *willbethesameacrossallblockswithinoneversion.</p>
     */
    classECBlocks{
        constructor(ecCodewords,ecBlocks1,ecBlocks2){
            this.ecCodewords=ecCodewords;
            this.ecBlocks=[ecBlocks1];
            ecBlocks2&&this.ecBlocks.push(ecBlocks2);
        }
        getECCodewords(){
            returnthis.ecCodewords;
        }
        getECBlocks(){
            returnthis.ecBlocks;
        }
    }
    /**
     *<p>Encapsulatestheparametersforoneerror-correctionblockinonesymbolversion.
     *Thisincludesthenumberofdatacodewords,andthenumberoftimesablockwiththese
     *parametersisusedconsecutivelyintheDataMatrixcodeversion'sformat.</p>
     */
    classECB{
        constructor(count,dataCodewords){
            this.count=count;
            this.dataCodewords=dataCodewords;
        }
        getCount(){
            returnthis.count;
        }
        getDataCodewords(){
            returnthis.dataCodewords;
        }
    }
    /**
     *TheVersionobjectencapsulatesattributesaboutaparticular
     *sizeDataMatrixCode.
     *
     *@authorbbrown@google.com(BrianBrown)
     */
    classVersion{
        constructor(versionNumber,symbolSizeRows,symbolSizeColumns,dataRegionSizeRows,dataRegionSizeColumns,ecBlocks){
            this.versionNumber=versionNumber;
            this.symbolSizeRows=symbolSizeRows;
            this.symbolSizeColumns=symbolSizeColumns;
            this.dataRegionSizeRows=dataRegionSizeRows;
            this.dataRegionSizeColumns=dataRegionSizeColumns;
            this.ecBlocks=ecBlocks;
            //Calculatethetotalnumberofcodewords
            lettotal=0;
            constecCodewords=ecBlocks.getECCodewords();
            constecbArray=ecBlocks.getECBlocks();
            for(letecBlockofecbArray){
                total+=ecBlock.getCount()*(ecBlock.getDataCodewords()+ecCodewords);
            }
            this.totalCodewords=total;
        }
        getVersionNumber(){
            returnthis.versionNumber;
        }
        getSymbolSizeRows(){
            returnthis.symbolSizeRows;
        }
        getSymbolSizeColumns(){
            returnthis.symbolSizeColumns;
        }
        getDataRegionSizeRows(){
            returnthis.dataRegionSizeRows;
        }
        getDataRegionSizeColumns(){
            returnthis.dataRegionSizeColumns;
        }
        getTotalCodewords(){
            returnthis.totalCodewords;
        }
        getECBlocks(){
            returnthis.ecBlocks;
        }
        /**
         *<p>DeducesversioninformationfromDataMatrixdimensions.</p>
         *
         *@paramnumRowsNumberofrowsinmodules
         *@paramnumColumnsNumberofcolumnsinmodules
         *@returnVersionforaDataMatrixCodeofthosedimensions
         *@throwsFormatExceptionifdimensionsdocorrespondtoavalidDataMatrixsize
         */
        staticgetVersionForDimensions(numRows,numColumns){
            if((numRows&0x01)!==0||(numColumns&0x01)!==0){
                thrownewFormatException();
            }
            for(letversionofVersion.VERSIONS){
                if(version.symbolSizeRows===numRows&&version.symbolSizeColumns===numColumns){
                    returnversion;
                }
            }
            thrownewFormatException();
        }
        // @Override
        toString(){
            return''+this.versionNumber;
        }
        /**
         *SeeISO16022:20065.5.1Table7
         */
        staticbuildVersions(){
            return[
                newVersion(1,10,10,8,8,newECBlocks(5,newECB(1,3))),
                newVersion(2,12,12,10,10,newECBlocks(7,newECB(1,5))),
                newVersion(3,14,14,12,12,newECBlocks(10,newECB(1,8))),
                newVersion(4,16,16,14,14,newECBlocks(12,newECB(1,12))),
                newVersion(5,18,18,16,16,newECBlocks(14,newECB(1,18))),
                newVersion(6,20,20,18,18,newECBlocks(18,newECB(1,22))),
                newVersion(7,22,22,20,20,newECBlocks(20,newECB(1,30))),
                newVersion(8,24,24,22,22,newECBlocks(24,newECB(1,36))),
                newVersion(9,26,26,24,24,newECBlocks(28,newECB(1,44))),
                newVersion(10,32,32,14,14,newECBlocks(36,newECB(1,62))),
                newVersion(11,36,36,16,16,newECBlocks(42,newECB(1,86))),
                newVersion(12,40,40,18,18,newECBlocks(48,newECB(1,114))),
                newVersion(13,44,44,20,20,newECBlocks(56,newECB(1,144))),
                newVersion(14,48,48,22,22,newECBlocks(68,newECB(1,174))),
                newVersion(15,52,52,24,24,newECBlocks(42,newECB(2,102))),
                newVersion(16,64,64,14,14,newECBlocks(56,newECB(2,140))),
                newVersion(17,72,72,16,16,newECBlocks(36,newECB(4,92))),
                newVersion(18,80,80,18,18,newECBlocks(48,newECB(4,114))),
                newVersion(19,88,88,20,20,newECBlocks(56,newECB(4,144))),
                newVersion(20,96,96,22,22,newECBlocks(68,newECB(4,174))),
                newVersion(21,104,104,24,24,newECBlocks(56,newECB(6,136))),
                newVersion(22,120,120,18,18,newECBlocks(68,newECB(6,175))),
                newVersion(23,132,132,20,20,newECBlocks(62,newECB(8,163))),
                newVersion(24,144,144,22,22,newECBlocks(62,newECB(8,156),newECB(2,155))),
                newVersion(25,8,18,6,16,newECBlocks(7,newECB(1,5))),
                newVersion(26,8,32,6,14,newECBlocks(11,newECB(1,10))),
                newVersion(27,12,26,10,24,newECBlocks(14,newECB(1,16))),
                newVersion(28,12,36,10,16,newECBlocks(18,newECB(1,22))),
                newVersion(29,16,36,14,16,newECBlocks(24,newECB(1,32))),
                newVersion(30,16,48,14,22,newECBlocks(28,newECB(1,49)))
            ];
        }
    }
    Version.VERSIONS=Version.buildVersions();

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *@authorbbrown@google.com(BrianBrown)
     */
    classBitMatrixParser{
        /**
         *@parambitMatrix{@linkBitMatrix}toparse
         *@throwsFormatExceptionifdimensionis<8or>144ornot0mod2
         */
        constructor(bitMatrix){
            constdimension=bitMatrix.getHeight();
            if(dimension<8||dimension>144||(dimension&0x01)!==0){
                thrownewFormatException();
            }
            this.version=BitMatrixParser.readVersion(bitMatrix);
            this.mappingBitMatrix=this.extractDataRegion(bitMatrix);
            this.readMappingMatrix=newBitMatrix(this.mappingBitMatrix.getWidth(),this.mappingBitMatrix.getHeight());
        }
        getVersion(){
            returnthis.version;
        }
        /**
         *<p>Createstheversionobjectbasedonthedimensionoftheoriginalbitmatrixfrom
         *thedatamatrixcode.</p>
         *
         *<p>SeeISO16022:2006Table7-ECC200symbolattributes</p>
         *
         *@parambitMatrixOriginal{@linkBitMatrix}includingalignmentpatterns
         *@return{@linkVersion}encapsulatingtheDataMatrixCode's"version"
         *@throwsFormatExceptionifthedimensionsofthemappingmatrixarenotvalid
         *DataMatrixdimensions.
         */
        staticreadVersion(bitMatrix){
            constnumRows=bitMatrix.getHeight();
            constnumColumns=bitMatrix.getWidth();
            returnVersion.getVersionForDimensions(numRows,numColumns);
        }
        /**
         *<p>Readsthebitsinthe{@linkBitMatrix}representingthemappingmatrix(Noalignmentpatterns)
         *inthecorrectorderinordertoreconstitutethecodewordsbytescontainedwithinthe
         *DataMatrixCode.</p>
         *
         *@returnbytesencodedwithintheDataMatrixCode
         *@throwsFormatExceptioniftheexactnumberofbytesexpectedisnotread
         */
        readCodewords(){
            constresult=newInt8Array(this.version.getTotalCodewords());
            letresultOffset=0;
            letrow=4;
            letcolumn=0;
            constnumRows=this.mappingBitMatrix.getHeight();
            constnumColumns=this.mappingBitMatrix.getWidth();
            letcorner1Read=false;
            letcorner2Read=false;
            letcorner3Read=false;
            letcorner4Read=false;
            //Readallofthecodewords
            do{
                //Checkthefourcornercases
                if((row===numRows)&&(column===0)&&!corner1Read){
                    result[resultOffset++]=this.readCorner1(numRows,numColumns)&0xff;
                    row-=2;
                    column+=2;
                    corner1Read=true;
                }
                elseif((row===numRows-2)&&(column===0)&&((numColumns&0x03)!==0)&&!corner2Read){
                    result[resultOffset++]=this.readCorner2(numRows,numColumns)&0xff;
                    row-=2;
                    column+=2;
                    corner2Read=true;
                }
                elseif((row===numRows+4)&&(column===2)&&((numColumns&0x07)===0)&&!corner3Read){
                    result[resultOffset++]=this.readCorner3(numRows,numColumns)&0xff;
                    row-=2;
                    column+=2;
                    corner3Read=true;
                }
                elseif((row===numRows-2)&&(column===0)&&((numColumns&0x07)===4)&&!corner4Read){
                    result[resultOffset++]=this.readCorner4(numRows,numColumns)&0xff;
                    row-=2;
                    column+=2;
                    corner4Read=true;
                }
                else{
                    //Sweepupwarddiagonallytotheright
                    do{
                        if((row<numRows)&&(column>=0)&&!this.readMappingMatrix.get(column,row)){
                            result[resultOffset++]=this.readUtah(row,column,numRows,numColumns)&0xff;
                        }
                        row-=2;
                        column+=2;
                    }while((row>=0)&&(column<numColumns));
                    row+=1;
                    column+=3;
                    //Sweepdownwarddiagonallytotheleft
                    do{
                        if((row>=0)&&(column<numColumns)&&!this.readMappingMatrix.get(column,row)){
                            result[resultOffset++]=this.readUtah(row,column,numRows,numColumns)&0xff;
                        }
                        row+=2;
                        column-=2;
                    }while((row<numRows)&&(column>=0));
                    row+=3;
                    column+=1;
                }
            }while((row<numRows)||(column<numColumns));
            if(resultOffset!==this.version.getTotalCodewords()){
                thrownewFormatException();
            }
            returnresult;
        }
        /**
         *<p>Readsabitofthemappingmatrixaccountingforboundarywrapping.</p>
         *
         *@paramrowRowtoreadinthemappingmatrix
         *@paramcolumnColumntoreadinthemappingmatrix
         *@paramnumRowsNumberofrowsinthemappingmatrix
         *@paramnumColumnsNumberofcolumnsinthemappingmatrix
         *@returnvalueofthegivenbitinthemappingmatrix
         */
        readModule(row,column,numRows,numColumns){
            //Adjusttherowandcolumnindicesbasedonboundarywrapping
            if(row<0){
                row+=numRows;
                column+=4-((numRows+4)&0x07);
            }
            if(column<0){
                column+=numColumns;
                row+=4-((numColumns+4)&0x07);
            }
            this.readMappingMatrix.set(column,row);
            returnthis.mappingBitMatrix.get(column,row);
        }
        /**
         *<p>Readsthe8bitsofthestandardUtah-shapedpattern.</p>
         *
         *<p>SeeISO16022:2006,5.8.1Figure6</p>
         *
         *@paramrowCurrentrowinthemappingmatrix,anchoredatthe8thbit(LSB)ofthepattern
         *@paramcolumnCurrentcolumninthemappingmatrix,anchoredatthe8thbit(LSB)ofthepattern
         *@paramnumRowsNumberofrowsinthemappingmatrix
         *@paramnumColumnsNumberofcolumnsinthemappingmatrix
         *@returnbytefromtheutahshape
         */
        readUtah(row,column,numRows,numColumns){
            letcurrentByte=0;
            if(this.readModule(row-2,column-2,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(row-2,column-1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(row-1,column-2,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(row-1,column-1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(row-1,column,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(row,column-2,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(row,column-1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(row,column,numRows,numColumns)){
                currentByte|=1;
            }
            returncurrentByte;
        }
        /**
         *<p>Readsthe8bitsofthespecialcornercondition1.</p>
         *
         *<p>SeeISO16022:2006,FigureF.3</p>
         *
         *@paramnumRowsNumberofrowsinthemappingmatrix
         *@paramnumColumnsNumberofcolumnsinthemappingmatrix
         *@returnbytefromtheCornercondition1
         */
        readCorner1(numRows,numColumns){
            letcurrentByte=0;
            if(this.readModule(numRows-1,0,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(numRows-1,1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(numRows-1,2,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(0,numColumns-2,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(0,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(1,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(2,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(3,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            returncurrentByte;
        }
        /**
         *<p>Readsthe8bitsofthespecialcornercondition2.</p>
         *
         *<p>SeeISO16022:2006,FigureF.4</p>
         *
         *@paramnumRowsNumberofrowsinthemappingmatrix
         *@paramnumColumnsNumberofcolumnsinthemappingmatrix
         *@returnbytefromtheCornercondition2
         */
        readCorner2(numRows,numColumns){
            letcurrentByte=0;
            if(this.readModule(numRows-3,0,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(numRows-2,0,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(numRows-1,0,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(0,numColumns-4,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(0,numColumns-3,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(0,numColumns-2,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(0,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(1,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            returncurrentByte;
        }
        /**
         *<p>Readsthe8bitsofthespecialcornercondition3.</p>
         *
         *<p>SeeISO16022:2006,FigureF.5</p>
         *
         *@paramnumRowsNumberofrowsinthemappingmatrix
         *@paramnumColumnsNumberofcolumnsinthemappingmatrix
         *@returnbytefromtheCornercondition3
         */
        readCorner3(numRows,numColumns){
            letcurrentByte=0;
            if(this.readModule(numRows-1,0,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(numRows-1,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(0,numColumns-3,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(0,numColumns-2,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(0,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(1,numColumns-3,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(1,numColumns-2,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(1,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            returncurrentByte;
        }
        /**
         *<p>Readsthe8bitsofthespecialcornercondition4.</p>
         *
         *<p>SeeISO16022:2006,FigureF.6</p>
         *
         *@paramnumRowsNumberofrowsinthemappingmatrix
         *@paramnumColumnsNumberofcolumnsinthemappingmatrix
         *@returnbytefromtheCornercondition4
         */
        readCorner4(numRows,numColumns){
            letcurrentByte=0;
            if(this.readModule(numRows-3,0,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(numRows-2,0,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(numRows-1,0,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(0,numColumns-2,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(0,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(1,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(2,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            currentByte<<=1;
            if(this.readModule(3,numColumns-1,numRows,numColumns)){
                currentByte|=1;
            }
            returncurrentByte;
        }
        /**
         *<p>Extractsthedataregionfroma{@linkBitMatrix}thatcontains
         *alignmentpatterns.</p>
         *
         *@parambitMatrixOriginal{@linkBitMatrix}withalignmentpatterns
         *@returnBitMatrixthathasthealignmentpatternsremoved
         */
        extractDataRegion(bitMatrix){
            constsymbolSizeRows=this.version.getSymbolSizeRows();
            constsymbolSizeColumns=this.version.getSymbolSizeColumns();
            if(bitMatrix.getHeight()!==symbolSizeRows){
                thrownewIllegalArgumentException('DimensionofbitMatrixmustmatchtheversionsize');
            }
            constdataRegionSizeRows=this.version.getDataRegionSizeRows();
            constdataRegionSizeColumns=this.version.getDataRegionSizeColumns();
            constnumDataRegionsRow=symbolSizeRows/dataRegionSizeRows|0;
            constnumDataRegionsColumn=symbolSizeColumns/dataRegionSizeColumns|0;
            constsizeDataRegionRow=numDataRegionsRow*dataRegionSizeRows;
            constsizeDataRegionColumn=numDataRegionsColumn*dataRegionSizeColumns;
            constbitMatrixWithoutAlignment=newBitMatrix(sizeDataRegionColumn,sizeDataRegionRow);
            for(letdataRegionRow=0;dataRegionRow<numDataRegionsRow;++dataRegionRow){
                constdataRegionRowOffset=dataRegionRow*dataRegionSizeRows;
                for(letdataRegionColumn=0;dataRegionColumn<numDataRegionsColumn;++dataRegionColumn){
                    constdataRegionColumnOffset=dataRegionColumn*dataRegionSizeColumns;
                    for(leti=0;i<dataRegionSizeRows;++i){
                        constreadRowOffset=dataRegionRow*(dataRegionSizeRows+2)+1+i;
                        constwriteRowOffset=dataRegionRowOffset+i;
                        for(letj=0;j<dataRegionSizeColumns;++j){
                            constreadColumnOffset=dataRegionColumn*(dataRegionSizeColumns+2)+1+j;
                            if(bitMatrix.get(readColumnOffset,readRowOffset)){
                                constwriteColumnOffset=dataRegionColumnOffset+j;
                                bitMatrixWithoutAlignment.set(writeColumnOffset,writeRowOffset);
                            }
                        }
                    }
                }
            }
            returnbitMatrixWithoutAlignment;
        }
    }

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>EncapsulatesablockofdatawithinaDataMatrixCode.DataMatrixCodesmaysplittheirdatainto
     *multipleblocks,eachofwhichisaunitofdataanderror-correctioncodewords.Each
     *isrepresentedbyaninstanceofthisclass.</p>
     *
     *@authorbbrown@google.com(BrianBrown)
     */
    classDataBlock{
        constructor(numDataCodewords,codewords){
            this.numDataCodewords=numDataCodewords;
            this.codewords=codewords;
        }
        /**
         *<p>WhenDataMatrixCodesusemultipledatablocks,theyactuallyinterleavethebytesofeachofthem.
         *Thatis,thefirstbyteofdatablock1toniswritten,thenthesecondbytes,andsoon.This
         *methodwillseparatethedataintooriginalblocks.</p>
         *
         *@paramrawCodewordsbytesasreaddirectlyfromtheDataMatrixCode
         *@paramversionversionoftheDataMatrixCode
         *@returnDataBlockscontainingoriginalbytes,"de-interleaved"fromrepresentationinthe
         *        DataMatrixCode
         */
        staticgetDataBlocks(rawCodewords,version){
            //Figureoutthenumberandsizeofdatablocksusedbythisversion
            constecBlocks=version.getECBlocks();
            //Firstcountthetotalnumberofdatablocks
            lettotalBlocks=0;
            constecBlockArray=ecBlocks.getECBlocks();
            for(letecBlockofecBlockArray){
                totalBlocks+=ecBlock.getCount();
            }
            //NowestablishDataBlocksoftheappropriatesizeandnumberofdatacodewords
            constresult=newArray(totalBlocks);
            letnumResultBlocks=0;
            for(letecBlockofecBlockArray){
                for(leti=0;i<ecBlock.getCount();i++){
                    constnumDataCodewords=ecBlock.getDataCodewords();
                    constnumBlockCodewords=ecBlocks.getECCodewords()+numDataCodewords;
                    result[numResultBlocks++]=newDataBlock(numDataCodewords,newUint8Array(numBlockCodewords));
                }
            }
            //Allblockshavethesameamountofdata,exceptthatthelastn
            //(wherenmaybe0)have1lessbyte.Figureoutwherethesestart.
            //TODO(bbrown):ThereisonlyonecasewherethereisadifferenceforDataMatrixforsize144
            constlongerBlocksTotalCodewords=result[0].codewords.length;
            //intshorterBlocksTotalCodewords=longerBlocksTotalCodewords-1;
            constlongerBlocksNumDataCodewords=longerBlocksTotalCodewords-ecBlocks.getECCodewords();
            constshorterBlocksNumDataCodewords=longerBlocksNumDataCodewords-1;
            //Thelastelementsofresultmaybe1elementshorterfor144matrix
            //firstfilloutasmanyelementsasallofthemhaveminus1
            letrawCodewordsOffset=0;
            for(leti=0;i<shorterBlocksNumDataCodewords;i++){
                for(letj=0;j<numResultBlocks;j++){
                    result[j].codewords[i]=rawCodewords[rawCodewordsOffset++];
                }
            }
            //Filloutthelastdatablockinthelongerones
            constspecialVersion=version.getVersionNumber()===24;
            constnumLongerBlocks=specialVersion?8:numResultBlocks;
            for(letj=0;j<numLongerBlocks;j++){
                result[j].codewords[longerBlocksNumDataCodewords-1]=rawCodewords[rawCodewordsOffset++];
            }
            //Nowaddinerrorcorrectionblocks
            constmax=result[0].codewords.length;
            for(leti=longerBlocksNumDataCodewords;i<max;i++){
                for(letj=0;j<numResultBlocks;j++){
                    constjOffset=specialVersion?(j+8)%numResultBlocks:j;
                    constiOffset=specialVersion&&jOffset>7?i-1:i;
                    result[jOffset].codewords[iOffset]=rawCodewords[rawCodewordsOffset++];
                }
            }
            if(rawCodewordsOffset!==rawCodewords.length){
                thrownewIllegalArgumentException();
            }
            returnresult;
        }
        getNumDataCodewords(){
            returnthis.numDataCodewords;
        }
        getCodewords(){
            returnthis.codewords;
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Thisprovidesaneasyabstractiontoreadbitsatatimefromasequenceofbytes,wherethe
     *numberofbitsreadisnotoftenamultipleof8.</p>
     *
     *<p>Thisclassisthread-safebutnotreentrant--unlessthecallermodifiesthebytesarray
     *itpassedin,inwhichcaseallbetsareoff.</p>
     *
     *@authorSeanOwen
     */
    classBitSource{
        /**
         *@parambytesbytesfromwhichthiswillreadbits.Bitswillbereadfromthefirstbytefirst.
         *Bitsarereadwithinabytefrommost-significanttoleast-significantbit.
         */
        constructor(bytes){
            this.bytes=bytes;
            this.byteOffset=0;
            this.bitOffset=0;
        }
        /**
         *@returnindexofnextbitincurrentbytewhichwouldbereadbythenextcallto{@link#readBits(int)}.
         */
        getBitOffset(){
            returnthis.bitOffset;
        }
        /**
         *@returnindexofnextbyteininputbytearraywhichwouldbereadbythenextcallto{@link#readBits(int)}.
         */
        getByteOffset(){
            returnthis.byteOffset;
        }
        /**
         *@paramnumBitsnumberofbitstoread
         *@returnintrepresentingthebitsread.Thebitswillappearastheleast-significant
         *        bitsoftheint
         *@throwsIllegalArgumentExceptionifnumBitsisn'tin[1,32]ormorethanisavailable
         */
        readBits(numBits/*int*/){
            if(numBits<1||numBits>32||numBits>this.available()){
                thrownewIllegalArgumentException(''+numBits);
            }
            letresult=0;
            letbitOffset=this.bitOffset;
            letbyteOffset=this.byteOffset;
            constbytes=this.bytes;
            //First,readremainderfromcurrentbyte
            if(bitOffset>0){
                constbitsLeft=8-bitOffset;
                consttoRead=numBits<bitsLeft?numBits:bitsLeft;
                constbitsToNotRead=bitsLeft-toRead;
                constmask=(0xFF>>(8-toRead))<<bitsToNotRead;
                result=(bytes[byteOffset]&mask)>>bitsToNotRead;
                numBits-=toRead;
                bitOffset+=toRead;
                if(bitOffset===8){
                    bitOffset=0;
                    byteOffset++;
                }
            }
            //Nextreadwholebytes
            if(numBits>0){
                while(numBits>=8){
                    result=(result<<8)|(bytes[byteOffset]&0xFF);
                    byteOffset++;
                    numBits-=8;
                }
                //Finallyreadapartialbyte
                if(numBits>0){
                    constbitsToNotRead=8-numBits;
                    constmask=(0xFF>>bitsToNotRead)<<bitsToNotRead;
                    result=(result<<numBits)|((bytes[byteOffset]&mask)>>bitsToNotRead);
                    bitOffset+=numBits;
                }
            }
            this.bitOffset=bitOffset;
            this.byteOffset=byteOffset;
            returnresult;
        }
        /**
         *@returnnumberofbitsthatcanbereadsuccessfully
         */
        available(){
            return8*(this.bytes.length-this.byteOffset)-this.bitOffset;
        }
    }

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    varMode;
    (function(Mode){
        Mode[Mode["PAD_ENCODE"]=0]="PAD_ENCODE";
        Mode[Mode["ASCII_ENCODE"]=1]="ASCII_ENCODE";
        Mode[Mode["C40_ENCODE"]=2]="C40_ENCODE";
        Mode[Mode["TEXT_ENCODE"]=3]="TEXT_ENCODE";
        Mode[Mode["ANSIX12_ENCODE"]=4]="ANSIX12_ENCODE";
        Mode[Mode["EDIFACT_ENCODE"]=5]="EDIFACT_ENCODE";
        Mode[Mode["BASE256_ENCODE"]=6]="BASE256_ENCODE";
    })(Mode||(Mode={}));
    /**
     *<p>DataMatrixCodescanencodetextasbitsinoneofseveralmodes,andcanusemultiplemodes
     *inoneDataMatrixCode.Thisclassdecodesthebitsbackintotext.</p>
     *
     *<p>SeeISO16022:2006,5.2.1-5.2.9.2</p>
     *
     *@authorbbrown@google.com(BrianBrown)
     *@authorSeanOwen
     */
    classDecodedBitStreamParser{
        staticdecode(bytes){
            constbits=newBitSource(bytes);
            constresult=newStringBuilder();
            constresultTrailer=newStringBuilder();
            constbyteSegments=newArray();
            letmode=Mode.ASCII_ENCODE;
            do{
                if(mode===Mode.ASCII_ENCODE){
                    mode=this.decodeAsciiSegment(bits,result,resultTrailer);
                }
                else{
                    switch(mode){
                        caseMode.C40_ENCODE:
                            this.decodeC40Segment(bits,result);
                            break;
                        caseMode.TEXT_ENCODE:
                            this.decodeTextSegment(bits,result);
                            break;
                        caseMode.ANSIX12_ENCODE:
                            this.decodeAnsiX12Segment(bits,result);
                            break;
                        caseMode.EDIFACT_ENCODE:
                            this.decodeEdifactSegment(bits,result);
                            break;
                        caseMode.BASE256_ENCODE:
                            this.decodeBase256Segment(bits,result,byteSegments);
                            break;
                        default:
                            thrownewFormatException();
                    }
                    mode=Mode.ASCII_ENCODE;
                }
            }while(mode!==Mode.PAD_ENCODE&&bits.available()>0);
            if(resultTrailer.length()>0){
                result.append(resultTrailer.toString());
            }
            returnnewDecoderResult(bytes,result.toString(),byteSegments.length===0?null:byteSegments,null);
        }
        /**
         *SeeISO16022:2006,5.2.3andAnnexC,TableC.2
         */
        staticdecodeAsciiSegment(bits,result,resultTrailer){
            letupperShift=false;
            do{
                letoneByte=bits.readBits(8);
                if(oneByte===0){
                    thrownewFormatException();
                }
                elseif(oneByte<=128){//ASCIIdata(ASCIIvalue+1)
                    if(upperShift){
                        oneByte+=128;
                        //upperShift=false;
                    }
                    result.append(String.fromCharCode(oneByte-1));
                    returnMode.ASCII_ENCODE;
                }
                elseif(oneByte===129){//Pad
                    returnMode.PAD_ENCODE;
                }
                elseif(oneByte<=229){//2-digitdata00-99(NumericValue+130)
                    constvalue=oneByte-130;
                    if(value<10){//padwith'0'forsingledigitvalues
                        result.append('0');
                    }
                    result.append(''+value);
                }
                else{
                    switch(oneByte){
                        case230://LatchtoC40encodation
                            returnMode.C40_ENCODE;
                        case231://LatchtoBase256encodation
                            returnMode.BASE256_ENCODE;
                        case232://FNC1
                            result.append(String.fromCharCode(29));//translateasASCII29
                            break;
                        case233://StructuredAppend
                        case234://ReaderProgramming
                            //Ignorethesesymbolsfornow
                            //throwReaderException.getInstance();
                            break;
                        case235://UpperShift(shifttoExtendedASCII)
                            upperShift=true;
                            break;
                        case236://05Macro
                            result.append('[)>\u001E05\u001D');
                            resultTrailer.insert(0,'\u001E\u0004');
                            break;
                        case237://06Macro
                            result.append('[)>\u001E06\u001D');
                            resultTrailer.insert(0,'\u001E\u0004');
                            break;
                        case238://LatchtoANSIX12encodation
                            returnMode.ANSIX12_ENCODE;
                        case239://LatchtoTextencodation
                            returnMode.TEXT_ENCODE;
                        case240://LatchtoEDIFACTencodation
                            returnMode.EDIFACT_ENCODE;
                        case241://ECICharacter
                            //TODO(bbrown):IthinkweneedtosupportECI
                            //throwReaderException.getInstance();
                            //Ignorethissymbolfornow
                            break;
                        default:
                            //NottobeusedinASCIIencodation
                            //butworkaroundencodersthatendwith254,latchbacktoASCII
                            if(oneByte!==254||bits.available()!==0){
                                thrownewFormatException();
                            }
                            break;
                    }
                }
            }while(bits.available()>0);
            returnMode.ASCII_ENCODE;
        }
        /**
         *SeeISO16022:2006,5.2.5andAnnexC,TableC.1
         */
        staticdecodeC40Segment(bits,result){
            //ThreeC40valuesareencodedina16-bitvalueas
            //(1600*C1)+(40*C2)+C3+1
            //TODO(bbrown):TheUpperShiftwithC40doesn'tworkinthe4valuescenarioallthetime
            letupperShift=false;
            constcValues=[];
            letshift=0;
            do{
                //IfthereisonlyonebyteleftthenitwillbeencodedasASCII
                if(bits.available()===8){
                    return;
                }
                constfirstByte=bits.readBits(8);
                if(firstByte===254){//Unlatchcodeword
                    return;
                }
                this.parseTwoBytes(firstByte,bits.readBits(8),cValues);
                for(leti=0;i<3;i++){
                    constcValue=cValues[i];
                    switch(shift){
                        case0:
                            if(cValue<3){
                                shift=cValue+1;
                            }
                            elseif(cValue<this.C40_BASIC_SET_CHARS.length){
                                constc40char=this.C40_BASIC_SET_CHARS[cValue];
                                if(upperShift){
                                    result.append(String.fromCharCode(c40char.charCodeAt(0)+128));
                                    upperShift=false;
                                }
                                else{
                                    result.append(c40char);
                                }
                            }
                            else{
                                thrownewFormatException();
                            }
                            break;
                        case1:
                            if(upperShift){
                                result.append(String.fromCharCode(cValue+128));
                                upperShift=false;
                            }
                            else{
                                result.append(String.fromCharCode(cValue));
                            }
                            shift=0;
                            break;
                        case2:
                            if(cValue<this.C40_SHIFT2_SET_CHARS.length){
                                constc40char=this.C40_SHIFT2_SET_CHARS[cValue];
                                if(upperShift){
                                    result.append(String.fromCharCode(c40char.charCodeAt(0)+128));
                                    upperShift=false;
                                }
                                else{
                                    result.append(c40char);
                                }
                            }
                            else{
                                switch(cValue){
                                    case27://FNC1
                                        result.append(String.fromCharCode(29));//translateasASCII29
                                        break;
                                    case30://UpperShift
                                        upperShift=true;
                                        break;
                                    default:
                                        thrownewFormatException();
                                }
                            }
                            shift=0;
                            break;
                        case3:
                            if(upperShift){
                                result.append(String.fromCharCode(cValue+224));
                                upperShift=false;
                            }
                            else{
                                result.append(String.fromCharCode(cValue+96));
                            }
                            shift=0;
                            break;
                        default:
                            thrownewFormatException();
                    }
                }
            }while(bits.available()>0);
        }
        /**
         *SeeISO16022:2006,5.2.6andAnnexC,TableC.2
         */
        staticdecodeTextSegment(bits,result){
            //ThreeTextvaluesareencodedina16-bitvalueas
            //(1600*C1)+(40*C2)+C3+1
            //TODO(bbrown):TheUpperShiftwithTextdoesn'tworkinthe4valuescenarioallthetime
            letupperShift=false;
            letcValues=[];
            letshift=0;
            do{
                //IfthereisonlyonebyteleftthenitwillbeencodedasASCII
                if(bits.available()===8){
                    return;
                }
                constfirstByte=bits.readBits(8);
                if(firstByte===254){//Unlatchcodeword
                    return;
                }
                this.parseTwoBytes(firstByte,bits.readBits(8),cValues);
                for(leti=0;i<3;i++){
                    constcValue=cValues[i];
                    switch(shift){
                        case0:
                            if(cValue<3){
                                shift=cValue+1;
                            }
                            elseif(cValue<this.TEXT_BASIC_SET_CHARS.length){
                                consttextChar=this.TEXT_BASIC_SET_CHARS[cValue];
                                if(upperShift){
                                    result.append(String.fromCharCode(textChar.charCodeAt(0)+128));
                                    upperShift=false;
                                }
                                else{
                                    result.append(textChar);
                                }
                            }
                            else{
                                thrownewFormatException();
                            }
                            break;
                        case1:
                            if(upperShift){
                                result.append(String.fromCharCode(cValue+128));
                                upperShift=false;
                            }
                            else{
                                result.append(String.fromCharCode(cValue));
                            }
                            shift=0;
                            break;
                        case2:
                            //Shift2forTextisthesameencodingasC40
                            if(cValue<this.TEXT_SHIFT2_SET_CHARS.length){
                                consttextChar=this.TEXT_SHIFT2_SET_CHARS[cValue];
                                if(upperShift){
                                    result.append(String.fromCharCode(textChar.charCodeAt(0)+128));
                                    upperShift=false;
                                }
                                else{
                                    result.append(textChar);
                                }
                            }
                            else{
                                switch(cValue){
                                    case27://FNC1
                                        result.append(String.fromCharCode(29));//translateasASCII29
                                        break;
                                    case30://UpperShift
                                        upperShift=true;
                                        break;
                                    default:
                                        thrownewFormatException();
                                }
                            }
                            shift=0;
                            break;
                        case3:
                            if(cValue<this.TEXT_SHIFT3_SET_CHARS.length){
                                consttextChar=this.TEXT_SHIFT3_SET_CHARS[cValue];
                                if(upperShift){
                                    result.append(String.fromCharCode(textChar.charCodeAt(0)+128));
                                    upperShift=false;
                                }
                                else{
                                    result.append(textChar);
                                }
                                shift=0;
                            }
                            else{
                                thrownewFormatException();
                            }
                            break;
                        default:
                            thrownewFormatException();
                    }
                }
            }while(bits.available()>0);
        }
        /**
         *SeeISO16022:2006,5.2.7
         */
        staticdecodeAnsiX12Segment(bits,result){
            //ThreeANSIX12valuesareencodedina16-bitvalueas
            //(1600*C1)+(40*C2)+C3+1
            constcValues=[];
            do{
                //IfthereisonlyonebyteleftthenitwillbeencodedasASCII
                if(bits.available()===8){
                    return;
                }
                constfirstByte=bits.readBits(8);
                if(firstByte===254){//Unlatchcodeword
                    return;
                }
                this.parseTwoBytes(firstByte,bits.readBits(8),cValues);
                for(leti=0;i<3;i++){
                    constcValue=cValues[i];
                    switch(cValue){
                        case0://X12segmentterminator<CR>
                            result.append('\r');
                            break;
                        case1://X12segmentseparator*
                            result.append('*');
                            break;
                        case2://X12sub-elementseparator>
                            result.append('>');
                            break;
                        case3://space
                            result.append('');
                            break;
                        default:
                            if(cValue<14){//0-9
                                result.append(String.fromCharCode(cValue+44));
                            }
                            elseif(cValue<40){//A-Z
                                result.append(String.fromCharCode(cValue+51));
                            }
                            else{
                                thrownewFormatException();
                            }
                            break;
                    }
                }
            }while(bits.available()>0);
        }
        staticparseTwoBytes(firstByte,secondByte,result){
            letfullBitValue=(firstByte<<8)+secondByte-1;
            lettemp=Math.floor(fullBitValue/1600);
            result[0]=temp;
            fullBitValue-=temp*1600;
            temp=Math.floor(fullBitValue/40);
            result[1]=temp;
            result[2]=fullBitValue-temp*40;
        }
        /**
         *SeeISO16022:2006,5.2.8andAnnexCTableC.3
         */
        staticdecodeEdifactSegment(bits,result){
            do{
                //IfthereisonlytwoorlessbytesleftthenitwillbeencodedasASCII
                if(bits.available()<=16){
                    return;
                }
                for(leti=0;i<4;i++){
                    letedifactValue=bits.readBits(6);
                    //Checkfortheunlatchcharacter
                    if(edifactValue===0x1F){//011111
                        //Readrestofbyte,whichshouldbe0,andstop
                        constbitsLeft=8-bits.getBitOffset();
                        if(bitsLeft!==8){
                            bits.readBits(bitsLeft);
                        }
                        return;
                    }
                    if((edifactValue&0x20)===0){//no1intheleading(6th)bit
                        edifactValue|=0x40;//Addaleading01tothe6bitbinaryvalue
                    }
                    result.append(String.fromCharCode(edifactValue));
                }
            }while(bits.available()>0);
        }
        /**
         *SeeISO16022:2006,5.2.9andAnnexB,B.2
         */
        staticdecodeBase256Segment(bits,result,byteSegments){
            //FigureouthowlongtheBase256Segmentis.
            letcodewordPosition=1+bits.getByteOffset();//positionis1-indexed
            constd1=this.unrandomize255State(bits.readBits(8),codewordPosition++);
            letcount;
            if(d1===0){//Readtheremainderofthesymbol
                count=bits.available()/8|0;
            }
            elseif(d1<250){
                count=d1;
            }
            else{
                count=250*(d1-249)+this.unrandomize255State(bits.readBits(8),codewordPosition++);
            }
            //We'reseeingNegativeArraySizeExceptionerrorsfromusers.
            if(count<0){
                thrownewFormatException();
            }
            constbytes=newUint8Array(count);
            for(leti=0;i<count;i++){
                //Haveseenthisparticularerrorinthewild,suchasat
                //http://www.bcgen.com/demo/IDAutomationStreamingDataMatrix.aspx?MODE=3&D=Fred&PFMT=3&PT=F&X=0.3&O=0&LM=0.2
                if(bits.available()<8){
                    thrownewFormatException();
                }
                bytes[i]=this.unrandomize255State(bits.readBits(8),codewordPosition++);
            }
            byteSegments.push(bytes);
            try{
                result.append(StringEncoding.decode(bytes,StringUtils.ISO88591));
            }
            catch(uee){
                thrownewIllegalStateException('Platformdoesnotsupportrequiredencoding:'+uee.message);
            }
        }
        /**
         *SeeISO16022:2006,AnnexB,B.2
         */
        staticunrandomize255State(randomizedBase256Codeword,base256CodewordPosition){
            constpseudoRandomNumber=((149*base256CodewordPosition)%255)+1;
            consttempVariable=randomizedBase256Codeword-pseudoRandomNumber;
            returntempVariable>=0?tempVariable:tempVariable+256;
        }
    }
    /**
     *SeeISO16022:2006,AnnexCTableC.1
     *TheC40BasicCharacterSet(*'susedforplaceholdersfortheshiftvalues)
     */
    DecodedBitStreamParser.C40_BASIC_SET_CHARS=[
        '*','*','*','','0','1','2','3','4','5','6','7','8','9',
        'A','B','C','D','E','F','G','H','I','J','K','L','M','N',
        'O','P','Q','R','S','T','U','V','W','X','Y','Z'
    ];
    DecodedBitStreamParser.C40_SHIFT2_SET_CHARS=[
        '!','"','#','$','%','&','\'','(',')','*','+',',','-','.',
        '/',':',';','<','=','>','?','@','[','\\',']','^','_'
    ];
    /**
     *SeeISO16022:2006,AnnexCTableC.2
     *TheTextBasicCharacterSet(*'susedforplaceholdersfortheshiftvalues)
     */
    DecodedBitStreamParser.TEXT_BASIC_SET_CHARS=[
        '*','*','*','','0','1','2','3','4','5','6','7','8','9',
        'a','b','c','d','e','f','g','h','i','j','k','l','m','n',
        'o','p','q','r','s','t','u','v','w','x','y','z'
    ];
    //Shift2forTextisthesameencodingasC40
    DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS=DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;
    DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS=[
        '`','A','B','C','D','E','F','G','H','I','J','K','L','M','N',
        'O','P','Q','R','S','T','U','V','W','X','Y','Z','{','|','}','~',String.fromCharCode(127)
    ];

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>ThemainclasswhichimplementsDataMatrixCodedecoding--asopposedtolocatingandextracting
     *theDataMatrixCodefromanimage.</p>
     *
     *@authorbbrown@google.com(BrianBrown)
     */
    classDecoder$1{
        constructor(){
            this.rsDecoder=newReedSolomonDecoder(GenericGF.DATA_MATRIX_FIELD_256);
        }
        /**
         *<p>DecodesaDataMatrixCoderepresentedasa{@linkBitMatrix}.A1or"true"istaken
         *tomeanablackmodule.</p>
         *
         *@parambitsbooleansrepresentingwhite/blackDataMatrixCodemodules
         *@returntextandbytesencodedwithintheDataMatrixCode
         *@throwsFormatExceptioniftheDataMatrixCodecannotbedecoded
         *@throwsChecksumExceptioniferrorcorrectionfails
         */
        decode(bits){
            //Constructaparserandreadversion,error-correctionlevel
            constparser=newBitMatrixParser(bits);
            constversion=parser.getVersion();
            //Readcodewords
            constcodewords=parser.readCodewords();
            //Separateintodatablocks
            constdataBlocks=DataBlock.getDataBlocks(codewords,version);
            //Counttotalnumberofdatabytes
            lettotalBytes=0;
            for(letdbofdataBlocks){
                totalBytes+=db.getNumDataCodewords();
            }
            constresultBytes=newUint8Array(totalBytes);
            constdataBlocksCount=dataBlocks.length;
            //Error-correctandcopydatablockstogetherintoastreamofbytes
            for(letj=0;j<dataBlocksCount;j++){
                constdataBlock=dataBlocks[j];
                constcodewordBytes=dataBlock.getCodewords();
                constnumDataCodewords=dataBlock.getNumDataCodewords();
                this.correctErrors(codewordBytes,numDataCodewords);
                for(leti=0;i<numDataCodewords;i++){
                    //De-interlacedatablocks.
                    resultBytes[i*dataBlocksCount+j]=codewordBytes[i];
                }
            }
            //Decodethecontentsofthatstreamofbytes
            returnDecodedBitStreamParser.decode(resultBytes);
        }
        /**
         *<p>Givendataanderror-correctioncodewordsreceived,possiblycorruptedbyerrors,attemptsto
         *correcttheerrorsin-placeusingReed-Solomonerrorcorrection.</p>
         *
         *@paramcodewordBytesdataanderrorcorrectioncodewords
         *@paramnumDataCodewordsnumberofcodewordsthataredatabytes
         *@throwsChecksumExceptioniferrorcorrectionfails
         */
        correctErrors(codewordBytes,numDataCodewords){
            //constnumCodewords=codewordBytes.length;
            //Firstreadintoanarrayofints
            constcodewordsInts=newInt32Array(codewordBytes);
            //for(leti=0;i<numCodewords;i++){
            //  codewordsInts[i]=codewordBytes[i]&0xFF;
            //}
            try{
                this.rsDecoder.decode(codewordsInts,codewordBytes.length-numDataCodewords);
            }
            catch(ignored/*ReedSolomonException*/){
                thrownewChecksumException();
            }
            //Copybackintoarrayofbytes--onlyneedtoworryaboutthebytesthatweredata
            //Wedon'tcareabouterrorsintheerror-correctioncodewords
            for(leti=0;i<numDataCodewords;i++){
                codewordBytes[i]=codewordsInts[i];
            }
        }
    }

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>EncapsulateslogicthatcandetectaDataMatrixCodeinanimage,eveniftheDataMatrixCode
     *isrotatedorskewed,orpartiallyobscured.</p>
     *
     *@authorSeanOwen
     */
    classDetector$1{
        constructor(image){
            this.image=image;
            this.rectangleDetector=newWhiteRectangleDetector(this.image);
        }
        /**
         *<p>DetectsaDataMatrixCodeinanimage.</p>
         *
         *@return{@linkDetectorResult}encapsulatingresultsofdetectingaDataMatrixCode
         *@throwsNotFoundExceptionifnoDataMatrixCodecanbefound
         */
        detect(){
            constcornerPoints=this.rectangleDetector.detect();
            letpoints=this.detectSolid1(cornerPoints);
            points=this.detectSolid2(points);
            points[3]=this.correctTopRight(points);
            if(!points[3]){
                thrownewNotFoundException();
            }
            points=this.shiftToModuleCenter(points);
            consttopLeft=points[0];
            constbottomLeft=points[1];
            constbottomRight=points[2];
            consttopRight=points[3];
            letdimensionTop=this.transitionsBetween(topLeft,topRight)+1;
            letdimensionRight=this.transitionsBetween(bottomRight,topRight)+1;
            if((dimensionTop&0x01)===1){
                dimensionTop+=1;
            }
            if((dimensionRight&0x01)===1){
                dimensionRight+=1;
            }
            if(4*dimensionTop<7*dimensionRight&&4*dimensionRight<7*dimensionTop){
                //Thematrixissquare
                dimensionTop=dimensionRight=Math.max(dimensionTop,dimensionRight);
            }
            letbits=Detector$1.sampleGrid(this.image,topLeft,bottomLeft,bottomRight,topRight,dimensionTop,dimensionRight);
            returnnewDetectorResult(bits,[topLeft,bottomLeft,bottomRight,topRight]);
        }
        staticshiftPoint(point,to,div){
            letx=(to.getX()-point.getX())/(div+1);
            lety=(to.getY()-point.getY())/(div+1);
            returnnewResultPoint(point.getX()+x,point.getY()+y);
        }
        staticmoveAway(point,fromX,fromY){
            letx=point.getX();
            lety=point.getY();
            if(x<fromX){
                x-=1;
            }
            else{
                x+=1;
            }
            if(y<fromY){
                y-=1;
            }
            else{
                y+=1;
            }
            returnnewResultPoint(x,y);
        }
        /**
         *Detectasolidsidewhichhasminimumtransition.
         */
        detectSolid1(cornerPoints){
            //0 2
            //1 3
            letpointA=cornerPoints[0];
            letpointB=cornerPoints[1];
            letpointC=cornerPoints[3];
            letpointD=cornerPoints[2];
            lettrAB=this.transitionsBetween(pointA,pointB);
            lettrBC=this.transitionsBetween(pointB,pointC);
            lettrCD=this.transitionsBetween(pointC,pointD);
            lettrDA=this.transitionsBetween(pointD,pointA);
            //0..3
            //: :
            //1--2
            letmin=trAB;
            letpoints=[pointD,pointA,pointB,pointC];
            if(min>trBC){
                min=trBC;
                points[0]=pointA;
                points[1]=pointB;
                points[2]=pointC;
                points[3]=pointD;
            }
            if(min>trCD){
                min=trCD;
                points[0]=pointB;
                points[1]=pointC;
                points[2]=pointD;
                points[3]=pointA;
            }
            if(min>trDA){
                points[0]=pointC;
                points[1]=pointD;
                points[2]=pointA;
                points[3]=pointB;
            }
            returnpoints;
        }
        /**
         *Detectasecondsolidsidenexttofirstsolidside.
         */
        detectSolid2(points){
            //A..D
            //: :
            //B--C
            letpointA=points[0];
            letpointB=points[1];
            letpointC=points[2];
            letpointD=points[3];
            //Transitiondetectionontheedgeisnotstable.
            //Tosafelydetect,shiftthepointstothemodulecenter.
            lettr=this.transitionsBetween(pointA,pointD);
            letpointBs=Detector$1.shiftPoint(pointB,pointC,(tr+1)*4);
            letpointCs=Detector$1.shiftPoint(pointC,pointB,(tr+1)*4);
            lettrBA=this.transitionsBetween(pointBs,pointA);
            lettrCD=this.transitionsBetween(pointCs,pointD);
            //0..3
            //| :
            //1--2
            if(trBA<trCD){
                //solidsides:A-B-C
                points[0]=pointA;
                points[1]=pointB;
                points[2]=pointC;
                points[3]=pointD;
            }
            else{
                //solidsides:B-C-D
                points[0]=pointB;
                points[1]=pointC;
                points[2]=pointD;
                points[3]=pointA;
            }
            returnpoints;
        }
        /**
         *Calculatesthecornerpositionofthewhitetoprightmodule.
         */
        correctTopRight(points){
            //A..D
            //| :
            //B--C
            letpointA=points[0];
            letpointB=points[1];
            letpointC=points[2];
            letpointD=points[3];
            //shiftpointsforsafetransitiondetection.
            lettrTop=this.transitionsBetween(pointA,pointD);
            lettrRight=this.transitionsBetween(pointB,pointD);
            letpointAs=Detector$1.shiftPoint(pointA,pointB,(trRight+1)*4);
            letpointCs=Detector$1.shiftPoint(pointC,pointB,(trTop+1)*4);
            trTop=this.transitionsBetween(pointAs,pointD);
            trRight=this.transitionsBetween(pointCs,pointD);
            letcandidate1=newResultPoint(pointD.getX()+(pointC.getX()-pointB.getX())/(trTop+1),pointD.getY()+(pointC.getY()-pointB.getY())/(trTop+1));
            letcandidate2=newResultPoint(pointD.getX()+(pointA.getX()-pointB.getX())/(trRight+1),pointD.getY()+(pointA.getY()-pointB.getY())/(trRight+1));
            if(!this.isValid(candidate1)){
                if(this.isValid(candidate2)){
                    returncandidate2;
                }
                returnnull;
            }
            if(!this.isValid(candidate2)){
                returncandidate1;
            }
            letsumc1=this.transitionsBetween(pointAs,candidate1)+this.transitionsBetween(pointCs,candidate1);
            letsumc2=this.transitionsBetween(pointAs,candidate2)+this.transitionsBetween(pointCs,candidate2);
            if(sumc1>sumc2){
                returncandidate1;
            }
            else{
                returncandidate2;
            }
        }
        /**
         *Shifttheedgepointstothemodulecenter.
         */
        shiftToModuleCenter(points){
            //A..D
            //| :
            //B--C
            letpointA=points[0];
            letpointB=points[1];
            letpointC=points[2];
            letpointD=points[3];
            //calculatepseudodimensions
            letdimH=this.transitionsBetween(pointA,pointD)+1;
            letdimV=this.transitionsBetween(pointC,pointD)+1;
            //shiftpointsforsafedimensiondetection
            letpointAs=Detector$1.shiftPoint(pointA,pointB,dimV*4);
            letpointCs=Detector$1.shiftPoint(pointC,pointB,dimH*4);
            // calculatemoreprecisedimensions
            dimH=this.transitionsBetween(pointAs,pointD)+1;
            dimV=this.transitionsBetween(pointCs,pointD)+1;
            if((dimH&0x01)===1){
                dimH+=1;
            }
            if((dimV&0x01)===1){
                dimV+=1;
            }
            //WhiteRectangleDetectorreturnspointsinsideoftherectangle.
            //Iwantpointsontheedges.
            letcenterX=(pointA.getX()+pointB.getX()+pointC.getX()+pointD.getX())/4;
            letcenterY=(pointA.getY()+pointB.getY()+pointC.getY()+pointD.getY())/4;
            pointA=Detector$1.moveAway(pointA,centerX,centerY);
            pointB=Detector$1.moveAway(pointB,centerX,centerY);
            pointC=Detector$1.moveAway(pointC,centerX,centerY);
            pointD=Detector$1.moveAway(pointD,centerX,centerY);
            letpointBs;
            letpointDs;
            //shiftpointstothecenterofeachmodules
            pointAs=Detector$1.shiftPoint(pointA,pointB,dimV*4);
            pointAs=Detector$1.shiftPoint(pointAs,pointD,dimH*4);
            pointBs=Detector$1.shiftPoint(pointB,pointA,dimV*4);
            pointBs=Detector$1.shiftPoint(pointBs,pointC,dimH*4);
            pointCs=Detector$1.shiftPoint(pointC,pointD,dimV*4);
            pointCs=Detector$1.shiftPoint(pointCs,pointB,dimH*4);
            pointDs=Detector$1.shiftPoint(pointD,pointC,dimV*4);
            pointDs=Detector$1.shiftPoint(pointDs,pointA,dimH*4);
            return[pointAs,pointBs,pointCs,pointDs];
        }
        isValid(p){
            returnp.getX()>=0&&p.getX()<this.image.getWidth()&&p.getY()>0&&p.getY()<this.image.getHeight();
        }
        staticsampleGrid(image,topLeft,bottomLeft,bottomRight,topRight,dimensionX,dimensionY){
            constsampler=GridSamplerInstance.getInstance();
            returnsampler.sampleGrid(image,dimensionX,dimensionY,0.5,0.5,dimensionX-0.5,0.5,dimensionX-0.5,dimensionY-0.5,0.5,dimensionY-0.5,topLeft.getX(),topLeft.getY(),topRight.getX(),topRight.getY(),bottomRight.getX(),bottomRight.getY(),bottomLeft.getX(),bottomLeft.getY());
        }
        /**
         *Countsthenumberofblack/whitetransitionsbetweentwopoints,usingsomethinglikeBresenham'salgorithm.
         */
        transitionsBetween(from,to){
            //SeeQRCodeDetector,sizeOfBlackWhiteBlackRun()
            letfromX=Math.trunc(from.getX());
            letfromY=Math.trunc(from.getY());
            lettoX=Math.trunc(to.getX());
            lettoY=Math.trunc(to.getY());
            letsteep=Math.abs(toY-fromY)>Math.abs(toX-fromX);
            if(steep){
                lettemp=fromX;
                fromX=fromY;
                fromY=temp;
                temp=toX;
                toX=toY;
                toY=temp;
            }
            letdx=Math.abs(toX-fromX);
            letdy=Math.abs(toY-fromY);
            leterror=-dx/2;
            letystep=fromY<toY?1:-1;
            letxstep=fromX<toX?1:-1;
            lettransitions=0;
            letinBlack=this.image.get(steep?fromY:fromX,steep?fromX:fromY);
            for(letx=fromX,y=fromY;x!==toX;x+=xstep){
                letisBlack=this.image.get(steep?y:x,steep?x:y);
                if(isBlack!==inBlack){
                    transitions++;
                    inBlack=isBlack;
                }
                error+=dy;
                if(error>0){
                    if(y===toY){
                        break;
                    }
                    y+=ystep;
                    error-=dx;
                }
            }
            returntransitions;
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *ThisimplementationcandetectanddecodeDataMatrixcodesinanimage.
     *
     *@authorbbrown@google.com(BrianBrown)
     */
    classDataMatrixReader{
        constructor(){
            this.decoder=newDecoder$1();
        }
        /**
         *LocatesanddecodesaDataMatrixcodeinanimage.
         *
         *@returnaStringrepresentingthecontentencodedbytheDataMatrixcode
         *@throwsNotFoundExceptionifaDataMatrixcodecannotbefound
         *@throwsFormatExceptionifaDataMatrixcodecannotbedecoded
         *@throwsChecksumExceptioniferrorcorrectionfails
         */
        //@Override
        //publicResultdecode(BinaryBitmapimage)throwsNotFoundException,ChecksumException,FormatException{
        //  returndecode(image,null);
        //}
        //@Override
        decode(image,hints=null){
            letdecoderResult;
            letpoints;
            if(hints!=null&&hints.has(DecodeHintType$1.PURE_BARCODE)){
                constbits=DataMatrixReader.extractPureBits(image.getBlackMatrix());
                decoderResult=this.decoder.decode(bits);
                points=DataMatrixReader.NO_POINTS;
            }
            else{
                constdetectorResult=newDetector$1(image.getBlackMatrix()).detect();
                decoderResult=this.decoder.decode(detectorResult.getBits());
                points=detectorResult.getPoints();
            }
            constrawBytes=decoderResult.getRawBytes();
            constresult=newResult(decoderResult.getText(),rawBytes,8*rawBytes.length,points,BarcodeFormat$1.DATA_MATRIX,System.currentTimeMillis());
            constbyteSegments=decoderResult.getByteSegments();
            if(byteSegments!=null){
                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS,byteSegments);
            }
            constecLevel=decoderResult.getECLevel();
            if(ecLevel!=null){
                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL,ecLevel);
            }
            returnresult;
        }
        //@Override
        reset(){
            //donothing
        }
        /**
         *Thismethoddetectsacodeina"pure"image--thatis,puremonochromeimage
         *whichcontainsonlyanunrotated,unskewed,imageofacode,withsomewhiteborder
         *aroundit.Thisisaspecializedmethodthatworksexceptionallyfastinthisspecial
         *case.
         *
         *@seecom.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)
         */
        staticextractPureBits(image){
            constleftTopBlack=image.getTopLeftOnBit();
            constrightBottomBlack=image.getBottomRightOnBit();
            if(leftTopBlack==null||rightBottomBlack==null){
                thrownewNotFoundException();
            }
            constmoduleSize=this.moduleSize(leftTopBlack,image);
            lettop=leftTopBlack[1];
            constbottom=rightBottomBlack[1];
            letleft=leftTopBlack[0];
            constright=rightBottomBlack[0];
            constmatrixWidth=(right-left+1)/moduleSize;
            constmatrixHeight=(bottom-top+1)/moduleSize;
            if(matrixWidth<=0||matrixHeight<=0){
                thrownewNotFoundException();
            }
            //Pushinthe"border"byhalfthemodulewidthsothatwestart
            //samplinginthemiddleofthemodule.Justincasetheimageisa
            //littleoff,thiswillhelprecover.
            constnudge=moduleSize/2;
            top+=nudge;
            left+=nudge;
            //Nowjustreadoffthebits
            constbits=newBitMatrix(matrixWidth,matrixHeight);
            for(lety=0;y<matrixHeight;y++){
                constiOffset=top+y*moduleSize;
                for(letx=0;x<matrixWidth;x++){
                    if(image.get(left+x*moduleSize,iOffset)){
                        bits.set(x,y);
                    }
                }
            }
            returnbits;
        }
        staticmoduleSize(leftTopBlack,image){
            constwidth=image.getWidth();
            letx=leftTopBlack[0];
            consty=leftTopBlack[1];
            while(x<width&&image.get(x,y)){
                x++;
            }
            if(x===width){
                thrownewNotFoundException();
            }
            constmoduleSize=x-leftTopBlack[0];
            if(moduleSize===0){
                thrownewNotFoundException();
            }
            returnmoduleSize;
        }
    }
    DataMatrixReader.NO_POINTS=[];

    /**
     *@deprecatedMovingto@zxing/browser
     *
     *QRCodereadertousefrombrowser.
     */
    classBrowserDatamatrixCodeReaderextendsBrowserCodeReader{
        /**
         *CreatesaninstanceofBrowserQRCodeReader.
         *@param{number}[timeBetweenScansMillis=500]thetimedelaybetweensubsequentdecodetries
         */
        constructor(timeBetweenScansMillis=500){
            super(newDataMatrixReader(),timeBetweenScansMillis);
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    varErrorCorrectionLevelValues;
    (function(ErrorCorrectionLevelValues){
        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["L"]=0]="L";
        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["M"]=1]="M";
        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["Q"]=2]="Q";
        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["H"]=3]="H";
    })(ErrorCorrectionLevelValues||(ErrorCorrectionLevelValues={}));
    /**
     *<p>SeeISO18004:2006,6.5.1.Thisenumencapsulatesthefourerrorcorrectionlevels
     *definedbytheQRcodestandard.</p>
     *
     *@authorSeanOwen
     */
    classErrorCorrectionLevel{
        constructor(value,stringValue,bits/*int*/){
            this.value=value;
            this.stringValue=stringValue;
            this.bits=bits;
            ErrorCorrectionLevel.FOR_BITS.set(bits,this);
            ErrorCorrectionLevel.FOR_VALUE.set(value,this);
        }
        getValue(){
            returnthis.value;
        }
        getBits(){
            returnthis.bits;
        }
        staticfromString(s){
            switch(s){
                case'L':returnErrorCorrectionLevel.L;
                case'M':returnErrorCorrectionLevel.M;
                case'Q':returnErrorCorrectionLevel.Q;
                case'H':returnErrorCorrectionLevel.H;
                default:thrownewArgumentException(s+'notavailable');
            }
        }
        toString(){
            returnthis.stringValue;
        }
        equals(o){
            if(!(oinstanceofErrorCorrectionLevel)){
                returnfalse;
            }
            constother=o;
            returnthis.value===other.value;
        }
        /**
         *@parambitsintcontainingthetwobitsencodingaQRCode'serrorcorrectionlevel
         *@returnErrorCorrectionLevelrepresentingtheencodederrorcorrectionlevel
         */
        staticforBits(bits/*int*/){
            if(bits<0||bits>=ErrorCorrectionLevel.FOR_BITS.size){
                thrownewIllegalArgumentException();
            }
            returnErrorCorrectionLevel.FOR_BITS.get(bits);
        }
    }
    ErrorCorrectionLevel.FOR_BITS=newMap();
    ErrorCorrectionLevel.FOR_VALUE=newMap();
    /**L=~7%correction*/
    ErrorCorrectionLevel.L=newErrorCorrectionLevel(ErrorCorrectionLevelValues.L,'L',0x01);
    /**M=~15%correction*/
    ErrorCorrectionLevel.M=newErrorCorrectionLevel(ErrorCorrectionLevelValues.M,'M',0x00);
    /**Q=~25%correction*/
    ErrorCorrectionLevel.Q=newErrorCorrectionLevel(ErrorCorrectionLevelValues.Q,'Q',0x03);
    /**H=~30%correction*/
    ErrorCorrectionLevel.H=newErrorCorrectionLevel(ErrorCorrectionLevelValues.H,'H',0x02);

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>EncapsulatesaQRCode'sformatinformation,includingthedatamaskusedand
     *errorcorrectionlevel.</p>
     *
     *@authorSeanOwen
     *@seeDataMask
     *@seeErrorCorrectionLevel
     */
    classFormatInformation{
        constructor(formatInfo/*int*/){
            //Bits3,4
            this.errorCorrectionLevel=ErrorCorrectionLevel.forBits((formatInfo>>3)&0x03);
            //Bottom3bits
            this.dataMask=/*(byte)*/(formatInfo&0x07);
        }
        staticnumBitsDiffering(a/*int*/,b/*int*/){
            returnInteger.bitCount(a^b);
        }
        /**
         *@parammaskedFormatInfo1formatinfoindicator,withmaskstillapplied
         *@parammaskedFormatInfo2secondcopyofsameinfo;botharecheckedatthesametime
         * toestablishbestmatch
         *@returninformationabouttheformatitspecifies,or{@codenull}
         * ifdoesn'tseemtomatchanyknownpattern
         */
        staticdecodeFormatInformation(maskedFormatInfo1/*int*/,maskedFormatInfo2/*int*/){
            constformatInfo=FormatInformation.doDecodeFormatInformation(maskedFormatInfo1,maskedFormatInfo2);
            if(formatInfo!==null){
                returnformatInfo;
            }
            //Shouldreturnnull,but,someQRcodesapparently
            //donotmaskthisinfo.Tryagainbyactuallymaskingthepattern
            //first
            returnFormatInformation.doDecodeFormatInformation(maskedFormatInfo1^FormatInformation.FORMAT_INFO_MASK_QR,maskedFormatInfo2^FormatInformation.FORMAT_INFO_MASK_QR);
        }
        staticdoDecodeFormatInformation(maskedFormatInfo1/*int*/,maskedFormatInfo2/*int*/){
            //FindtheintinFORMAT_INFO_DECODE_LOOKUPwithfewestbitsdiffering
            letbestDifference=Number.MAX_SAFE_INTEGER;
            letbestFormatInfo=0;
            for(constdecodeInfoofFormatInformation.FORMAT_INFO_DECODE_LOOKUP){
                consttargetInfo=decodeInfo[0];
                if(targetInfo===maskedFormatInfo1||targetInfo===maskedFormatInfo2){
                    //Foundanexactmatch
                    returnnewFormatInformation(decodeInfo[1]);
                }
                letbitsDifference=FormatInformation.numBitsDiffering(maskedFormatInfo1,targetInfo);
                if(bitsDifference<bestDifference){
                    bestFormatInfo=decodeInfo[1];
                    bestDifference=bitsDifference;
                }
                if(maskedFormatInfo1!==maskedFormatInfo2){
                    //alsotrytheotheroption
                    bitsDifference=FormatInformation.numBitsDiffering(maskedFormatInfo2,targetInfo);
                    if(bitsDifference<bestDifference){
                        bestFormatInfo=decodeInfo[1];
                        bestDifference=bitsDifference;
                    }
                }
            }
            //Hammingdistanceofthe32maskedcodesis7,byconstruction,so<=3bits
            //differingmeanswefoundamatch
            if(bestDifference<=3){
                returnnewFormatInformation(bestFormatInfo);
            }
            returnnull;
        }
        getErrorCorrectionLevel(){
            returnthis.errorCorrectionLevel;
        }
        getDataMask(){
            returnthis.dataMask;
        }
        /*@Override*/
        hashCode(){
            return(this.errorCorrectionLevel.getBits()<<3)|this.dataMask;
        }
        /*@Override*/
        equals(o){
            if(!(oinstanceofFormatInformation)){
                returnfalse;
            }
            constother=o;
            returnthis.errorCorrectionLevel===other.errorCorrectionLevel&&
                this.dataMask===other.dataMask;
        }
    }
    FormatInformation.FORMAT_INFO_MASK_QR=0x5412;
    /**
     *SeeISO18004:2006,AnnexC,TableC.1
     */
    FormatInformation.FORMAT_INFO_DECODE_LOOKUP=[
        Int32Array.from([0x5412,0x00]),
        Int32Array.from([0x5125,0x01]),
        Int32Array.from([0x5E7C,0x02]),
        Int32Array.from([0x5B4B,0x03]),
        Int32Array.from([0x45F9,0x04]),
        Int32Array.from([0x40CE,0x05]),
        Int32Array.from([0x4F97,0x06]),
        Int32Array.from([0x4AA0,0x07]),
        Int32Array.from([0x77C4,0x08]),
        Int32Array.from([0x72F3,0x09]),
        Int32Array.from([0x7DAA,0x0A]),
        Int32Array.from([0x789D,0x0B]),
        Int32Array.from([0x662F,0x0C]),
        Int32Array.from([0x6318,0x0D]),
        Int32Array.from([0x6C41,0x0E]),
        Int32Array.from([0x6976,0x0F]),
        Int32Array.from([0x1689,0x10]),
        Int32Array.from([0x13BE,0x11]),
        Int32Array.from([0x1CE7,0x12]),
        Int32Array.from([0x19D0,0x13]),
        Int32Array.from([0x0762,0x14]),
        Int32Array.from([0x0255,0x15]),
        Int32Array.from([0x0D0C,0x16]),
        Int32Array.from([0x083B,0x17]),
        Int32Array.from([0x355F,0x18]),
        Int32Array.from([0x3068,0x19]),
        Int32Array.from([0x3F31,0x1A]),
        Int32Array.from([0x3A06,0x1B]),
        Int32Array.from([0x24B4,0x1C]),
        Int32Array.from([0x2183,0x1D]),
        Int32Array.from([0x2EDA,0x1E]),
        Int32Array.from([0x2BED,0x1F]),
    ];

    /**
     *<p>Encapsulatesasetoferror-correctionblocksinonesymbolversion.Mostversionswill
     *useblocksofdifferingsizeswithinoneversion,so,thisencapsulatestheparametersfor
     *eachsetofblocks.Italsoholdsthenumberoferror-correctioncodewordsperblocksinceit
     *willbethesameacrossallblockswithinoneversion.</p>
     */
    classECBlocks$1{
        constructor(ecCodewordsPerBlock/*int*/,...ecBlocks){
            this.ecCodewordsPerBlock=ecCodewordsPerBlock;
            this.ecBlocks=ecBlocks;
        }
        getECCodewordsPerBlock(){
            returnthis.ecCodewordsPerBlock;
        }
        getNumBlocks(){
            lettotal=0;
            constecBlocks=this.ecBlocks;
            for(constecBlockofecBlocks){
                total+=ecBlock.getCount();
            }
            returntotal;
        }
        getTotalECCodewords(){
            returnthis.ecCodewordsPerBlock*this.getNumBlocks();
        }
        getECBlocks(){
            returnthis.ecBlocks;
        }
    }

    /**
     *<p>Encapsulatestheparametersforoneerror-correctionblockinonesymbolversion.
     *Thisincludesthenumberofdatacodewords,andthenumberoftimesablockwiththese
     *parametersisusedconsecutivelyintheQRcodeversion'sformat.</p>
     */
    classECB$1{
        constructor(count/*int*/,dataCodewords/*int*/){
            this.count=count;
            this.dataCodewords=dataCodewords;
        }
        getCount(){
            returnthis.count;
        }
        getDataCodewords(){
            returnthis.dataCodewords;
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *SeeISO18004:2006AnnexD
     *
     *@authorSeanOwen
     */
    classVersion$1{
        constructor(versionNumber/*int*/,alignmentPatternCenters,...ecBlocks){
            this.versionNumber=versionNumber;
            this.alignmentPatternCenters=alignmentPatternCenters;
            this.ecBlocks=ecBlocks;
            lettotal=0;
            constecCodewords=ecBlocks[0].getECCodewordsPerBlock();
            constecbArray=ecBlocks[0].getECBlocks();
            for(constecBlockofecbArray){
                total+=ecBlock.getCount()*(ecBlock.getDataCodewords()+ecCodewords);
            }
            this.totalCodewords=total;
        }
        getVersionNumber(){
            returnthis.versionNumber;
        }
        getAlignmentPatternCenters(){
            returnthis.alignmentPatternCenters;
        }
        getTotalCodewords(){
            returnthis.totalCodewords;
        }
        getDimensionForVersion(){
            return17+4*this.versionNumber;
        }
        getECBlocksForLevel(ecLevel){
            returnthis.ecBlocks[ecLevel.getValue()];
            //TYPESCRIPTPORT:originalwasusingordinal,andusingtheorderoflevelsasdefinedinErrorCorrectionLevelenum(LMQH)
            //IwillusethedirectvaluefromErrorCorrectionLevelValuesenumwhichintypescriptgoestoanumber
        }
        /**
         *<p>DeducesversioninformationpurelyfromQRCodedimensions.</p>
         *
         *@paramdimensiondimensioninmodules
         *@returnVersionforaQRCodeofthatdimension
         *@throwsFormatExceptionifdimensionisnot1mod4
         */
        staticgetProvisionalVersionForDimension(dimension/*int*/){
            if(dimension%4!==1){
                thrownewFormatException();
            }
            try{
                returnthis.getVersionForNumber((dimension-17)/4);
            }
            catch(ignored/*:IllegalArgumentException*/){
                thrownewFormatException();
            }
        }
        staticgetVersionForNumber(versionNumber/*int*/){
            if(versionNumber<1||versionNumber>40){
                thrownewIllegalArgumentException();
            }
            returnVersion$1.VERSIONS[versionNumber-1];
        }
        staticdecodeVersionInformation(versionBits/*int*/){
            letbestDifference=Number.MAX_SAFE_INTEGER;
            letbestVersion=0;
            for(leti=0;i<Version$1.VERSION_DECODE_INFO.length;i++){
                consttargetVersion=Version$1.VERSION_DECODE_INFO[i];
                //Dotheversioninfobitsmatchexactly?done.
                if(targetVersion===versionBits){
                    returnVersion$1.getVersionForNumber(i+7);
                }
                //Otherwiseseeifthisistheclosesttoarealversioninfobitstring
                //wehaveseensofar
                constbitsDifference=FormatInformation.numBitsDiffering(versionBits,targetVersion);
                if(bitsDifference<bestDifference){
                    bestVersion=i+7;
                    bestDifference=bitsDifference;
                }
            }
            //Wecantolerateupto3bitsoferrorsincenotwoversioninfocodewordswill
            //differinlessthan8bits.
            if(bestDifference<=3){
                returnVersion$1.getVersionForNumber(bestVersion);
            }
            //Ifwedidn'tfindacloseenoughmatch,fail
            returnnull;
        }
        /**
         *SeeISO18004:2006AnnexE
         */
        buildFunctionPattern(){
            constdimension=this.getDimensionForVersion();
            constbitMatrix=newBitMatrix(dimension);
            //Topleftfinderpattern+separator+format
            bitMatrix.setRegion(0,0,9,9);
            //Toprightfinderpattern+separator+format
            bitMatrix.setRegion(dimension-8,0,8,9);
            //Bottomleftfinderpattern+separator+format
            bitMatrix.setRegion(0,dimension-8,9,8);
            //Alignmentpatterns
            constmax=this.alignmentPatternCenters.length;
            for(letx=0;x<max;x++){
                consti=this.alignmentPatternCenters[x]-2;
                for(lety=0;y<max;y++){
                    if((x===0&&(y===0||y===max-1))||(x===max-1&&y===0)){
                        //Noalignmentpatternsnearthethreefinderpatterns
                        continue;
                    }
                    bitMatrix.setRegion(this.alignmentPatternCenters[y]-2,i,5,5);
                }
            }
            //Verticaltimingpattern
            bitMatrix.setRegion(6,9,1,dimension-17);
            //Horizontaltimingpattern
            bitMatrix.setRegion(9,6,dimension-17,1);
            if(this.versionNumber>6){
                //Versioninfo,topright
                bitMatrix.setRegion(dimension-11,0,3,6);
                //Versioninfo,bottomleft
                bitMatrix.setRegion(0,dimension-11,6,3);
            }
            returnbitMatrix;
        }
        /*@Override*/
        toString(){
            return''+this.versionNumber;
        }
    }
    /**
       *SeeISO18004:2006AnnexD.
       *Elementirepresentstherawversionbitsthatspecifyversioni+7
       */
    Version$1.VERSION_DECODE_INFO=Int32Array.from([
        0x07C94,0x085BC,0x09A99,0x0A4D3,0x0BBF6,
        0x0C762,0x0D847,0x0E60D,0x0F928,0x10B78,
        0x1145D,0x12A17,0x13532,0x149A6,0x15683,
        0x168C9,0x177EC,0x18EC4,0x191E1,0x1AFAB,
        0x1B08E,0x1CC1A,0x1D33F,0x1ED75,0x1F250,
        0x209D5,0x216F0,0x228BA,0x2379F,0x24B0B,
        0x2542E,0x26A64,0x27541,0x28C69
    ]);
    /**
       *SeeISO18004:20066.5.1Table9
       */
    Version$1.VERSIONS=[
        newVersion$1(1,newInt32Array(0),newECBlocks$1(7,newECB$1(1,19)),newECBlocks$1(10,newECB$1(1,16)),newECBlocks$1(13,newECB$1(1,13)),newECBlocks$1(17,newECB$1(1,9))),
        newVersion$1(2,Int32Array.from([6,18]),newECBlocks$1(10,newECB$1(1,34)),newECBlocks$1(16,newECB$1(1,28)),newECBlocks$1(22,newECB$1(1,22)),newECBlocks$1(28,newECB$1(1,16))),
        newVersion$1(3,Int32Array.from([6,22]),newECBlocks$1(15,newECB$1(1,55)),newECBlocks$1(26,newECB$1(1,44)),newECBlocks$1(18,newECB$1(2,17)),newECBlocks$1(22,newECB$1(2,13))),
        newVersion$1(4,Int32Array.from([6,26]),newECBlocks$1(20,newECB$1(1,80)),newECBlocks$1(18,newECB$1(2,32)),newECBlocks$1(26,newECB$1(2,24)),newECBlocks$1(16,newECB$1(4,9))),
        newVersion$1(5,Int32Array.from([6,30]),newECBlocks$1(26,newECB$1(1,108)),newECBlocks$1(24,newECB$1(2,43)),newECBlocks$1(18,newECB$1(2,15),newECB$1(2,16)),newECBlocks$1(22,newECB$1(2,11),newECB$1(2,12))),
        newVersion$1(6,Int32Array.from([6,34]),newECBlocks$1(18,newECB$1(2,68)),newECBlocks$1(16,newECB$1(4,27)),newECBlocks$1(24,newECB$1(4,19)),newECBlocks$1(28,newECB$1(4,15))),
        newVersion$1(7,Int32Array.from([6,22,38]),newECBlocks$1(20,newECB$1(2,78)),newECBlocks$1(18,newECB$1(4,31)),newECBlocks$1(18,newECB$1(2,14),newECB$1(4,15)),newECBlocks$1(26,newECB$1(4,13),newECB$1(1,14))),
        newVersion$1(8,Int32Array.from([6,24,42]),newECBlocks$1(24,newECB$1(2,97)),newECBlocks$1(22,newECB$1(2,38),newECB$1(2,39)),newECBlocks$1(22,newECB$1(4,18),newECB$1(2,19)),newECBlocks$1(26,newECB$1(4,14),newECB$1(2,15))),
        newVersion$1(9,Int32Array.from([6,26,46]),newECBlocks$1(30,newECB$1(2,116)),newECBlocks$1(22,newECB$1(3,36),newECB$1(2,37)),newECBlocks$1(20,newECB$1(4,16),newECB$1(4,17)),newECBlocks$1(24,newECB$1(4,12),newECB$1(4,13))),
        newVersion$1(10,Int32Array.from([6,28,50]),newECBlocks$1(18,newECB$1(2,68),newECB$1(2,69)),newECBlocks$1(26,newECB$1(4,43),newECB$1(1,44)),newECBlocks$1(24,newECB$1(6,19),newECB$1(2,20)),newECBlocks$1(28,newECB$1(6,15),newECB$1(2,16))),
        newVersion$1(11,Int32Array.from([6,30,54]),newECBlocks$1(20,newECB$1(4,81)),newECBlocks$1(30,newECB$1(1,50),newECB$1(4,51)),newECBlocks$1(28,newECB$1(4,22),newECB$1(4,23)),newECBlocks$1(24,newECB$1(3,12),newECB$1(8,13))),
        newVersion$1(12,Int32Array.from([6,32,58]),newECBlocks$1(24,newECB$1(2,92),newECB$1(2,93)),newECBlocks$1(22,newECB$1(6,36),newECB$1(2,37)),newECBlocks$1(26,newECB$1(4,20),newECB$1(6,21)),newECBlocks$1(28,newECB$1(7,14),newECB$1(4,15))),
        newVersion$1(13,Int32Array.from([6,34,62]),newECBlocks$1(26,newECB$1(4,107)),newECBlocks$1(22,newECB$1(8,37),newECB$1(1,38)),newECBlocks$1(24,newECB$1(8,20),newECB$1(4,21)),newECBlocks$1(22,newECB$1(12,11),newECB$1(4,12))),
        newVersion$1(14,Int32Array.from([6,26,46,66]),newECBlocks$1(30,newECB$1(3,115),newECB$1(1,116)),newECBlocks$1(24,newECB$1(4,40),newECB$1(5,41)),newECBlocks$1(20,newECB$1(11,16),newECB$1(5,17)),newECBlocks$1(24,newECB$1(11,12),newECB$1(5,13))),
        newVersion$1(15,Int32Array.from([6,26,48,70]),newECBlocks$1(22,newECB$1(5,87),newECB$1(1,88)),newECBlocks$1(24,newECB$1(5,41),newECB$1(5,42)),newECBlocks$1(30,newECB$1(5,24),newECB$1(7,25)),newECBlocks$1(24,newECB$1(11,12),newECB$1(7,13))),
        newVersion$1(16,Int32Array.from([6,26,50,74]),newECBlocks$1(24,newECB$1(5,98),newECB$1(1,99)),newECBlocks$1(28,newECB$1(7,45),newECB$1(3,46)),newECBlocks$1(24,newECB$1(15,19),newECB$1(2,20)),newECBlocks$1(30,newECB$1(3,15),newECB$1(13,16))),
        newVersion$1(17,Int32Array.from([6,30,54,78]),newECBlocks$1(28,newECB$1(1,107),newECB$1(5,108)),newECBlocks$1(28,newECB$1(10,46),newECB$1(1,47)),newECBlocks$1(28,newECB$1(1,22),newECB$1(15,23)),newECBlocks$1(28,newECB$1(2,14),newECB$1(17,15))),
        newVersion$1(18,Int32Array.from([6,30,56,82]),newECBlocks$1(30,newECB$1(5,120),newECB$1(1,121)),newECBlocks$1(26,newECB$1(9,43),newECB$1(4,44)),newECBlocks$1(28,newECB$1(17,22),newECB$1(1,23)),newECBlocks$1(28,newECB$1(2,14),newECB$1(19,15))),
        newVersion$1(19,Int32Array.from([6,30,58,86]),newECBlocks$1(28,newECB$1(3,113),newECB$1(4,114)),newECBlocks$1(26,newECB$1(3,44),newECB$1(11,45)),newECBlocks$1(26,newECB$1(17,21),newECB$1(4,22)),newECBlocks$1(26,newECB$1(9,13),newECB$1(16,14))),
        newVersion$1(20,Int32Array.from([6,34,62,90]),newECBlocks$1(28,newECB$1(3,107),newECB$1(5,108)),newECBlocks$1(26,newECB$1(3,41),newECB$1(13,42)),newECBlocks$1(30,newECB$1(15,24),newECB$1(5,25)),newECBlocks$1(28,newECB$1(15,15),newECB$1(10,16))),
        newVersion$1(21,Int32Array.from([6,28,50,72,94]),newECBlocks$1(28,newECB$1(4,116),newECB$1(4,117)),newECBlocks$1(26,newECB$1(17,42)),newECBlocks$1(28,newECB$1(17,22),newECB$1(6,23)),newECBlocks$1(30,newECB$1(19,16),newECB$1(6,17))),
        newVersion$1(22,Int32Array.from([6,26,50,74,98]),newECBlocks$1(28,newECB$1(2,111),newECB$1(7,112)),newECBlocks$1(28,newECB$1(17,46)),newECBlocks$1(30,newECB$1(7,24),newECB$1(16,25)),newECBlocks$1(24,newECB$1(34,13))),
        newVersion$1(23,Int32Array.from([6,30,54,78,102]),newECBlocks$1(30,newECB$1(4,121),newECB$1(5,122)),newECBlocks$1(28,newECB$1(4,47),newECB$1(14,48)),newECBlocks$1(30,newECB$1(11,24),newECB$1(14,25)),newECBlocks$1(30,newECB$1(16,15),newECB$1(14,16))),
        newVersion$1(24,Int32Array.from([6,28,54,80,106]),newECBlocks$1(30,newECB$1(6,117),newECB$1(4,118)),newECBlocks$1(28,newECB$1(6,45),newECB$1(14,46)),newECBlocks$1(30,newECB$1(11,24),newECB$1(16,25)),newECBlocks$1(30,newECB$1(30,16),newECB$1(2,17))),
        newVersion$1(25,Int32Array.from([6,32,58,84,110]),newECBlocks$1(26,newECB$1(8,106),newECB$1(4,107)),newECBlocks$1(28,newECB$1(8,47),newECB$1(13,48)),newECBlocks$1(30,newECB$1(7,24),newECB$1(22,25)),newECBlocks$1(30,newECB$1(22,15),newECB$1(13,16))),
        newVersion$1(26,Int32Array.from([6,30,58,86,114]),newECBlocks$1(28,newECB$1(10,114),newECB$1(2,115)),newECBlocks$1(28,newECB$1(19,46),newECB$1(4,47)),newECBlocks$1(28,newECB$1(28,22),newECB$1(6,23)),newECBlocks$1(30,newECB$1(33,16),newECB$1(4,17))),
        newVersion$1(27,Int32Array.from([6,34,62,90,118]),newECBlocks$1(30,newECB$1(8,122),newECB$1(4,123)),newECBlocks$1(28,newECB$1(22,45),newECB$1(3,46)),newECBlocks$1(30,newECB$1(8,23),newECB$1(26,24)),newECBlocks$1(30,newECB$1(12,15),newECB$1(28,16))),
        newVersion$1(28,Int32Array.from([6,26,50,74,98,122]),newECBlocks$1(30,newECB$1(3,117),newECB$1(10,118)),newECBlocks$1(28,newECB$1(3,45),newECB$1(23,46)),newECBlocks$1(30,newECB$1(4,24),newECB$1(31,25)),newECBlocks$1(30,newECB$1(11,15),newECB$1(31,16))),
        newVersion$1(29,Int32Array.from([6,30,54,78,102,126]),newECBlocks$1(30,newECB$1(7,116),newECB$1(7,117)),newECBlocks$1(28,newECB$1(21,45),newECB$1(7,46)),newECBlocks$1(30,newECB$1(1,23),newECB$1(37,24)),newECBlocks$1(30,newECB$1(19,15),newECB$1(26,16))),
        newVersion$1(30,Int32Array.from([6,26,52,78,104,130]),newECBlocks$1(30,newECB$1(5,115),newECB$1(10,116)),newECBlocks$1(28,newECB$1(19,47),newECB$1(10,48)),newECBlocks$1(30,newECB$1(15,24),newECB$1(25,25)),newECBlocks$1(30,newECB$1(23,15),newECB$1(25,16))),
        newVersion$1(31,Int32Array.from([6,30,56,82,108,134]),newECBlocks$1(30,newECB$1(13,115),newECB$1(3,116)),newECBlocks$1(28,newECB$1(2,46),newECB$1(29,47)),newECBlocks$1(30,newECB$1(42,24),newECB$1(1,25)),newECBlocks$1(30,newECB$1(23,15),newECB$1(28,16))),
        newVersion$1(32,Int32Array.from([6,34,60,86,112,138]),newECBlocks$1(30,newECB$1(17,115)),newECBlocks$1(28,newECB$1(10,46),newECB$1(23,47)),newECBlocks$1(30,newECB$1(10,24),newECB$1(35,25)),newECBlocks$1(30,newECB$1(19,15),newECB$1(35,16))),
        newVersion$1(33,Int32Array.from([6,30,58,86,114,142]),newECBlocks$1(30,newECB$1(17,115),newECB$1(1,116)),newECBlocks$1(28,newECB$1(14,46),newECB$1(21,47)),newECBlocks$1(30,newECB$1(29,24),newECB$1(19,25)),newECBlocks$1(30,newECB$1(11,15),newECB$1(46,16))),
        newVersion$1(34,Int32Array.from([6,34,62,90,118,146]),newECBlocks$1(30,newECB$1(13,115),newECB$1(6,116)),newECBlocks$1(28,newECB$1(14,46),newECB$1(23,47)),newECBlocks$1(30,newECB$1(44,24),newECB$1(7,25)),newECBlocks$1(30,newECB$1(59,16),newECB$1(1,17))),
        newVersion$1(35,Int32Array.from([6,30,54,78,102,126,150]),newECBlocks$1(30,newECB$1(12,121),newECB$1(7,122)),newECBlocks$1(28,newECB$1(12,47),newECB$1(26,48)),newECBlocks$1(30,newECB$1(39,24),newECB$1(14,25)),newECBlocks$1(30,newECB$1(22,15),newECB$1(41,16))),
        newVersion$1(36,Int32Array.from([6,24,50,76,102,128,154]),newECBlocks$1(30,newECB$1(6,121),newECB$1(14,122)),newECBlocks$1(28,newECB$1(6,47),newECB$1(34,48)),newECBlocks$1(30,newECB$1(46,24),newECB$1(10,25)),newECBlocks$1(30,newECB$1(2,15),newECB$1(64,16))),
        newVersion$1(37,Int32Array.from([6,28,54,80,106,132,158]),newECBlocks$1(30,newECB$1(17,122),newECB$1(4,123)),newECBlocks$1(28,newECB$1(29,46),newECB$1(14,47)),newECBlocks$1(30,newECB$1(49,24),newECB$1(10,25)),newECBlocks$1(30,newECB$1(24,15),newECB$1(46,16))),
        newVersion$1(38,Int32Array.from([6,32,58,84,110,136,162]),newECBlocks$1(30,newECB$1(4,122),newECB$1(18,123)),newECBlocks$1(28,newECB$1(13,46),newECB$1(32,47)),newECBlocks$1(30,newECB$1(48,24),newECB$1(14,25)),newECBlocks$1(30,newECB$1(42,15),newECB$1(32,16))),
        newVersion$1(39,Int32Array.from([6,26,54,82,110,138,166]),newECBlocks$1(30,newECB$1(20,117),newECB$1(4,118)),newECBlocks$1(28,newECB$1(40,47),newECB$1(7,48)),newECBlocks$1(30,newECB$1(43,24),newECB$1(22,25)),newECBlocks$1(30,newECB$1(10,15),newECB$1(67,16))),
        newVersion$1(40,Int32Array.from([6,30,58,86,114,142,170]),newECBlocks$1(30,newECB$1(19,118),newECB$1(6,119)),newECBlocks$1(28,newECB$1(18,47),newECB$1(31,48)),newECBlocks$1(30,newECB$1(34,24),newECB$1(34,25)),newECBlocks$1(30,newECB$1(20,15),newECB$1(61,16)))
    ];

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    varDataMaskValues;
    (function(DataMaskValues){
        DataMaskValues[DataMaskValues["DATA_MASK_000"]=0]="DATA_MASK_000";
        DataMaskValues[DataMaskValues["DATA_MASK_001"]=1]="DATA_MASK_001";
        DataMaskValues[DataMaskValues["DATA_MASK_010"]=2]="DATA_MASK_010";
        DataMaskValues[DataMaskValues["DATA_MASK_011"]=3]="DATA_MASK_011";
        DataMaskValues[DataMaskValues["DATA_MASK_100"]=4]="DATA_MASK_100";
        DataMaskValues[DataMaskValues["DATA_MASK_101"]=5]="DATA_MASK_101";
        DataMaskValues[DataMaskValues["DATA_MASK_110"]=6]="DATA_MASK_110";
        DataMaskValues[DataMaskValues["DATA_MASK_111"]=7]="DATA_MASK_111";
    })(DataMaskValues||(DataMaskValues={}));
    /**
     *<p>EncapsulatesdatamasksforthedatabitsinaQRcode,perISO18004:20066.8.Implementations
     *ofthisclasscanun-maskarawBitMatrix.Forsimplicity,theywillunmasktheentireBitMatrix,
     *includingareasusedforfinderpatterns,timingpatterns,etc.Theseareasshouldbeunused
     *afterthepointtheyareunmaskedanyway.</p>
     *
     *<p>Notethatthediagraminsection6.8.1ismisleadingsinceitindicatesthatiiscolumnposition
     *andjisrowposition.Infact,asthetextsays,iisrowpositionandjiscolumnposition.</p>
     *
     *@authorSeanOwen
     */
    classDataMask{
        //SeeISO18004:20066.8.1
        constructor(value,isMasked){
            this.value=value;
            this.isMasked=isMasked;
        }
        //Endofenumconstants.
        /**
         *<p>ImplementationsofthismethodreversethedatamaskingprocessappliedtoaQRCodeand
         *makeitsbitsreadytoread.</p>
         *
         *@parambitsrepresentationofQRCodebits
         *@paramdimensiondimensionofQRCode,representedbybits,beingunmasked
         */
        unmaskBitMatrix(bits,dimension/*int*/){
            for(leti=0;i<dimension;i++){
                for(letj=0;j<dimension;j++){
                    if(this.isMasked(i,j)){
                        bits.flip(j,i);
                    }
                }
            }
        }
    }
    DataMask.values=newMap([
        /**
         *000:maskbitsforwhich(x+y)mod2==0
         */
        [DataMaskValues.DATA_MASK_000,newDataMask(DataMaskValues.DATA_MASK_000,(i/*int*/,j/*int*/)=>{return((i+j)&0x01)===0;})],
        /**
         *001:maskbitsforwhichxmod2==0
         */
        [DataMaskValues.DATA_MASK_001,newDataMask(DataMaskValues.DATA_MASK_001,(i/*int*/,j/*int*/)=>{return(i&0x01)===0;})],
        /**
         *010:maskbitsforwhichymod3==0
         */
        [DataMaskValues.DATA_MASK_010,newDataMask(DataMaskValues.DATA_MASK_010,(i/*int*/,j/*int*/)=>{returnj%3===0;})],
        /**
         *011:maskbitsforwhich(x+y)mod3==0
         */
        [DataMaskValues.DATA_MASK_011,newDataMask(DataMaskValues.DATA_MASK_011,(i/*int*/,j/*int*/)=>{return(i+j)%3===0;})],
        /**
         *100:maskbitsforwhich(x/2+y/3)mod2==0
         */
        [DataMaskValues.DATA_MASK_100,newDataMask(DataMaskValues.DATA_MASK_100,(i/*int*/,j/*int*/)=>{return((Math.floor(i/2)+Math.floor(j/3))&0x01)===0;})],
        /**
         *101:maskbitsforwhichxymod2+xymod3==0
         *equivalently,suchthatxymod6==0
         */
        [DataMaskValues.DATA_MASK_101,newDataMask(DataMaskValues.DATA_MASK_101,(i/*int*/,j/*int*/)=>{return(i*j)%6===0;})],
        /**
         *110:maskbitsforwhich(xymod2+xymod3)mod2==0
         *equivalently,suchthatxymod6<3
         */
        [DataMaskValues.DATA_MASK_110,newDataMask(DataMaskValues.DATA_MASK_110,(i/*int*/,j/*int*/)=>{return((i*j)%6)<3;})],
        /**
         *111:maskbitsforwhich((x+y)mod2+xymod3)mod2==0
         *equivalently,suchthat(x+y+xymod3)mod2==0
         */
        [DataMaskValues.DATA_MASK_111,newDataMask(DataMaskValues.DATA_MASK_111,(i/*int*/,j/*int*/)=>{return((i+j+((i*j)%3))&0x01)===0;})],
    ]);

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *@authorSeanOwen
     */
    classBitMatrixParser$1{
        /**
         *@parambitMatrix{@linkBitMatrix}toparse
         *@throwsFormatExceptionifdimensionisnot>=21and1mod4
         */
        constructor(bitMatrix){
            constdimension=bitMatrix.getHeight();
            if(dimension<21||(dimension&0x03)!==1){
                thrownewFormatException();
            }
            this.bitMatrix=bitMatrix;
        }
        /**
         *<p>ReadsformatinformationfromoneofitstwolocationswithintheQRCode.</p>
         *
         *@return{@linkFormatInformation}encapsulatingtheQRCode'sformatinfo
         *@throwsFormatExceptionifbothformatinformationlocationscannotbeparsedas
         *thevalidencodingofformatinformation
         */
        readFormatInformation(){
            if(this.parsedFormatInfo!==null&&this.parsedFormatInfo!==undefined){
                returnthis.parsedFormatInfo;
            }
            //Readtop-leftformatinfobits
            letformatInfoBits1=0;
            for(leti=0;i<6;i++){
                formatInfoBits1=this.copyBit(i,8,formatInfoBits1);
            }
            //..andskipabitinthetimingpattern...
            formatInfoBits1=this.copyBit(7,8,formatInfoBits1);
            formatInfoBits1=this.copyBit(8,8,formatInfoBits1);
            formatInfoBits1=this.copyBit(8,7,formatInfoBits1);
            //..andskipabitinthetimingpattern...
            for(letj=5;j>=0;j--){
                formatInfoBits1=this.copyBit(8,j,formatInfoBits1);
            }
            //Readthetop-right/bottom-leftpatterntoo
            constdimension=this.bitMatrix.getHeight();
            letformatInfoBits2=0;
            constjMin=dimension-7;
            for(letj=dimension-1;j>=jMin;j--){
                formatInfoBits2=this.copyBit(8,j,formatInfoBits2);
            }
            for(leti=dimension-8;i<dimension;i++){
                formatInfoBits2=this.copyBit(i,8,formatInfoBits2);
            }
            this.parsedFormatInfo=FormatInformation.decodeFormatInformation(formatInfoBits1,formatInfoBits2);
            if(this.parsedFormatInfo!==null){
                returnthis.parsedFormatInfo;
            }
            thrownewFormatException();
        }
        /**
         *<p>ReadsversioninformationfromoneofitstwolocationswithintheQRCode.</p>
         *
         *@return{@linkVersion}encapsulatingtheQRCode'sversion
         *@throwsFormatExceptionifbothversioninformationlocationscannotbeparsedas
         *thevalidencodingofversioninformation
         */
        readVersion(){
            if(this.parsedVersion!==null&&this.parsedVersion!==undefined){
                returnthis.parsedVersion;
            }
            constdimension=this.bitMatrix.getHeight();
            constprovisionalVersion=Math.floor((dimension-17)/4);
            if(provisionalVersion<=6){
                returnVersion$1.getVersionForNumber(provisionalVersion);
            }
            //Readtop-rightversioninfo:3wideby6tall
            letversionBits=0;
            constijMin=dimension-11;
            for(letj=5;j>=0;j--){
                for(leti=dimension-9;i>=ijMin;i--){
                    versionBits=this.copyBit(i,j,versionBits);
                }
            }
            lettheParsedVersion=Version$1.decodeVersionInformation(versionBits);
            if(theParsedVersion!==null&&theParsedVersion.getDimensionForVersion()===dimension){
                this.parsedVersion=theParsedVersion;
                returntheParsedVersion;
            }
            //Hmm,failed.Trybottomleft:6wideby3tall
            versionBits=0;
            for(leti=5;i>=0;i--){
                for(letj=dimension-9;j>=ijMin;j--){
                    versionBits=this.copyBit(i,j,versionBits);
                }
            }
            theParsedVersion=Version$1.decodeVersionInformation(versionBits);
            if(theParsedVersion!==null&&theParsedVersion.getDimensionForVersion()===dimension){
                this.parsedVersion=theParsedVersion;
                returntheParsedVersion;
            }
            thrownewFormatException();
        }
        copyBit(i/*int*/,j/*int*/,versionBits/*int*/){
            constbit=this.isMirror?this.bitMatrix.get(j,i):this.bitMatrix.get(i,j);
            returnbit?(versionBits<<1)|0x1:versionBits<<1;
        }
        /**
         *<p>Readsthebitsinthe{@linkBitMatrix}representingthefinderpatterninthe
         *correctorderinordertoreconstructthecodewordsbytescontainedwithinthe
         *QRCode.</p>
         *
         *@returnbytesencodedwithintheQRCode
         *@throwsFormatExceptioniftheexactnumberofbytesexpectedisnotread
         */
        readCodewords(){
            constformatInfo=this.readFormatInformation();
            constversion=this.readVersion();
            //GetthedatamaskfortheformatusedinthisQRCode.Thiswillexclude
            //somebitsfromreadingaswewindthroughthebitmatrix.
            constdataMask=DataMask.values.get(formatInfo.getDataMask());
            constdimension=this.bitMatrix.getHeight();
            dataMask.unmaskBitMatrix(this.bitMatrix,dimension);
            constfunctionPattern=version.buildFunctionPattern();
            letreadingUp=true;
            constresult=newUint8Array(version.getTotalCodewords());
            letresultOffset=0;
            letcurrentByte=0;
            letbitsRead=0;
            //Readcolumnsinpairs,fromrighttoleft
            for(letj=dimension-1;j>0;j-=2){
                if(j===6){
                    //Skipwholecolumnwithverticalalignmentpattern
                    //savestimeandmakestheothercodeproceedmorecleanly
                    j--;
                }
                //Readalternatinglyfrombottomtotopthentoptobottom
                for(letcount=0;count<dimension;count++){
                    consti=readingUp?dimension-1-count:count;
                    for(letcol=0;col<2;col++){
                        //Ignorebitscoveredbythefunctionpattern
                        if(!functionPattern.get(j-col,i)){
                            //Readabit
                            bitsRead++;
                            currentByte<<=1;
                            if(this.bitMatrix.get(j-col,i)){
                                currentByte|=1;
                            }
                            //Ifwe'vemadeawholebyte,saveitoff
                            if(bitsRead===8){
                                result[resultOffset++]=/*(byte)*/currentByte;
                                bitsRead=0;
                                currentByte=0;
                            }
                        }
                    }
                }
                readingUp=!readingUp;//readingUp^=true;//readingUp=!readingUp;//switchdirections
            }
            if(resultOffset!==version.getTotalCodewords()){
                thrownewFormatException();
            }
            returnresult;
        }
        /**
         *Revertthemaskremovaldonewhilereadingthecodewords.Thebitmatrixshouldreverttoitsoriginalstate.
         */
        remask(){
            if(this.parsedFormatInfo===null){
                return;//Wehavenoformatinformation,andhavenodatamask
            }
            constdataMask=DataMask.values[this.parsedFormatInfo.getDataMask()];
            constdimension=this.bitMatrix.getHeight();
            dataMask.unmaskBitMatrix(this.bitMatrix,dimension);
        }
        /**
         *Preparetheparserforamirroredoperation.
         *Thisflaghaseffectonlyonthe{@link#readFormatInformation()}andthe
         *{@link#readVersion()}.Beforeproceedingwith{@link#readCodewords()}the
         *{@link#mirror()}methodshouldbecalled.
         *
         *@parammirrorWhethertoreadversionandformatinformationmirrored.
         */
        setMirror(isMirror){
            this.parsedVersion=null;
            this.parsedFormatInfo=null;
            this.isMirror=isMirror;
        }
        /**Mirrorthebitmatrixinordertoattemptasecondreading.*/
        mirror(){
            constbitMatrix=this.bitMatrix;
            for(letx=0,width=bitMatrix.getWidth();x<width;x++){
                for(lety=x+1,height=bitMatrix.getHeight();y<height;y++){
                    if(bitMatrix.get(x,y)!==bitMatrix.get(y,x)){
                        bitMatrix.flip(y,x);
                        bitMatrix.flip(x,y);
                    }
                }
            }
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>EncapsulatesablockofdatawithinaQRCode.QRCodesmaysplittheirdatainto
     *multipleblocks,eachofwhichisaunitofdataanderror-correctioncodewords.Each
     *isrepresentedbyaninstanceofthisclass.</p>
     *
     *@authorSeanOwen
     */
    classDataBlock$1{
        constructor(numDataCodewords/*int*/,codewords){
            this.numDataCodewords=numDataCodewords;
            this.codewords=codewords;
        }
        /**
         *<p>WhenQRCodesusemultipledatablocks,theyareactuallyinterleaved.
         *Thatis,thefirstbyteofdatablock1toniswritten,thenthesecondbytes,andsoon.This
         *methodwillseparatethedataintooriginalblocks.</p>
         *
         *@paramrawCodewordsbytesasreaddirectlyfromtheQRCode
         *@paramversionversionoftheQRCode
         *@paramecLevelerror-correctionleveloftheQRCode
         *@returnDataBlockscontainingoriginalbytes,"de-interleaved"fromrepresentationinthe
         *        QRCode
         */
        staticgetDataBlocks(rawCodewords,version,ecLevel){
            if(rawCodewords.length!==version.getTotalCodewords()){
                thrownewIllegalArgumentException();
            }
            //Figureoutthenumberandsizeofdatablocksusedbythisversionand
            //errorcorrectionlevel
            constecBlocks=version.getECBlocksForLevel(ecLevel);
            //Firstcountthetotalnumberofdatablocks
            lettotalBlocks=0;
            constecBlockArray=ecBlocks.getECBlocks();
            for(constecBlockofecBlockArray){
                totalBlocks+=ecBlock.getCount();
            }
            //NowestablishDataBlocksoftheappropriatesizeandnumberofdatacodewords
            constresult=newArray(totalBlocks);
            letnumResultBlocks=0;
            for(constecBlockofecBlockArray){
                for(leti=0;i<ecBlock.getCount();i++){
                    constnumDataCodewords=ecBlock.getDataCodewords();
                    constnumBlockCodewords=ecBlocks.getECCodewordsPerBlock()+numDataCodewords;
                    result[numResultBlocks++]=newDataBlock$1(numDataCodewords,newUint8Array(numBlockCodewords));
                }
            }
            //Allblockshavethesameamountofdata,exceptthatthelastn
            //(wherenmaybe0)have1morebyte.Figureoutwherethesestart.
            constshorterBlocksTotalCodewords=result[0].codewords.length;
            letlongerBlocksStartAt=result.length-1;
            //TYPESCRIPTPORT:checklengthiscorrecthere
            while(longerBlocksStartAt>=0){
                constnumCodewords=result[longerBlocksStartAt].codewords.length;
                if(numCodewords===shorterBlocksTotalCodewords){
                    break;
                }
                longerBlocksStartAt--;
            }
            longerBlocksStartAt++;
            constshorterBlocksNumDataCodewords=shorterBlocksTotalCodewords-ecBlocks.getECCodewordsPerBlock();
            //Thelastelementsofresultmaybe1elementlonger
            //firstfilloutasmanyelementsasallofthemhave
            letrawCodewordsOffset=0;
            for(leti=0;i<shorterBlocksNumDataCodewords;i++){
                for(letj=0;j<numResultBlocks;j++){
                    result[j].codewords[i]=rawCodewords[rawCodewordsOffset++];
                }
            }
            //Filloutthelastdatablockinthelongerones
            for(letj=longerBlocksStartAt;j<numResultBlocks;j++){
                result[j].codewords[shorterBlocksNumDataCodewords]=rawCodewords[rawCodewordsOffset++];
            }
            //Nowaddinerrorcorrectionblocks
            constmax=result[0].codewords.length;
            for(leti=shorterBlocksNumDataCodewords;i<max;i++){
                for(letj=0;j<numResultBlocks;j++){
                    constiOffset=j<longerBlocksStartAt?i:i+1;
                    result[j].codewords[iOffset]=rawCodewords[rawCodewordsOffset++];
                }
            }
            returnresult;
        }
        getNumDataCodewords(){
            returnthis.numDataCodewords;
        }
        getCodewords(){
            returnthis.codewords;
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    varModeValues;
    (function(ModeValues){
        ModeValues[ModeValues["TERMINATOR"]=0]="TERMINATOR";
        ModeValues[ModeValues["NUMERIC"]=1]="NUMERIC";
        ModeValues[ModeValues["ALPHANUMERIC"]=2]="ALPHANUMERIC";
        ModeValues[ModeValues["STRUCTURED_APPEND"]=3]="STRUCTURED_APPEND";
        ModeValues[ModeValues["BYTE"]=4]="BYTE";
        ModeValues[ModeValues["ECI"]=5]="ECI";
        ModeValues[ModeValues["KANJI"]=6]="KANJI";
        ModeValues[ModeValues["FNC1_FIRST_POSITION"]=7]="FNC1_FIRST_POSITION";
        ModeValues[ModeValues["FNC1_SECOND_POSITION"]=8]="FNC1_SECOND_POSITION";
        /**SeeGBT18284-2000;"Hanzi"isatransliterationofthismodename.*/
        ModeValues[ModeValues["HANZI"]=9]="HANZI";
    })(ModeValues||(ModeValues={}));
    /**
     *<p>SeeISO18004:2006,6.4.1,Tables2and3.Thisenumencapsulatesthevariousmodesinwhich
     *datacanbeencodedtobitsintheQRcodestandard.</p>
     *
     *@authorSeanOwen
     */
    classMode$1{
        constructor(value,stringValue,characterCountBitsForVersions,bits/*int*/){
            this.value=value;
            this.stringValue=stringValue;
            this.characterCountBitsForVersions=characterCountBitsForVersions;
            this.bits=bits;
            Mode$1.FOR_BITS.set(bits,this);
            Mode$1.FOR_VALUE.set(value,this);
        }
        /**
         *@parambitsfourbitsencodingaQRCodedatamode
         *@returnModeencodedbythesebits
         *@throwsIllegalArgumentExceptionifbitsdonotcorrespondtoaknownmode
         */
        staticforBits(bits/*int*/){
            constmode=Mode$1.FOR_BITS.get(bits);
            if(undefined===mode){
                thrownewIllegalArgumentException();
            }
            returnmode;
        }
        /**
         *@paramversionversioninquestion
         *@returnnumberofbitsused,inthisQRCodesymbol{@linkVersion},toencodethe
         *        countofcharactersthatwillfollowencodedinthisMode
         */
        getCharacterCountBits(version){
            constversionNumber=version.getVersionNumber();
            letoffset;
            if(versionNumber<=9){
                offset=0;
            }
            elseif(versionNumber<=26){
                offset=1;
            }
            else{
                offset=2;
            }
            returnthis.characterCountBitsForVersions[offset];
        }
        getValue(){
            returnthis.value;
        }
        getBits(){
            returnthis.bits;
        }
        equals(o){
            if(!(oinstanceofMode$1)){
                returnfalse;
            }
            constother=o;
            returnthis.value===other.value;
        }
        toString(){
            returnthis.stringValue;
        }
    }
    Mode$1.FOR_BITS=newMap();
    Mode$1.FOR_VALUE=newMap();
    Mode$1.TERMINATOR=newMode$1(ModeValues.TERMINATOR,'TERMINATOR',Int32Array.from([0,0,0]),0x00);//Notreallyamode...
    Mode$1.NUMERIC=newMode$1(ModeValues.NUMERIC,'NUMERIC',Int32Array.from([10,12,14]),0x01);
    Mode$1.ALPHANUMERIC=newMode$1(ModeValues.ALPHANUMERIC,'ALPHANUMERIC',Int32Array.from([9,11,13]),0x02);
    Mode$1.STRUCTURED_APPEND=newMode$1(ModeValues.STRUCTURED_APPEND,'STRUCTURED_APPEND',Int32Array.from([0,0,0]),0x03);//Notsupported
    Mode$1.BYTE=newMode$1(ModeValues.BYTE,'BYTE',Int32Array.from([8,16,16]),0x04);
    Mode$1.ECI=newMode$1(ModeValues.ECI,'ECI',Int32Array.from([0,0,0]),0x07);//charactercountsdon'tapply
    Mode$1.KANJI=newMode$1(ModeValues.KANJI,'KANJI',Int32Array.from([8,10,12]),0x08);
    Mode$1.FNC1_FIRST_POSITION=newMode$1(ModeValues.FNC1_FIRST_POSITION,'FNC1_FIRST_POSITION',Int32Array.from([0,0,0]),0x05);
    Mode$1.FNC1_SECOND_POSITION=newMode$1(ModeValues.FNC1_SECOND_POSITION,'FNC1_SECOND_POSITION',Int32Array.from([0,0,0]),0x09);
    /**SeeGBT18284-2000;"Hanzi"isatransliterationofthismodename.*/
    Mode$1.HANZI=newMode$1(ModeValues.HANZI,'HANZI',Int32Array.from([8,10,12]),0x0D);

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*importjava.io.UnsupportedEncodingException;*/
    /*importjava.util.ArrayList;*/
    /*importjava.util.Collection;*/
    /*importjava.util.List;*/
    /*importjava.util.Map;*/
    /**
     *<p>QRCodescanencodetextasbitsinoneofseveralmodes,andcanusemultiplemodes
     *inoneQRCode.Thisclassdecodesthebitsbackintotext.</p>
     *
     *<p>SeeISO18004:2006,6.4.3-6.4.7</p>
     *
     *@authorSeanOwen
     */
    classDecodedBitStreamParser$1{
        staticdecode(bytes,version,ecLevel,hints){
            constbits=newBitSource(bytes);
            letresult=newStringBuilder();
            constbyteSegments=newArray();//1
            //TYPESCRIPTPORT:Idonotuseconstructorwithsize1asinoriginalJavameanscapacityandthearraylengthischeckedbelow
            letsymbolSequence=-1;
            letparityData=-1;
            try{
                letcurrentCharacterSetECI=null;
                letfc1InEffect=false;
                letmode;
                do{
                    //Whilestillanothersegmenttoread...
                    if(bits.available()<4){
                        //OK,assumewe'redone.Really,aTERMINATORmodeshouldhavebeenrecordedhere
                        mode=Mode$1.TERMINATOR;
                    }
                    else{
                        constmodeBits=bits.readBits(4);
                        mode=Mode$1.forBits(modeBits);//modeisencodedby4bits
                    }
                    switch(mode){
                        caseMode$1.TERMINATOR:
                            break;
                        caseMode$1.FNC1_FIRST_POSITION:
                        caseMode$1.FNC1_SECOND_POSITION:
                            //WedolittlewithFNC1exceptaltertheparsedresultabitaccordingtothespec
                            fc1InEffect=true;
                            break;
                        caseMode$1.STRUCTURED_APPEND:
                            if(bits.available()<16){
                                thrownewFormatException();
                            }
                            //sequencenumberandparityisaddedlatertotheresultmetadata
                            //Readnext8bits(symbolsequence#)and8bits(data:parity),thencontinue
                            symbolSequence=bits.readBits(8);
                            parityData=bits.readBits(8);
                            break;
                        caseMode$1.ECI:
                            //Countdoesn'tapplytoECI
                            constvalue=DecodedBitStreamParser$1.parseECIValue(bits);
                            currentCharacterSetECI=CharacterSetECI.getCharacterSetECIByValue(value);
                            if(currentCharacterSetECI===null){
                                thrownewFormatException();
                            }
                            break;
                        caseMode$1.HANZI:
                            //FirsthandleHanzimodewhichdoesnotstartwithcharactercount
                            //Chinesemodecontainsasubsetindicatorrightaftermodeindicator
                            constsubset=bits.readBits(4);
                            constcountHanzi=bits.readBits(mode.getCharacterCountBits(version));
                            if(subset===DecodedBitStreamParser$1.GB2312_SUBSET){
                                DecodedBitStreamParser$1.decodeHanziSegment(bits,result,countHanzi);
                            }
                            break;
                        default:
                            //"Normal"QRcodemodes:
                            //Howmanycharacterswillfollow,encodedinthismode?
                            constcount=bits.readBits(mode.getCharacterCountBits(version));
                            switch(mode){
                                caseMode$1.NUMERIC:
                                    DecodedBitStreamParser$1.decodeNumericSegment(bits,result,count);
                                    break;
                                caseMode$1.ALPHANUMERIC:
                                    DecodedBitStreamParser$1.decodeAlphanumericSegment(bits,result,count,fc1InEffect);
                                    break;
                                caseMode$1.BYTE:
                                    DecodedBitStreamParser$1.decodeByteSegment(bits,result,count,currentCharacterSetECI,byteSegments,hints);
                                    break;
                                caseMode$1.KANJI:
                                    DecodedBitStreamParser$1.decodeKanjiSegment(bits,result,count);
                                    break;
                                default:
                                    thrownewFormatException();
                            }
                            break;
                    }
                }while(mode!==Mode$1.TERMINATOR);
            }
            catch(iae/*:IllegalArgumentException*/){
                //fromreadBits()calls
                thrownewFormatException();
            }
            returnnewDecoderResult(bytes,result.toString(),byteSegments.length===0?null:byteSegments,ecLevel===null?null:ecLevel.toString(),symbolSequence,parityData);
        }
        /**
         *SeespecificationGBT18284-2000
         */
        staticdecodeHanziSegment(bits,result,count/*int*/){
            //Don'tcrashtryingtoreadmorebitsthanwehaveavailable.
            if(count*13>bits.available()){
                thrownewFormatException();
            }
            //Eachcharacterwillrequire2bytes.Readthecharactersas2-bytepairs
            //anddecodeasGB2312afterwards
            constbuffer=newUint8Array(2*count);
            letoffset=0;
            while(count>0){
                //Each13bitsencodesa2-bytecharacter
                consttwoBytes=bits.readBits(13);
                letassembledTwoBytes=(((twoBytes/0x060)<<8)&0xFFFFFFFF)|(twoBytes%0x060);
                if(assembledTwoBytes<0x003BF){
                    //Inthe0xA1A1to0xAAFErange
                    assembledTwoBytes+=0x0A1A1;
                }
                else{
                    //Inthe0xB0A1to0xFAFErange
                    assembledTwoBytes+=0x0A6A1;
                }
                buffer[offset]=/*(byte)*/((assembledTwoBytes>>8)&0xFF);
                buffer[offset+1]=/*(byte)*/(assembledTwoBytes&0xFF);
                offset+=2;
                count--;
            }
            try{
                result.append(StringEncoding.decode(buffer,StringUtils.GB2312));
                //TYPESCRIPTPORT:TODO:implementGB2312decode.StringViewfromMDNcouldbeastartingpoint
            }
            catch(ignored/*:UnsupportedEncodingException*/){
                thrownewFormatException(ignored);
            }
        }
        staticdecodeKanjiSegment(bits,result,count/*int*/){
            //Don'tcrashtryingtoreadmorebitsthanwehaveavailable.
            if(count*13>bits.available()){
                thrownewFormatException();
            }
            //Eachcharacterwillrequire2bytes.Readthecharactersas2-bytepairs
            //anddecodeasShift_JISafterwards
            constbuffer=newUint8Array(2*count);
            letoffset=0;
            while(count>0){
                //Each13bitsencodesa2-bytecharacter
                consttwoBytes=bits.readBits(13);
                letassembledTwoBytes=(((twoBytes/0x0C0)<<8)&0xFFFFFFFF)|(twoBytes%0x0C0);
                if(assembledTwoBytes<0x01F00){
                    //Inthe0x8140to0x9FFCrange
                    assembledTwoBytes+=0x08140;
                }
                else{
                    //Inthe0xE040to0xEBBFrange
                    assembledTwoBytes+=0x0C140;
                }
                buffer[offset]=/*(byte)*/(assembledTwoBytes>>8);
                buffer[offset+1]=/*(byte)*/assembledTwoBytes;
                offset+=2;
                count--;
            }
            //Shift_JISmaynotbesupportedinsomeenvironments:
            try{
                result.append(StringEncoding.decode(buffer,StringUtils.SHIFT_JIS));
                //TYPESCRIPTPORT:TODO:implementSHIFT_JISdecode.StringViewfromMDNcouldbeastartingpoint
            }
            catch(ignored/*:UnsupportedEncodingException*/){
                thrownewFormatException(ignored);
            }
        }
        staticdecodeByteSegment(bits,result,count/*int*/,currentCharacterSetECI,byteSegments,hints){
            //Don'tcrashtryingtoreadmorebitsthanwehaveavailable.
            if(8*count>bits.available()){
                thrownewFormatException();
            }
            constreadBytes=newUint8Array(count);
            for(leti=0;i<count;i++){
                readBytes[i]=/*(byte)*/bits.readBits(8);
            }
            letencoding;
            if(currentCharacterSetECI===null){
                //Thespecisn'tclearonthismode;see
                //section6.4.5:tdoesnotsaywhichencodingtoassuming
                //upondecoding.IhaveseenISO-8859-1usedaswellas
                //Shift_JIS--withoutanythinglikeanECIdesignatorto
                //giveahint.
                encoding=StringUtils.guessEncoding(readBytes,hints);
            }
            else{
                encoding=currentCharacterSetECI.getName();
            }
            try{
                result.append(StringEncoding.decode(readBytes,encoding));
            }
            catch(ignored/*:UnsupportedEncodingException*/){
                thrownewFormatException(ignored);
            }
            byteSegments.push(readBytes);
        }
        statictoAlphaNumericChar(value/*int*/){
            if(value>=DecodedBitStreamParser$1.ALPHANUMERIC_CHARS.length){
                thrownewFormatException();
            }
            returnDecodedBitStreamParser$1.ALPHANUMERIC_CHARS[value];
        }
        staticdecodeAlphanumericSegment(bits,result,count/*int*/,fc1InEffect){
            //Readtwocharactersatatime
            conststart=result.length();
            while(count>1){
                if(bits.available()<11){
                    thrownewFormatException();
                }
                constnextTwoCharsBits=bits.readBits(11);
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(nextTwoCharsBits/45)));
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(nextTwoCharsBits%45));
                count-=2;
            }
            if(count===1){
                //specialcase:onecharacterleft
                if(bits.available()<6){
                    thrownewFormatException();
                }
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(bits.readBits(6)));
            }
            //Seesection6.4.8.1,6.4.8.2
            if(fc1InEffect){
                //WeneedtomassagetheresultabitifinanFNC1mode:
                for(leti=start;i<result.length();i++){
                    if(result.charAt(i)==='%'){
                        if(i<result.length()-1&&result.charAt(i+1)==='%'){
                            //%%isrenderedas%
                            result.deleteCharAt(i+1);
                        }
                        else{
                            //Inalphamode,%shouldbeconvertedtoFNC1separator0x1D
                            result.setCharAt(i,String.fromCharCode(0x1D));
                        }
                    }
                }
            }
        }
        staticdecodeNumericSegment(bits,result,count/*int*/){
            //Readthreedigitsatatime
            while(count>=3){
                //Each10bitsencodesthreedigits
                if(bits.available()<10){
                    thrownewFormatException();
                }
                constthreeDigitsBits=bits.readBits(10);
                if(threeDigitsBits>=1000){
                    thrownewFormatException();
                }
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits/100)));
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits/10)%10));
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(threeDigitsBits%10));
                count-=3;
            }
            if(count===2){
                //Twodigitsleftovertoread,encodedin7bits
                if(bits.available()<7){
                    thrownewFormatException();
                }
                consttwoDigitsBits=bits.readBits(7);
                if(twoDigitsBits>=100){
                    thrownewFormatException();
                }
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(twoDigitsBits/10)));
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(twoDigitsBits%10));
            }
            elseif(count===1){
                //Onedigitleftovertoread
                if(bits.available()<4){
                    thrownewFormatException();
                }
                constdigitBits=bits.readBits(4);
                if(digitBits>=10){
                    thrownewFormatException();
                }
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(digitBits));
            }
        }
        staticparseECIValue(bits){
            constfirstByte=bits.readBits(8);
            if((firstByte&0x80)===0){
                //justonebyte
                returnfirstByte&0x7F;
            }
            if((firstByte&0xC0)===0x80){
                //twobytes
                constsecondByte=bits.readBits(8);
                return(((firstByte&0x3F)<<8)&0xFFFFFFFF)|secondByte;
            }
            if((firstByte&0xE0)===0xC0){
                //threebytes
                constsecondThirdBytes=bits.readBits(16);
                return(((firstByte&0x1F)<<16)&0xFFFFFFFF)|secondThirdBytes;
            }
            thrownewFormatException();
        }
    }
    /**
     *SeeISO18004:2006,6.4.4Table5
     */
    DecodedBitStreamParser$1.ALPHANUMERIC_CHARS='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$%*+-./:';
    DecodedBitStreamParser$1.GB2312_SUBSET=1;
    //functionUint8ArrayToString(a:Uint8Array):string{
    //    constCHUNK_SZ=0x8000;
    //    constc=newStringBuilder();
    //    for(leti=0,length=a.length;i<length;i+=CHUNK_SZ){
    //        c.append(String.fromCharCode.apply(null,a.subarray(i,i+CHUNK_SZ)));
    //    }
    //    returnc.toString();
    //}

    /*
     *Copyright2013ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *Meta-datacontainerforQRCodedecoding.Instancesofthisclassmaybeusedtoconveyinformationbacktothe
     *decodingcaller.Callersareexpectedtoprocessthis.
     *
     *@seecom.google.zxing.common.DecoderResult#getOther()
     */
    classQRCodeDecoderMetaData{
        constructor(mirrored){
            this.mirrored=mirrored;
        }
        /**
         *@returntrueiftheQRCodewasmirrored.
         */
        isMirrored(){
            returnthis.mirrored;
        }
        /**
         *Applytheresultpoints'ordercorrectionduetomirroring.
         *
         *@parampointsArrayofpointstoapplymirrorcorrectionto.
         */
        applyMirroredCorrection(points){
            if(!this.mirrored||points===null||points.length<3){
                return;
            }
            constbottomLeft=points[0];
            points[0]=points[2];
            points[2]=bottomLeft;
            //Noneedto'fix'top-leftandalignmentpattern.
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*importjava.util.Map;*/
    /**
     *<p>ThemainclasswhichimplementsQRCodedecoding--asopposedtolocatingandextracting
     *theQRCodefromanimage.</p>
     *
     *@authorSeanOwen
     */
    classDecoder$2{
        constructor(){
            this.rsDecoder=newReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);
        }
        //publicdecode(image:boolean[][]):DecoderResult/*throwsChecksumException,FormatException*/{
        //  returndecode(image,null)
        //}
        /**
         *<p>ConveniencemethodthatcandecodeaQRCoderepresentedasa2Darrayofbooleans.
         *"true"istakentomeanablackmodule.</p>
         *
         *@paramimagebooleansrepresentingwhite/blackQRCodemodules
         *@paramhintsdecodinghintsthatshouldbeusedtoinfluencedecoding
         *@returntextandbytesencodedwithintheQRCode
         *@throwsFormatExceptioniftheQRCodecannotbedecoded
         *@throwsChecksumExceptioniferrorcorrectionfails
         */
        decodeBooleanArray(image,hints){
            returnthis.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image),hints);
        }
        //publicdecodeBitMatrix(bits:BitMatrix):DecoderResult/*throwsChecksumException,FormatException*/{
        //  returndecode(bits,null)
        //}
        /**
         *<p>DecodesaQRCoderepresentedasa{@linkBitMatrix}.A1or"true"istakentomeanablackmodule.</p>
         *
         *@parambitsbooleansrepresentingwhite/blackQRCodemodules
         *@paramhintsdecodinghintsthatshouldbeusedtoinfluencedecoding
         *@returntextandbytesencodedwithintheQRCode
         *@throwsFormatExceptioniftheQRCodecannotbedecoded
         *@throwsChecksumExceptioniferrorcorrectionfails
         */
        decodeBitMatrix(bits,hints){
            //Constructaparserandreadversion,error-correctionlevel
            constparser=newBitMatrixParser$1(bits);
            letex=null;
            try{
                returnthis.decodeBitMatrixParser(parser,hints);
            }
            catch(e/*:FormatException,ChecksumException*/){
                ex=e;
            }
            try{
                //Revertthebitmatrix
                parser.remask();
                //Willbeattemptingamirroredreadingoftheversionandformatinfo.
                parser.setMirror(true);
                //Preemptivelyreadtheversion.
                parser.readVersion();
                //Preemptivelyreadtheformatinformation.
                parser.readFormatInformation();
                /*
                 *Sincewe'rehere,thismeanswehavesuccessfullydetectedsomekind
                 *ofversionandformatinformationwhenmirrored.Thisisagoodsign,
                 *thattheQRcodemaybemirrored,andweshouldtryoncemorewitha
                 *mirroredcontent.
                 */
                //Prepareforamirroredreading.
                parser.mirror();
                constresult=this.decodeBitMatrixParser(parser,hints);
                //Success!Notifythecallerthatthecodewasmirrored.
                result.setOther(newQRCodeDecoderMetaData(true));
                returnresult;
            }
            catch(e/*FormatException|ChecksumException*/){
                //Throwtheexceptionfromtheoriginalreading
                if(ex!==null){
                    throwex;
                }
                throwe;
            }
        }
        decodeBitMatrixParser(parser,hints){
            constversion=parser.readVersion();
            constecLevel=parser.readFormatInformation().getErrorCorrectionLevel();
            //Readcodewords
            constcodewords=parser.readCodewords();
            //Separateintodatablocks
            constdataBlocks=DataBlock$1.getDataBlocks(codewords,version,ecLevel);
            //Counttotalnumberofdatabytes
            lettotalBytes=0;
            for(constdataBlockofdataBlocks){
                totalBytes+=dataBlock.getNumDataCodewords();
            }
            constresultBytes=newUint8Array(totalBytes);
            letresultOffset=0;
            //Error-correctandcopydatablockstogetherintoastreamofbytes
            for(constdataBlockofdataBlocks){
                constcodewordBytes=dataBlock.getCodewords();
                constnumDataCodewords=dataBlock.getNumDataCodewords();
                this.correctErrors(codewordBytes,numDataCodewords);
                for(leti=0;i<numDataCodewords;i++){
                    resultBytes[resultOffset++]=codewordBytes[i];
                }
            }
            //Decodethecontentsofthatstreamofbytes
            returnDecodedBitStreamParser$1.decode(resultBytes,version,ecLevel,hints);
        }
        /**
         *<p>Givendataanderror-correctioncodewordsreceived,possiblycorruptedbyerrors,attemptsto
         *correcttheerrorsin-placeusingReed-Solomonerrorcorrection.</p>
         *
         *@paramcodewordBytesdataanderrorcorrectioncodewords
         *@paramnumDataCodewordsnumberofcodewordsthataredatabytes
         *@throwsChecksumExceptioniferrorcorrectionfails
         */
        correctErrors(codewordBytes,numDataCodewords/*int*/){
            //constnumCodewords=codewordBytes.length;
            //Firstreadintoanarrayofints
            constcodewordsInts=newInt32Array(codewordBytes);
            //TYPESCRIPTPORT:notrealynecessarytotransformtoints?couldredesigneverythingtoworkwithunsignedbytes?
            //constcodewordsInts=newInt32Array(numCodewords)
            //for(leti=0;i<numCodewords;i++){
            //  codewordsInts[i]=codewordBytes[i]&0xFF
            //}
            try{
                this.rsDecoder.decode(codewordsInts,codewordBytes.length-numDataCodewords);
            }
            catch(ignored/*:ReedSolomonException*/){
                thrownewChecksumException();
            }
            //Copybackintoarrayofbytes--onlyneedtoworryaboutthebytesthatweredata
            //Wedon'tcareabouterrorsintheerror-correctioncodewords
            for(leti=0;i<numDataCodewords;i++){
                codewordBytes[i]=/*(byte)*/codewordsInts[i];
            }
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Encapsulatesanalignmentpattern,whicharethesmallersquarepatternsfoundin
     *allbutthesimplestQRCodes.</p>
     *
     *@authorSeanOwen
     */
    classAlignmentPatternextendsResultPoint{
        constructor(posX/*float*/,posY/*float*/,estimatedModuleSize/*float*/){
            super(posX,posY);
            this.estimatedModuleSize=estimatedModuleSize;
        }
        /**
         *<p>Determinesifthisalignmentpattern"aboutequals"analignmentpatternatthestated
         *positionandsize--meaning,itisatnearlythesamecenterwithnearlythesamesize.</p>
         */
        aboutEquals(moduleSize/*float*/,i/*float*/,j/*float*/){
            if(Math.abs(i-this.getY())<=moduleSize&&Math.abs(j-this.getX())<=moduleSize){
                constmoduleSizeDiff=Math.abs(moduleSize-this.estimatedModuleSize);
                returnmoduleSizeDiff<=1.0||moduleSizeDiff<=this.estimatedModuleSize;
            }
            returnfalse;
        }
        /**
         *Combinesthisobject'scurrentestimateofafinderpatternpositionandmodulesize
         *withanewestimate.Itreturnsanew{@codeFinderPattern}containinganaverageofthetwo.
         */
        combineEstimate(i/*float*/,j/*float*/,newModuleSize/*float*/){
            constcombinedX=(this.getX()+j)/2.0;
            constcombinedY=(this.getY()+i)/2.0;
            constcombinedModuleSize=(this.estimatedModuleSize+newModuleSize)/2.0;
            returnnewAlignmentPattern(combinedX,combinedY,combinedModuleSize);
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*importjava.util.ArrayList;*/
    /*importjava.util.List;*/
    /**
     *<p>ThisclassattemptstofindalignmentpatternsinaQRCode.Alignmentpatternslooklikefinder
     *patternsbutaresmallerandappearatregularintervalsthroughouttheimage.</p>
     *
     *<p>Atthemomentthisonlylooksforthebottom-rightalignmentpattern.</p>
     *
     *<p>Thisismostlyasimplifiedcopyof{@linkFinderPatternFinder}.Itiscopied,
     *pastedandstrippeddownhereformaximumperformancebutdoesunfortunatelyduplicate
     *somecode.</p>
     *
     *<p>Thisclassisthread-safebutnotreentrant.Eachthreadmustallocateitsownobject.</p>
     *
     *@authorSeanOwen
     */
    classAlignmentPatternFinder{
        /**
         *<p>Createsafinderthatwilllookinaportionofthewholeimage.</p>
         *
         *@paramimageimagetosearch
         *@paramstartXleftcolumnfromwhichtostartsearching
         *@paramstartYtoprowfromwhichtostartsearching
         *@paramwidthwidthofregiontosearch
         *@paramheightheightofregiontosearch
         *@parammoduleSizeestimatedmodulesizesofar
         */
        constructor(image,startX/*int*/,startY/*int*/,width/*int*/,height/*int*/,moduleSize/*float*/,resultPointCallback){
            this.image=image;
            this.startX=startX;
            this.startY=startY;
            this.width=width;
            this.height=height;
            this.moduleSize=moduleSize;
            this.resultPointCallback=resultPointCallback;
            this.possibleCenters=[];//newArray<any>(5))
            //TYPESCRIPTPORT:arrayinitializationwithoutsizeasthelengthischeckedbelow
            this.crossCheckStateCount=newInt32Array(3);
        }
        /**
         *<p>Thismethodattemptstofindthebottom-rightalignmentpatternintheimage.Itisabitmessysince
         *it'sprettyperformance-criticalandsoiswrittentobefastforemost.</p>
         *
         *@return{@linkAlignmentPattern}iffound
         *@throwsNotFoundExceptionifnotfound
         */
        find(){
            conststartX=this.startX;
            constheight=this.height;
            constwidth=this.width;
            constmaxJ=startX+width;
            constmiddleI=this.startY+(height/2);
            //Wearelookingforblack/white/blackmodulesin1:1:1ratio
            //thistracksthenumberofblack/white/blackmodulesseensofar
            conststateCount=newInt32Array(3);
            constimage=this.image;
            for(letiGen=0;iGen<height;iGen++){
                //Searchfrommiddleoutwards
                consti=middleI+((iGen&0x01)===0?Math.floor((iGen+1)/2):-Math.floor((iGen+1)/2));
                stateCount[0]=0;
                stateCount[1]=0;
                stateCount[2]=0;
                letj=startX;
                //Burnoffleadingwhitepixelsbeforeanythingelse;ifwestartinthemiddleof
                //awhiterun,itdoesn'tmakesensetocountitslength,sincewedon'tknowifthe
                //whiteruncontinuedtotheleftofthestartpoint
                while(j<maxJ&&!image.get(j,i)){
                    j++;
                }
                letcurrentState=0;
                while(j<maxJ){
                    if(image.get(j,i)){
                        //Blackpixel
                        if(currentState===1){//Countingblackpixels
                            stateCount[1]++;
                        }
                        else{//Countingwhitepixels
                            if(currentState===2){//Awinner?
                                if(this.foundPatternCross(stateCount)){//Yes
                                    constconfirmed=this.handlePossibleCenter(stateCount,i,j);
                                    if(confirmed!==null){
                                        returnconfirmed;
                                    }
                                }
                                stateCount[0]=stateCount[2];
                                stateCount[1]=1;
                                stateCount[2]=0;
                                currentState=1;
                            }
                            else{
                                stateCount[++currentState]++;
                            }
                        }
                    }
                    else{//Whitepixel
                        if(currentState===1){//Countingblackpixels
                            currentState++;
                        }
                        stateCount[currentState]++;
                    }
                    j++;
                }
                if(this.foundPatternCross(stateCount)){
                    constconfirmed=this.handlePossibleCenter(stateCount,i,maxJ);
                    if(confirmed!==null){
                        returnconfirmed;
                    }
                }
            }
            //Hmm,nothingwesawwasobservedandconfirmedtwice.Ifwehad
            //anyguessatall,returnit.
            if(this.possibleCenters.length!==0){
                returnthis.possibleCenters[0];
            }
            thrownewNotFoundException();
        }
        /**
         *Givenacountofblack/white/blackpixelsjustseenandanendposition,
         *figuresthelocationofthecenterofthisblack/white/blackrun.
         */
        staticcenterFromEnd(stateCount,end/*int*/){
            return(end-stateCount[2])-stateCount[1]/2.0;
        }
        /**
         *@paramstateCountcountofblack/white/blackpixelsjustread
         *@returntrueifftheproportionsofthecountsiscloseenoughtothe1/1/1ratios
         *        usedbyalignmentpatternstobeconsideredamatch
         */
        foundPatternCross(stateCount){
            constmoduleSize=this.moduleSize;
            constmaxVariance=moduleSize/2.0;
            for(leti=0;i<3;i++){
                if(Math.abs(moduleSize-stateCount[i])>=maxVariance){
                    returnfalse;
                }
            }
            returntrue;
        }
        /**
         *<p>Afterahorizontalscanfindsapotentialalignmentpattern,thismethod
         *"cross-checks"byscanningdownverticallythroughthecenterofthepossible
         *alignmentpatterntoseeifthesameproportionisdetected.</p>
         *
         *@paramstartIrowwhereanalignmentpatternwasdetected
         *@paramcenterJcenterofthesectionthatappearstocrossanalignmentpattern
         *@parammaxCountmaximumreasonablenumberofmodulesthatshouldbe
         *observedinanyreadingstate,basedontheresultsofthehorizontalscan
         *@returnverticalcenterofalignmentpattern,or{@linkFloat#NaN}ifnotfound
         */
        crossCheckVertical(startI/*int*/,centerJ/*int*/,maxCount/*int*/,originalStateCountTotal/*int*/){
            constimage=this.image;
            constmaxI=image.getHeight();
            conststateCount=this.crossCheckStateCount;
            stateCount[0]=0;
            stateCount[1]=0;
            stateCount[2]=0;
            //Startcountingupfromcenter
            leti=startI;
            while(i>=0&&image.get(centerJ,i)&&stateCount[1]<=maxCount){
                stateCount[1]++;
                i--;
            }
            //Ifalreadytoomanymodulesinthisstateorranofftheedge:
            if(i<0||stateCount[1]>maxCount){
                returnNaN;
            }
            while(i>=0&&!image.get(centerJ,i)&&stateCount[0]<=maxCount){
                stateCount[0]++;
                i--;
            }
            if(stateCount[0]>maxCount){
                returnNaN;
            }
            //Nowalsocountdownfromcenter
            i=startI+1;
            while(i<maxI&&image.get(centerJ,i)&&stateCount[1]<=maxCount){
                stateCount[1]++;
                i++;
            }
            if(i===maxI||stateCount[1]>maxCount){
                returnNaN;
            }
            while(i<maxI&&!image.get(centerJ,i)&&stateCount[2]<=maxCount){
                stateCount[2]++;
                i++;
            }
            if(stateCount[2]>maxCount){
                returnNaN;
            }
            conststateCountTotal=stateCount[0]+stateCount[1]+stateCount[2];
            if(5*Math.abs(stateCountTotal-originalStateCountTotal)>=2*originalStateCountTotal){
                returnNaN;
            }
            returnthis.foundPatternCross(stateCount)?AlignmentPatternFinder.centerFromEnd(stateCount,i):NaN;
        }
        /**
         *<p>Thisiscalledwhenahorizontalscanfindsapossiblealignmentpattern.Itwill
         *crosscheckwithaverticalscan,andifsuccessful,willseeifthispatternhadbeen
         *foundonaprevioushorizontalscan.Ifso,weconsideritconfirmedandconcludewehave
         *foundthealignmentpattern.</p>
         *
         *@paramstateCountreadingstatemodulecountsfromhorizontalscan
         *@paramirowwherealignmentpatternmaybefound
         *@paramjendofpossiblealignmentpatterninrow
         *@return{@linkAlignmentPattern}ifwehavefoundthesamepatterntwice,ornullifnot
         */
        handlePossibleCenter(stateCount,i/*int*/,j/*int*/){
            conststateCountTotal=stateCount[0]+stateCount[1]+stateCount[2];
            constcenterJ=AlignmentPatternFinder.centerFromEnd(stateCount,j);
            constcenterI=this.crossCheckVertical(i,/*(int)*/centerJ,2*stateCount[1],stateCountTotal);
            if(!isNaN(centerI)){
                constestimatedModuleSize=(stateCount[0]+stateCount[1]+stateCount[2])/3.0;
                for(constcenterofthis.possibleCenters){
                    //Lookforaboutthesamecenterandmodulesize:
                    if(center.aboutEquals(estimatedModuleSize,centerI,centerJ)){
                        returncenter.combineEstimate(centerI,centerJ,estimatedModuleSize);
                    }
                }
                //Hadn'tfoundthisbefore;saveit
                constpoint=newAlignmentPattern(centerJ,centerI,estimatedModuleSize);
                this.possibleCenters.push(point);
                if(this.resultPointCallback!==null&&this.resultPointCallback!==undefined){
                    this.resultPointCallback.foundPossibleResultPoint(point);
                }
            }
            returnnull;
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Encapsulatesafinderpattern,whicharethethreesquarepatternsfoundin
     *thecornersofQRCodes.Italsoencapsulatesacountofsimilarfinderpatterns,
     *asaconveniencetothefinder'sbookkeeping.</p>
     *
     *@authorSeanOwen
     */
    classFinderPattern$1extendsResultPoint{
        //FinderPattern(posX:number/*float*/,posY:number/*float*/,estimatedModuleSize:number/*float*/){
        //  this(posX,posY,estimatedModuleSize,1)
        //}
        constructor(posX/*float*/,posY/*float*/,estimatedModuleSize/*float*/,count/*int*/){
            super(posX,posY);
            this.estimatedModuleSize=estimatedModuleSize;
            this.count=count;
            if(undefined===count){
                this.count=1;
            }
        }
        getEstimatedModuleSize(){
            returnthis.estimatedModuleSize;
        }
        getCount(){
            returnthis.count;
        }
        /*
        voidincrementCount(){
          this.count++
        }
         */
        /**
         *<p>Determinesifthisfinderpattern"aboutequals"afinderpatternatthestated
         *positionandsize--meaning,itisatnearlythesamecenterwithnearlythesamesize.</p>
         */
        aboutEquals(moduleSize/*float*/,i/*float*/,j/*float*/){
            if(Math.abs(i-this.getY())<=moduleSize&&Math.abs(j-this.getX())<=moduleSize){
                constmoduleSizeDiff=Math.abs(moduleSize-this.estimatedModuleSize);
                returnmoduleSizeDiff<=1.0||moduleSizeDiff<=this.estimatedModuleSize;
            }
            returnfalse;
        }
        /**
         *Combinesthisobject'scurrentestimateofafinderpatternpositionandmodulesize
         *withanewestimate.Itreturnsanew{@codeFinderPattern}containingaweightedaverage
         *basedoncount.
         */
        combineEstimate(i/*float*/,j/*float*/,newModuleSize/*float*/){
            constcombinedCount=this.count+1;
            constcombinedX=(this.count*this.getX()+j)/combinedCount;
            constcombinedY=(this.count*this.getY()+i)/combinedCount;
            constcombinedModuleSize=(this.count*this.estimatedModuleSize+newModuleSize)/combinedCount;
            returnnewFinderPattern$1(combinedX,combinedY,combinedModuleSize,combinedCount);
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Encapsulatesinformationaboutfinderpatternsinanimage,includingthelocationof
     *thethreefinderpatterns,andtheirestimatedmodulesize.</p>
     *
     *@authorSeanOwen
     */
    classFinderPatternInfo{
        constructor(patternCenters){
            this.bottomLeft=patternCenters[0];
            this.topLeft=patternCenters[1];
            this.topRight=patternCenters[2];
        }
        getBottomLeft(){
            returnthis.bottomLeft;
        }
        getTopLeft(){
            returnthis.topLeft;
        }
        getTopRight(){
            returnthis.topRight;
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*importjava.io.Serializable;*/
    /*importjava.util.ArrayList;*/
    /*importjava.util.Collections;*/
    /*importjava.util.Comparator;*/
    /*importjava.util.List;*/
    /*importjava.util.Map;*/
    /**
     *<p>ThisclassattemptstofindfinderpatternsinaQRCode.Finderpatternsarethesquare
     *markersatthreecornersofaQRCode.</p>
     *
     *<p>Thisclassisthread-safebutnotreentrant.Eachthreadmustallocateitsownobject.
     *
     *@authorSeanOwen
     */
    classFinderPatternFinder{
        /**
         *<p>Createsafinderthatwillsearchtheimageforthreefinderpatterns.</p>
         *
         *@paramimageimagetosearch
         */
        //publicconstructor(image:BitMatrix){
        //  this(image,null)
        //}
        constructor(image,resultPointCallback){
            this.image=image;
            this.resultPointCallback=resultPointCallback;
            this.possibleCenters=[];
            this.crossCheckStateCount=newInt32Array(5);
            this.resultPointCallback=resultPointCallback;
        }
        getImage(){
            returnthis.image;
        }
        getPossibleCenters(){
            returnthis.possibleCenters;
        }
        find(hints){
            consttryHarder=(hints!==null&&hints!==undefined)&&undefined!==hints.get(DecodeHintType$1.TRY_HARDER);
            constpureBarcode=(hints!==null&&hints!==undefined)&&undefined!==hints.get(DecodeHintType$1.PURE_BARCODE);
            constimage=this.image;
            constmaxI=image.getHeight();
            constmaxJ=image.getWidth();
            //Wearelookingforblack/white/black/white/blackmodulesin
            //1:1:3:1:1ratio;thistracksthenumberofsuchmodulesseensofar
            //Let'sassumethatthemaximumversionQRCodewesupporttakesup1/4theheightofthe
            //image,andthenaccountforthecenterbeing3modulesinsize.Thisgivesthesmallest
            //numberofpixelsthecentercouldbe,soskipthisoften.Whentryingharder,lookforall
            //QRversionsregardlessofhowdensetheyare.
            letiSkip=Math.floor((3*maxI)/(4*FinderPatternFinder.MAX_MODULES));
            if(iSkip<FinderPatternFinder.MIN_SKIP||tryHarder){
                iSkip=FinderPatternFinder.MIN_SKIP;
            }
            letdone=false;
            conststateCount=newInt32Array(5);
            for(leti=iSkip-1;i<maxI&&!done;i+=iSkip){
                //Getarowofblack/whitevalues
                stateCount[0]=0;
                stateCount[1]=0;
                stateCount[2]=0;
                stateCount[3]=0;
                stateCount[4]=0;
                letcurrentState=0;
                for(letj=0;j<maxJ;j++){
                    if(image.get(j,i)){
                        //Blackpixel
                        if((currentState&1)===1){//Countingwhitepixels
                            currentState++;
                        }
                        stateCount[currentState]++;
                    }
                    else{//Whitepixel
                        if((currentState&1)===0){//Countingblackpixels
                            if(currentState===4){//Awinner?
                                if(FinderPatternFinder.foundPatternCross(stateCount)){//Yes
                                    constconfirmed=this.handlePossibleCenter(stateCount,i,j,pureBarcode);
                                    if(confirmed===true){
                                        //Startexaminingeveryotherline.Checkingeachlineturnedouttobetoo
                                        //expensiveanddidn'timproveperformance.
                                        iSkip=2;
                                        if(this.hasSkipped===true){
                                            done=this.haveMultiplyConfirmedCenters();
                                        }
                                        else{
                                            constrowSkip=this.findRowSkip();
                                            if(rowSkip>stateCount[2]){
                                                //Skiprowsbetweenrowoflowerconfirmedcenter
                                                //andtopofpresumedthirdconfirmedcenter
                                                //butbackupabittogetafullchanceofdetecting
                                                //it,entirewidthofcenteroffinderpattern
                                                //SkipbyrowSkip,butbackoffbystateCount[2](sizeoflastcenter
                                                //ofpatternwesaw)tobeconservative,andalsobackoffbyiSkipwhich
                                                //isabouttobere-added
                                                i+=rowSkip-stateCount[2]-iSkip;
                                                j=maxJ-1;
                                            }
                                        }
                                    }
                                    else{
                                        stateCount[0]=stateCount[2];
                                        stateCount[1]=stateCount[3];
                                        stateCount[2]=stateCount[4];
                                        stateCount[3]=1;
                                        stateCount[4]=0;
                                        currentState=3;
                                        continue;
                                    }
                                    //Clearstatetostartlookingagain
                                    currentState=0;
                                    stateCount[0]=0;
                                    stateCount[1]=0;
                                    stateCount[2]=0;
                                    stateCount[3]=0;
                                    stateCount[4]=0;
                                }
                                else{//No,shiftcountsbackbytwo
                                    stateCount[0]=stateCount[2];
                                    stateCount[1]=stateCount[3];
                                    stateCount[2]=stateCount[4];
                                    stateCount[3]=1;
                                    stateCount[4]=0;
                                    currentState=3;
                                }
                            }
                            else{
                                stateCount[++currentState]++;
                            }
                        }
                        else{//Countingwhitepixels
                            stateCount[currentState]++;
                        }
                    }
                }
                if(FinderPatternFinder.foundPatternCross(stateCount)){
                    constconfirmed=this.handlePossibleCenter(stateCount,i,maxJ,pureBarcode);
                    if(confirmed===true){
                        iSkip=stateCount[0];
                        if(this.hasSkipped){
                            //Foundathirdone
                            done=this.haveMultiplyConfirmedCenters();
                        }
                    }
                }
            }
            constpatternInfo=this.selectBestPatterns();
            ResultPoint.orderBestPatterns(patternInfo);
            returnnewFinderPatternInfo(patternInfo);
        }
        /**
         *Givenacountofblack/white/black/white/blackpixelsjustseenandanendposition,
         *figuresthelocationofthecenterofthisrun.
         */
        staticcenterFromEnd(stateCount,end/*int*/){
            return(end-stateCount[4]-stateCount[3])-stateCount[2]/2.0;
        }
        /**
         *@paramstateCountcountofblack/white/black/white/blackpixelsjustread
         *@returntrueifftheproportionsofthecountsiscloseenoughtothe1/1/3/1/1ratios
         *        usedbyfinderpatternstobeconsideredamatch
         */
        staticfoundPatternCross(stateCount){
            lettotalModuleSize=0;
            for(leti=0;i<5;i++){
                constcount=stateCount[i];
                if(count===0){
                    returnfalse;
                }
                totalModuleSize+=count;
            }
            if(totalModuleSize<7){
                returnfalse;
            }
            constmoduleSize=totalModuleSize/7.0;
            constmaxVariance=moduleSize/2.0;
            //Allowlessthan50%variancefrom1-1-3-1-1proportions
            returnMath.abs(moduleSize-stateCount[0])<maxVariance&&
                Math.abs(moduleSize-stateCount[1])<maxVariance&&
                Math.abs(3.0*moduleSize-stateCount[2])<3*maxVariance&&
                Math.abs(moduleSize-stateCount[3])<maxVariance&&
                Math.abs(moduleSize-stateCount[4])<maxVariance;
        }
        getCrossCheckStateCount(){
            constcrossCheckStateCount=this.crossCheckStateCount;
            crossCheckStateCount[0]=0;
            crossCheckStateCount[1]=0;
            crossCheckStateCount[2]=0;
            crossCheckStateCount[3]=0;
            crossCheckStateCount[4]=0;
            returncrossCheckStateCount;
        }
        /**
         *Afteraverticalandhorizontalscanfindsapotentialfinderpattern,thismethod
         *"cross-cross-cross-checks"byscanningdowndiagonallythroughthecenterofthepossible
         *finderpatterntoseeifthesameproportionisdetected.
         *
         *@paramstartIrowwhereafinderpatternwasdetected
         *@paramcenterJcenterofthesectionthatappearstocrossafinderpattern
         *@parammaxCountmaximumreasonablenumberofmodulesthatshouldbe
         * observedinanyreadingstate,basedontheresultsofthehorizontalscan
         *@paramoriginalStateCountTotalTheoriginalstatecounttotal.
         *@returntrueifproportionsarewithingexpectedlimits
         */
        crossCheckDiagonal(startI/*int*/,centerJ/*int*/,maxCount/*int*/,originalStateCountTotal/*int*/){
            conststateCount=this.getCrossCheckStateCount();
            //Startcountingup,leftfromcenterfindingblackcentermass
            leti=0;
            constimage=this.image;
            while(startI>=i&&centerJ>=i&&image.get(centerJ-i,startI-i)){
                stateCount[2]++;
                i++;
            }
            if(startI<i||centerJ<i){
                returnfalse;
            }
            //Continueup,leftfindingwhitespace
            while(startI>=i&&centerJ>=i&&!image.get(centerJ-i,startI-i)&&
                stateCount[1]<=maxCount){
                stateCount[1]++;
                i++;
            }
            //Ifalreadytoomanymodulesinthisstateorranofftheedge:
            if(startI<i||centerJ<i||stateCount[1]>maxCount){
                returnfalse;
            }
            //Continueup,leftfindingblackborder
            while(startI>=i&&centerJ>=i&&image.get(centerJ-i,startI-i)&&
                stateCount[0]<=maxCount){
                stateCount[0]++;
                i++;
            }
            if(stateCount[0]>maxCount){
                returnfalse;
            }
            constmaxI=image.getHeight();
            constmaxJ=image.getWidth();
            //Nowalsocountdown,rightfromcenter
            i=1;
            while(startI+i<maxI&&centerJ+i<maxJ&&image.get(centerJ+i,startI+i)){
                stateCount[2]++;
                i++;
            }
            //Ranofftheedge?
            if(startI+i>=maxI||centerJ+i>=maxJ){
                returnfalse;
            }
            while(startI+i<maxI&&centerJ+i<maxJ&&!image.get(centerJ+i,startI+i)&&
                stateCount[3]<maxCount){
                stateCount[3]++;
                i++;
            }
            if(startI+i>=maxI||centerJ+i>=maxJ||stateCount[3]>=maxCount){
                returnfalse;
            }
            while(startI+i<maxI&&centerJ+i<maxJ&&image.get(centerJ+i,startI+i)&&
                stateCount[4]<maxCount){
                stateCount[4]++;
                i++;
            }
            if(stateCount[4]>=maxCount){
                returnfalse;
            }
            //Ifwefoundafinder-pattern-likesection,butitssizeismorethan100%differentthan
            //theoriginal,assumeit'safalsepositive
            conststateCountTotal=stateCount[0]+stateCount[1]+stateCount[2]+stateCount[3]+stateCount[4];
            returnMath.abs(stateCountTotal-originalStateCountTotal)<2*originalStateCountTotal&&
                FinderPatternFinder.foundPatternCross(stateCount);
        }
        /**
         *<p>Afterahorizontalscanfindsapotentialfinderpattern,thismethod
         *"cross-checks"byscanningdownverticallythroughthecenterofthepossible
         *finderpatterntoseeifthesameproportionisdetected.</p>
         *
         *@paramstartIrowwhereafinderpatternwasdetected
         *@paramcenterJcenterofthesectionthatappearstocrossafinderpattern
         *@parammaxCountmaximumreasonablenumberofmodulesthatshouldbe
         *observedinanyreadingstate,basedontheresultsofthehorizontalscan
         *@returnverticalcenteroffinderpattern,or{@linkFloat#NaN}ifnotfound
         */
        crossCheckVertical(startI/*int*/,centerJ/*int*/,maxCount/*int*/,originalStateCountTotal/*int*/){
            constimage=this.image;
            constmaxI=image.getHeight();
            conststateCount=this.getCrossCheckStateCount();
            //Startcountingupfromcenter
            leti=startI;
            while(i>=0&&image.get(centerJ,i)){
                stateCount[2]++;
                i--;
            }
            if(i<0){
                returnNaN;
            }
            while(i>=0&&!image.get(centerJ,i)&&stateCount[1]<=maxCount){
                stateCount[1]++;
                i--;
            }
            //Ifalreadytoomanymodulesinthisstateorranofftheedge:
            if(i<0||stateCount[1]>maxCount){
                returnNaN;
            }
            while(i>=0&&image.get(centerJ,i)&&stateCount[0]<=maxCount){
                stateCount[0]++;
                i--;
            }
            if(stateCount[0]>maxCount){
                returnNaN;
            }
            //Nowalsocountdownfromcenter
            i=startI+1;
            while(i<maxI&&image.get(centerJ,i)){
                stateCount[2]++;
                i++;
            }
            if(i===maxI){
                returnNaN;
            }
            while(i<maxI&&!image.get(centerJ,i)&&stateCount[3]<maxCount){
                stateCount[3]++;
                i++;
            }
            if(i===maxI||stateCount[3]>=maxCount){
                returnNaN;
            }
            while(i<maxI&&image.get(centerJ,i)&&stateCount[4]<maxCount){
                stateCount[4]++;
                i++;
            }
            if(stateCount[4]>=maxCount){
                returnNaN;
            }
            //Ifwefoundafinder-pattern-likesection,butitssizeismorethan40%differentthan
            //theoriginal,assumeit'safalsepositive
            conststateCountTotal=stateCount[0]+stateCount[1]+stateCount[2]+stateCount[3]+
                stateCount[4];
            if(5*Math.abs(stateCountTotal-originalStateCountTotal)>=2*originalStateCountTotal){
                returnNaN;
            }
            returnFinderPatternFinder.foundPatternCross(stateCount)?FinderPatternFinder.centerFromEnd(stateCount,i):NaN;
        }
        /**
         *<p>Like{@link#crossCheckVertical(int,int,int,int)},andinfactisbasicallyidentical,
         *exceptitreadshorizontallyinsteadofvertically.Thisisusedtocross-cross
         *checkaverticalcrosscheckandlocatetherealcenterofthealignmentpattern.</p>
         */
        crossCheckHorizontal(startJ/*int*/,centerI/*int*/,maxCount/*int*/,originalStateCountTotal/*int*/){
            constimage=this.image;
            constmaxJ=image.getWidth();
            conststateCount=this.getCrossCheckStateCount();
            letj=startJ;
            while(j>=0&&image.get(j,centerI)){
                stateCount[2]++;
                j--;
            }
            if(j<0){
                returnNaN;
            }
            while(j>=0&&!image.get(j,centerI)&&stateCount[1]<=maxCount){
                stateCount[1]++;
                j--;
            }
            if(j<0||stateCount[1]>maxCount){
                returnNaN;
            }
            while(j>=0&&image.get(j,centerI)&&stateCount[0]<=maxCount){
                stateCount[0]++;
                j--;
            }
            if(stateCount[0]>maxCount){
                returnNaN;
            }
            j=startJ+1;
            while(j<maxJ&&image.get(j,centerI)){
                stateCount[2]++;
                j++;
            }
            if(j===maxJ){
                returnNaN;
            }
            while(j<maxJ&&!image.get(j,centerI)&&stateCount[3]<maxCount){
                stateCount[3]++;
                j++;
            }
            if(j===maxJ||stateCount[3]>=maxCount){
                returnNaN;
            }
            while(j<maxJ&&image.get(j,centerI)&&stateCount[4]<maxCount){
                stateCount[4]++;
                j++;
            }
            if(stateCount[4]>=maxCount){
                returnNaN;
            }
            //Ifwefoundafinder-pattern-likesection,butitssizeissignificantlydifferentthan
            //theoriginal,assumeit'safalsepositive
            conststateCountTotal=stateCount[0]+stateCount[1]+stateCount[2]+stateCount[3]+
                stateCount[4];
            if(5*Math.abs(stateCountTotal-originalStateCountTotal)>=originalStateCountTotal){
                returnNaN;
            }
            returnFinderPatternFinder.foundPatternCross(stateCount)?FinderPatternFinder.centerFromEnd(stateCount,j):NaN;
        }
        /**
         *<p>Thisiscalledwhenahorizontalscanfindsapossiblealignmentpattern.Itwill
         *crosscheckwithaverticalscan,andifsuccessful,will,ah,cross-cross-check
         *withanotherhorizontalscan.Thisisneededprimarilytolocatetherealhorizontal
         *centerofthepatternincasesofextremeskew.
         *Andthenwecross-cross-crosscheckwithanotherdiagonalscan.</p>
         *
         *<p>Ifthatsucceedsthefinderpatternlocationisaddedtoalistthattracks
         *thenumberoftimeseachlocationhasbeennearly-matchedasafinderpattern.
         *Eachadditionalfindismoreevidencethatthelocationisinfactafinder
         *patterncenter
         *
         *@paramstateCountreadingstatemodulecountsfromhorizontalscan
         *@paramirowwherefinderpatternmaybefound
         *@paramjendofpossiblefinderpatterninrow
         *@parampureBarcodetrueifin"purebarcode"mode
         *@returntrueifafinderpatterncandidatewasfoundthistime
         */
        handlePossibleCenter(stateCount,i/*int*/,j/*int*/,pureBarcode){
            conststateCountTotal=stateCount[0]+stateCount[1]+stateCount[2]+stateCount[3]+
                stateCount[4];
            letcenterJ=FinderPatternFinder.centerFromEnd(stateCount,j);
            letcenterI=this.crossCheckVertical(i,/*(int)*/Math.floor(centerJ),stateCount[2],stateCountTotal);
            if(!isNaN(centerI)){
                //Re-crosscheck
                centerJ=this.crossCheckHorizontal(/*(int)*/Math.floor(centerJ),/*(int)*/Math.floor(centerI),stateCount[2],stateCountTotal);
                if(!isNaN(centerJ)&&
                    (!pureBarcode||this.crossCheckDiagonal(/*(int)*/Math.floor(centerI),/*(int)*/Math.floor(centerJ),stateCount[2],stateCountTotal))){
                    constestimatedModuleSize=stateCountTotal/7.0;
                    letfound=false;
                    constpossibleCenters=this.possibleCenters;
                    for(letindex=0,length=possibleCenters.length;index<length;index++){
                        constcenter=possibleCenters[index];
                        //Lookforaboutthesamecenterandmodulesize:
                        if(center.aboutEquals(estimatedModuleSize,centerI,centerJ)){
                            possibleCenters[index]=center.combineEstimate(centerI,centerJ,estimatedModuleSize);
                            found=true;
                            break;
                        }
                    }
                    if(!found){
                        constpoint=newFinderPattern$1(centerJ,centerI,estimatedModuleSize);
                        possibleCenters.push(point);
                        if(this.resultPointCallback!==null&&this.resultPointCallback!==undefined){
                            this.resultPointCallback.foundPossibleResultPoint(point);
                        }
                    }
                    returntrue;
                }
            }
            returnfalse;
        }
        /**
         *@returnnumberofrowswecouldsafelyskipduringscanning,basedonthefirst
         *        twofinderpatternsthathavebeenlocated.Insomecasestheirpositionwill
         *        allowustoinferthatthethirdpatternmustliebelowacertainpointfarther
         *        downintheimage.
         */
        findRowSkip(){
            constmax=this.possibleCenters.length;
            if(max<=1){
                return0;
            }
            letfirstConfirmedCenter=null;
            for(constcenterofthis.possibleCenters){
                if(center.getCount()>=FinderPatternFinder.CENTER_QUORUM){
                    if(firstConfirmedCenter==null){
                        firstConfirmedCenter=center;
                    }
                    else{
                        //Wehavetwoconfirmedcenters
                        //Howfardowncanweskipbeforeresuminglookingforthenext
                        //pattern?Intheworstcase,onlythedifferencebetweenthe
                        //differenceinthex/ycoordinatesofthetwocenters.
                        //Thisisthecasewhereyoufindtopleftlast.
                        this.hasSkipped=true;
                        return/*(int)*/Math.floor((Math.abs(firstConfirmedCenter.getX()-center.getX())-
                            Math.abs(firstConfirmedCenter.getY()-center.getY()))/2);
                    }
                }
            }
            return0;
        }
        /**
         *@returntrueiffwehavefoundatleast3finderpatternsthathavebeendetected
         *        atleast{@link#CENTER_QUORUM}timeseach,and,theestimatedmodulesizeofthe
         *        candidatesis"prettysimilar"
         */
        haveMultiplyConfirmedCenters(){
            letconfirmedCount=0;
            lettotalModuleSize=0.0;
            constmax=this.possibleCenters.length;
            for(constpatternofthis.possibleCenters){
                if(pattern.getCount()>=FinderPatternFinder.CENTER_QUORUM){
                    confirmedCount++;
                    totalModuleSize+=pattern.getEstimatedModuleSize();
                }
            }
            if(confirmedCount<3){
                returnfalse;
            }
            //OK,wehaveatleast3confirmedcenters,but,it'spossiblethatoneisa"falsepositive"
            //andthatweneedtokeeplooking.Wedetectthisbyaskingiftheestimatedmodulesizes
            //varytoomuch.Wearbitrarilysaythatwhenthetotaldeviationfromaverageexceeds
            //5%ofthetotalmodulesizeestimates,it'stoomuch.
            constaverage=totalModuleSize/max;
            lettotalDeviation=0.0;
            for(constpatternofthis.possibleCenters){
                totalDeviation+=Math.abs(pattern.getEstimatedModuleSize()-average);
            }
            returntotalDeviation<=0.05*totalModuleSize;
        }
        /**
         *@returnthe3best{@linkFinderPattern}sfromourlistofcandidates.The"best"are
         *        thosethathavebeendetectedatleast{@link#CENTER_QUORUM}times,andwhosemodule
         *        sizediffersfromtheaverageamongthosepatternstheleast
         *@throwsNotFoundExceptionif3suchfinderpatternsdonotexist
         */
        selectBestPatterns(){
            conststartSize=this.possibleCenters.length;
            if(startSize<3){
                //Couldn'tfindenoughfinderpatterns
                thrownewNotFoundException();
            }
            constpossibleCenters=this.possibleCenters;
            letaverage;
            //Filteroutlierpossibilitieswhosemodulesizeistoodifferent
            if(startSize>3){
                //Butwecanonlyaffordtodosoifwehaveatleast4possibilitiestochoosefrom
                lettotalModuleSize=0.0;
                letsquare=0.0;
                for(constcenterofthis.possibleCenters){
                    constsize=center.getEstimatedModuleSize();
                    totalModuleSize+=size;
                    square+=size*size;
                }
                average=totalModuleSize/startSize;
                letstdDev=Math.sqrt(square/startSize-average*average);
                possibleCenters.sort(
                /**
                 *<p>Ordersbyfurthestfromaverage</p>
                 */
                //FurthestFromAverageComparatorimplementsComparator<FinderPattern>
                (center1,center2)=>{
                    constdA=Math.abs(center2.getEstimatedModuleSize()-average);
                    constdB=Math.abs(center1.getEstimatedModuleSize()-average);
                    returndA<dB?-1:dA>dB?1:0;
                });
                constlimit=Math.max(0.2*average,stdDev);
                for(leti=0;i<possibleCenters.length&&possibleCenters.length>3;i++){
                    constpattern=possibleCenters[i];
                    if(Math.abs(pattern.getEstimatedModuleSize()-average)>limit){
                        possibleCenters.splice(i,1);
                        i--;
                    }
                }
            }
            if(possibleCenters.length>3){
                //Throwawayallbutthosefirstsizecandidatepointswefound.
                lettotalModuleSize=0.0;
                for(constpossibleCenterofpossibleCenters){
                    totalModuleSize+=possibleCenter.getEstimatedModuleSize();
                }
                average=totalModuleSize/possibleCenters.length;
                possibleCenters.sort(
                /**
                 *<p>Ordersby{@linkFinderPattern#getCount()},descending.</p>
                 */
                //CenterComparatorimplementsComparator<FinderPattern>
                (center1,center2)=>{
                    if(center2.getCount()===center1.getCount()){
                        constdA=Math.abs(center2.getEstimatedModuleSize()-average);
                        constdB=Math.abs(center1.getEstimatedModuleSize()-average);
                        returndA<dB?1:dA>dB?-1:0;
                    }
                    else{
                        returncenter2.getCount()-center1.getCount();
                    }
                });
                possibleCenters.splice(3);//thisisnotrealynecessaryasweonlyreturnfirst3anyway
            }
            return[
                possibleCenters[0],
                possibleCenters[1],
                possibleCenters[2]
            ];
        }
    }
    FinderPatternFinder.CENTER_QUORUM=2;
    FinderPatternFinder.MIN_SKIP=3;//1pixel/moduletimes3modules/center
    FinderPatternFinder.MAX_MODULES=57;//supportuptoversion10formobileclients

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*importjava.util.Map;*/
    /**
     *<p>EncapsulateslogicthatcandetectaQRCodeinanimage,eveniftheQRCode
     *isrotatedorskewed,orpartiallyobscured.</p>
     *
     *@authorSeanOwen
     */
    classDetector$2{
        constructor(image){
            this.image=image;
        }
        getImage(){
            returnthis.image;
        }
        getResultPointCallback(){
            returnthis.resultPointCallback;
        }
        /**
         *<p>DetectsaQRCodeinanimage.</p>
         *
         *@return{@linkDetectorResult}encapsulatingresultsofdetectingaQRCode
         *@throwsNotFoundExceptionifQRCodecannotbefound
         *@throwsFormatExceptionifaQRCodecannotbedecoded
         */
        //publicdetect():DetectorResult/*throwsNotFoundException,FormatException*/{
        //  returndetect(null)
        //}
        /**
         *<p>DetectsaQRCodeinanimage.</p>
         *
         *@paramhintsoptionalhintstodetector
         *@return{@linkDetectorResult}encapsulatingresultsofdetectingaQRCode
         *@throwsNotFoundExceptionifQRCodecannotbefound
         *@throwsFormatExceptionifaQRCodecannotbedecoded
         */
        detect(hints){
            this.resultPointCallback=(hints===null||hints===undefined)?null:
                /*(ResultPointCallback)*/hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
            constfinder=newFinderPatternFinder(this.image,this.resultPointCallback);
            constinfo=finder.find(hints);
            returnthis.processFinderPatternInfo(info);
        }
        processFinderPatternInfo(info){
            consttopLeft=info.getTopLeft();
            consttopRight=info.getTopRight();
            constbottomLeft=info.getBottomLeft();
            constmoduleSize=this.calculateModuleSize(topLeft,topRight,bottomLeft);
            if(moduleSize<1.0){
                thrownewNotFoundException('Nopatternfoundinproccessfinder.');
            }
            constdimension=Detector$2.computeDimension(topLeft,topRight,bottomLeft,moduleSize);
            constprovisionalVersion=Version$1.getProvisionalVersionForDimension(dimension);
            constmodulesBetweenFPCenters=provisionalVersion.getDimensionForVersion()-7;
            letalignmentPattern=null;
            //Anythingaboveversion1hasanalignmentpattern
            if(provisionalVersion.getAlignmentPatternCenters().length>0){
                //Guesswherea"bottomright"finderpatternwouldhavebeen
                constbottomRightX=topRight.getX()-topLeft.getX()+bottomLeft.getX();
                constbottomRightY=topRight.getY()-topLeft.getY()+bottomLeft.getY();
                //Estimatethatalignmentpatterniscloserby3modules
                //from"bottomright"toknowntopleftlocation
                constcorrectionToTopLeft=1.0-3.0/modulesBetweenFPCenters;
                constestAlignmentX=/*(int)*/Math.floor(topLeft.getX()+correctionToTopLeft*(bottomRightX-topLeft.getX()));
                constestAlignmentY=/*(int)*/Math.floor(topLeft.getY()+correctionToTopLeft*(bottomRightY-topLeft.getY()));
                //Kindofarbitrary--expandsearchradiusbeforegivingup
                for(leti=4;i<=16;i<<=1){
                    try{
                        alignmentPattern=this.findAlignmentInRegion(moduleSize,estAlignmentX,estAlignmentY,i);
                        break;
                    }
                    catch(re/*NotFoundException*/){
                        if(!(reinstanceofNotFoundException)){
                            throwre;
                        }
                        //trynextround
                    }
                }
                //Ifwedidn'tfindalignmentpattern...welltryanywaywithoutit
            }
            consttransform=Detector$2.createTransform(topLeft,topRight,bottomLeft,alignmentPattern,dimension);
            constbits=Detector$2.sampleGrid(this.image,transform,dimension);
            letpoints;
            if(alignmentPattern===null){
                points=[bottomLeft,topLeft,topRight];
            }
            else{
                points=[bottomLeft,topLeft,topRight,alignmentPattern];
            }
            returnnewDetectorResult(bits,points);
        }
        staticcreateTransform(topLeft,topRight,bottomLeft,alignmentPattern,dimension/*int*/){
            constdimMinusThree=dimension-3.5;
            letbottomRightX;/*float*/
            letbottomRightY;/*float*/
            letsourceBottomRightX;/*float*/
            letsourceBottomRightY;/*float*/
            if(alignmentPattern!==null){
                bottomRightX=alignmentPattern.getX();
                bottomRightY=alignmentPattern.getY();
                sourceBottomRightX=dimMinusThree-3.0;
                sourceBottomRightY=sourceBottomRightX;
            }
            else{
                //Don'thaveanalignmentpattern,justmakeupthebottom-rightpoint
                bottomRightX=(topRight.getX()-topLeft.getX())+bottomLeft.getX();
                bottomRightY=(topRight.getY()-topLeft.getY())+bottomLeft.getY();
                sourceBottomRightX=dimMinusThree;
                sourceBottomRightY=dimMinusThree;
            }
            returnPerspectiveTransform.quadrilateralToQuadrilateral(3.5,3.5,dimMinusThree,3.5,sourceBottomRightX,sourceBottomRightY,3.5,dimMinusThree,topLeft.getX(),topLeft.getY(),topRight.getX(),topRight.getY(),bottomRightX,bottomRightY,bottomLeft.getX(),bottomLeft.getY());
        }
        staticsampleGrid(image,transform,dimension/*int*/){
            constsampler=GridSamplerInstance.getInstance();
            returnsampler.sampleGridWithTransform(image,dimension,dimension,transform);
        }
        /**
         *<p>Computesthedimension(numberofmodulesonasize)oftheQRCodebasedontheposition
         *ofthefinderpatternsandestimatedmodulesize.</p>
         */
        staticcomputeDimension(topLeft,topRight,bottomLeft,moduleSize/*float*/){
            consttltrCentersDimension=MathUtils.round(ResultPoint.distance(topLeft,topRight)/moduleSize);
            consttlblCentersDimension=MathUtils.round(ResultPoint.distance(topLeft,bottomLeft)/moduleSize);
            letdimension=Math.floor((tltrCentersDimension+tlblCentersDimension)/2)+7;
            switch(dimension&0x03){//mod4
                case0:
                    dimension++;
                    break;
                //1?donothing
                case2:
                    dimension--;
                    break;
                case3:
                    thrownewNotFoundException('Dimensionscouldbenotfound.');
            }
            returndimension;
        }
        /**
         *<p>Computesanaverageestimatedmodulesizebasedonestimatedderivedfromthepositions
         *ofthethreefinderpatterns.</p>
         *
         *@paramtopLeftdetectedtop-leftfinderpatterncenter
         *@paramtopRightdetectedtop-rightfinderpatterncenter
         *@parambottomLeftdetectedbottom-leftfinderpatterncenter
         *@returnestimatedmodulesize
         */
        calculateModuleSize(topLeft,topRight,bottomLeft){
            //Taketheaverage
            return(this.calculateModuleSizeOneWay(topLeft,topRight)+
                this.calculateModuleSizeOneWay(topLeft,bottomLeft))/2.0;
        }
        /**
         *<p>Estimatesmodulesizebasedontwofinderpatterns--ituses
         *{@link#sizeOfBlackWhiteBlackRunBothWays(int,int,int,int)}tofigurethe
         *widthofeach,measuringalongtheaxisbetweentheircenters.</p>
         */
        calculateModuleSizeOneWay(pattern,otherPattern){
            constmoduleSizeEst1=this.sizeOfBlackWhiteBlackRunBothWays(/*(int)*/Math.floor(pattern.getX()),
            /*(int)*/Math.floor(pattern.getY()),
            /*(int)*/Math.floor(otherPattern.getX()),
            /*(int)*/Math.floor(otherPattern.getY()));
            constmoduleSizeEst2=this.sizeOfBlackWhiteBlackRunBothWays(/*(int)*/Math.floor(otherPattern.getX()),
            /*(int)*/Math.floor(otherPattern.getY()),
            /*(int)*/Math.floor(pattern.getX()),
            /*(int)*/Math.floor(pattern.getY()));
            if(isNaN(moduleSizeEst1)){
                returnmoduleSizeEst2/7.0;
            }
            if(isNaN(moduleSizeEst2)){
                returnmoduleSizeEst1/7.0;
            }
            //Averagethem,anddivideby7sincewe'vecountedthewidthof3blackmodules,
            //and1whiteand1blackmoduleoneitherside.Ergo,dividesumby14.
            return(moduleSizeEst1+moduleSizeEst2)/14.0;
        }
        /**
         *See{@link#sizeOfBlackWhiteBlackRun(int,int,int,int)};computesthetotalwidthof
         *afinderpatternbylookingforablack-white-blackrunfromthecenterinthedirection
         *ofanotherpoint(anotherfinderpatterncenter),andintheoppositedirectiontoo.
         */
        sizeOfBlackWhiteBlackRunBothWays(fromX/*int*/,fromY/*int*/,toX/*int*/,toY/*int*/){
            letresult=this.sizeOfBlackWhiteBlackRun(fromX,fromY,toX,toY);
            //Nowcountotherway--don'trunoffimagethoughofcourse
            letscale=1.0;
            letotherToX=fromX-(toX-fromX);
            if(otherToX<0){
                scale=fromX//*(float)*/(fromX-otherToX);
                otherToX=0;
            }
            elseif(otherToX>=this.image.getWidth()){
                scale=(this.image.getWidth()-1-fromX)//*(float)*/(otherToX-fromX);
                otherToX=this.image.getWidth()-1;
            }
            letotherToY=/*(int)*/Math.floor(fromY-(toY-fromY)*scale);
            scale=1.0;
            if(otherToY<0){
                scale=fromY//*(float)*/(fromY-otherToY);
                otherToY=0;
            }
            elseif(otherToY>=this.image.getHeight()){
                scale=(this.image.getHeight()-1-fromY)//*(float)*/(otherToY-fromY);
                otherToY=this.image.getHeight()-1;
            }
            otherToX=/*(int)*/Math.floor(fromX+(otherToX-fromX)*scale);
            result+=this.sizeOfBlackWhiteBlackRun(fromX,fromY,otherToX,otherToY);
            //Middlepixelisdouble-countedthisway;subtract1
            returnresult-1.0;
        }
        /**
         *<p>Thismethodtracesalinefromapointintheimage,inthedirectiontowardsanotherpoint.
         *Itbeginsinablackregion,andkeepsgoinguntilitfindswhite,thenblack,thenwhiteagain.
         *Itreportsthedistancefromthestarttothispoint.</p>
         *
         *<p>Thisisusedwhenfiguringouthowwideafinderpatternis,whenthefinderpattern
         *maybeskewedorrotated.</p>
         */
        sizeOfBlackWhiteBlackRun(fromX/*int*/,fromY/*int*/,toX/*int*/,toY/*int*/){
            //MildvariantofBresenham'salgorithm
            //seehttp://en.wikipedia.org/wiki/Bresenham's_line_algorithm
            conststeep=Math.abs(toY-fromY)>Math.abs(toX-fromX);
            if(steep){
                lettemp=fromX;
                fromX=fromY;
                fromY=temp;
                temp=toX;
                toX=toY;
                toY=temp;
            }
            constdx=Math.abs(toX-fromX);
            constdy=Math.abs(toY-fromY);
            leterror=-dx/2;
            constxstep=fromX<toX?1:-1;
            constystep=fromY<toY?1:-1;
            //Inblackpixels,lookingforwhite,firstorsecondtime.
            letstate=0;
            //Loopupuntilx==toX,butnotbeyond
            constxLimit=toX+xstep;
            for(letx=fromX,y=fromY;x!==xLimit;x+=xstep){
                constrealX=steep?y:x;
                constrealY=steep?x:y;
                //Doescurrentpixelmeanwehavemovedwhitetoblackorviceversa?
                //Scanningblackinstate0,2andwhiteinstate1,soifwefindthewrong
                //color,advancetonextstateorendifweareinstate2already
                if((state===1)===this.image.get(realX,realY)){
                    if(state===2){
                        returnMathUtils.distance(x,y,fromX,fromY);
                    }
                    state++;
                }
                error+=dy;
                if(error>0){
                    if(y===toY){
                        break;
                    }
                    y+=ystep;
                    error-=dx;
                }
            }
            //Foundblack-white-black;givethebenefitofthedoubtthatthenextpixeloutsidetheimage
            //is"white"sothislastpointat(toX+xStep,toY)istherightending.Thisisreallya
            //smallapproximation;(toX+xStep,toY+yStep)mightbereallycorrect.Ignorethis.
            if(state===2){
                returnMathUtils.distance(toX+xstep,toY,fromX,fromY);
            }
            //elsewedidn'tfindevenblack-white-black;noestimateisreallypossible
            returnNaN;
        }
        /**
         *<p>Attemptstolocateanalignmentpatterninalimitedregionoftheimage,whichis
         *guessedtocontainit.Thismethoduses{@linkAlignmentPattern}.</p>
         *
         *@paramoverallEstModuleSizeestimatedmodulesizesofar
         *@paramestAlignmentXxcoordinateofcenterofareaprobablycontainingalignmentpattern
         *@paramestAlignmentYycoordinateofabove
         *@paramallowanceFactornumberofpixelsinalldirectionstosearchfromthecenter
         *@return{@linkAlignmentPattern}iffound,ornullotherwise
         *@throwsNotFoundExceptionifanunexpectederroroccursduringdetection
         */
        findAlignmentInRegion(overallEstModuleSize/*float*/,estAlignmentX/*int*/,estAlignmentY/*int*/,allowanceFactor/*float*/){
            //Lookforanalignmentpattern(3modulesinsize)aroundwhereit
            //shouldbe
            constallowance=/*(int)*/Math.floor(allowanceFactor*overallEstModuleSize);
            constalignmentAreaLeftX=Math.max(0,estAlignmentX-allowance);
            constalignmentAreaRightX=Math.min(this.image.getWidth()-1,estAlignmentX+allowance);
            if(alignmentAreaRightX-alignmentAreaLeftX<overallEstModuleSize*3){
                thrownewNotFoundException('Alignmenttopexceedsestimatedmodulesize.');
            }
            constalignmentAreaTopY=Math.max(0,estAlignmentY-allowance);
            constalignmentAreaBottomY=Math.min(this.image.getHeight()-1,estAlignmentY+allowance);
            if(alignmentAreaBottomY-alignmentAreaTopY<overallEstModuleSize*3){
                thrownewNotFoundException('Alignmentbottomexceedsestimatedmodulesize.');
            }
            constalignmentFinder=newAlignmentPatternFinder(this.image,alignmentAreaLeftX,alignmentAreaTopY,alignmentAreaRightX-alignmentAreaLeftX,alignmentAreaBottomY-alignmentAreaTopY,overallEstModuleSize,this.resultPointCallback);
            returnalignmentFinder.find();
        }
    }

    /*
     *Copyright2007ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*importjava.util.List;*/
    /*importjava.util.Map;*/
    /**
     *ThisimplementationcandetectanddecodeQRCodesinanimage.
     *
     *@authorSeanOwen
     */
    classQRCodeReader{
        constructor(){
            this.decoder=newDecoder$2();
        }
        getDecoder(){
            returnthis.decoder;
        }
        /**
         *LocatesanddecodesaQRcodeinanimage.
         *
         *@returnarepresenting:stringthecontentencodedbytheQRcode
         *@throwsNotFoundExceptionifaQRcodecannotbefound
         *@throwsFormatExceptionifaQRcodecannotbedecoded
         *@throwsChecksumExceptioniferrorcorrectionfails
         */
        /*@Override*/
        //publicdecode(image:BinaryBitmap):Result/*throwsNotFoundException,ChecksumException,FormatException*/{
        //  returnthis.decode(image,null)
        //}
        /*@Override*/
        decode(image,hints){
            letdecoderResult;
            letpoints;
            if(hints!==undefined&&hints!==null&&undefined!==hints.get(DecodeHintType$1.PURE_BARCODE)){
                constbits=QRCodeReader.extractPureBits(image.getBlackMatrix());
                decoderResult=this.decoder.decodeBitMatrix(bits,hints);
                points=QRCodeReader.NO_POINTS;
            }
            else{
                constdetectorResult=newDetector$2(image.getBlackMatrix()).detect(hints);
                decoderResult=this.decoder.decodeBitMatrix(detectorResult.getBits(),hints);
                points=detectorResult.getPoints();
            }
            //Ifthecodewasmirrored:swapthebottom-leftandthetop-rightpoints.
            if(decoderResult.getOther()instanceofQRCodeDecoderMetaData){
                decoderResult.getOther().applyMirroredCorrection(points);
            }
            constresult=newResult(decoderResult.getText(),decoderResult.getRawBytes(),undefined,points,BarcodeFormat$1.QR_CODE,undefined);
            constbyteSegments=decoderResult.getByteSegments();
            if(byteSegments!==null){
                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS,byteSegments);
            }
            constecLevel=decoderResult.getECLevel();
            if(ecLevel!==null){
                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL,ecLevel);
            }
            if(decoderResult.hasStructuredAppend()){
                result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_SEQUENCE,decoderResult.getStructuredAppendSequenceNumber());
                result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_PARITY,decoderResult.getStructuredAppendParity());
            }
            returnresult;
        }
        /*@Override*/
        reset(){
            //donothing
        }
        /**
         *Thismethoddetectsacodeina"pure"image--thatis,puremonochromeimage
         *whichcontainsonlyanunrotated,unskewed,imageofacode,withsomewhiteborder
         *aroundit.Thisisaspecializedmethodthatworksexceptionallyfastinthisspecial
         *case.
         *
         *@seecom.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)
         */
        staticextractPureBits(image){
            constleftTopBlack=image.getTopLeftOnBit();
            constrightBottomBlack=image.getBottomRightOnBit();
            if(leftTopBlack===null||rightBottomBlack===null){
                thrownewNotFoundException();
            }
            constmoduleSize=this.moduleSize(leftTopBlack,image);
            lettop=leftTopBlack[1];
            letbottom=rightBottomBlack[1];
            letleft=leftTopBlack[0];
            letright=rightBottomBlack[0];
            //Sanitycheck!
            if(left>=right||top>=bottom){
                thrownewNotFoundException();
            }
            if(bottom-top!==right-left){
                //Specialcase,wherebottom-rightmodulewasn'tblacksowefoundsomethingelseinthelastrow
                //Assumeit'sasquare,souseheightasthewidth
                right=left+(bottom-top);
                if(right>=image.getWidth()){
                    //Abortifthatwouldnotmakesense--offimage
                    thrownewNotFoundException();
                }
            }
            constmatrixWidth=Math.round((right-left+1)/moduleSize);
            constmatrixHeight=Math.round((bottom-top+1)/moduleSize);
            if(matrixWidth<=0||matrixHeight<=0){
                thrownewNotFoundException();
            }
            if(matrixHeight!==matrixWidth){
                //Onlypossiblydecodesquareregions
                thrownewNotFoundException();
            }
            //Pushinthe"border"byhalfthemodulewidthsothatwestart
            //samplinginthemiddleofthemodule.Justincasetheimageisa
            //littleoff,thiswillhelprecover.
            constnudge=/*(int)*/Math.floor(moduleSize/2.0);
            top+=nudge;
            left+=nudge;
            //Butcarefulthatthisdoesnotsampleofftheedge
            //"right"isthefarthest-rightvalidpixellocation--right+1isnotnecessarily
            //Thisispositivebyhowmuchtheinnerxloopbelowwouldbetoolarge
            constnudgedTooFarRight=left+/*(int)*/Math.floor((matrixWidth-1)*moduleSize)-right;
            if(nudgedTooFarRight>0){
                if(nudgedTooFarRight>nudge){
                    //Neitherwayfits;abort
                    thrownewNotFoundException();
                }
                left-=nudgedTooFarRight;
            }
            //Seelogicabove
            constnudgedTooFarDown=top+/*(int)*/Math.floor((matrixHeight-1)*moduleSize)-bottom;
            if(nudgedTooFarDown>0){
                if(nudgedTooFarDown>nudge){
                    //Neitherwayfits;abort
                    thrownewNotFoundException();
                }
                top-=nudgedTooFarDown;
            }
            //Nowjustreadoffthebits
            constbits=newBitMatrix(matrixWidth,matrixHeight);
            for(lety=0;y<matrixHeight;y++){
                constiOffset=top+/*(int)*/Math.floor(y*moduleSize);
                for(letx=0;x<matrixWidth;x++){
                    if(image.get(left+/*(int)*/Math.floor(x*moduleSize),iOffset)){
                        bits.set(x,y);
                    }
                }
            }
            returnbits;
        }
        staticmoduleSize(leftTopBlack,image){
            constheight=image.getHeight();
            constwidth=image.getWidth();
            letx=leftTopBlack[0];
            lety=leftTopBlack[1];
            letinBlack=true;
            lettransitions=0;
            while(x<width&&y<height){
                if(inBlack!==image.get(x,y)){
                    if(++transitions===5){
                        break;
                    }
                    inBlack=!inBlack;
                }
                x++;
                y++;
            }
            if(x===width||y===height){
                thrownewNotFoundException();
            }
            return(x-leftTopBlack[0])/7.0;
        }
    }
    QRCodeReader.NO_POINTS=newArray();

    /*
    *Copyright2009ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    /**
     *@authorSITALab(kevin.osullivan@sita.aero)
     *@authorGuentherGrau
     */
    /*publicfinal*/classPDF417Common{
        PDF417Common(){
        }
        /**
         *@parammoduleBitCountvaluestosum
         *@returnsumofvalues
         *@deprecatedcall{@linkMathUtils#sum(int[])}
         */
        //@Deprecated
        staticgetBitCountSum(moduleBitCount){
            returnMathUtils.sum(moduleBitCount);
        }
        statictoIntArray(list){
            if(list==null||!list.length){
                returnPDF417Common.EMPTY_INT_ARRAY;
            }
            constresult=newInt32Array(list.length);
            leti=0;
            for(constintegeroflist){
                result[i++]=integer;
            }
            returnresult;
        }
        /**
         *@paramsymbolencodedsymboltotranslatetoacodeword
         *@returnthecodewordcorrespondingtothesymbol.
         */
        staticgetCodeword(symbol/*int*/){
            consti=Arrays.binarySearch(PDF417Common.SYMBOL_TABLE,symbol&0x3FFFF);
            if(i<0){
                return-1;
            }
            return(PDF417Common.CODEWORD_TABLE[i]-1)%PDF417Common.NUMBER_OF_CODEWORDS;
        }
    }
    PDF417Common.NUMBER_OF_CODEWORDS=929;
    //MaximumCodewords(Data+Error).
    PDF417Common.MAX_CODEWORDS_IN_BARCODE=PDF417Common.NUMBER_OF_CODEWORDS-1;
    PDF417Common.MIN_ROWS_IN_BARCODE=3;
    PDF417Common.MAX_ROWS_IN_BARCODE=90;
    //Oneleftrowindicationcolumn+max30datacolumns+onerightrowindicatorcolumn
    //publicstatic/*final*/MAX_CODEWORDS_IN_ROW:/*int*/number=32;
    PDF417Common.MODULES_IN_CODEWORD=17;
    PDF417Common.MODULES_IN_STOP_PATTERN=18;
    PDF417Common.BARS_IN_MODULE=8;
    PDF417Common.EMPTY_INT_ARRAY=newInt32Array([]);
    /**
     *Thesortedtableofallpossiblesymbols.ExtractedfromthePDF417
     *specification.Theindexofasymbolinthistablecorrespondstothe
     *indexintothecodewordtable.
     */
    PDF417Common.SYMBOL_TABLE=Int32Array.from([
        0x1025e,0x1027a,0x1029e,0x102bc,0x102f2,0x102f4,0x1032e,0x1034e,0x1035c,0x10396,0x103a6,0x103ac,
        0x10422,0x10428,0x10436,0x10442,0x10444,0x10448,0x10450,0x1045e,0x10466,0x1046c,0x1047a,0x10482,
        0x1049e,0x104a0,0x104bc,0x104c6,0x104d8,0x104ee,0x104f2,0x104f4,0x10504,0x10508,0x10510,0x1051e,
        0x10520,0x1053c,0x10540,0x10578,0x10586,0x1058c,0x10598,0x105b0,0x105be,0x105ce,0x105dc,0x105e2,
        0x105e4,0x105e8,0x105f6,0x1062e,0x1064e,0x1065c,0x1068e,0x1069c,0x106b8,0x106de,0x106fa,0x10716,
        0x10726,0x1072c,0x10746,0x1074c,0x10758,0x1076e,0x10792,0x10794,0x107a2,0x107a4,0x107a8,0x107b6,
        0x10822,0x10828,0x10842,0x10848,0x10850,0x1085e,0x10866,0x1086c,0x1087a,0x10882,0x10884,0x10890,
        0x1089e,0x108a0,0x108bc,0x108c6,0x108cc,0x108d8,0x108ee,0x108f2,0x108f4,0x10902,0x10908,0x1091e,
        0x10920,0x1093c,0x10940,0x10978,0x10986,0x10998,0x109b0,0x109be,0x109ce,0x109dc,0x109e2,0x109e4,
        0x109e8,0x109f6,0x10a08,0x10a10,0x10a1e,0x10a20,0x10a3c,0x10a40,0x10a78,0x10af0,0x10b06,0x10b0c,
        0x10b18,0x10b30,0x10b3e,0x10b60,0x10b7c,0x10b8e,0x10b9c,0x10bb8,0x10bc2,0x10bc4,0x10bc8,0x10bd0,
        0x10bde,0x10be6,0x10bec,0x10c2e,0x10c4e,0x10c5c,0x10c62,0x10c64,0x10c68,0x10c76,0x10c8e,0x10c9c,
        0x10cb8,0x10cc2,0x10cc4,0x10cc8,0x10cd0,0x10cde,0x10ce6,0x10cec,0x10cfa,0x10d0e,0x10d1c,0x10d38,
        0x10d70,0x10d7e,0x10d82,0x10d84,0x10d88,0x10d90,0x10d9e,0x10da0,0x10dbc,0x10dc6,0x10dcc,0x10dd8,
        0x10dee,0x10df2,0x10df4,0x10e16,0x10e26,0x10e2c,0x10e46,0x10e58,0x10e6e,0x10e86,0x10e8c,0x10e98,
        0x10eb0,0x10ebe,0x10ece,0x10edc,0x10f0a,0x10f12,0x10f14,0x10f22,0x10f28,0x10f36,0x10f42,0x10f44,
        0x10f48,0x10f50,0x10f5e,0x10f66,0x10f6c,0x10fb2,0x10fb4,0x11022,0x11028,0x11042,0x11048,0x11050,
        0x1105e,0x1107a,0x11082,0x11084,0x11090,0x1109e,0x110a0,0x110bc,0x110c6,0x110cc,0x110d8,0x110ee,
        0x110f2,0x110f4,0x11102,0x1111e,0x11120,0x1113c,0x11140,0x11178,0x11186,0x11198,0x111b0,0x111be,
        0x111ce,0x111dc,0x111e2,0x111e4,0x111e8,0x111f6,0x11208,0x1121e,0x11220,0x11278,0x112f0,0x1130c,
        0x11330,0x1133e,0x11360,0x1137c,0x1138e,0x1139c,0x113b8,0x113c2,0x113c8,0x113d0,0x113de,0x113e6,
        0x113ec,0x11408,0x11410,0x1141e,0x11420,0x1143c,0x11440,0x11478,0x114f0,0x115e0,0x1160c,0x11618,
        0x11630,0x1163e,0x11660,0x1167c,0x116c0,0x116f8,0x1171c,0x11738,0x11770,0x1177e,0x11782,0x11784,
        0x11788,0x11790,0x1179e,0x117a0,0x117bc,0x117c6,0x117cc,0x117d8,0x117ee,0x1182e,0x11834,0x1184e,
        0x1185c,0x11862,0x11864,0x11868,0x11876,0x1188e,0x1189c,0x118b8,0x118c2,0x118c8,0x118d0,0x118de,
        0x118e6,0x118ec,0x118fa,0x1190e,0x1191c,0x11938,0x11970,0x1197e,0x11982,0x11984,0x11990,0x1199e,
        0x119a0,0x119bc,0x119c6,0x119cc,0x119d8,0x119ee,0x119f2,0x119f4,0x11a0e,0x11a1c,0x11a38,0x11a70,
        0x11a7e,0x11ae0,0x11afc,0x11b08,0x11b10,0x11b1e,0x11b20,0x11b3c,0x11b40,0x11b78,0x11b8c,0x11b98,
        0x11bb0,0x11bbe,0x11bce,0x11bdc,0x11be2,0x11be4,0x11be8,0x11bf6,0x11c16,0x11c26,0x11c2c,0x11c46,
        0x11c4c,0x11c58,0x11c6e,0x11c86,0x11c98,0x11cb0,0x11cbe,0x11cce,0x11cdc,0x11ce2,0x11ce4,0x11ce8,
        0x11cf6,0x11d06,0x11d0c,0x11d18,0x11d30,0x11d3e,0x11d60,0x11d7c,0x11d8e,0x11d9c,0x11db8,0x11dc4,
        0x11dc8,0x11dd0,0x11dde,0x11de6,0x11dec,0x11dfa,0x11e0a,0x11e12,0x11e14,0x11e22,0x11e24,0x11e28,
        0x11e36,0x11e42,0x11e44,0x11e50,0x11e5e,0x11e66,0x11e6c,0x11e82,0x11e84,0x11e88,0x11e90,0x11e9e,
        0x11ea0,0x11ebc,0x11ec6,0x11ecc,0x11ed8,0x11eee,0x11f1a,0x11f2e,0x11f32,0x11f34,0x11f4e,0x11f5c,
        0x11f62,0x11f64,0x11f68,0x11f76,0x12048,0x1205e,0x12082,0x12084,0x12090,0x1209e,0x120a0,0x120bc,
        0x120d8,0x120f2,0x120f4,0x12108,0x1211e,0x12120,0x1213c,0x12140,0x12178,0x12186,0x12198,0x121b0,
        0x121be,0x121e2,0x121e4,0x121e8,0x121f6,0x12204,0x12210,0x1221e,0x12220,0x12278,0x122f0,0x12306,
        0x1230c,0x12330,0x1233e,0x12360,0x1237c,0x1238e,0x1239c,0x123b8,0x123c2,0x123c8,0x123d0,0x123e6,
        0x123ec,0x1241e,0x12420,0x1243c,0x124f0,0x125e0,0x12618,0x1263e,0x12660,0x1267c,0x126c0,0x126f8,
        0x12738,0x12770,0x1277e,0x12782,0x12784,0x12790,0x1279e,0x127a0,0x127bc,0x127c6,0x127cc,0x127d8,
        0x127ee,0x12820,0x1283c,0x12840,0x12878,0x128f0,0x129e0,0x12bc0,0x12c18,0x12c30,0x12c3e,0x12c60,
        0x12c7c,0x12cc0,0x12cf8,0x12df0,0x12e1c,0x12e38,0x12e70,0x12e7e,0x12ee0,0x12efc,0x12f04,0x12f08,
        0x12f10,0x12f20,0x12f3c,0x12f40,0x12f78,0x12f86,0x12f8c,0x12f98,0x12fb0,0x12fbe,0x12fce,0x12fdc,
        0x1302e,0x1304e,0x1305c,0x13062,0x13068,0x1308e,0x1309c,0x130b8,0x130c2,0x130c8,0x130d0,0x130de,
        0x130ec,0x130fa,0x1310e,0x13138,0x13170,0x1317e,0x13182,0x13184,0x13190,0x1319e,0x131a0,0x131bc,
        0x131c6,0x131cc,0x131d8,0x131f2,0x131f4,0x1320e,0x1321c,0x13270,0x1327e,0x132e0,0x132fc,0x13308,
        0x1331e,0x13320,0x1333c,0x13340,0x13378,0x13386,0x13398,0x133b0,0x133be,0x133ce,0x133dc,0x133e2,
        0x133e4,0x133e8,0x133f6,0x1340e,0x1341c,0x13438,0x13470,0x1347e,0x134e0,0x134fc,0x135c0,0x135f8,
        0x13608,0x13610,0x1361e,0x13620,0x1363c,0x13640,0x13678,0x136f0,0x1370c,0x13718,0x13730,0x1373e,
        0x13760,0x1377c,0x1379c,0x137b8,0x137c2,0x137c4,0x137c8,0x137d0,0x137de,0x137e6,0x137ec,0x13816,
        0x13826,0x1382c,0x13846,0x1384c,0x13858,0x1386e,0x13874,0x13886,0x13898,0x138b0,0x138be,0x138ce,
        0x138dc,0x138e2,0x138e4,0x138e8,0x13906,0x1390c,0x13930,0x1393e,0x13960,0x1397c,0x1398e,0x1399c,
        0x139b8,0x139c8,0x139d0,0x139de,0x139e6,0x139ec,0x139fa,0x13a06,0x13a0c,0x13a18,0x13a30,0x13a3e,
        0x13a60,0x13a7c,0x13ac0,0x13af8,0x13b0e,0x13b1c,0x13b38,0x13b70,0x13b7e,0x13b88,0x13b90,0x13b9e,
        0x13ba0,0x13bbc,0x13bcc,0x13bd8,0x13bee,0x13bf2,0x13bf4,0x13c12,0x13c14,0x13c22,0x13c24,0x13c28,
        0x13c36,0x13c42,0x13c48,0x13c50,0x13c5e,0x13c66,0x13c6c,0x13c82,0x13c84,0x13c90,0x13c9e,0x13ca0,
        0x13cbc,0x13cc6,0x13ccc,0x13cd8,0x13cee,0x13d02,0x13d04,0x13d08,0x13d10,0x13d1e,0x13d20,0x13d3c,
        0x13d40,0x13d78,0x13d86,0x13d8c,0x13d98,0x13db0,0x13dbe,0x13dce,0x13ddc,0x13de4,0x13de8,0x13df6,
        0x13e1a,0x13e2e,0x13e32,0x13e34,0x13e4e,0x13e5c,0x13e62,0x13e64,0x13e68,0x13e76,0x13e8e,0x13e9c,
        0x13eb8,0x13ec2,0x13ec4,0x13ec8,0x13ed0,0x13ede,0x13ee6,0x13eec,0x13f26,0x13f2c,0x13f3a,0x13f46,
        0x13f4c,0x13f58,0x13f6e,0x13f72,0x13f74,0x14082,0x1409e,0x140a0,0x140bc,0x14104,0x14108,0x14110,
        0x1411e,0x14120,0x1413c,0x14140,0x14178,0x1418c,0x14198,0x141b0,0x141be,0x141e2,0x141e4,0x141e8,
        0x14208,0x14210,0x1421e,0x14220,0x1423c,0x14240,0x14278,0x142f0,0x14306,0x1430c,0x14318,0x14330,
        0x1433e,0x14360,0x1437c,0x1438e,0x143c2,0x143c4,0x143c8,0x143d0,0x143e6,0x143ec,0x14408,0x14410,
        0x1441e,0x14420,0x1443c,0x14440,0x14478,0x144f0,0x145e0,0x1460c,0x14618,0x14630,0x1463e,0x14660,
        0x1467c,0x146c0,0x146f8,0x1471c,0x14738,0x14770,0x1477e,0x14782,0x14784,0x14788,0x14790,0x147a0,
        0x147bc,0x147c6,0x147cc,0x147d8,0x147ee,0x14810,0x14820,0x1483c,0x14840,0x14878,0x148f0,0x149e0,
        0x14bc0,0x14c30,0x14c3e,0x14c60,0x14c7c,0x14cc0,0x14cf8,0x14df0,0x14e38,0x14e70,0x14e7e,0x14ee0,
        0x14efc,0x14f04,0x14f08,0x14f10,0x14f1e,0x14f20,0x14f3c,0x14f40,0x14f78,0x14f86,0x14f8c,0x14f98,
        0x14fb0,0x14fce,0x14fdc,0x15020,0x15040,0x15078,0x150f0,0x151e0,0x153c0,0x15860,0x1587c,0x158c0,
        0x158f8,0x159f0,0x15be0,0x15c70,0x15c7e,0x15ce0,0x15cfc,0x15dc0,0x15df8,0x15e08,0x15e10,0x15e20,
        0x15e40,0x15e78,0x15ef0,0x15f0c,0x15f18,0x15f30,0x15f60,0x15f7c,0x15f8e,0x15f9c,0x15fb8,0x1604e,
        0x1605c,0x1608e,0x1609c,0x160b8,0x160c2,0x160c4,0x160c8,0x160de,0x1610e,0x1611c,0x16138,0x16170,
        0x1617e,0x16184,0x16188,0x16190,0x1619e,0x161a0,0x161bc,0x161c6,0x161cc,0x161d8,0x161f2,0x161f4,
        0x1620e,0x1621c,0x16238,0x16270,0x1627e,0x162e0,0x162fc,0x16304,0x16308,0x16310,0x1631e,0x16320,
        0x1633c,0x16340,0x16378,0x16386,0x1638c,0x16398,0x163b0,0x163be,0x163ce,0x163dc,0x163e2,0x163e4,
        0x163e8,0x163f6,0x1640e,0x1641c,0x16438,0x16470,0x1647e,0x164e0,0x164fc,0x165c0,0x165f8,0x16610,
        0x1661e,0x16620,0x1663c,0x16640,0x16678,0x166f0,0x16718,0x16730,0x1673e,0x16760,0x1677c,0x1678e,
        0x1679c,0x167b8,0x167c2,0x167c4,0x167c8,0x167d0,0x167de,0x167e6,0x167ec,0x1681c,0x16838,0x16870,
        0x168e0,0x168fc,0x169c0,0x169f8,0x16bf0,0x16c10,0x16c1e,0x16c20,0x16c3c,0x16c40,0x16c78,0x16cf0,
        0x16de0,0x16e18,0x16e30,0x16e3e,0x16e60,0x16e7c,0x16ec0,0x16ef8,0x16f1c,0x16f38,0x16f70,0x16f7e,
        0x16f84,0x16f88,0x16f90,0x16f9e,0x16fa0,0x16fbc,0x16fc6,0x16fcc,0x16fd8,0x17026,0x1702c,0x17046,
        0x1704c,0x17058,0x1706e,0x17086,0x1708c,0x17098,0x170b0,0x170be,0x170ce,0x170dc,0x170e8,0x17106,
        0x1710c,0x17118,0x17130,0x1713e,0x17160,0x1717c,0x1718e,0x1719c,0x171b8,0x171c2,0x171c4,0x171c8,
        0x171d0,0x171de,0x171e6,0x171ec,0x171fa,0x17206,0x1720c,0x17218,0x17230,0x1723e,0x17260,0x1727c,
        0x172c0,0x172f8,0x1730e,0x1731c,0x17338,0x17370,0x1737e,0x17388,0x17390,0x1739e,0x173a0,0x173bc,
        0x173cc,0x173d8,0x173ee,0x173f2,0x173f4,0x1740c,0x17418,0x17430,0x1743e,0x17460,0x1747c,0x174c0,
        0x174f8,0x175f0,0x1760e,0x1761c,0x17638,0x17670,0x1767e,0x176e0,0x176fc,0x17708,0x17710,0x1771e,
        0x17720,0x1773c,0x17740,0x17778,0x17798,0x177b0,0x177be,0x177dc,0x177e2,0x177e4,0x177e8,0x17822,
        0x17824,0x17828,0x17836,0x17842,0x17844,0x17848,0x17850,0x1785e,0x17866,0x1786c,0x17882,0x17884,
        0x17888,0x17890,0x1789e,0x178a0,0x178bc,0x178c6,0x178cc,0x178d8,0x178ee,0x178f2,0x178f4,0x17902,
        0x17904,0x17908,0x17910,0x1791e,0x17920,0x1793c,0x17940,0x17978,0x17986,0x1798c,0x17998,0x179b0,
        0x179be,0x179ce,0x179dc,0x179e2,0x179e4,0x179e8,0x179f6,0x17a04,0x17a08,0x17a10,0x17a1e,0x17a20,
        0x17a3c,0x17a40,0x17a78,0x17af0,0x17b06,0x17b0c,0x17b18,0x17b30,0x17b3e,0x17b60,0x17b7c,0x17b8e,
        0x17b9c,0x17bb8,0x17bc4,0x17bc8,0x17bd0,0x17bde,0x17be6,0x17bec,0x17c2e,0x17c32,0x17c34,0x17c4e,
        0x17c5c,0x17c62,0x17c64,0x17c68,0x17c76,0x17c8e,0x17c9c,0x17cb8,0x17cc2,0x17cc4,0x17cc8,0x17cd0,
        0x17cde,0x17ce6,0x17cec,0x17d0e,0x17d1c,0x17d38,0x17d70,0x17d82,0x17d84,0x17d88,0x17d90,0x17d9e,
        0x17da0,0x17dbc,0x17dc6,0x17dcc,0x17dd8,0x17dee,0x17e26,0x17e2c,0x17e3a,0x17e46,0x17e4c,0x17e58,
        0x17e6e,0x17e72,0x17e74,0x17e86,0x17e8c,0x17e98,0x17eb0,0x17ece,0x17edc,0x17ee2,0x17ee4,0x17ee8,
        0x17ef6,0x1813a,0x18172,0x18174,0x18216,0x18226,0x1823a,0x1824c,0x18258,0x1826e,0x18272,0x18274,
        0x18298,0x182be,0x182e2,0x182e4,0x182e8,0x182f6,0x1835e,0x1837a,0x183ae,0x183d6,0x18416,0x18426,
        0x1842c,0x1843a,0x18446,0x18458,0x1846e,0x18472,0x18474,0x18486,0x184b0,0x184be,0x184ce,0x184dc,
        0x184e2,0x184e4,0x184e8,0x184f6,0x18506,0x1850c,0x18518,0x18530,0x1853e,0x18560,0x1857c,0x1858e,
        0x1859c,0x185b8,0x185c2,0x185c4,0x185c8,0x185d0,0x185de,0x185e6,0x185ec,0x185fa,0x18612,0x18614,
        0x18622,0x18628,0x18636,0x18642,0x18650,0x1865e,0x1867a,0x18682,0x18684,0x18688,0x18690,0x1869e,
        0x186a0,0x186bc,0x186c6,0x186cc,0x186d8,0x186ee,0x186f2,0x186f4,0x1872e,0x1874e,0x1875c,0x18796,
        0x187a6,0x187ac,0x187d2,0x187d4,0x18826,0x1882c,0x1883a,0x18846,0x1884c,0x18858,0x1886e,0x18872,
        0x18874,0x18886,0x18898,0x188b0,0x188be,0x188ce,0x188dc,0x188e2,0x188e4,0x188e8,0x188f6,0x1890c,
        0x18930,0x1893e,0x18960,0x1897c,0x1898e,0x189b8,0x189c2,0x189c8,0x189d0,0x189de,0x189e6,0x189ec,
        0x189fa,0x18a18,0x18a30,0x18a3e,0x18a60,0x18a7c,0x18ac0,0x18af8,0x18b1c,0x18b38,0x18b70,0x18b7e,
        0x18b82,0x18b84,0x18b88,0x18b90,0x18b9e,0x18ba0,0x18bbc,0x18bc6,0x18bcc,0x18bd8,0x18bee,0x18bf2,
        0x18bf4,0x18c22,0x18c24,0x18c28,0x18c36,0x18c42,0x18c48,0x18c50,0x18c5e,0x18c66,0x18c7a,0x18c82,
        0x18c84,0x18c90,0x18c9e,0x18ca0,0x18cbc,0x18ccc,0x18cf2,0x18cf4,0x18d04,0x18d08,0x18d10,0x18d1e,
        0x18d20,0x18d3c,0x18d40,0x18d78,0x18d86,0x18d98,0x18dce,0x18de2,0x18de4,0x18de8,0x18e2e,0x18e32,
        0x18e34,0x18e4e,0x18e5c,0x18e62,0x18e64,0x18e68,0x18e8e,0x18e9c,0x18eb8,0x18ec2,0x18ec4,0x18ec8,
        0x18ed0,0x18efa,0x18f16,0x18f26,0x18f2c,0x18f46,0x18f4c,0x18f58,0x18f6e,0x18f8a,0x18f92,0x18f94,
        0x18fa2,0x18fa4,0x18fa8,0x18fb6,0x1902c,0x1903a,0x19046,0x1904c,0x19058,0x19072,0x19074,0x19086,
        0x19098,0x190b0,0x190be,0x190ce,0x190dc,0x190e2,0x190e8,0x190f6,0x19106,0x1910c,0x19130,0x1913e,
        0x19160,0x1917c,0x1918e,0x1919c,0x191b8,0x191c2,0x191c8,0x191d0,0x191de,0x191e6,0x191ec,0x191fa,
        0x19218,0x1923e,0x19260,0x1927c,0x192c0,0x192f8,0x19338,0x19370,0x1937e,0x19382,0x19384,0x19390,
        0x1939e,0x193a0,0x193bc,0x193c6,0x193cc,0x193d8,0x193ee,0x193f2,0x193f4,0x19430,0x1943e,0x19460,
        0x1947c,0x194c0,0x194f8,0x195f0,0x19638,0x19670,0x1967e,0x196e0,0x196fc,0x19702,0x19704,0x19708,
        0x19710,0x19720,0x1973c,0x19740,0x19778,0x19786,0x1978c,0x19798,0x197b0,0x197be,0x197ce,0x197dc,
        0x197e2,0x197e4,0x197e8,0x19822,0x19824,0x19842,0x19848,0x19850,0x1985e,0x19866,0x1987a,0x19882,
        0x19884,0x19890,0x1989e,0x198a0,0x198bc,0x198cc,0x198f2,0x198f4,0x19902,0x19908,0x1991e,0x19920,
        0x1993c,0x19940,0x19978,0x19986,0x19998,0x199ce,0x199e2,0x199e4,0x199e8,0x19a08,0x19a10,0x19a1e,
        0x19a20,0x19a3c,0x19a40,0x19a78,0x19af0,0x19b18,0x19b3e,0x19b60,0x19b9c,0x19bc2,0x19bc4,0x19bc8,
        0x19bd0,0x19be6,0x19c2e,0x19c34,0x19c4e,0x19c5c,0x19c62,0x19c64,0x19c68,0x19c8e,0x19c9c,0x19cb8,
        0x19cc2,0x19cc8,0x19cd0,0x19ce6,0x19cfa,0x19d0e,0x19d1c,0x19d38,0x19d70,0x19d7e,0x19d82,0x19d84,
        0x19d88,0x19d90,0x19da0,0x19dcc,0x19df2,0x19df4,0x19e16,0x19e26,0x19e2c,0x19e46,0x19e4c,0x19e58,
        0x19e74,0x19e86,0x19e8c,0x19e98,0x19eb0,0x19ebe,0x19ece,0x19ee2,0x19ee4,0x19ee8,0x19f0a,0x19f12,
        0x19f14,0x19f22,0x19f24,0x19f28,0x19f42,0x19f44,0x19f48,0x19f50,0x19f5e,0x19f6c,0x19f9a,0x19fae,
        0x19fb2,0x19fb4,0x1a046,0x1a04c,0x1a072,0x1a074,0x1a086,0x1a08c,0x1a098,0x1a0b0,0x1a0be,0x1a0e2,
        0x1a0e4,0x1a0e8,0x1a0f6,0x1a106,0x1a10c,0x1a118,0x1a130,0x1a13e,0x1a160,0x1a17c,0x1a18e,0x1a19c,
        0x1a1b8,0x1a1c2,0x1a1c4,0x1a1c8,0x1a1d0,0x1a1de,0x1a1e6,0x1a1ec,0x1a218,0x1a230,0x1a23e,0x1a260,
        0x1a27c,0x1a2c0,0x1a2f8,0x1a31c,0x1a338,0x1a370,0x1a37e,0x1a382,0x1a384,0x1a388,0x1a390,0x1a39e,
        0x1a3a0,0x1a3bc,0x1a3c6,0x1a3cc,0x1a3d8,0x1a3ee,0x1a3f2,0x1a3f4,0x1a418,0x1a430,0x1a43e,0x1a460,
        0x1a47c,0x1a4c0,0x1a4f8,0x1a5f0,0x1a61c,0x1a638,0x1a670,0x1a67e,0x1a6e0,0x1a6fc,0x1a702,0x1a704,
        0x1a708,0x1a710,0x1a71e,0x1a720,0x1a73c,0x1a740,0x1a778,0x1a786,0x1a78c,0x1a798,0x1a7b0,0x1a7be,
        0x1a7ce,0x1a7dc,0x1a7e2,0x1a7e4,0x1a7e8,0x1a830,0x1a860,0x1a87c,0x1a8c0,0x1a8f8,0x1a9f0,0x1abe0,
        0x1ac70,0x1ac7e,0x1ace0,0x1acfc,0x1adc0,0x1adf8,0x1ae04,0x1ae08,0x1ae10,0x1ae20,0x1ae3c,0x1ae40,
        0x1ae78,0x1aef0,0x1af06,0x1af0c,0x1af18,0x1af30,0x1af3e,0x1af60,0x1af7c,0x1af8e,0x1af9c,0x1afb8,
        0x1afc4,0x1afc8,0x1afd0,0x1afde,0x1b042,0x1b05e,0x1b07a,0x1b082,0x1b084,0x1b088,0x1b090,0x1b09e,
        0x1b0a0,0x1b0bc,0x1b0cc,0x1b0f2,0x1b0f4,0x1b102,0x1b104,0x1b108,0x1b110,0x1b11e,0x1b120,0x1b13c,
        0x1b140,0x1b178,0x1b186,0x1b198,0x1b1ce,0x1b1e2,0x1b1e4,0x1b1e8,0x1b204,0x1b208,0x1b210,0x1b21e,
        0x1b220,0x1b23c,0x1b240,0x1b278,0x1b2f0,0x1b30c,0x1b33e,0x1b360,0x1b39c,0x1b3c2,0x1b3c4,0x1b3c8,
        0x1b3d0,0x1b3e6,0x1b410,0x1b41e,0x1b420,0x1b43c,0x1b440,0x1b478,0x1b4f0,0x1b5e0,0x1b618,0x1b660,
        0x1b67c,0x1b6c0,0x1b738,0x1b782,0x1b784,0x1b788,0x1b790,0x1b79e,0x1b7a0,0x1b7cc,0x1b82e,0x1b84e,
        0x1b85c,0x1b88e,0x1b89c,0x1b8b8,0x1b8c2,0x1b8c4,0x1b8c8,0x1b8d0,0x1b8e6,0x1b8fa,0x1b90e,0x1b91c,
        0x1b938,0x1b970,0x1b97e,0x1b982,0x1b984,0x1b988,0x1b990,0x1b99e,0x1b9a0,0x1b9cc,0x1b9f2,0x1b9f4,
        0x1ba0e,0x1ba1c,0x1ba38,0x1ba70,0x1ba7e,0x1bae0,0x1bafc,0x1bb08,0x1bb10,0x1bb20,0x1bb3c,0x1bb40,
        0x1bb98,0x1bbce,0x1bbe2,0x1bbe4,0x1bbe8,0x1bc16,0x1bc26,0x1bc2c,0x1bc46,0x1bc4c,0x1bc58,0x1bc72,
        0x1bc74,0x1bc86,0x1bc8c,0x1bc98,0x1bcb0,0x1bcbe,0x1bcce,0x1bce2,0x1bce4,0x1bce8,0x1bd06,0x1bd0c,
        0x1bd18,0x1bd30,0x1bd3e,0x1bd60,0x1bd7c,0x1bd9c,0x1bdc2,0x1bdc4,0x1bdc8,0x1bdd0,0x1bde6,0x1bdfa,
        0x1be12,0x1be14,0x1be22,0x1be24,0x1be28,0x1be42,0x1be44,0x1be48,0x1be50,0x1be5e,0x1be66,0x1be82,
        0x1be84,0x1be88,0x1be90,0x1be9e,0x1bea0,0x1bebc,0x1becc,0x1bef4,0x1bf1a,0x1bf2e,0x1bf32,0x1bf34,
        0x1bf4e,0x1bf5c,0x1bf62,0x1bf64,0x1bf68,0x1c09a,0x1c0b2,0x1c0b4,0x1c11a,0x1c132,0x1c134,0x1c162,
        0x1c164,0x1c168,0x1c176,0x1c1ba,0x1c21a,0x1c232,0x1c234,0x1c24e,0x1c25c,0x1c262,0x1c264,0x1c268,
        0x1c276,0x1c28e,0x1c2c2,0x1c2c4,0x1c2c8,0x1c2d0,0x1c2de,0x1c2e6,0x1c2ec,0x1c2fa,0x1c316,0x1c326,
        0x1c33a,0x1c346,0x1c34c,0x1c372,0x1c374,0x1c41a,0x1c42e,0x1c432,0x1c434,0x1c44e,0x1c45c,0x1c462,
        0x1c464,0x1c468,0x1c476,0x1c48e,0x1c49c,0x1c4b8,0x1c4c2,0x1c4c8,0x1c4d0,0x1c4de,0x1c4e6,0x1c4ec,
        0x1c4fa,0x1c51c,0x1c538,0x1c570,0x1c57e,0x1c582,0x1c584,0x1c588,0x1c590,0x1c59e,0x1c5a0,0x1c5bc,
        0x1c5c6,0x1c5cc,0x1c5d8,0x1c5ee,0x1c5f2,0x1c5f4,0x1c616,0x1c626,0x1c62c,0x1c63a,0x1c646,0x1c64c,
        0x1c658,0x1c66e,0x1c672,0x1c674,0x1c686,0x1c68c,0x1c698,0x1c6b0,0x1c6be,0x1c6ce,0x1c6dc,0x1c6e2,
        0x1c6e4,0x1c6e8,0x1c712,0x1c714,0x1c722,0x1c728,0x1c736,0x1c742,0x1c744,0x1c748,0x1c750,0x1c75e,
        0x1c766,0x1c76c,0x1c77a,0x1c7ae,0x1c7d6,0x1c7ea,0x1c81a,0x1c82e,0x1c832,0x1c834,0x1c84e,0x1c85c,
        0x1c862,0x1c864,0x1c868,0x1c876,0x1c88e,0x1c89c,0x1c8b8,0x1c8c2,0x1c8c8,0x1c8d0,0x1c8de,0x1c8e6,
        0x1c8ec,0x1c8fa,0x1c90e,0x1c938,0x1c970,0x1c97e,0x1c982,0x1c984,0x1c990,0x1c99e,0x1c9a0,0x1c9bc,
        0x1c9c6,0x1c9cc,0x1c9d8,0x1c9ee,0x1c9f2,0x1c9f4,0x1ca38,0x1ca70,0x1ca7e,0x1cae0,0x1cafc,0x1cb02,
        0x1cb04,0x1cb08,0x1cb10,0x1cb20,0x1cb3c,0x1cb40,0x1cb78,0x1cb86,0x1cb8c,0x1cb98,0x1cbb0,0x1cbbe,
        0x1cbce,0x1cbdc,0x1cbe2,0x1cbe4,0x1cbe8,0x1cbf6,0x1cc16,0x1cc26,0x1cc2c,0x1cc3a,0x1cc46,0x1cc58,
        0x1cc72,0x1cc74,0x1cc86,0x1ccb0,0x1ccbe,0x1ccce,0x1cce2,0x1cce4,0x1cce8,0x1cd06,0x1cd0c,0x1cd18,
        0x1cd30,0x1cd3e,0x1cd60,0x1cd7c,0x1cd9c,0x1cdc2,0x1cdc4,0x1cdc8,0x1cdd0,0x1cdde,0x1cde6,0x1cdfa,
        0x1ce22,0x1ce28,0x1ce42,0x1ce50,0x1ce5e,0x1ce66,0x1ce7a,0x1ce82,0x1ce84,0x1ce88,0x1ce90,0x1ce9e,
        0x1cea0,0x1cebc,0x1cecc,0x1cef2,0x1cef4,0x1cf2e,0x1cf32,0x1cf34,0x1cf4e,0x1cf5c,0x1cf62,0x1cf64,
        0x1cf68,0x1cf96,0x1cfa6,0x1cfac,0x1cfca,0x1cfd2,0x1cfd4,0x1d02e,0x1d032,0x1d034,0x1d04e,0x1d05c,
        0x1d062,0x1d064,0x1d068,0x1d076,0x1d08e,0x1d09c,0x1d0b8,0x1d0c2,0x1d0c4,0x1d0c8,0x1d0d0,0x1d0de,
        0x1d0e6,0x1d0ec,0x1d0fa,0x1d11c,0x1d138,0x1d170,0x1d17e,0x1d182,0x1d184,0x1d188,0x1d190,0x1d19e,
        0x1d1a0,0x1d1bc,0x1d1c6,0x1d1cc,0x1d1d8,0x1d1ee,0x1d1f2,0x1d1f4,0x1d21c,0x1d238,0x1d270,0x1d27e,
        0x1d2e0,0x1d2fc,0x1d302,0x1d304,0x1d308,0x1d310,0x1d31e,0x1d320,0x1d33c,0x1d340,0x1d378,0x1d386,
        0x1d38c,0x1d398,0x1d3b0,0x1d3be,0x1d3ce,0x1d3dc,0x1d3e2,0x1d3e4,0x1d3e8,0x1d3f6,0x1d470,0x1d47e,
        0x1d4e0,0x1d4fc,0x1d5c0,0x1d5f8,0x1d604,0x1d608,0x1d610,0x1d620,0x1d640,0x1d678,0x1d6f0,0x1d706,
        0x1d70c,0x1d718,0x1d730,0x1d73e,0x1d760,0x1d77c,0x1d78e,0x1d79c,0x1d7b8,0x1d7c2,0x1d7c4,0x1d7c8,
        0x1d7d0,0x1d7de,0x1d7e6,0x1d7ec,0x1d826,0x1d82c,0x1d83a,0x1d846,0x1d84c,0x1d858,0x1d872,0x1d874,
        0x1d886,0x1d88c,0x1d898,0x1d8b0,0x1d8be,0x1d8ce,0x1d8e2,0x1d8e4,0x1d8e8,0x1d8f6,0x1d90c,0x1d918,
        0x1d930,0x1d93e,0x1d960,0x1d97c,0x1d99c,0x1d9c2,0x1d9c4,0x1d9c8,0x1d9d0,0x1d9e6,0x1d9fa,0x1da0c,
        0x1da18,0x1da30,0x1da3e,0x1da60,0x1da7c,0x1dac0,0x1daf8,0x1db38,0x1db82,0x1db84,0x1db88,0x1db90,
        0x1db9e,0x1dba0,0x1dbcc,0x1dbf2,0x1dbf4,0x1dc22,0x1dc42,0x1dc44,0x1dc48,0x1dc50,0x1dc5e,0x1dc66,
        0x1dc7a,0x1dc82,0x1dc84,0x1dc88,0x1dc90,0x1dc9e,0x1dca0,0x1dcbc,0x1dccc,0x1dcf2,0x1dcf4,0x1dd04,
        0x1dd08,0x1dd10,0x1dd1e,0x1dd20,0x1dd3c,0x1dd40,0x1dd78,0x1dd86,0x1dd98,0x1ddce,0x1dde2,0x1dde4,
        0x1dde8,0x1de2e,0x1de32,0x1de34,0x1de4e,0x1de5c,0x1de62,0x1de64,0x1de68,0x1de8e,0x1de9c,0x1deb8,
        0x1dec2,0x1dec4,0x1dec8,0x1ded0,0x1dee6,0x1defa,0x1df16,0x1df26,0x1df2c,0x1df46,0x1df4c,0x1df58,
        0x1df72,0x1df74,0x1df8a,0x1df92,0x1df94,0x1dfa2,0x1dfa4,0x1dfa8,0x1e08a,0x1e092,0x1e094,0x1e0a2,
        0x1e0a4,0x1e0a8,0x1e0b6,0x1e0da,0x1e10a,0x1e112,0x1e114,0x1e122,0x1e124,0x1e128,0x1e136,0x1e142,
        0x1e144,0x1e148,0x1e150,0x1e166,0x1e16c,0x1e17a,0x1e19a,0x1e1b2,0x1e1b4,0x1e20a,0x1e212,0x1e214,
        0x1e222,0x1e224,0x1e228,0x1e236,0x1e242,0x1e248,0x1e250,0x1e25e,0x1e266,0x1e26c,0x1e27a,0x1e282,
        0x1e284,0x1e288,0x1e290,0x1e2a0,0x1e2bc,0x1e2c6,0x1e2cc,0x1e2d8,0x1e2ee,0x1e2f2,0x1e2f4,0x1e31a,
        0x1e332,0x1e334,0x1e35c,0x1e362,0x1e364,0x1e368,0x1e3ba,0x1e40a,0x1e412,0x1e414,0x1e422,0x1e428,
        0x1e436,0x1e442,0x1e448,0x1e450,0x1e45e,0x1e466,0x1e46c,0x1e47a,0x1e482,0x1e484,0x1e490,0x1e49e,
        0x1e4a0,0x1e4bc,0x1e4c6,0x1e4cc,0x1e4d8,0x1e4ee,0x1e4f2,0x1e4f4,0x1e502,0x1e504,0x1e508,0x1e510,
        0x1e51e,0x1e520,0x1e53c,0x1e540,0x1e578,0x1e586,0x1e58c,0x1e598,0x1e5b0,0x1e5be,0x1e5ce,0x1e5dc,
        0x1e5e2,0x1e5e4,0x1e5e8,0x1e5f6,0x1e61a,0x1e62e,0x1e632,0x1e634,0x1e64e,0x1e65c,0x1e662,0x1e668,
        0x1e68e,0x1e69c,0x1e6b8,0x1e6c2,0x1e6c4,0x1e6c8,0x1e6d0,0x1e6e6,0x1e6fa,0x1e716,0x1e726,0x1e72c,
        0x1e73a,0x1e746,0x1e74c,0x1e758,0x1e772,0x1e774,0x1e792,0x1e794,0x1e7a2,0x1e7a4,0x1e7a8,0x1e7b6,
        0x1e812,0x1e814,0x1e822,0x1e824,0x1e828,0x1e836,0x1e842,0x1e844,0x1e848,0x1e850,0x1e85e,0x1e866,
        0x1e86c,0x1e87a,0x1e882,0x1e884,0x1e888,0x1e890,0x1e89e,0x1e8a0,0x1e8bc,0x1e8c6,0x1e8cc,0x1e8d8,
        0x1e8ee,0x1e8f2,0x1e8f4,0x1e902,0x1e904,0x1e908,0x1e910,0x1e920,0x1e93c,0x1e940,0x1e978,0x1e986,
        0x1e98c,0x1e998,0x1e9b0,0x1e9be,0x1e9ce,0x1e9dc,0x1e9e2,0x1e9e4,0x1e9e8,0x1e9f6,0x1ea04,0x1ea08,
        0x1ea10,0x1ea20,0x1ea40,0x1ea78,0x1eaf0,0x1eb06,0x1eb0c,0x1eb18,0x1eb30,0x1eb3e,0x1eb60,0x1eb7c,
        0x1eb8e,0x1eb9c,0x1ebb8,0x1ebc2,0x1ebc4,0x1ebc8,0x1ebd0,0x1ebde,0x1ebe6,0x1ebec,0x1ec1a,0x1ec2e,
        0x1ec32,0x1ec34,0x1ec4e,0x1ec5c,0x1ec62,0x1ec64,0x1ec68,0x1ec8e,0x1ec9c,0x1ecb8,0x1ecc2,0x1ecc4,
        0x1ecc8,0x1ecd0,0x1ece6,0x1ecfa,0x1ed0e,0x1ed1c,0x1ed38,0x1ed70,0x1ed7e,0x1ed82,0x1ed84,0x1ed88,
        0x1ed90,0x1ed9e,0x1eda0,0x1edcc,0x1edf2,0x1edf4,0x1ee16,0x1ee26,0x1ee2c,0x1ee3a,0x1ee46,0x1ee4c,
        0x1ee58,0x1ee6e,0x1ee72,0x1ee74,0x1ee86,0x1ee8c,0x1ee98,0x1eeb0,0x1eebe,0x1eece,0x1eedc,0x1eee2,
        0x1eee4,0x1eee8,0x1ef12,0x1ef22,0x1ef24,0x1ef28,0x1ef36,0x1ef42,0x1ef44,0x1ef48,0x1ef50,0x1ef5e,
        0x1ef66,0x1ef6c,0x1ef7a,0x1efae,0x1efb2,0x1efb4,0x1efd6,0x1f096,0x1f0a6,0x1f0ac,0x1f0ba,0x1f0ca,
        0x1f0d2,0x1f0d4,0x1f116,0x1f126,0x1f12c,0x1f13a,0x1f146,0x1f14c,0x1f158,0x1f16e,0x1f172,0x1f174,
        0x1f18a,0x1f192,0x1f194,0x1f1a2,0x1f1a4,0x1f1a8,0x1f1da,0x1f216,0x1f226,0x1f22c,0x1f23a,0x1f246,
        0x1f258,0x1f26e,0x1f272,0x1f274,0x1f286,0x1f28c,0x1f298,0x1f2b0,0x1f2be,0x1f2ce,0x1f2dc,0x1f2e2,
        0x1f2e4,0x1f2e8,0x1f2f6,0x1f30a,0x1f312,0x1f314,0x1f322,0x1f328,0x1f342,0x1f344,0x1f348,0x1f350,
        0x1f35e,0x1f366,0x1f37a,0x1f39a,0x1f3ae,0x1f3b2,0x1f3b4,0x1f416,0x1f426,0x1f42c,0x1f43a,0x1f446,
        0x1f44c,0x1f458,0x1f46e,0x1f472,0x1f474,0x1f486,0x1f48c,0x1f498,0x1f4b0,0x1f4be,0x1f4ce,0x1f4dc,
        0x1f4e2,0x1f4e4,0x1f4e8,0x1f4f6,0x1f506,0x1f50c,0x1f518,0x1f530,0x1f53e,0x1f560,0x1f57c,0x1f58e,
        0x1f59c,0x1f5b8,0x1f5c2,0x1f5c4,0x1f5c8,0x1f5d0,0x1f5de,0x1f5e6,0x1f5ec,0x1f5fa,0x1f60a,0x1f612,
        0x1f614,0x1f622,0x1f624,0x1f628,0x1f636,0x1f642,0x1f644,0x1f648,0x1f650,0x1f65e,0x1f666,0x1f67a,
        0x1f682,0x1f684,0x1f688,0x1f690,0x1f69e,0x1f6a0,0x1f6bc,0x1f6cc,0x1f6f2,0x1f6f4,0x1f71a,0x1f72e,
        0x1f732,0x1f734,0x1f74e,0x1f75c,0x1f762,0x1f764,0x1f768,0x1f776,0x1f796,0x1f7a6,0x1f7ac,0x1f7ba,
        0x1f7d2,0x1f7d4,0x1f89a,0x1f8ae,0x1f8b2,0x1f8b4,0x1f8d6,0x1f8ea,0x1f91a,0x1f92e,0x1f932,0x1f934,
        0x1f94e,0x1f95c,0x1f962,0x1f964,0x1f968,0x1f976,0x1f996,0x1f9a6,0x1f9ac,0x1f9ba,0x1f9ca,0x1f9d2,
        0x1f9d4,0x1fa1a,0x1fa2e,0x1fa32,0x1fa34,0x1fa4e,0x1fa5c,0x1fa62,0x1fa64,0x1fa68,0x1fa76,0x1fa8e,
        0x1fa9c,0x1fab8,0x1fac2,0x1fac4,0x1fac8,0x1fad0,0x1fade,0x1fae6,0x1faec,0x1fb16,0x1fb26,0x1fb2c,
        0x1fb3a,0x1fb46,0x1fb4c,0x1fb58,0x1fb6e,0x1fb72,0x1fb74,0x1fb8a,0x1fb92,0x1fb94,0x1fba2,0x1fba4,
        0x1fba8,0x1fbb6,0x1fbda
    ]);
    /**
     *Thistablecontainstocodewordsforallsymbols.
     */
    PDF417Common.CODEWORD_TABLE=Int32Array.from([
        2627,1819,2622,2621,1813,1812,2729,2724,2723,2779,2774,2773,902,896,908,868,865,861,859,2511,
        873,871,1780,835,2493,825,2491,842,837,844,1764,1762,811,810,809,2483,807,2482,806,2480,815,
        814,813,812,2484,817,816,1745,1744,1742,1746,2655,2637,2635,2626,2625,2623,2628,1820,2752,
        2739,2737,2728,2727,2725,2730,2785,2783,2778,2777,2775,2780,787,781,747,739,736,2413,754,752,
        1719,692,689,681,2371,678,2369,700,697,694,703,1688,1686,642,638,2343,631,2341,627,2338,651,
        646,643,2345,654,652,1652,1650,1647,1654,601,599,2322,596,2321,594,2319,2317,611,610,608,606,
        2324,603,2323,615,614,612,1617,1616,1614,1612,616,1619,1618,2575,2538,2536,905,901,898,909,
        2509,2507,2504,870,867,864,860,2512,875,872,1781,2490,2489,2487,2485,1748,836,834,832,830,
        2494,827,2492,843,841,839,845,1765,1763,2701,2676,2674,2653,2648,2656,2634,2633,2631,2629,
        1821,2638,2636,2770,2763,2761,2750,2745,2753,2736,2735,2733,2731,1848,2740,2738,2786,2784,591,
        588,576,569,566,2296,1590,537,534,526,2276,522,2274,545,542,539,548,1572,1570,481,2245,466,
        2242,462,2239,492,485,482,2249,496,494,1534,1531,1528,1538,413,2196,406,2191,2188,425,419,
        2202,415,2199,432,430,427,1472,1467,1464,433,1476,1474,368,367,2160,365,2159,362,2157,2155,
        2152,378,377,375,2166,372,2165,369,2162,383,381,379,2168,1419,1418,1416,1414,385,1411,384,
        1423,1422,1420,1424,2461,802,2441,2439,790,786,783,794,2409,2406,2403,750,742,738,2414,756,
        753,1720,2367,2365,2362,2359,1663,693,691,684,2373,680,2370,702,699,696,704,1690,1687,2337,
        2336,2334,2332,1624,2329,1622,640,637,2344,634,2342,630,2340,650,648,645,2346,655,653,1653,
        1651,1649,1655,2612,2597,2595,2571,2568,2565,2576,2534,2529,2526,1787,2540,2537,907,904,900,
        910,2503,2502,2500,2498,1768,2495,1767,2510,2508,2506,869,866,863,2513,876,874,1782,2720,2713,
        2711,2697,2694,2691,2702,2672,2670,2664,1828,2678,2675,2647,2646,2644,2642,1823,2639,1822,2654,
        2652,2650,2657,2771,1855,2765,2762,1850,1849,2751,2749,2747,2754,353,2148,344,342,336,2142,
        332,2140,345,1375,1373,306,2130,299,2128,295,2125,319,314,311,2132,1354,1352,1349,1356,262,
        257,2101,253,2096,2093,274,273,267,2107,263,2104,280,278,275,1316,1311,1308,1320,1318,2052,
        202,2050,2044,2040,219,2063,212,2060,208,2055,224,221,2066,1260,1258,1252,231,1248,229,1266,
        1264,1261,1268,155,1998,153,1996,1994,1991,1988,165,164,2007,162,2006,159,2003,2000,172,171,
        169,2012,166,2010,1186,1184,1182,1179,175,1176,173,1192,1191,1189,1187,176,1194,1193,2313,
        2307,2305,592,589,2294,2292,2289,578,572,568,2297,580,1591,2272,2267,2264,1547,538,536,529,
        2278,525,2275,547,544,541,1574,1571,2237,2235,2229,1493,2225,1489,478,2247,470,2244,465,2241,
        493,488,484,2250,498,495,1536,1533,1530,1539,2187,2186,2184,2182,1432,2179,1430,2176,1427,414,
        412,2197,409,2195,405,2193,2190,426,424,421,2203,418,2201,431,429,1473,1471,1469,1466,434,
        1477,1475,2478,2472,2470,2459,2457,2454,2462,803,2437,2432,2429,1726,2443,2440,792,789,785,
        2401,2399,2393,1702,2389,1699,2411,2408,2405,745,741,2415,758,755,1721,2358,2357,2355,2353,
        1661,2350,1660,2347,1657,2368,2366,2364,2361,1666,690,687,2374,683,2372,701,698,705,1691,1689,
        2619,2617,2610,2608,2605,2613,2593,2588,2585,1803,2599,2596,2563,2561,2555,1797,2551,1795,2573,
        2570,2567,2577,2525,2524,2522,2520,1786,2517,1785,2514,1783,2535,2533,2531,2528,1788,2541,2539,
        906,903,911,2721,1844,2715,2712,1838,1836,2699,2696,2693,2703,1827,1826,1824,2673,2671,2669,
        2666,1829,2679,2677,1858,1857,2772,1854,1853,1851,1856,2766,2764,143,1987,139,1986,135,133,
        131,1984,128,1983,125,1981,138,137,136,1985,1133,1132,1130,112,110,1974,107,1973,104,1971,
        1969,122,121,119,117,1977,114,1976,124,1115,1114,1112,1110,1117,1116,84,83,1953,81,1952,78,
        1950,1948,1945,94,93,91,1959,88,1958,85,1955,99,97,95,1961,1086,1085,1083,1081,1078,100,
        1090,1089,1087,1091,49,47,1917,44,1915,1913,1910,1907,59,1926,56,1925,53,1922,1919,66,64,
        1931,61,1929,1042,1040,1038,71,1035,70,1032,68,1048,1047,1045,1043,1050,1049,12,10,1869,1867,
        1864,1861,21,1880,19,1877,1874,1871,28,1888,25,1886,22,1883,982,980,977,974,32,30,991,989,
        987,984,34,995,994,992,2151,2150,2147,2146,2144,356,355,354,2149,2139,2138,2136,2134,1359,
        343,341,338,2143,335,2141,348,347,346,1376,1374,2124,2123,2121,2119,1326,2116,1324,310,308,
        305,2131,302,2129,298,2127,320,318,316,313,2133,322,321,1355,1353,1351,1357,2092,2091,2089,
        2087,1276,2084,1274,2081,1271,259,2102,256,2100,252,2098,2095,272,269,2108,266,2106,281,279,
        277,1317,1315,1313,1310,282,1321,1319,2039,2037,2035,2032,1203,2029,1200,1197,207,2053,205,
        2051,201,2049,2046,2043,220,218,2064,215,2062,211,2059,228,226,223,2069,1259,1257,1254,232,
        1251,230,1267,1265,1263,2316,2315,2312,2311,2309,2314,2304,2303,2301,2299,1593,2308,2306,590,
        2288,2287,2285,2283,1578,2280,1577,2295,2293,2291,579,577,574,571,2298,582,581,1592,2263,2262,
        2260,2258,1545,2255,1544,2252,1541,2273,2271,2269,2266,1550,535,532,2279,528,2277,546,543,549,
        1575,1573,2224,2222,2220,1486,2217,1485,2214,1482,1479,2238,2236,2234,2231,1496,2228,1492,480,
        477,2248,473,2246,469,2243,490,487,2251,497,1537,1535,1532,2477,2476,2474,2479,2469,2468,2466,
        2464,1730,2473,2471,2453,2452,2450,2448,1729,2445,1728,2460,2458,2456,2463,805,804,2428,2427,
        2425,2423,1725,2420,1724,2417,1722,2438,2436,2434,2431,1727,2444,2442,793,791,788,795,2388,
        2386,2384,1697,2381,1696,2378,1694,1692,2402,2400,2398,2395,1703,2392,1701,2412,2410,2407,751,
        748,744,2416,759,757,1807,2620,2618,1806,1805,2611,2609,2607,2614,1802,1801,1799,2594,2592,
        2590,2587,1804,2600,2598,1794,1793,1791,1789,2564,2562,2560,2557,1798,2554,1796,2574,2572,2569,
        2578,1847,1846,2722,1843,1842,1840,1845,2716,2714,1835,1834,1832,1830,1839,1837,2700,2698,2695,
        2704,1817,1811,1810,897,862,1777,829,826,838,1760,1758,808,2481,1741,1740,1738,1743,2624,1818,
        2726,2776,782,740,737,1715,686,679,695,1682,1680,639,628,2339,647,644,1645,1643,1640,1648,
        602,600,597,595,2320,593,2318,609,607,604,1611,1610,1608,1606,613,1615,1613,2328,926,924,892,
        886,899,857,850,2505,1778,824,823,821,819,2488,818,2486,833,831,828,840,1761,1759,2649,2632,
        2630,2746,2734,2732,2782,2781,570,567,1587,531,527,523,540,1566,1564,476,467,463,2240,486,
        483,1524,1521,1518,1529,411,403,2192,399,2189,423,416,1462,1457,1454,428,1468,1465,2210,366,
        363,2158,360,2156,357,2153,376,373,370,2163,1410,1409,1407,1405,382,1402,380,1417,1415,1412,
        1421,2175,2174,777,774,771,784,732,725,722,2404,743,1716,676,674,668,2363,665,2360,685,1684,
        1681,626,624,622,2335,620,2333,617,2330,641,635,649,1646,1644,1642,2566,928,925,2530,2527,
        894,891,888,2501,2499,2496,858,856,854,851,1779,2692,2668,2665,2645,2643,2640,2651,2768,2759,
        2757,2744,2743,2741,2748,352,1382,340,337,333,1371,1369,307,300,296,2126,315,312,1347,1342,
        1350,261,258,250,2097,246,2094,271,268,264,1306,1301,1298,276,1312,1309,2115,203,2048,195,
        2045,191,2041,213,209,2056,1246,1244,1238,225,1234,222,1256,1253,1249,1262,2080,2079,154,1997,
        150,1995,147,1992,1989,163,160,2004,156,2001,1175,1174,1172,1170,1167,170,1164,167,1185,1183,
        1180,1177,174,1190,1188,2025,2024,2022,587,586,564,559,556,2290,573,1588,520,518,512,2268,
        508,2265,530,1568,1565,461,457,2233,450,2230,446,2226,479,471,489,1526,1523,1520,397,395,
        2185,392,2183,389,2180,2177,410,2194,402,422,1463,1461,1459,1456,1470,2455,799,2433,2430,779,
        776,773,2397,2394,2390,734,728,724,746,1717,2356,2354,2351,2348,1658,677,675,673,670,667,688,
        1685,1683,2606,2589,2586,2559,2556,2552,927,2523,2521,2518,2515,1784,2532,895,893,890,2718,
        2709,2707,2689,2687,2684,2663,2662,2660,2658,1825,2667,2769,1852,2760,2758,142,141,1139,1138,
        134,132,129,126,1982,1129,1128,1126,1131,113,111,108,105,1972,101,1970,120,118,115,1109,1108,
        1106,1104,123,1113,1111,82,79,1951,75,1949,72,1946,92,89,86,1956,1077,1076,1074,1072,98,
        1069,96,1084,1082,1079,1088,1968,1967,48,45,1916,42,1914,39,1911,1908,60,57,54,1923,50,1920,
        1031,1030,1028,1026,67,1023,65,1020,62,1041,1039,1036,1033,69,1046,1044,1944,1943,1941,11,9,
        1868,7,1865,1862,1859,20,1878,16,1875,13,1872,970,968,966,963,29,960,26,23,983,981,978,975,
        33,971,31,990,988,985,1906,1904,1902,993,351,2145,1383,331,330,328,326,2137,323,2135,339,
        1372,1370,294,293,291,289,2122,286,2120,283,2117,309,303,317,1348,1346,1344,245,244,242,2090,
        239,2088,236,2085,2082,260,2099,249,270,1307,1305,1303,1300,1314,189,2038,186,2036,183,2033,
        2030,2026,206,198,2047,194,216,1247,1245,1243,1240,227,1237,1255,2310,2302,2300,2286,2284,
        2281,565,563,561,558,575,1589,2261,2259,2256,2253,1542,521,519,517,514,2270,511,533,1569,
        1567,2223,2221,2218,2215,1483,2211,1480,459,456,453,2232,449,474,491,1527,1525,1522,2475,2467,
        2465,2451,2449,2446,801,800,2426,2424,2421,2418,1723,2435,780,778,775,2387,2385,2382,2379,
        1695,2375,1693,2396,735,733,730,727,749,1718,2616,2615,2604,2603,2601,2584,2583,2581,2579,
        1800,2591,2550,2549,2547,2545,1792,2542,1790,2558,929,2719,1841,2710,2708,1833,1831,2690,2688,
        2686,1815,1809,1808,1774,1756,1754,1737,1736,1734,1739,1816,1711,1676,1674,633,629,1638,1636,
        1633,1641,598,1605,1604,1602,1600,605,1609,1607,2327,887,853,1775,822,820,1757,1755,1584,524,
        1560,1558,468,464,1514,1511,1508,1519,408,404,400,1452,1447,1444,417,1458,1455,2208,364,361,
        358,2154,1401,1400,1398,1396,374,1393,371,1408,1406,1403,1413,2173,2172,772,726,723,1712,672,
        669,666,682,1678,1675,625,623,621,618,2331,636,632,1639,1637,1635,920,918,884,880,889,849,
        848,847,846,2497,855,852,1776,2641,2742,2787,1380,334,1367,1365,301,297,1340,1338,1335,1343,
        255,251,247,1296,1291,1288,265,1302,1299,2113,204,196,192,2042,1232,1230,1224,214,1220,210,
        1242,1239,1235,1250,2077,2075,151,148,1993,144,1990,1163,1162,1160,1158,1155,161,1152,157,
        1173,1171,1168,1165,168,1181,1178,2021,2020,2018,2023,585,560,557,1585,516,509,1562,1559,458,
        447,2227,472,1516,1513,1510,398,396,393,390,2181,386,2178,407,1453,1451,1449,1446,420,1460,
        2209,769,764,720,712,2391,729,1713,664,663,661,659,2352,656,2349,671,1679,1677,2553,922,919,
        2519,2516,885,883,881,2685,2661,2659,2767,2756,2755,140,1137,1136,130,127,1125,1124,1122,1127,
        109,106,102,1103,1102,1100,1098,116,1107,1105,1980,80,76,73,1947,1068,1067,1065,1063,90,1060,
        87,1075,1073,1070,1080,1966,1965,46,43,40,1912,36,1909,1019,1018,1016,1014,58,1011,55,1008,
        51,1029,1027,1024,1021,63,1037,1034,1940,1939,1937,1942,8,1866,4,1863,1,1860,956,954,952,
        949,946,17,14,969,967,964,961,27,957,24,979,976,972,1901,1900,1898,1896,986,1905,1903,350,
        349,1381,329,327,324,1368,1366,292,290,287,284,2118,304,1341,1339,1337,1345,243,240,237,2086,
        233,2083,254,1297,1295,1293,1290,1304,2114,190,187,184,2034,180,2031,177,2027,199,1233,1231,
        1229,1226,217,1223,1241,2078,2076,584,555,554,552,550,2282,562,1586,507,506,504,502,2257,499,
        2254,515,1563,1561,445,443,441,2219,438,2216,435,2212,460,454,475,1517,1515,1512,2447,798,
        797,2422,2419,770,768,766,2383,2380,2376,721,719,717,714,731,1714,2602,2582,2580,2548,2546,
        2543,923,921,2717,2706,2705,2683,2682,2680,1771,1752,1750,1733,1732,1731,1735,1814,1707,1670,
        1668,1631,1629,1626,1634,1599,1598,1596,1594,1603,1601,2326,1772,1753,1751,1581,1554,1552,1504,
        1501,1498,1509,1442,1437,1434,401,1448,1445,2206,1392,1391,1389,1387,1384,359,1399,1397,1394,
        1404,2171,2170,1708,1672,1669,619,1632,1630,1628,1773,1378,1363,1361,1333,1328,1336,1286,1281,
        1278,248,1292,1289,2111,1218,1216,1210,197,1206,193,1228,1225,1221,1236,2073,2071,1151,1150,
        1148,1146,152,1143,149,1140,145,1161,1159,1156,1153,158,1169,1166,2017,2016,2014,2019,1582,
        510,1556,1553,452,448,1506,1500,394,391,387,1443,1441,1439,1436,1450,2207,765,716,713,1709,
        662,660,657,1673,1671,916,914,879,878,877,882,1135,1134,1121,1120,1118,1123,1097,1096,1094,
        1092,103,1101,1099,1979,1059,1058,1056,1054,77,1051,74,1066,1064,1061,1071,1964,1963,1007,
        1006,1004,1002,999,41,996,37,1017,1015,1012,1009,52,1025,1022,1936,1935,1933,1938,942,940,
        938,935,932,5,2,955,953,950,947,18,943,15,965,962,958,1895,1894,1892,1890,973,1899,1897,
        1379,325,1364,1362,288,285,1334,1332,1330,241,238,234,1287,1285,1283,1280,1294,2112,188,185,
        181,178,2028,1219,1217,1215,1212,200,1209,1227,2074,2072,583,553,551,1583,505,503,500,513,
        1557,1555,444,442,439,436,2213,455,451,1507,1505,1502,796,763,762,760,767,711,710,708,706,
        2377,718,715,1710,2544,917,915,2681,1627,1597,1595,2325,1769,1749,1747,1499,1438,1435,2204,
        1390,1388,1385,1395,2169,2167,1704,1665,1662,1625,1623,1620,1770,1329,1282,1279,2109,1214,1207,
        1222,2068,2065,1149,1147,1144,1141,146,1157,1154,2013,2011,2008,2015,1579,1549,1546,1495,1487,
        1433,1431,1428,1425,388,1440,2205,1705,658,1667,1664,1119,1095,1093,1978,1057,1055,1052,1062,
        1962,1960,1005,1003,1000,997,38,1013,1010,1932,1930,1927,1934,941,939,936,933,6,930,3,951,
        948,944,1889,1887,1884,1881,959,1893,1891,35,1377,1360,1358,1327,1325,1322,1331,1277,1275,
        1272,1269,235,1284,2110,1205,1204,1201,1198,182,1195,179,1213,2070,2067,1580,501,1551,1548,
        440,437,1497,1494,1490,1503,761,709,707,1706,913,912,2198,1386,2164,2161,1621,1766,2103,1208,
        2058,2054,1145,1142,2005,2002,1999,2009,1488,1429,1426,2200,1698,1659,1656,1975,1053,1957,1954,
        1001,998,1924,1921,1918,1928,937,934,931,1879,1876,1873,1870,945,1885,1882,1323,1273,1270,
        2105,1202,1199,1196,1211,2061,2057,1576,1543,1540,1484,1481,1478,1491,1700
    ]);

    /*
    *Copyright2007ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    //importjava.util.List;
    /**
     *@authorGuentherGrau
     */
    /*publicfinal*/classPDF417DetectorResult{
        constructor(bits,points){
            this.bits=bits;
            this.points=points;
        }
        getBits(){
            returnthis.bits;
        }
        getPoints(){
            returnthis.points;
        }
    }

    /*
    *Copyright2009ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    //importjava.util.ArrayList;
    //importjava.util.Arrays;
    //importjava.util.List;
    //importjava.util.Map;
    /**
     *<p>EncapsulateslogicthatcandetectaPDF417Codeinanimage,evenifthe
     *PDF417Codeisrotatedorskewed,orpartiallyobscured.</p>
     *
     *@authorSITALab(kevin.osullivan@sita.aero)
     *@authordswitkin@google.com(DanielSwitkin)
     *@authorGuentherGrau
     */
    /*public*//*final*/classDetector$3{
        /**
         *<p>DetectsaPDF417Codeinanimage.Onlychecks0and180degreerotations.</p>
         *
         *@paramimagebarcodeimagetodecode
         *@paramhintsoptionalhintstodetector
         *@parammultipleiftrue,thentheimageissearchedformultiplecodes.Iffalse,thenatmostonecodewill
         *befoundandreturned
         *@return{@linkPDF417DetectorResult}encapsulatingresultsofdetectingaPDF417code
         *@throwsNotFoundExceptionifnoPDF417Codecanbefound
         */
        staticdetectMultiple(image,hints,multiple){
            //TODOdetectionimprovement,tryHardercouldtryseveraldifferentluminancethresholds/blackpointsoreven
            //differentbinarizers
            //booleantryHarder=hints!=null&&hints.containsKey(DecodeHintType.TRY_HARDER);
            letbitMatrix=image.getBlackMatrix();
            letbarcodeCoordinates=Detector$3.detect(multiple,bitMatrix);
            if(!barcodeCoordinates.length){
                bitMatrix=bitMatrix.clone();
                bitMatrix.rotate180();
                barcodeCoordinates=Detector$3.detect(multiple,bitMatrix);
            }
            returnnewPDF417DetectorResult(bitMatrix,barcodeCoordinates);
        }
        /**
         *DetectsPDF417codesinanimage.Onlychecks0degreerotation
         *@parammultipleiftrue,thentheimageissearchedformultiplecodes.Iffalse,thenatmostonecodewill
         *befoundandreturned
         *@parambitMatrixbitmatrixtodetectbarcodesin
         *@returnListofResultPointarrayscontainingthecoordinatesoffoundbarcodes
         */
        staticdetect(multiple,bitMatrix){
            constbarcodeCoordinates=newArray();
            letrow=0;
            letcolumn=0;
            letfoundBarcodeInRow=false;
            while(row<bitMatrix.getHeight()){
                constvertices=Detector$3.findVertices(bitMatrix,row,column);
                if(vertices[0]==null&&vertices[3]==null){
                    if(!foundBarcodeInRow){
                        //wedidn'tfindanybarcodesothat'stheendofsearching
                        break;
                    }
                    //wedidn'tfindabarcodestartingatthegivencolumnandrow.Tryagainfromthefirstcolumnandslightly
                    //belowthelowestbarcodewefoundsofar.
                    foundBarcodeInRow=false;
                    column=0;
                    for(constbarcodeCoordinateofbarcodeCoordinates){
                        if(barcodeCoordinate[1]!=null){
                            row=Math.trunc(Math.max(row,barcodeCoordinate[1].getY()));
                        }
                        if(barcodeCoordinate[3]!=null){
                            row=Math.max(row,Math.trunc(barcodeCoordinate[3].getY()));
                        }
                    }
                    row+=Detector$3.ROW_STEP;
                    continue;
                }
                foundBarcodeInRow=true;
                barcodeCoordinates.push(vertices);
                if(!multiple){
                    break;
                }
                //ifwedidn'tfindarightrowindicatorcolumn,thencontinuethesearchforthenextbarcodeafterthe
                //startpatternofthebarcodejustfound.
                if(vertices[2]!=null){
                    column=Math.trunc(vertices[2].getX());
                    row=Math.trunc(vertices[2].getY());
                }
                else{
                    column=Math.trunc(vertices[4].getX());
                    row=Math.trunc(vertices[4].getY());
                }
            }
            returnbarcodeCoordinates;
        }
        /**
         *LocatetheverticesandthecodewordsareaofablackblobusingtheStart
         *andStoppatternsaslocators.
         *
         *@parammatrixthescannedbarcodeimage.
         *@returnanarraycontainingthevertices:
         *          vertices[0]x,ytopleftbarcode
         *          vertices[1]x,ybottomleftbarcode
         *          vertices[2]x,ytoprightbarcode
         *          vertices[3]x,ybottomrightbarcode
         *          vertices[4]x,ytopleftcodewordarea
         *          vertices[5]x,ybottomleftcodewordarea
         *          vertices[6]x,ytoprightcodewordarea
         *          vertices[7]x,ybottomrightcodewordarea
         */
        staticfindVertices(matrix,startRow,startColumn){
            constheight=matrix.getHeight();
            constwidth=matrix.getWidth();
            //constresult=newResultPoint[8];
            constresult=newArray(8);
            Detector$3.copyToResult(result,Detector$3.findRowsWithPattern(matrix,height,width,startRow,startColumn,Detector$3.START_PATTERN),Detector$3.INDEXES_START_PATTERN);
            if(result[4]!=null){
                startColumn=Math.trunc(result[4].getX());
                startRow=Math.trunc(result[4].getY());
            }
            Detector$3.copyToResult(result,Detector$3.findRowsWithPattern(matrix,height,width,startRow,startColumn,Detector$3.STOP_PATTERN),Detector$3.INDEXES_STOP_PATTERN);
            returnresult;
        }
        staticcopyToResult(result,tmpResult,destinationIndexes){
            for(leti=0;i<destinationIndexes.length;i++){
                result[destinationIndexes[i]]=tmpResult[i];
            }
        }
        staticfindRowsWithPattern(matrix,height,width,startRow,startColumn,pattern){
            //constresult=newResultPoint[4];
            constresult=newArray(4);
            letfound=false;
            constcounters=newInt32Array(pattern.length);
            for(;startRow<height;startRow+=Detector$3.ROW_STEP){
                letloc=Detector$3.findGuardPattern(matrix,startColumn,startRow,width,false,pattern,counters);
                if(loc!=null){
                    while(startRow>0){
                        constpreviousRowLoc=Detector$3.findGuardPattern(matrix,startColumn,--startRow,width,false,pattern,counters);
                        if(previousRowLoc!=null){
                            loc=previousRowLoc;
                        }
                        else{
                            startRow++;
                            break;
                        }
                    }
                    result[0]=newResultPoint(loc[0],startRow);
                    result[1]=newResultPoint(loc[1],startRow);
                    found=true;
                    break;
                }
            }
            letstopRow=startRow+1;
            //Lastrowofthecurrentsymbolthatcontainspattern
            if(found){
                letskippedRowCount=0;
                letpreviousRowLoc=Int32Array.from([Math.trunc(result[0].getX()),Math.trunc(result[1].getX())]);
                for(;stopRow<height;stopRow++){
                    constloc=Detector$3.findGuardPattern(matrix,previousRowLoc[0],stopRow,width,false,pattern,counters);
                    //afoundpatternisonlyconsideredtobelongtothesamebarcodeifthestartandendpositions
                    //don'tdiffertoomuch.Patterndriftshouldbenotbiggerthantwoforconsecutiverows.With
                    //ahighernumberofskippedrowsdriftcouldbelarger.Tokeepitsimplefornow,weallowaslightly
                    //largerdriftanddon'tcheckforskippedrows.
                    if(loc!=null&&
                        Math.abs(previousRowLoc[0]-loc[0])<Detector$3.MAX_PATTERN_DRIFT&&
                        Math.abs(previousRowLoc[1]-loc[1])<Detector$3.MAX_PATTERN_DRIFT){
                        previousRowLoc=loc;
                        skippedRowCount=0;
                    }
                    else{
                        if(skippedRowCount>Detector$3.SKIPPED_ROW_COUNT_MAX){
                            break;
                        }
                        else{
                            skippedRowCount++;
                        }
                    }
                }
                stopRow-=skippedRowCount+1;
                result[2]=newResultPoint(previousRowLoc[0],stopRow);
                result[3]=newResultPoint(previousRowLoc[1],stopRow);
            }
            if(stopRow-startRow<Detector$3.BARCODE_MIN_HEIGHT){
                Arrays.fill(result,null);
            }
            returnresult;
        }
        /**
         *@parammatrixrowofblack/whitevaluestosearch
         *@paramcolumnxpositiontostartsearch
         *@paramrowypositiontostartsearch
         *@paramwidththenumberofpixelstosearchonthisrow
         *@parampatternpatternofcountsofnumberofblackandwhitepixelsthatare
         *                beingsearchedforasapattern
         *@paramcountersarrayofcounters,aslongaspattern,tore-use
         *@returnstart/endhorizontaloffsetofguardpattern,asanarrayoftwoints.
         */
        staticfindGuardPattern(matrix,column,row,width,whiteFirst,pattern,counters){
            Arrays.fillWithin(counters,0,counters.length,0);
            letpatternStart=column;
            letpixelDrift=0;
            //ifthereareblackpixelsleftofthecurrentpixelshifttotheleft,butonlyforMAX_PIXEL_DRIFTpixels
            while(matrix.get(patternStart,row)&&patternStart>0&&pixelDrift++<Detector$3.MAX_PIXEL_DRIFT){
                patternStart--;
            }
            letx=patternStart;
            letcounterPosition=0;
            letpatternLength=pattern.length;
            for(letisWhite=whiteFirst;x<width;x++){
                letpixel=matrix.get(x,row);
                if(pixel!==isWhite){
                    counters[counterPosition]++;
                }
                else{
                    if(counterPosition===patternLength-1){
                        if(Detector$3.patternMatchVariance(counters,pattern,Detector$3.MAX_INDIVIDUAL_VARIANCE)<Detector$3.MAX_AVG_VARIANCE){
                            returnnewInt32Array([patternStart,x]);
                        }
                        patternStart+=counters[0]+counters[1];
                        System.arraycopy(counters,2,counters,0,counterPosition-1);
                        counters[counterPosition-1]=0;
                        counters[counterPosition]=0;
                        counterPosition--;
                    }
                    else{
                        counterPosition++;
                    }
                    counters[counterPosition]=1;
                    isWhite=!isWhite;
                }
            }
            if(counterPosition===patternLength-1&&
                Detector$3.patternMatchVariance(counters,pattern,Detector$3.MAX_INDIVIDUAL_VARIANCE)<Detector$3.MAX_AVG_VARIANCE){
                returnnewInt32Array([patternStart,x-1]);
            }
            returnnull;
        }
        /**
         *Determineshowcloselyasetofobservedcountsofrunsofblack/white
         *valuesmatchesagiventargetpattern.Thisisreportedastheratioof
         *thetotalvariancefromtheexpectedpatternproportionsacrossall
         *patternelements,tothelengthofthepattern.
         *
         *@paramcountersobservedcounters
         *@parampatternexpectedpattern
         *@parammaxIndividualVarianceThemostanycountercandifferbeforewegiveup
         *@returnratiooftotalvariancebetweencountersandpatterncomparedtototalpatternsize
         */
        staticpatternMatchVariance(counters,pattern,maxIndividualVariance){
            letnumCounters=counters.length;
            lettotal=0;
            letpatternLength=0;
            for(leti=0;i<numCounters;i++){
                total+=counters[i];
                patternLength+=pattern[i];
            }
            if(total<patternLength){
                //Ifwedon'tevenhaveonepixelperunitofbarwidth,assumethis
                //istoosmalltoreliablymatch,sofail:
                return/*Float.POSITIVE_INFINITY*/Infinity;
            }
            //We'regoingtofakefloating-pointmathinintegers.Wejustneedtousemorebits.
            //ScaleuppatternLengthsothatintermediatevaluesbelowlikescaledCounterwillhave
            //more"significantdigits".
            letunitBarWidth=total/patternLength;
            maxIndividualVariance*=unitBarWidth;
            lettotalVariance=0.0;
            for(letx=0;x<numCounters;x++){
                letcounter=counters[x];
                letscaledPattern=pattern[x]*unitBarWidth;
                letvariance=counter>scaledPattern?counter-scaledPattern:scaledPattern-counter;
                if(variance>maxIndividualVariance){
                    return/*Float.POSITIVE_INFINITY*/Infinity;
                }
                totalVariance+=variance;
            }
            returntotalVariance/total;
        }
    }
    Detector$3.INDEXES_START_PATTERN=Int32Array.from([0,4,1,5]);
    Detector$3.INDEXES_STOP_PATTERN=Int32Array.from([6,2,7,3]);
    Detector$3.MAX_AVG_VARIANCE=0.42;
    Detector$3.MAX_INDIVIDUAL_VARIANCE=0.8;
    //BSBSBSBSBar/Spacepattern
    //11111111010101000
    Detector$3.START_PATTERN=Int32Array.from([8,1,1,1,1,1,1,3]);
    //111111101000101001
    Detector$3.STOP_PATTERN=Int32Array.from([7,1,1,3,1,1,1,2,1]);
    Detector$3.MAX_PIXEL_DRIFT=3;
    Detector$3.MAX_PATTERN_DRIFT=5;
    //ifwesetthevaluetoolow,thenwedon'tdetectthecorrectheightofthebarifthestartpatternsaredamaged.
    //ifwesetthevaluetoohigh,thenwemightdetectthestartpatternfromaneighborbarcode.
    Detector$3.SKIPPED_ROW_COUNT_MAX=25;
    //APDF471barcodeshouldhaveatleast3rows,witheachrowbeing>=3timesthemodulewidth.Thereforeitshouldbeatleast
    //9pixelstall.Tobeconservative,weuseabouthalfthesizetoensurewedon'tmissit.
    Detector$3.ROW_STEP=5;
    Detector$3.BARCODE_MIN_HEIGHT=10;

    /*
    *Copyright2012ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    /**
     *@authorSeanOwen
     *@seecom.google.zxing.common.reedsolomon.GenericGFPoly
     */
    /*final*/classModulusPoly{
        constructor(field,coefficients){
            if(coefficients.length===0){
                thrownewIllegalArgumentException();
            }
            this.field=field;
            letcoefficientsLength=/*int*/coefficients.length;
            if(coefficientsLength>1&&coefficients[0]===0){
                //Leadingtermmustbenon-zeroforanythingexcepttheconstantpolynomial"0"
                letfirstNonZero=/*int*/1;
                while(firstNonZero<coefficientsLength&&coefficients[firstNonZero]===0){
                    firstNonZero++;
                }
                if(firstNonZero===coefficientsLength){
                    this.coefficients=newInt32Array([0]);
                }
                else{
                    this.coefficients=newInt32Array(coefficientsLength-firstNonZero);
                    System.arraycopy(coefficients,firstNonZero,this.coefficients,0,this.coefficients.length);
                }
            }
            else{
                this.coefficients=coefficients;
            }
        }
        getCoefficients(){
            returnthis.coefficients;
        }
        /**
         *@returndegreeofthispolynomial
         */
        getDegree(){
            returnthis.coefficients.length-1;
        }
        /**
         *@returntrueiffthispolynomialisthemonomial"0"
         */
        isZero(){
            returnthis.coefficients[0]===0;
        }
        /**
         *@returncoefficientofx^degreeterminthispolynomial
         */
        getCoefficient(degree){
            returnthis.coefficients[this.coefficients.length-1-degree];
        }
        /**
         *@returnevaluationofthispolynomialatagivenpoint
         */
        evaluateAt(a){
            if(a===0){
                //Justreturnthex^0coefficient
                returnthis.getCoefficient(0);
            }
            if(a===1){
                //Justthesumofthecoefficients
                letsum=/*int*/0;
                for(letcoefficient/*int*/ofthis.coefficients){
                    sum=this.field.add(sum,coefficient);
                }
                returnsum;
            }
            letresult=/*int*/this.coefficients[0];
            letsize=/*int*/this.coefficients.length;
            for(leti/*int*/=1;i<size;i++){
                result=this.field.add(this.field.multiply(a,result),this.coefficients[i]);
            }
            returnresult;
        }
        add(other){
            if(!this.field.equals(other.field)){
                thrownewIllegalArgumentException('ModulusPolysdonothavesameModulusGFfield');
            }
            if(this.isZero()){
                returnother;
            }
            if(other.isZero()){
                returnthis;
            }
            letsmallerCoefficients=this.coefficients;
            letlargerCoefficients=other.coefficients;
            if(smallerCoefficients.length>largerCoefficients.length){
                lettemp=smallerCoefficients;
                smallerCoefficients=largerCoefficients;
                largerCoefficients=temp;
            }
            letsumDiff=newInt32Array(largerCoefficients.length);
            letlengthDiff=/*int*/largerCoefficients.length-smallerCoefficients.length;
            //Copyhigh-ordertermsonlyfoundinhigher-degreepolynomial'scoefficients
            System.arraycopy(largerCoefficients,0,sumDiff,0,lengthDiff);
            for(leti/*int*/=lengthDiff;i<largerCoefficients.length;i++){
                sumDiff[i]=this.field.add(smallerCoefficients[i-lengthDiff],largerCoefficients[i]);
            }
            returnnewModulusPoly(this.field,sumDiff);
        }
        subtract(other){
            if(!this.field.equals(other.field)){
                thrownewIllegalArgumentException('ModulusPolysdonothavesameModulusGFfield');
            }
            if(other.isZero()){
                returnthis;
            }
            returnthis.add(other.negative());
        }
        multiply(other){
            if(otherinstanceofModulusPoly){
                returnthis.multiplyOther(other);
            }
            returnthis.multiplyScalar(other);
        }
        multiplyOther(other){
            if(!this.field.equals(other.field)){
                thrownewIllegalArgumentException('ModulusPolysdonothavesameModulusGFfield');
            }
            if(this.isZero()||other.isZero()){
                //returnthis.field.getZero();
                returnnewModulusPoly(this.field,newInt32Array([0]));
            }
            letaCoefficients=this.coefficients;
            letaLength=/*int*/aCoefficients.length;
            letbCoefficients=other.coefficients;
            letbLength=/*int*/bCoefficients.length;
            letproduct=newInt32Array(aLength+bLength-1);
            for(leti/*int*/=0;i<aLength;i++){
                letaCoeff=/*int*/aCoefficients[i];
                for(letj/*int*/=0;j<bLength;j++){
                    product[i+j]=this.field.add(product[i+j],this.field.multiply(aCoeff,bCoefficients[j]));
                }
            }
            returnnewModulusPoly(this.field,product);
        }
        negative(){
            letsize=/*int*/this.coefficients.length;
            letnegativeCoefficients=newInt32Array(size);
            for(leti/*int*/=0;i<size;i++){
                negativeCoefficients[i]=this.field.subtract(0,this.coefficients[i]);
            }
            returnnewModulusPoly(this.field,negativeCoefficients);
        }
        multiplyScalar(scalar){
            if(scalar===0){
                returnnewModulusPoly(this.field,newInt32Array([0]));
            }
            if(scalar===1){
                returnthis;
            }
            letsize=/*int*/this.coefficients.length;
            letproduct=newInt32Array(size);
            for(leti/*int*/=0;i<size;i++){
                product[i]=this.field.multiply(this.coefficients[i],scalar);
            }
            returnnewModulusPoly(this.field,product);
        }
        multiplyByMonomial(degree,coefficient){
            if(degree<0){
                thrownewIllegalArgumentException();
            }
            if(coefficient===0){
                returnnewModulusPoly(this.field,newInt32Array([0]));
            }
            letsize=/*int*/this.coefficients.length;
            letproduct=newInt32Array(size+degree);
            for(leti/*int*/=0;i<size;i++){
                product[i]=this.field.multiply(this.coefficients[i],coefficient);
            }
            returnnewModulusPoly(this.field,product);
        }
        /*
        ModulusPoly[]divide(other:ModulusPoly){
          if(!field.equals(other.field)){
            thrownewIllegalArgumentException("ModulusPolysdonothavesameModulusGFfield");
          }
          if(other.isZero()){
            thrownewIllegalArgumentException("Divideby0");
          }

          letquotient:ModulusPoly=field.getZero();
          letremainder:ModulusPoly=this;

          letdenominatorLeadingTerm:/*int/number=other.getCoefficient(other.getDegree());
          letinverseDenominatorLeadingTerm:/*int/number=field.inverse(denominatorLeadingTerm);

          while(remainder.getDegree()>=other.getDegree()&&!remainder.isZero()){
            letdegreeDifference:/*int/number=remainder.getDegree()-other.getDegree();
            letscale:/*int/number=field.multiply(remainder.getCoefficient(remainder.getDegree()),inverseDenominatorLeadingTerm);
            letterm:ModulusPoly=other.multiplyByMonomial(degreeDifference,scale);
            letiterationQuotient:ModulusPoly=field.buildMonomial(degreeDifference,scale);
            quotient=quotient.add(iterationQuotient);
            remainder=remainder.subtract(term);
          }

          returnnewModulusPoly[]{quotient,remainder};
        }
        */
        //@Override
        toString(){
            letresult=newStringBuilder(/*8*this.getDegree()*/);//dynamicstringsizeinJS
            for(letdegree/*int*/=this.getDegree();degree>=0;degree--){
                letcoefficient=/*int*/this.getCoefficient(degree);
                if(coefficient!==0){
                    if(coefficient<0){
                        result.append('-');
                        coefficient=-coefficient;
                    }
                    else{
                        if(result.length()>0){
                            result.append('+');
                        }
                    }
                    if(degree===0||coefficient!==1){
                        result.append(coefficient);
                    }
                    if(degree!==0){
                        if(degree===1){
                            result.append('x');
                        }
                        else{
                            result.append('x^');
                            result.append(degree);
                        }
                    }
                }
            }
            returnresult.toString();
        }
    }

    classModulusBase{
        add(a,b){
            return(a+b)%this.modulus;
        }
        subtract(a,b){
            return(this.modulus+a-b)%this.modulus;
        }
        exp(a){
            returnthis.expTable[a];
        }
        log(a){
            if(a===0){
                thrownewIllegalArgumentException();
            }
            returnthis.logTable[a];
        }
        inverse(a){
            if(a===0){
                thrownewArithmeticException();
            }
            returnthis.expTable[this.modulus-this.logTable[a]-1];
        }
        multiply(a,b){
            if(a===0||b===0){
                return0;
            }
            returnthis.expTable[(this.logTable[a]+this.logTable[b])%(this.modulus-1)];
        }
        getSize(){
            returnthis.modulus;
        }
        equals(o){
            returno===this;
        }
    }

    /*
     *Copyright2012ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>Afieldbasedonpowersofageneratorinteger,modulosomemodulus.</p>
     *
     *@authorSeanOwen
     *@seecom.google.zxing.common.reedsolomon.GenericGF
     */
    /*publicfinal*/classModulusGFextendsModulusBase{
        //private/*final*/modulus:/*int*/number;
        constructor(modulus,generator){
            super();
            this.modulus=modulus;
            this.expTable=newInt32Array(modulus);
            this.logTable=newInt32Array(modulus);
            letx=/*int*/1;
            for(leti/*int*/=0;i<modulus;i++){
                this.expTable[i]=x;
                x=(x*generator)%modulus;
            }
            for(leti/*int*/=0;i<modulus-1;i++){
                this.logTable[this.expTable[i]]=i;
            }
            //logTable[0]==0butthisshouldneverbeused
            this.zero=newModulusPoly(this,newInt32Array([0]));
            this.one=newModulusPoly(this,newInt32Array([1]));
        }
        getZero(){
            returnthis.zero;
        }
        getOne(){
            returnthis.one;
        }
        buildMonomial(degree,coefficient){
            if(degree<0){
                thrownewIllegalArgumentException();
            }
            if(coefficient===0){
                returnthis.zero;
            }
            letcoefficients=newInt32Array(degree+1);
            coefficients[0]=coefficient;
            returnnewModulusPoly(this,coefficients);
        }
    }
    ModulusGF.PDF417_GF=newModulusGF(PDF417Common.NUMBER_OF_CODEWORDS,3);

    /*
    *Copyright2012ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    /**
     *<p>PDF417errorcorrectionimplementation.</p>
     *
     *<p>This<ahref="http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example">example</a>
     *isquiteusefulinunderstandingthealgorithm.</p>
     *
     *@authorSeanOwen
     *@seecom.google.zxing.common.reedsolomon.ReedSolomonDecoder
     */
    /*publicfinal*/classErrorCorrection{
        constructor(){
            this.field=ModulusGF.PDF417_GF;
        }
        /**
         *@paramreceivedreceivedcodewords
         *@paramnumECCodewordsnumberofthosecodewordsusedforEC
         *@paramerasureslocationoferasures
         *@returnnumberoferrors
         *@throwsChecksumExceptioniferrorscannotbecorrected,maybebecauseoftoomanyerrors
         */
        decode(received,numECCodewords,erasures){
            letpoly=newModulusPoly(this.field,received);
            letS=newInt32Array(numECCodewords);
            leterror=false;
            for(leti/*int*/=numECCodewords;i>0;i--){
                letevaluation=poly.evaluateAt(this.field.exp(i));
                S[numECCodewords-i]=evaluation;
                if(evaluation!==0){
                    error=true;
                }
            }
            if(!error){
                return0;
            }
            letknownErrors=this.field.getOne();
            if(erasures!=null){
                for(consterasureoferasures){
                    letb=this.field.exp(received.length-1-erasure);
                    //Add(1-bx)term:
                    letterm=newModulusPoly(this.field,newInt32Array([this.field.subtract(0,b),1]));
                    knownErrors=knownErrors.multiply(term);
                }
            }
            letsyndrome=newModulusPoly(this.field,S);
            //syndrome=syndrome.multiply(knownErrors);
            letsigmaOmega=this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords,1),syndrome,numECCodewords);
            letsigma=sigmaOmega[0];
            letomega=sigmaOmega[1];
            //sigma=sigma.multiply(knownErrors);
            leterrorLocations=this.findErrorLocations(sigma);
            leterrorMagnitudes=this.findErrorMagnitudes(omega,sigma,errorLocations);
            for(leti/*int*/=0;i<errorLocations.length;i++){
                letposition=received.length-1-this.field.log(errorLocations[i]);
                if(position<0){
                    throwChecksumException.getChecksumInstance();
                }
                received[position]=this.field.subtract(received[position],errorMagnitudes[i]);
            }
            returnerrorLocations.length;
        }
        /**
         *
         *@paramModulusPoly
         *@parama
         *@paramModulusPoly
         *@paramb
         *@paramint
         *@paramR
         *@throwsChecksumException
         */
        runEuclideanAlgorithm(a,b,R){
            //Assumea'sdegreeis>=b's
            if(a.getDegree()<b.getDegree()){
                lettemp=a;
                a=b;
                b=temp;
            }
            letrLast=a;
            letr=b;
            lettLast=this.field.getZero();
            lett=this.field.getOne();
            //RunEuclideanalgorithmuntilr'sdegreeislessthanR/2
            while(r.getDegree()>=Math.round(R/2)){
                letrLastLast=rLast;
                lettLastLast=tLast;
                rLast=r;
                tLast=t;
                //DividerLastLastbyrLast,withquotientinqandremainderinr
                if(rLast.isZero()){
                    //Oops,Euclideanalgorithmalreadyterminated?
                    throwChecksumException.getChecksumInstance();
                }
                r=rLastLast;
                letq=this.field.getZero();
                letdenominatorLeadingTerm=rLast.getCoefficient(rLast.getDegree());
                letdltInverse=this.field.inverse(denominatorLeadingTerm);
                while(r.getDegree()>=rLast.getDegree()&&!r.isZero()){
                    letdegreeDiff=r.getDegree()-rLast.getDegree();
                    letscale=this.field.multiply(r.getCoefficient(r.getDegree()),dltInverse);
                    q=q.add(this.field.buildMonomial(degreeDiff,scale));
                    r=r.subtract(rLast.multiplyByMonomial(degreeDiff,scale));
                }
                t=q.multiply(tLast).subtract(tLastLast).negative();
            }
            letsigmaTildeAtZero=t.getCoefficient(0);
            if(sigmaTildeAtZero===0){
                throwChecksumException.getChecksumInstance();
            }
            letinverse=this.field.inverse(sigmaTildeAtZero);
            letsigma=t.multiply(inverse);
            letomega=r.multiply(inverse);
            return[sigma,omega];
        }
        /**
         *
         *@paramerrorLocator
         *@throwsChecksumException
         */
        findErrorLocations(errorLocator){
            //ThisisadirectapplicationofChien'ssearch
            letnumErrors=errorLocator.getDegree();
            letresult=newInt32Array(numErrors);
            lete=0;
            for(leti/*int*/=1;i<this.field.getSize()&&e<numErrors;i++){
                if(errorLocator.evaluateAt(i)===0){
                    result[e]=this.field.inverse(i);
                    e++;
                }
            }
            if(e!==numErrors){
                throwChecksumException.getChecksumInstance();
            }
            returnresult;
        }
        findErrorMagnitudes(errorEvaluator,errorLocator,errorLocations){
            leterrorLocatorDegree=errorLocator.getDegree();
            letformalDerivativeCoefficients=newInt32Array(errorLocatorDegree);
            for(leti/*int*/=1;i<=errorLocatorDegree;i++){
                formalDerivativeCoefficients[errorLocatorDegree-i]=
                    this.field.multiply(i,errorLocator.getCoefficient(i));
            }
            letformalDerivative=newModulusPoly(this.field,formalDerivativeCoefficients);
            //ThisisdirectlyapplyingForney'sFormula
            lets=errorLocations.length;
            letresult=newInt32Array(s);
            for(leti/*int*/=0;i<s;i++){
                letxiInverse=this.field.inverse(errorLocations[i]);
                letnumerator=this.field.subtract(0,errorEvaluator.evaluateAt(xiInverse));
                letdenominator=this.field.inverse(formalDerivative.evaluateAt(xiInverse));
                result[i]=this.field.multiply(numerator,denominator);
            }
            returnresult;
        }
    }

    /*
    *Copyright2013ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    /**
     *@authorGuentherGrau
     */
    /*final*/classBoundingBox{
        constructor(image,topLeft,bottomLeft,topRight,bottomRight){
            if(imageinstanceofBoundingBox){
                this.constructor_2(image);
            }
            else{
                this.constructor_1(image,topLeft,bottomLeft,topRight,bottomRight);
            }
        }
        /**
         *
         *@paramimage
         *@paramtopLeft
         *@parambottomLeft
         *@paramtopRight
         *@parambottomRight
         *
         *@throwsNotFoundException
         */
        constructor_1(image,topLeft,bottomLeft,topRight,bottomRight){
            constleftUnspecified=topLeft==null||bottomLeft==null;
            constrightUnspecified=topRight==null||bottomRight==null;
            if(leftUnspecified&&rightUnspecified){
                thrownewNotFoundException();
            }
            if(leftUnspecified){
                topLeft=newResultPoint(0,topRight.getY());
                bottomLeft=newResultPoint(0,bottomRight.getY());
            }
            elseif(rightUnspecified){
                topRight=newResultPoint(image.getWidth()-1,topLeft.getY());
                bottomRight=newResultPoint(image.getWidth()-1,bottomLeft.getY());
            }
            this.image=image;
            this.topLeft=topLeft;
            this.bottomLeft=bottomLeft;
            this.topRight=topRight;
            this.bottomRight=bottomRight;
            this.minX=Math.trunc(Math.min(topLeft.getX(),bottomLeft.getX()));
            this.maxX=Math.trunc(Math.max(topRight.getX(),bottomRight.getX()));
            this.minY=Math.trunc(Math.min(topLeft.getY(),topRight.getY()));
            this.maxY=Math.trunc(Math.max(bottomLeft.getY(),bottomRight.getY()));
        }
        constructor_2(boundingBox){
            this.image=boundingBox.image;
            this.topLeft=boundingBox.getTopLeft();
            this.bottomLeft=boundingBox.getBottomLeft();
            this.topRight=boundingBox.getTopRight();
            this.bottomRight=boundingBox.getBottomRight();
            this.minX=boundingBox.getMinX();
            this.maxX=boundingBox.getMaxX();
            this.minY=boundingBox.getMinY();
            this.maxY=boundingBox.getMaxY();
        }
        /**
         *@throwsNotFoundException
         */
        staticmerge(leftBox,rightBox){
            if(leftBox==null){
                returnrightBox;
            }
            if(rightBox==null){
                returnleftBox;
            }
            returnnewBoundingBox(leftBox.image,leftBox.topLeft,leftBox.bottomLeft,rightBox.topRight,rightBox.bottomRight);
        }
        /**
         *@throwsNotFoundException
         */
        addMissingRows(missingStartRows,missingEndRows,isLeft){
            letnewTopLeft=this.topLeft;
            letnewBottomLeft=this.bottomLeft;
            letnewTopRight=this.topRight;
            letnewBottomRight=this.bottomRight;
            if(missingStartRows>0){
                lettop=isLeft?this.topLeft:this.topRight;
                letnewMinY=Math.trunc(top.getY()-missingStartRows);
                if(newMinY<0){
                    newMinY=0;
                }
                letnewTop=newResultPoint(top.getX(),newMinY);
                if(isLeft){
                    newTopLeft=newTop;
                }
                else{
                    newTopRight=newTop;
                }
            }
            if(missingEndRows>0){
                letbottom=isLeft?this.bottomLeft:this.bottomRight;
                letnewMaxY=Math.trunc(bottom.getY()+missingEndRows);
                if(newMaxY>=this.image.getHeight()){
                    newMaxY=this.image.getHeight()-1;
                }
                letnewBottom=newResultPoint(bottom.getX(),newMaxY);
                if(isLeft){
                    newBottomLeft=newBottom;
                }
                else{
                    newBottomRight=newBottom;
                }
            }
            returnnewBoundingBox(this.image,newTopLeft,newBottomLeft,newTopRight,newBottomRight);
        }
        getMinX(){
            returnthis.minX;
        }
        getMaxX(){
            returnthis.maxX;
        }
        getMinY(){
            returnthis.minY;
        }
        getMaxY(){
            returnthis.maxY;
        }
        getTopLeft(){
            returnthis.topLeft;
        }
        getTopRight(){
            returnthis.topRight;
        }
        getBottomLeft(){
            returnthis.bottomLeft;
        }
        getBottomRight(){
            returnthis.bottomRight;
        }
    }

    /*
     *Copyright2013ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    //packagecom.google.zxing.pdf417.decoder;
    /**
     *@authorGuentherGrau
     */
    /*final*/classBarcodeMetadata{
        constructor(columnCount,rowCountUpperPart,rowCountLowerPart,errorCorrectionLevel){
            this.columnCount=columnCount;
            this.errorCorrectionLevel=errorCorrectionLevel;
            this.rowCountUpperPart=rowCountUpperPart;
            this.rowCountLowerPart=rowCountLowerPart;
            this.rowCount=rowCountUpperPart+rowCountLowerPart;
        }
        getColumnCount(){
            returnthis.columnCount;
        }
        getErrorCorrectionLevel(){
            returnthis.errorCorrectionLevel;
        }
        getRowCount(){
            returnthis.rowCount;
        }
        getRowCountUpperPart(){
            returnthis.rowCountUpperPart;
        }
        getRowCountLowerPart(){
            returnthis.rowCountLowerPart;
        }
    }

    /**
     *JavaFormatterclasspolyfillthatworksintheJSway.
     */
    classFormatter{
        constructor(){
            this.buffer='';
        }
        /**
         *
         *@seehttps://stackoverflow.com/a/13439711/4367683
         *
         *@paramstr
         *@paramarr
         */
        staticform(str,arr){
            leti=-1;
            functioncallback(exp,p0,p1,p2,p3,p4){
                if(exp==='%%')
                    return'%';
                if(arr[++i]===undefined)
                    returnundefined;
                exp=p2?parseInt(p2.substr(1)):undefined;
                letbase=p3?parseInt(p3.substr(1)):undefined;
                letval;
                switch(p4){
                    case's':
                        val=arr[i];
                        break;
                    case'c':
                        val=arr[i][0];
                        break;
                    case'f':
                        val=parseFloat(arr[i]).toFixed(exp);
                        break;
                    case'p':
                        val=parseFloat(arr[i]).toPrecision(exp);
                        break;
                    case'e':
                        val=parseFloat(arr[i]).toExponential(exp);
                        break;
                    case'x':
                        val=parseInt(arr[i]).toString(base?base:16);
                        break;
                    case'd':
                        val=parseFloat(parseInt(arr[i],base?base:10).toPrecision(exp)).toFixed(0);
                        break;
                }
                val=typeofval==='object'?JSON.stringify(val):(+val).toString(base);
                letsize=parseInt(p1);/*paddingsize*/
                letch=p1&&(p1[0]+'')==='0'?'0':'';/*isnull?*/
                while(val.length<size)
                    val=p0!==undefined?val+ch:ch+val;/*isminus?*/
                returnval;
            }
            letregex=/%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
            returnstr.replace(regex,callback);
        }
        /**
         *
         *@paramappendThenewstringtoappend.
         *@paramargsArgumetsvaluestobeformated.
         */
        format(append,...args){
            this.buffer+=Formatter.form(append,args);
        }
        /**
         *ReturnstheFormatterstringvalue.
         */
        toString(){
            returnthis.buffer;
        }
    }

    /*
     *Copyright2013ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *@authorGuentherGrau
     */
    classDetectionResultColumn{
        constructor(boundingBox){
            this.boundingBox=newBoundingBox(boundingBox);
            //this.codewords=newCodeword[boundingBox.getMaxY()-boundingBox.getMinY()+1];
            this.codewords=newArray(boundingBox.getMaxY()-boundingBox.getMinY()+1);
        }
        /*final*/getCodewordNearby(imageRow){
            letcodeword=this.getCodeword(imageRow);
            if(codeword!=null){
                returncodeword;
            }
            for(leti=1;i<DetectionResultColumn.MAX_NEARBY_DISTANCE;i++){
                letnearImageRow=this.imageRowToCodewordIndex(imageRow)-i;
                if(nearImageRow>=0){
                    codeword=this.codewords[nearImageRow];
                    if(codeword!=null){
                        returncodeword;
                    }
                }
                nearImageRow=this.imageRowToCodewordIndex(imageRow)+i;
                if(nearImageRow<this.codewords.length){
                    codeword=this.codewords[nearImageRow];
                    if(codeword!=null){
                        returncodeword;
                    }
                }
            }
            returnnull;
        }
        /*finalint*/imageRowToCodewordIndex(imageRow){
            returnimageRow-this.boundingBox.getMinY();
        }
        /*finalvoid*/setCodeword(imageRow,codeword){
            this.codewords[this.imageRowToCodewordIndex(imageRow)]=codeword;
        }
        /*final*/getCodeword(imageRow){
            returnthis.codewords[this.imageRowToCodewordIndex(imageRow)];
        }
        /*final*/getBoundingBox(){
            returnthis.boundingBox;
        }
        /*final*/getCodewords(){
            returnthis.codewords;
        }
        //@Override
        toString(){
            constformatter=newFormatter();
            letrow=0;
            for(constcodewordofthis.codewords){
                if(codeword==null){
                    formatter.format('%3d:   |  %n',row++);
                    continue;
                }
                formatter.format('%3d:%3d|%3d%n',row++,codeword.getRowNumber(),codeword.getValue());
            }
            returnformatter.toString();
        }
    }
    DetectionResultColumn.MAX_NEARBY_DISTANCE=5;

    /*
     *Copyright2013ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    //importjava.util.ArrayList;
    //importjava.util.Collection;
    //importjava.util.HashMap;
    //importjava.util.Map;
    //importjava.util.Map.Entry;
    /**
     *@authorGuentherGrau
     */
    /*final*/classBarcodeValue{
        constructor(){
            this.values=newMap();
        }
        /**
         *Addanoccurrenceofavalue
         */
        setValue(value){
            value=Math.trunc(value);
            letconfidence=this.values.get(value);
            if(confidence==null){
                confidence=0;
            }
            confidence++;
            this.values.set(value,confidence);
        }
        /**
         *Determinesthemaximumoccurrenceofasetvalueandreturnsallvalueswhichweresetwiththisoccurrence.
         *@returnanarrayofint,containingthevalueswiththehighestoccurrence,ornull,ifnovaluewasset
         */
        getValue(){
            letmaxConfidence=-1;
            letresult=newArray();
            for(const[key,value]ofthis.values.entries()){
                constentry={
                    getKey:()=>key,
                    getValue:()=>value,
                };
                if(entry.getValue()>maxConfidence){
                    maxConfidence=entry.getValue();
                    result=[];
                    result.push(entry.getKey());
                }
                elseif(entry.getValue()===maxConfidence){
                    result.push(entry.getKey());
                }
            }
            returnPDF417Common.toIntArray(result);
        }
        getConfidence(value){
            returnthis.values.get(value);
        }
    }

    /*
     *Copyright2013ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *@authorGuentherGrau
     */
    /*final*/classDetectionResultRowIndicatorColumnextendsDetectionResultColumn{
        constructor(boundingBox,isLeft){
            super(boundingBox);
            this._isLeft=isLeft;
        }
        setRowNumbers(){
            for(letcodeword/*Codeword*/ofthis.getCodewords()){
                if(codeword!=null){
                    codeword.setRowNumberAsRowIndicatorColumn();
                }
            }
        }
        //TODOimplementproperly
        //TODOmaybeweshouldaddmissingcodewordstostorethecorrectrownumbertomake
        //findingrownumbersforothercolumnseasier
        //userowheightcounttomakedetectionofinvalidrownumbersmorereliable
        adjustCompleteIndicatorColumnRowNumbers(barcodeMetadata){
            letcodewords=this.getCodewords();
            this.setRowNumbers();
            this.removeIncorrectCodewords(codewords,barcodeMetadata);
            letboundingBox=this.getBoundingBox();
            lettop=this._isLeft?boundingBox.getTopLeft():boundingBox.getTopRight();
            letbottom=this._isLeft?boundingBox.getBottomLeft():boundingBox.getBottomRight();
            letfirstRow=this.imageRowToCodewordIndex(Math.trunc(top.getY()));
            letlastRow=this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
            //Weneedtobecarefulusingtheaveragerowheight.Barcodecouldbeskewedsothatwehavesmallerand
            //tallerrows
            //floataverageRowHeight=(lastRow-firstRow)//*(float)*/barcodeMetadata.getRowCount();
            letbarcodeRow=-1;
            letmaxRowHeight=1;
            letcurrentRowHeight=0;
            for(letcodewordsRow/*int*/=firstRow;codewordsRow<lastRow;codewordsRow++){
                if(codewords[codewordsRow]==null){
                    continue;
                }
                letcodeword=codewords[codewordsRow];
                //     floatexpectedRowNumber=(codewordsRow-firstRow)/averageRowHeight;
                //     if(Math.abs(codeword.getRowNumber()-expectedRowNumber)>2){
                //       SimpleLog.log(LEVEL.WARNING,
                //           "Removingcodeword,rowNumberSkewtoohigh,codeword["+codewordsRow+"]:ExpectedRow:"+
                //               expectedRowNumber+",RealRow:"+codeword.getRowNumber()+",value:"+codeword.getValue());
                //       codewords[codewordsRow]=null;
                //     }
                letrowDifference=codeword.getRowNumber()-barcodeRow;
                //TODOimprovehandlingwithcasewherefirstrowindicatordoesn'tstartwith0
                if(rowDifference===0){
                    currentRowHeight++;
                }
                elseif(rowDifference===1){
                    maxRowHeight=Math.max(maxRowHeight,currentRowHeight);
                    currentRowHeight=1;
                    barcodeRow=codeword.getRowNumber();
                }
                elseif(rowDifference<0||
                    codeword.getRowNumber()>=barcodeMetadata.getRowCount()||
                    rowDifference>codewordsRow){
                    codewords[codewordsRow]=null;
                }
                else{
                    letcheckedRows;
                    if(maxRowHeight>2){
                        checkedRows=(maxRowHeight-2)*rowDifference;
                    }
                    else{
                        checkedRows=rowDifference;
                    }
                    letclosePreviousCodewordFound=checkedRows>=codewordsRow;
                    for(leti/*int*/=1;i<=checkedRows&&!closePreviousCodewordFound;i++){
                        //theremustbe(height*rowDifference)numberofcodewordsmissing.Fornowweassumeheight=1.
                        //Thisshouldhopefullygetridofmostproblemsalready.
                        closePreviousCodewordFound=codewords[codewordsRow-i]!=null;
                    }
                    if(closePreviousCodewordFound){
                        codewords[codewordsRow]=null;
                    }
                    else{
                        barcodeRow=codeword.getRowNumber();
                        currentRowHeight=1;
                    }
                }
            }
            //return(int)(averageRowHeight+0.5);
        }
        getRowHeights(){
            letbarcodeMetadata=this.getBarcodeMetadata();
            if(barcodeMetadata==null){
                returnnull;
            }
            this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);
            letresult=newInt32Array(barcodeMetadata.getRowCount());
            for(letcodeword/*Codeword*/ofthis.getCodewords()){
                if(codeword!=null){
                    letrowNumber=codeword.getRowNumber();
                    if(rowNumber>=result.length){
                        //Wehavemorerowsthanthebarcodemetadataallowsfor,ignorethem.
                        continue;
                    }
                    result[rowNumber]++;
                }//elsethrowexception?
            }
            returnresult;
        }
        //TODOmaybeweshouldaddmissingcodewordstostorethecorrectrownumbertomake
        //findingrownumbersforothercolumnseasier
        //userowheightcounttomakedetectionofinvalidrownumbersmorereliable
        adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata){
            letboundingBox=this.getBoundingBox();
            lettop=this._isLeft?boundingBox.getTopLeft():boundingBox.getTopRight();
            letbottom=this._isLeft?boundingBox.getBottomLeft():boundingBox.getBottomRight();
            letfirstRow=this.imageRowToCodewordIndex(Math.trunc(top.getY()));
            letlastRow=this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
            //floataverageRowHeight=(lastRow-firstRow)//*(float)*/barcodeMetadata.getRowCount();
            letcodewords=this.getCodewords();
            letbarcodeRow=-1;
            for(letcodewordsRow/*int*/=firstRow;codewordsRow<lastRow;codewordsRow++){
                if(codewords[codewordsRow]==null){
                    continue;
                }
                letcodeword=codewords[codewordsRow];
                codeword.setRowNumberAsRowIndicatorColumn();
                letrowDifference=codeword.getRowNumber()-barcodeRow;
                //TODOimprovehandlingwithcasewherefirstrowindicatordoesn'tstartwith0
                if(rowDifference===0);
                elseif(rowDifference===1){
                    barcodeRow=codeword.getRowNumber();
                }
                elseif(codeword.getRowNumber()>=barcodeMetadata.getRowCount()){
                    codewords[codewordsRow]=null;
                }
                else{
                    barcodeRow=codeword.getRowNumber();
                }
            }
            //return(int)(averageRowHeight+0.5);
        }
        getBarcodeMetadata(){
            letcodewords=this.getCodewords();
            letbarcodeColumnCount=newBarcodeValue();
            letbarcodeRowCountUpperPart=newBarcodeValue();
            letbarcodeRowCountLowerPart=newBarcodeValue();
            letbarcodeECLevel=newBarcodeValue();
            for(letcodeword/*Codeword*/ofcodewords){
                if(codeword==null){
                    continue;
                }
                codeword.setRowNumberAsRowIndicatorColumn();
                letrowIndicatorValue=codeword.getValue()%30;
                letcodewordRowNumber=codeword.getRowNumber();
                if(!this._isLeft){
                    codewordRowNumber+=2;
                }
                switch(codewordRowNumber%3){
                    case0:
                        barcodeRowCountUpperPart.setValue(rowIndicatorValue*3+1);
                        break;
                    case1:
                        barcodeECLevel.setValue(rowIndicatorValue/3);
                        barcodeRowCountLowerPart.setValue(rowIndicatorValue%3);
                        break;
                    case2:
                        barcodeColumnCount.setValue(rowIndicatorValue+1);
                        break;
                }
            }
            //Maybeweshouldcheckifwehaveambiguousvalues?
            if((barcodeColumnCount.getValue().length===0)||
                (barcodeRowCountUpperPart.getValue().length===0)||
                (barcodeRowCountLowerPart.getValue().length===0)||
                (barcodeECLevel.getValue().length===0)||
                barcodeColumnCount.getValue()[0]<1||
                barcodeRowCountUpperPart.getValue()[0]+barcodeRowCountLowerPart.getValue()[0]<PDF417Common.MIN_ROWS_IN_BARCODE||
                barcodeRowCountUpperPart.getValue()[0]+barcodeRowCountLowerPart.getValue()[0]>PDF417Common.MAX_ROWS_IN_BARCODE){
                returnnull;
            }
            letbarcodeMetadata=newBarcodeMetadata(barcodeColumnCount.getValue()[0],barcodeRowCountUpperPart.getValue()[0],barcodeRowCountLowerPart.getValue()[0],barcodeECLevel.getValue()[0]);
            this.removeIncorrectCodewords(codewords,barcodeMetadata);
            returnbarcodeMetadata;
        }
        removeIncorrectCodewords(codewords,barcodeMetadata){
            //Removecodewordswhichdonotmatchthemetadata
            //TODOMaybeweshouldkeeptheincorrectcodewordsforthestartandendpositions?
            for(letcodewordRow/*int*/=0;codewordRow<codewords.length;codewordRow++){
                letcodeword=codewords[codewordRow];
                if(codewords[codewordRow]==null){
                    continue;
                }
                letrowIndicatorValue=codeword.getValue()%30;
                letcodewordRowNumber=codeword.getRowNumber();
                if(codewordRowNumber>barcodeMetadata.getRowCount()){
                    codewords[codewordRow]=null;
                    continue;
                }
                if(!this._isLeft){
                    codewordRowNumber+=2;
                }
                switch(codewordRowNumber%3){
                    case0:
                        if(rowIndicatorValue*3+1!==barcodeMetadata.getRowCountUpperPart()){
                            codewords[codewordRow]=null;
                        }
                        break;
                    case1:
                        if(Math.trunc(rowIndicatorValue/3)!==barcodeMetadata.getErrorCorrectionLevel()||
                            rowIndicatorValue%3!==barcodeMetadata.getRowCountLowerPart()){
                            codewords[codewordRow]=null;
                        }
                        break;
                    case2:
                        if(rowIndicatorValue+1!==barcodeMetadata.getColumnCount()){
                            codewords[codewordRow]=null;
                        }
                        break;
                }
            }
        }
        isLeft(){
            returnthis._isLeft;
        }
        //@Override
        toString(){
            return'IsLeft:'+this._isLeft+'\n'+super.toString();
        }
    }

    /*
     *Copyright2013ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *@authorGuentherGrau
     */
    /*final*/classDetectionResult{
        constructor(barcodeMetadata,boundingBox){
            /*final*/this.ADJUST_ROW_NUMBER_SKIP=2;
            this.barcodeMetadata=barcodeMetadata;
            this.barcodeColumnCount=barcodeMetadata.getColumnCount();
            this.boundingBox=boundingBox;
            //this.detectionResultColumns=newDetectionResultColumn[this.barcodeColumnCount+2];
            this.detectionResultColumns=newArray(this.barcodeColumnCount+2);
        }
        getDetectionResultColumns(){
            this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);
            this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount+1]);
            letunadjustedCodewordCount=PDF417Common.MAX_CODEWORDS_IN_BARCODE;
            letpreviousUnadjustedCount;
            do{
                previousUnadjustedCount=unadjustedCodewordCount;
                unadjustedCodewordCount=this.adjustRowNumbersAndGetCount();
            }while(unadjustedCodewordCount>0&&unadjustedCodewordCount<previousUnadjustedCount);
            returnthis.detectionResultColumns;
        }
        adjustIndicatorColumnRowNumbers(detectionResultColumn){
            if(detectionResultColumn!=null){
                detectionResultColumn
                    .adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);
            }
        }
        //TODOensurethatnodetectedcodewordswithunknownrownumberareleft
        //weshouldbeabletoestimatetherowheightanduseitasahintfortherownumber
        //weshouldalsofilltherowstoptobottomandbottomtotop
        /**
         *@returnnumberofcodewordswhichdon'thaveavalidrownumber.Notethatthecountisnotaccurateascodewords
         *willbecountedseveraltimes.Itjustservesasanindicatortoseewhenwecanstopadjustingrownumbers
         */
        adjustRowNumbersAndGetCount(){
            letunadjustedCount=this.adjustRowNumbersByRow();
            if(unadjustedCount===0){
                return0;
            }
            for(letbarcodeColumn/*int*/=1;barcodeColumn<this.barcodeColumnCount+1;barcodeColumn++){
                letcodewords=this.detectionResultColumns[barcodeColumn].getCodewords();
                for(letcodewordsRow/*int*/=0;codewordsRow<codewords.length;codewordsRow++){
                    if(codewords[codewordsRow]==null){
                        continue;
                    }
                    if(!codewords[codewordsRow].hasValidRowNumber()){
                        this.adjustRowNumbers(barcodeColumn,codewordsRow,codewords);
                    }
                }
            }
            returnunadjustedCount;
        }
        adjustRowNumbersByRow(){
            this.adjustRowNumbersFromBothRI();
            //TODOweshouldonlydofullrowadjustmentsifrownumbersofleftandrightrowindicatorcolumnmatch.
            //Maybeit'sevenbettertocalculatedtheheight(rows:d)anddivideitbythenumberofbarcode
            //rows.This,togetherwiththeLRIandRRIrownumbersshouldallowustogetagoodestimatewherearow
            //numberstartsandends.
            letunadjustedCount=this.adjustRowNumbersFromLRI();
            returnunadjustedCount+this.adjustRowNumbersFromRRI();
        }
        adjustRowNumbersFromBothRI(){
            if(this.detectionResultColumns[0]==null||this.detectionResultColumns[this.barcodeColumnCount+1]==null){
                return;
            }
            letLRIcodewords=this.detectionResultColumns[0].getCodewords();
            letRRIcodewords=this.detectionResultColumns[this.barcodeColumnCount+1].getCodewords();
            for(letcodewordsRow/*int*/=0;codewordsRow<LRIcodewords.length;codewordsRow++){
                if(LRIcodewords[codewordsRow]!=null&&
                    RRIcodewords[codewordsRow]!=null&&
                    LRIcodewords[codewordsRow].getRowNumber()===RRIcodewords[codewordsRow].getRowNumber()){
                    for(letbarcodeColumn/*int*/=1;barcodeColumn<=this.barcodeColumnCount;barcodeColumn++){
                        letcodeword=this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                        if(codeword==null){
                            continue;
                        }
                        codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());
                        if(!codeword.hasValidRowNumber()){
                            this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow]=null;
                        }
                    }
                }
            }
        }
        adjustRowNumbersFromRRI(){
            if(this.detectionResultColumns[this.barcodeColumnCount+1]==null){
                return0;
            }
            letunadjustedCount=0;
            letcodewords=this.detectionResultColumns[this.barcodeColumnCount+1].getCodewords();
            for(letcodewordsRow/*int*/=0;codewordsRow<codewords.length;codewordsRow++){
                if(codewords[codewordsRow]==null){
                    continue;
                }
                letrowIndicatorRowNumber=codewords[codewordsRow].getRowNumber();
                letinvalidRowCounts=0;
                for(letbarcodeColumn/*int*/=this.barcodeColumnCount+1;barcodeColumn>0&&invalidRowCounts<this.ADJUST_ROW_NUMBER_SKIP;barcodeColumn--){
                    letcodeword=this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                    if(codeword!=null){
                        invalidRowCounts=DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber,invalidRowCounts,codeword);
                        if(!codeword.hasValidRowNumber()){
                            unadjustedCount++;
                        }
                    }
                }
            }
            returnunadjustedCount;
        }
        adjustRowNumbersFromLRI(){
            if(this.detectionResultColumns[0]==null){
                return0;
            }
            letunadjustedCount=0;
            letcodewords=this.detectionResultColumns[0].getCodewords();
            for(letcodewordsRow/*int*/=0;codewordsRow<codewords.length;codewordsRow++){
                if(codewords[codewordsRow]==null){
                    continue;
                }
                letrowIndicatorRowNumber=codewords[codewordsRow].getRowNumber();
                letinvalidRowCounts=0;
                for(letbarcodeColumn/*int*/=1;barcodeColumn<this.barcodeColumnCount+1&&invalidRowCounts<this.ADJUST_ROW_NUMBER_SKIP;barcodeColumn++){
                    letcodeword=this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                    if(codeword!=null){
                        invalidRowCounts=DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber,invalidRowCounts,codeword);
                        if(!codeword.hasValidRowNumber()){
                            unadjustedCount++;
                        }
                    }
                }
            }
            returnunadjustedCount;
        }
        staticadjustRowNumberIfValid(rowIndicatorRowNumber,invalidRowCounts,codeword){
            if(codeword==null){
                returninvalidRowCounts;
            }
            if(!codeword.hasValidRowNumber()){
                if(codeword.isValidRowNumber(rowIndicatorRowNumber)){
                    codeword.setRowNumber(rowIndicatorRowNumber);
                    invalidRowCounts=0;
                }
                else{
                    ++invalidRowCounts;
                }
            }
            returninvalidRowCounts;
        }
        adjustRowNumbers(barcodeColumn,codewordsRow,codewords){
            letcodeword=codewords[codewordsRow];
            letpreviousColumnCodewords=this.detectionResultColumns[barcodeColumn-1].getCodewords();
            letnextColumnCodewords=previousColumnCodewords;
            if(this.detectionResultColumns[barcodeColumn+1]!=null){
                nextColumnCodewords=this.detectionResultColumns[barcodeColumn+1].getCodewords();
            }
            //letotherCodewords:Codeword[]=newCodeword[14];
            letotherCodewords=newArray(14);
            otherCodewords[2]=previousColumnCodewords[codewordsRow];
            otherCodewords[3]=nextColumnCodewords[codewordsRow];
            if(codewordsRow>0){
                otherCodewords[0]=codewords[codewordsRow-1];
                otherCodewords[4]=previousColumnCodewords[codewordsRow-1];
                otherCodewords[5]=nextColumnCodewords[codewordsRow-1];
            }
            if(codewordsRow>1){
                otherCodewords[8]=codewords[codewordsRow-2];
                otherCodewords[10]=previousColumnCodewords[codewordsRow-2];
                otherCodewords[11]=nextColumnCodewords[codewordsRow-2];
            }
            if(codewordsRow<codewords.length-1){
                otherCodewords[1]=codewords[codewordsRow+1];
                otherCodewords[6]=previousColumnCodewords[codewordsRow+1];
                otherCodewords[7]=nextColumnCodewords[codewordsRow+1];
            }
            if(codewordsRow<codewords.length-2){
                otherCodewords[9]=codewords[codewordsRow+2];
                otherCodewords[12]=previousColumnCodewords[codewordsRow+2];
                otherCodewords[13]=nextColumnCodewords[codewordsRow+2];
            }
            for(letotherCodewordofotherCodewords){
                if(DetectionResult.adjustRowNumber(codeword,otherCodeword)){
                    return;
                }
            }
        }
        /**
         *@returntrue,ifrownumberwasadjusted,falseotherwise
         */
        staticadjustRowNumber(codeword,otherCodeword){
            if(otherCodeword==null){
                returnfalse;
            }
            if(otherCodeword.hasValidRowNumber()&&otherCodeword.getBucket()===codeword.getBucket()){
                codeword.setRowNumber(otherCodeword.getRowNumber());
                returntrue;
            }
            returnfalse;
        }
        getBarcodeColumnCount(){
            returnthis.barcodeColumnCount;
        }
        getBarcodeRowCount(){
            returnthis.barcodeMetadata.getRowCount();
        }
        getBarcodeECLevel(){
            returnthis.barcodeMetadata.getErrorCorrectionLevel();
        }
        setBoundingBox(boundingBox){
            this.boundingBox=boundingBox;
        }
        getBoundingBox(){
            returnthis.boundingBox;
        }
        setDetectionResultColumn(barcodeColumn,detectionResultColumn){
            this.detectionResultColumns[barcodeColumn]=detectionResultColumn;
        }
        getDetectionResultColumn(barcodeColumn){
            returnthis.detectionResultColumns[barcodeColumn];
        }
        //@Override
        toString(){
            letrowIndicatorColumn=this.detectionResultColumns[0];
            if(rowIndicatorColumn==null){
                rowIndicatorColumn=this.detectionResultColumns[this.barcodeColumnCount+1];
            }
            //try(
            letformatter=newFormatter();
            //){
            for(letcodewordsRow/*int*/=0;codewordsRow<rowIndicatorColumn.getCodewords().length;codewordsRow++){
                formatter.format('CW%3d:',codewordsRow);
                for(letbarcodeColumn/*int*/=0;barcodeColumn<this.barcodeColumnCount+2;barcodeColumn++){
                    if(this.detectionResultColumns[barcodeColumn]==null){
                        formatter.format('   |  ');
                        continue;
                    }
                    letcodeword=this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                    if(codeword==null){
                        formatter.format('   |  ');
                        continue;
                    }
                    formatter.format('%3d|%3d',codeword.getRowNumber(),codeword.getValue());
                }
                formatter.format('%n');
            }
            returnformatter.toString();
            //}
        }
    }

    /*
     *Copyright2013ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    //packagecom.google.zxing.pdf417.decoder;
    /**
     *@authorGuentherGrau
     */
    /*final*/classCodeword{
        constructor(startX,endX,bucket,value){
            this.rowNumber=Codeword.BARCODE_ROW_UNKNOWN;
            this.startX=Math.trunc(startX);
            this.endX=Math.trunc(endX);
            this.bucket=Math.trunc(bucket);
            this.value=Math.trunc(value);
        }
        hasValidRowNumber(){
            returnthis.isValidRowNumber(this.rowNumber);
        }
        isValidRowNumber(rowNumber){
            returnrowNumber!==Codeword.BARCODE_ROW_UNKNOWN&&this.bucket===(rowNumber%3)*3;
        }
        setRowNumberAsRowIndicatorColumn(){
            this.rowNumber=Math.trunc((Math.trunc(this.value/30))*3+Math.trunc(this.bucket/3));
        }
        getWidth(){
            returnthis.endX-this.startX;
        }
        getStartX(){
            returnthis.startX;
        }
        getEndX(){
            returnthis.endX;
        }
        getBucket(){
            returnthis.bucket;
        }
        getValue(){
            returnthis.value;
        }
        getRowNumber(){
            returnthis.rowNumber;
        }
        setRowNumber(rowNumber){
            this.rowNumber=rowNumber;
        }
        //  @Override
        toString(){
            returnthis.rowNumber+'|'+this.value;
        }
    }
    Codeword.BARCODE_ROW_UNKNOWN=-1;

    /*
    *Copyright2013ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    /**
     *@authorGuentherGrau
     *@authorcreataleGmbH(christoph.schulz@creatale.de)
     */
    /*final*/classPDF417CodewordDecoder{
        /*@note
         *thisactionhavetobeperformedbeforefirstuseofclass
         *-staticconstructor
         *workingwith32bitfloat(basedfromJavalogic)
        */
        staticinitialize(){
            //Pre-computesthesymbolratiotable.
            for(/*int*/leti=0;i<PDF417Common.SYMBOL_TABLE.length;i++){
                letcurrentSymbol=PDF417Common.SYMBOL_TABLE[i];
                letcurrentBit=currentSymbol&0x1;
                for(/*int*/letj=0;j<PDF417Common.BARS_IN_MODULE;j++){
                    letsize=0.0;
                    while((currentSymbol&0x1)===currentBit){
                        size+=1.0;
                        currentSymbol>>=1;
                    }
                    currentBit=currentSymbol&0x1;
                    if(!PDF417CodewordDecoder.RATIOS_TABLE[i]){
                        PDF417CodewordDecoder.RATIOS_TABLE[i]=newArray(PDF417Common.BARS_IN_MODULE);
                    }
                    PDF417CodewordDecoder.RATIOS_TABLE[i][PDF417Common.BARS_IN_MODULE-j-1]=Math.fround(size/PDF417Common.MODULES_IN_CODEWORD);
                }
            }
            this.bSymbolTableReady=true;
        }
        staticgetDecodedValue(moduleBitCount){
            letdecodedValue=PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));
            if(decodedValue!==-1){
                returndecodedValue;
            }
            returnPDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);
        }
        staticsampleBitCounts(moduleBitCount){
            letbitCountSum=MathUtils.sum(moduleBitCount);
            letresult=newInt32Array(PDF417Common.BARS_IN_MODULE);
            letbitCountIndex=0;
            letsumPreviousBits=0;
            for(/*int*/leti=0;i<PDF417Common.MODULES_IN_CODEWORD;i++){
                letsampleIndex=bitCountSum/(2*PDF417Common.MODULES_IN_CODEWORD)+
                    (i*bitCountSum)/PDF417Common.MODULES_IN_CODEWORD;
                if(sumPreviousBits+moduleBitCount[bitCountIndex]<=sampleIndex){
                    sumPreviousBits+=moduleBitCount[bitCountIndex];
                    bitCountIndex++;
                }
                result[bitCountIndex]++;
            }
            returnresult;
        }
        staticgetDecodedCodewordValue(moduleBitCount){
            letdecodedValue=PDF417CodewordDecoder.getBitValue(moduleBitCount);
            returnPDF417Common.getCodeword(decodedValue)===-1?-1:decodedValue;
        }
        staticgetBitValue(moduleBitCount){
            letresult=/*long*/0;
            for(let/*int*/i=0;i<moduleBitCount.length;i++){
                for(/*int*/letbit=0;bit<moduleBitCount[i];bit++){
                    result=(result<<1)|(i%2===0?1:0);
                }
            }
            returnMath.trunc(result);
        }
        //workingwith32bitfloat(asinJava)
        staticgetClosestDecodedValue(moduleBitCount){
            letbitCountSum=MathUtils.sum(moduleBitCount);
            letbitCountRatios=newArray(PDF417Common.BARS_IN_MODULE);
            if(bitCountSum>1){
                for(let/*int*/i=0;i<bitCountRatios.length;i++){
                    bitCountRatios[i]=Math.fround(moduleBitCount[i]/bitCountSum);
                }
            }
            letbestMatchError=Float.MAX_VALUE;
            letbestMatch=-1;
            if(!this.bSymbolTableReady){
                PDF417CodewordDecoder.initialize();
            }
            for(/*int*/letj=0;j<PDF417CodewordDecoder.RATIOS_TABLE.length;j++){
                leterror=0.0;
                letratioTableRow=PDF417CodewordDecoder.RATIOS_TABLE[j];
                for(/*int*/letk=0;k<PDF417Common.BARS_IN_MODULE;k++){
                    letdiff=Math.fround(ratioTableRow[k]-bitCountRatios[k]);
                    error+=Math.fround(diff*diff);
                    if(error>=bestMatchError){
                        break;
                    }
                }
                if(error<bestMatchError){
                    bestMatchError=error;
                    bestMatch=PDF417Common.SYMBOL_TABLE[j];
                }
            }
            returnbestMatch;
        }
    }
    //flagthatthetableisreadyforuse
    PDF417CodewordDecoder.bSymbolTableReady=false;
    PDF417CodewordDecoder.RATIOS_TABLE=newArray(PDF417Common.SYMBOL_TABLE.length).map(x=>x=newArray(PDF417Common.BARS_IN_MODULE));

    /*
     *Copyright2013ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    //packagecom.google.zxing.pdf417;
    /**
     *@authorGuentherGrau
     */
    /*publicfinal*/classPDF417ResultMetadata{
        constructor(){
            this.segmentCount=-1;
            this.fileSize=-1;
            this.timestamp=-1;
            this.checksum=-1;
        }
        /**
         *TheSegmentIDrepresentsthesegmentofthewholefiledistributedoverdifferentsymbols.
         *
         *@returnFilesegmentindex
         */
        getSegmentIndex(){
            returnthis.segmentIndex;
        }
        setSegmentIndex(segmentIndex){
            this.segmentIndex=segmentIndex;
        }
        /**
         *IsthesameforeachrelatedPDF417symbol
         *
         *@returnFileID
         */
        getFileId(){
            returnthis.fileId;
        }
        setFileId(fileId){
            this.fileId=fileId;
        }
        /**
         *@returnalwaysnull
         *@deprecatedusededicatedalreadyparsedfields
         */
        //  @Deprecated
        getOptionalData(){
            returnthis.optionalData;
        }
        /**
         *@paramoptionalDataoldoptionaldataformatasintarray
         *@deprecatedparseandusenewfields
         */
        //  @Deprecated
        setOptionalData(optionalData){
            this.optionalData=optionalData;
        }
        /**
         *@returntrueifitisthelastsegment
         */
        isLastSegment(){
            returnthis.lastSegment;
        }
        setLastSegment(lastSegment){
            this.lastSegment=lastSegment;
        }
        /**
         *@returncountofsegments,-1ifnotset
         */
        getSegmentCount(){
            returnthis.segmentCount;
        }
        setSegmentCount(segmentCount/*int*/){
            this.segmentCount=segmentCount;
        }
        getSender(){
            returnthis.sender||null;
        }
        setSender(sender){
            this.sender=sender;
        }
        getAddressee(){
            returnthis.addressee||null;
        }
        setAddressee(addressee){
            this.addressee=addressee;
        }
        /**
         *Filenameoftheencodedfile
         *
         *@returnfilename
         */
        getFileName(){
            returnthis.fileName;
        }
        setFileName(fileName){
            this.fileName=fileName;
        }
        /**
         *filesizeinbytesoftheencodedfile
         *
         *@returnfilesizeinbytes,-1ifnotset
         */
        getFileSize(){
            returnthis.fileSize;
        }
        setFileSize(fileSize/*long*/){
            this.fileSize=fileSize;
        }
        /**
         *16-bitCRCchecksumusingCCITT-16
         *
         *@returncrcchecksum,-1ifnotset
         */
        getChecksum(){
            returnthis.checksum;
        }
        setChecksum(checksum/*int*/){
            this.checksum=checksum;
        }
        /**
         *unixepocktimestamp,elapsedsecondssince1970-01-01
         *
         *@returnelapsedseconds,-1ifnotset
         */
        getTimestamp(){
            returnthis.timestamp;
        }
        setTimestamp(timestamp/*long*/){
            this.timestamp=timestamp;
        }
    }

    /**
     *PonyfillforJava'sLongclass.
     */
    classLong{
        /**
         *Parsesastringtoanumber,sinceJShasnoreallyInt64.
         *
         *@paramnumNumericstring.
         *@paramradixDestinationradix.
         */
        staticparseLong(num,radix=undefined){
            returnparseInt(num,radix);
        }
    }

    /**
     *CustomErrorclassoftypeException.
     */
    classNullPointerExceptionextendsException{
    }
    NullPointerException.kind='NullPointerException';

    /*
     *Copyright(c)1994,2004,Oracleand/oritsaffiliates.Allrightsreserved.
     *DONOTALTERORREMOVECOPYRIGHTNOTICESORTHISFILEHEADER.
     *
     *Thiscodeisfreesoftware;youcanredistributeitand/ormodifyit
     *underthetermsoftheGNUGeneralPublicLicenseversion2only,as
     *publishedbytheFreeSoftwareFoundation. Oracledesignatesthis
     *particularfileassubjecttothe"Classpath"exceptionasprovided
     *byOracleintheLICENSEfilethataccompaniedthiscode.
     *
     *Thiscodeisdistributedinthehopethatitwillbeuseful,butWITHOUT
     *ANYWARRANTY;withouteventheimpliedwarrantyofMERCHANTABILITYor
     *FITNESSFORAPARTICULARPURPOSE. SeetheGNUGeneralPublicLicense
     *version2formoredetails(acopyisincludedintheLICENSEfilethat
     *accompaniedthiscode).
     *
     *YoushouldhavereceivedacopyoftheGNUGeneralPublicLicenseversion
     *2alongwiththiswork;ifnot,writetotheFreeSoftwareFoundation,
     *Inc.,51FranklinSt,FifthFloor,Boston,MA02110-1301USA.
     *
     *PleasecontactOracle,500OracleParkway,RedwoodShores,CA94065USA
     *orvisitwww.oracle.comifyouneedadditionalinformationorhaveany
     *questions.
     */
    //packagejava.io;
    /**
     *Thisabstractclassisthesuperclassofallclassesrepresenting
     *anoutputstreamofbytes.Anoutputstreamacceptsoutputbytes
     *andsendsthemtosomesink.
     *<p>
     *Applicationsthatneedtodefineasubclassof
     *<code>OutputStream</code>mustalwaysprovideatleastamethod
     *thatwritesonebyteofoutput.
     *
     *@author ArthurvanHoff
     *@see    java.io.BufferedOutputStream
     *@see    java.io.ByteArrayOutputStream
     *@see    java.io.DataOutputStream
     *@see    java.io.FilterOutputStream
     *@see    java.io.InputStream
     *@see    java.io.OutputStream#write(int)
     *@since  JDK1.0
     */
    /*public*/classOutputStream/*implementsCloseable,Flushable*/{
        /**
         *Writes<code>b.length</code>bytesfromthespecifiedbytearray
         *tothisoutputstream.Thegeneralcontractfor<code>write(b)</code>
         *isthatitshouldhaveexactlythesameeffectasthecall
         *<code>write(b,0,b.length)</code>.
         *
         *@param     b  thedata.
         *@exception IOException ifanI/Oerroroccurs.
         *@see       java.io.OutputStream#write(byte[],int,int)
         */
        writeBytes(b){
            this.writeBytesOffset(b,0,b.length);
        }
        /**
         *Writes<code>len</code>bytesfromthespecifiedbytearray
         *startingatoffset<code>off</code>tothisoutputstream.
         *Thegeneralcontractfor<code>write(b,off,len)</code>isthat
         *someofthebytesinthearray<code>b</code>arewrittentothe
         *outputstreaminorder;element<code>b[off]</code>isthefirst
         *bytewrittenand<code>b[off+len-1]</code>isthelastbytewritten
         *bythisoperation.
         *<p>
         *The<code>write</code>methodof<code>OutputStream</code>calls
         *thewritemethodofoneargumentoneachofthebytestobe
         *writtenout.Subclassesareencouragedtooverridethismethodand
         *provideamoreefficientimplementation.
         *<p>
         *If<code>b</code>is<code>null</code>,a
         *<code>NullPointerException</code>isthrown.
         *<p>
         *If<code>off</code>isnegative,or<code>len</code>isnegative,or
         *<code>off+len</code>isgreaterthanthelengthofthearray
         *<code>b</code>,thenan<tt>IndexOutOfBoundsException</tt>isthrown.
         *
         *@param     b    thedata.
         *@param     off  thestartoffsetinthedata.
         *@param     len  thenumberofbytestowrite.
         *@exception IOException ifanI/Oerroroccurs.Inparticular,
         *            an<code>IOException</code>isthrowniftheoutput
         *            streamisclosed.
         */
        writeBytesOffset(b,off,len){
            if(b==null){
                thrownewNullPointerException();
            }
            elseif((off<0)||(off>b.length)||(len<0)||
                ((off+len)>b.length)||((off+len)<0)){
                thrownewIndexOutOfBoundsException();
            }
            elseif(len===0){
                return;
            }
            for(leti=0;i<len;i++){
                this.write(b[off+i]);
            }
        }
        /**
         *Flushesthisoutputstreamandforcesanybufferedoutputbytes
         *tobewrittenout.Thegeneralcontractof<code>flush</code>is
         *thatcallingitisanindicationthat,ifanybytespreviously
         *writtenhavebeenbufferedbytheimplementationoftheoutput
         *stream,suchbytesshouldimmediatelybewrittentotheir
         *intendeddestination.
         *<p>
         *Iftheintendeddestinationofthisstreamisanabstractionprovidedby
         *theunderlyingoperatingsystem,forexampleafile,thenflushingthe
         *streamguaranteesonlythatbytespreviouslywrittentothestreamare
         *passedtotheoperatingsystemforwriting;itdoesnotguaranteethat
         *theyareactuallywrittentoaphysicaldevicesuchasadiskdrive.
         *<p>
         *The<code>flush</code>methodof<code>OutputStream</code>doesnothing.
         *
         *@exception IOException ifanI/Oerroroccurs.
         */
        flush(){
        }
        /**
         *Closesthisoutputstreamandreleasesanysystemresources
         *associatedwiththisstream.Thegeneralcontractof<code>close</code>
         *isthatitclosestheoutputstream.Aclosedstreamcannotperform
         *outputoperationsandcannotbereopened.
         *<p>
         *The<code>close</code>methodof<code>OutputStream</code>doesnothing.
         *
         *@exception IOException ifanI/Oerroroccurs.
         */
        close(){
        }
    }

    /**
     *CustomErrorclassoftypeException.
     */
    classOutOfMemoryErrorextendsException{
    }

    /*
     *Copyright(c)1994,2010,Oracleand/oritsaffiliates.Allrightsreserved.
     *DONOTALTERORREMOVECOPYRIGHTNOTICESORTHISFILEHEADER.
     *
     *Thiscodeisfreesoftware;youcanredistributeitand/ormodifyit
     *underthetermsoftheGNUGeneralPublicLicenseversion2only,as
     *publishedbytheFreeSoftwareFoundation. Oracledesignatesthis
     *particularfileassubjecttothe"Classpath"exceptionasprovided
     *byOracleintheLICENSEfilethataccompaniedthiscode.
     *
     *Thiscodeisdistributedinthehopethatitwillbeuseful,butWITHOUT
     *ANYWARRANTY;withouteventheimpliedwarrantyofMERCHANTABILITYor
     *FITNESSFORAPARTICULARPURPOSE. SeetheGNUGeneralPublicLicense
     *version2formoredetails(acopyisincludedintheLICENSEfilethat
     *accompaniedthiscode).
     *
     *YoushouldhavereceivedacopyoftheGNUGeneralPublicLicenseversion
     *2alongwiththiswork;ifnot,writetotheFreeSoftwareFoundation,
     *Inc.,51FranklinSt,FifthFloor,Boston,MA02110-1301USA.
     *
     *PleasecontactOracle,500OracleParkway,RedwoodShores,CA94065USA
     *orvisitwww.oracle.comifyouneedadditionalinformationorhaveany
     *questions.
     */
    /**
     *Thisclassimplementsanoutputstreaminwhichthedatais
     *writtenintoabytearray.Thebufferautomaticallygrowsasdata
     *iswrittentoit.
     *Thedatacanberetrievedusing<code>toByteArray()</code>and
     *<code>toString()</code>.
     *<p>
     *Closinga<tt>ByteArrayOutputStream</tt>hasnoeffect.Themethodsin
     *thisclasscanbecalledafterthestreamhasbeenclosedwithout
     *generatingan<tt>IOException</tt>.
     *
     *@author ArthurvanHoff
     *@since  JDK1.0
     */
    /*public*/classByteArrayOutputStreamextendsOutputStream{
        /**
         *Createsanewbytearrayoutputstream.Thebuffercapacityis
         *initially32bytes,thoughitssizeincreasesifnecessary.
         */
        //publicconstructor(){
        //    this(32);
        //}
        /**
         *Createsanewbytearrayoutputstream,withabuffercapacityof
         *thespecifiedsize,inbytes.
         *
         *@param  size  theinitialsize.
         *@exception IllegalArgumentExceptionifsizeisnegative.
         */
        constructor(size=32){
            super();
            /**
             *Thenumberofvalidbytesinthebuffer.
             */
            this.count=0;
            if(size<0){
                thrownewIllegalArgumentException('Negativeinitialsize:'
                    +size);
            }
            this.buf=newUint8Array(size);
        }
        /**
         *Increasesthecapacityifnecessarytoensurethatitcanhold
         *atleastthenumberofelementsspecifiedbytheminimum
         *capacityargument.
         *
         *@paramminCapacitythedesiredminimumcapacity
         *@throwsOutOfMemoryErrorif{@codeminCapacity<0}. Thisis
         *interpretedasarequestfortheunsatisfiablylargecapacity
         *{@code(long)Integer.MAX_VALUE+(minCapacity-Integer.MAX_VALUE)}.
         */
        ensureCapacity(minCapacity){
            //overflow-consciouscode
            if(minCapacity-this.buf.length>0)
                this.grow(minCapacity);
        }
        /**
         *Increasesthecapacitytoensurethatitcanholdatleastthe
         *numberofelementsspecifiedbytheminimumcapacityargument.
         *
         *@paramminCapacitythedesiredminimumcapacity
         */
        grow(minCapacity){
            //overflow-consciouscode
            letoldCapacity=this.buf.length;
            letnewCapacity=oldCapacity<<1;
            if(newCapacity-minCapacity<0)
                newCapacity=minCapacity;
            if(newCapacity<0){
                if(minCapacity<0)//overflow
                    thrownewOutOfMemoryError();
                newCapacity=Integer.MAX_VALUE;
            }
            this.buf=Arrays.copyOfUint8Array(this.buf,newCapacity);
        }
        /**
         *Writesthespecifiedbytetothisbytearrayoutputstream.
         *
         *@param  b  thebytetobewritten.
         */
        write(b){
            this.ensureCapacity(this.count+1);
            this.buf[this.count]=/*(byte)*/b;
            this.count+=1;
        }
        /**
         *Writes<code>len</code>bytesfromthespecifiedbytearray
         *startingatoffset<code>off</code>tothisbytearrayoutputstream.
         *
         *@param  b    thedata.
         *@param  off  thestartoffsetinthedata.
         *@param  len  thenumberofbytestowrite.
         */
        writeBytesOffset(b,off,len){
            if((off<0)||(off>b.length)||(len<0)||
                ((off+len)-b.length>0)){
                thrownewIndexOutOfBoundsException();
            }
            this.ensureCapacity(this.count+len);
            System.arraycopy(b,off,this.buf,this.count,len);
            this.count+=len;
        }
        /**
         *Writesthecompletecontentsofthisbytearrayoutputstreamto
         *thespecifiedoutputstreamargument,asifbycallingtheoutput
         *stream'swritemethodusing<code>out.write(buf,0,count)</code>.
         *
         *@param     out  theoutputstreamtowhichtowritethedata.
         *@exception IOException ifanI/Oerroroccurs.
         */
        writeTo(out){
            out.writeBytesOffset(this.buf,0,this.count);
        }
        /**
         *Resetsthe<code>count</code>fieldofthisbytearrayoutput
         *streamtozero,sothatallcurrentlyaccumulatedoutputinthe
         *outputstreamisdiscarded.Theoutputstreamcanbeusedagain,
         *reusingthealreadyallocatedbufferspace.
         *
         *@see    java.io.ByteArrayInputStream#count
         */
        reset(){
            this.count=0;
        }
        /**
         *Createsanewlyallocatedbytearray.Itssizeisthecurrent
         *sizeofthisoutputstreamandthevalidcontentsofthebuffer
         *havebeencopiedintoit.
         *
         *@return thecurrentcontentsofthisoutputstream,asabytearray.
         *@see    java.io.ByteArrayOutputStream#size()
         */
        toByteArray(){
            returnArrays.copyOfUint8Array(this.buf,this.count);
        }
        /**
         *Returnsthecurrentsizeofthebuffer.
         *
         *@return thevalueofthe<code>count</code>field,whichisthenumber
         *         ofvalidbytesinthisoutputstream.
         *@see    java.io.ByteArrayOutputStream#count
         */
        size(){
            returnthis.count;
        }
        toString(param){
            if(!param){
                returnthis.toString_void();
            }
            if(typeofparam==='string'){
                returnthis.toString_string(param);
            }
            returnthis.toString_number(param);
        }
        /**
         *Convertsthebuffer'scontentsintoastringdecodingbytesusingthe
         *platform'sdefaultcharacterset.Thelengthofthenew<tt>String</tt>
         *isafunctionofthecharacterset,andhencemaynotbeequaltothe
         *sizeofthebuffer.
         *
         *<p>Thismethodalwaysreplacesmalformed-inputandunmappable-character
         *sequenceswiththedefaultreplacementstringfortheplatform's
         *defaultcharacterset.The{@linkplainjava.nio.charset.CharsetDecoder}
         *classshouldbeusedwhenmorecontroloverthedecodingprocessis
         *required.
         *
         *@returnStringdecodedfromthebuffer'scontents.
         *@since JDK1.1
         */
        toString_void(){
            returnnewString(this.buf/*,0,this.count*/).toString();
        }
        /**
         *Convertsthebuffer'scontentsintoastringbydecodingthebytesusing
         *thespecified{@linkjava.nio.charset.CharsetcharsetName}.Thelengthof
         *thenew<tt>String</tt>isafunctionofthecharset,andhencemaynotbe
         *equaltothelengthofthebytearray.
         *
         *<p>Thismethodalwaysreplacesmalformed-inputandunmappable-character
         *sequenceswiththischarset'sdefaultreplacementstring.The{@link
         *java.nio.charset.CharsetDecoder}classshouldbeusedwhenmorecontrol
         *overthedecodingprocessisrequired.
         *
         *@param charsetName thenameofasupported
         *             {@linkplainjava.nio.charset.Charset</code>charset<code>}
         *@returnStringdecodedfromthebuffer'scontents.
         *@exception UnsupportedEncodingException
         *            Ifthenamedcharsetisnotsupported
         *@since  JDK1.1
         */
        toString_string(charsetName){
            returnnewString(this.buf/*,0,this.count,charsetName*/).toString();
        }
        /**
         *Createsanewlyallocatedstring.Itssizeisthecurrentsizeof
         *theoutputstreamandthevalidcontentsofthebufferhavebeen
         *copiedintoit.Eachcharacter<i>c</i>intheresultingstringis
         *constructedfromthecorrespondingelement<i>b</i>inthebyte
         *arraysuchthat:
         *<blockquote><pre>
         *    c==(char)(((hibyte&amp;0xff)&lt;&lt;8)|(b&amp;0xff))
         *</pre></blockquote>
         *
         *@deprecatedThismethoddoesnotproperlyconvertbytesintocharacters.
         *AsofJDK&nbsp;1.1,thepreferredwaytodothisisviathe
         *<code>toString(Stringenc)</code>method,whichtakesanencoding-name
         *argument,orthe<code>toString()</code>method,whichusesthe
         *platform'sdefaultcharacterencoding.
         *
         *@param     hibyte   thehighbyteofeachresultingUnicodecharacter.
         *@return    thecurrentcontentsoftheoutputstream,asastring.
         *@see       java.io.ByteArrayOutputStream#size()
         *@see       java.io.ByteArrayOutputStream#toString(String)
         *@see       java.io.ByteArrayOutputStream#toString()
         */
        //@Deprecated
        toString_number(hibyte){
            returnnewString(this.buf/*,hibyte,0,this.count*/).toString();
        }
        /**
         *Closinga<tt>ByteArrayOutputStream</tt>hasnoeffect.Themethodsin
         *thisclasscanbecalledafterthestreamhasbeenclosedwithout
         *generatingan<tt>IOException</tt>.
         *<p>
         *
         *@throwsIOException
         */
        close(){
        }
    }

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*private*/varMode$2;
    (function(Mode){
        Mode[Mode["ALPHA"]=0]="ALPHA";
        Mode[Mode["LOWER"]=1]="LOWER";
        Mode[Mode["MIXED"]=2]="MIXED";
        Mode[Mode["PUNCT"]=3]="PUNCT";
        Mode[Mode["ALPHA_SHIFT"]=4]="ALPHA_SHIFT";
        Mode[Mode["PUNCT_SHIFT"]=5]="PUNCT_SHIFT";
    })(Mode$2||(Mode$2={}));
    /**
     *IndirectlyaccesstheglobalBigIntconstructor,it
     *allowsbrowsersthatdoesn'tsupportBigInttorun
     *thelibrarywithoutbreakingdueto"undefinedBigInt"
     *errors.
     */
    functiongetBigIntConstructor(){
        if(typeofwindow!=='undefined'){
            returnwindow['BigInt']||null;
        }
        if(typeofglobal!=='undefined'){
            returnglobal['BigInt']||null;
        }
        if(typeofself!=='undefined'){
            returnself['BigInt']||null;
        }
        thrownewError('Can\'tsearchglobalsforBigInt!');
    }
    /**
     *UsedtostoretheBigIntconstructor.
     */
    letBigInteger;
    /**
     *Thisfunctioncreatesabigintvalue.Itallowsbrowsers
     *thatdoesn'tsupportBigInttoruntherestofthelibrary
     *bynotdirectlyaccessingtheBigIntconstructor.
     */
    functioncreateBigInt(num){
        if(typeofBigInteger==='undefined'){
            BigInteger=getBigIntConstructor();
        }
        if(BigInteger===null){
            thrownewError('BigIntisnotsupported!');
        }
        returnBigInteger(num);
    }
    functiongetEXP900(){
        //inJava-arraywithlength=16
        letEXP900=[];
        EXP900[0]=createBigInt(1);
        letnineHundred=createBigInt(900);
        EXP900[1]=nineHundred;
        //inJava-arraywithlength=16
        for(leti/*int*/=2;i<16;i++){
            EXP900[i]=EXP900[i-1]*nineHundred;
        }
        returnEXP900;
    }
    /**
     *<p>ThisclasscontainsthemethodsfordecodingthePDF417codewords.</p>
     *
     *@authorSITALab(kevin.osullivan@sita.aero)
     *@authorGuentherGrau
     */
    /*final*/classDecodedBitStreamParser$2{
        //  privateDecodedBitStreamParser(){
        //}
        /**
         *
         *@paramcodewords
         *@paramecLevel
         *
         *@throwsFormatException
         */
        staticdecode(codewords,ecLevel){
            //passencodingtoresult(willbeusedfordecodesymbolsinbytemode)
            letresult=newStringBuilder('');
            //letencoding:Charset=StandardCharsets.ISO_8859_1;
            letencoding=CharacterSetECI.ISO8859_1;
            /**
             *@notethenextcommandisspecificfromthisTypeScriptlibrary
             *becauseTScan'tproperlycastsomevaluestocharand
             *convertittostringlatercorrectlyduetoencoding
             *differencesfromJavaversion.Asreportedhere:
             *https://github.com/zxing-js/library/pull/264/files#r382831593
             */
            result.enableDecoding(encoding);
            //Getcompactionmode
            letcodeIndex=1;
            letcode=codewords[codeIndex++];
            letresultMetadata=newPDF417ResultMetadata();
            while(codeIndex<codewords[0]){
                switch(code){
                    caseDecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                        codeIndex=DecodedBitStreamParser$2.textCompaction(codewords,codeIndex,result);
                        break;
                    caseDecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                    caseDecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                        codeIndex=DecodedBitStreamParser$2.byteCompaction(code,codewords,encoding,codeIndex,result);
                        break;
                    caseDecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                        result.append(/*(char)*/codewords[codeIndex++]);
                        break;
                    caseDecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                        codeIndex=DecodedBitStreamParser$2.numericCompaction(codewords,codeIndex,result);
                        break;
                    caseDecodedBitStreamParser$2.ECI_CHARSET:
                        letcharsetECI=CharacterSetECI.getCharacterSetECIByValue(codewords[codeIndex++]);
                        //encoding=Charset.forName(charsetECI.getName());
                        break;
                    caseDecodedBitStreamParser$2.ECI_GENERAL_PURPOSE:
                        //Can'tdoanythingwithgenericECI;skipits2characters
                        codeIndex+=2;
                        break;
                    caseDecodedBitStreamParser$2.ECI_USER_DEFINED:
                        //Can'tdoanythingwithuserECI;skipits1character
                        codeIndex++;
                        break;
                    caseDecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                        codeIndex=DecodedBitStreamParser$2.decodeMacroBlock(codewords,codeIndex,resultMetadata);
                        break;
                    caseDecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                    caseDecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                        //Shouldnotseetheseoutsideamacroblock
                        thrownewFormatException();
                    default:
                        //Defaulttotextcompaction.Duringtestingnumerousbarcodes
                        //appearedtobemissingthestartingmode.Inthesecasesdefaulting
                        //totextcompactionseemstowork.
                        codeIndex--;
                        codeIndex=DecodedBitStreamParser$2.textCompaction(codewords,codeIndex,result);
                        break;
                }
                if(codeIndex<codewords.length){
                    code=codewords[codeIndex++];
                }
                else{
                    throwFormatException.getFormatInstance();
                }
            }
            if(result.length()===0){
                throwFormatException.getFormatInstance();
            }
            letdecoderResult=newDecoderResult(null,result.toString(),null,ecLevel);
            decoderResult.setOther(resultMetadata);
            returndecoderResult;
        }
        /**
         *
         *@paramint
         *@paramparam1
         *@paramcodewords
         *@paramint
         *@paramcodeIndex
         *@paramPDF417ResultMetadata
         *@paramresultMetadata
         *
         *@throwsFormatException
         */
        //@SuppressWarnings("deprecation")
        staticdecodeMacroBlock(codewords,codeIndex,resultMetadata){
            if(codeIndex+DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS>codewords[0]){
                //wemusthaveatleasttwobytesleftforthesegmentindex
                throwFormatException.getFormatInstance();
            }
            letsegmentIndexArray=newInt32Array(DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS);
            for(leti/*int*/=0;i<DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS;i++,codeIndex++){
                segmentIndexArray[i]=codewords[codeIndex];
            }
            resultMetadata.setSegmentIndex(Integer.parseInt(DecodedBitStreamParser$2.decodeBase900toBase10(segmentIndexArray,DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS)));
            letfileId=newStringBuilder();
            codeIndex=DecodedBitStreamParser$2.textCompaction(codewords,codeIndex,fileId);
            resultMetadata.setFileId(fileId.toString());
            letoptionalFieldsStart=-1;
            if(codewords[codeIndex]===DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD){
                optionalFieldsStart=codeIndex+1;
            }
            while(codeIndex<codewords[0]){
                switch(codewords[codeIndex]){
                    caseDecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                        codeIndex++;
                        switch(codewords[codeIndex]){
                            caseDecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                                letfileName=newStringBuilder();
                                codeIndex=DecodedBitStreamParser$2.textCompaction(codewords,codeIndex+1,fileName);
                                resultMetadata.setFileName(fileName.toString());
                                break;
                            caseDecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                                letsender=newStringBuilder();
                                codeIndex=DecodedBitStreamParser$2.textCompaction(codewords,codeIndex+1,sender);
                                resultMetadata.setSender(sender.toString());
                                break;
                            caseDecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                                letaddressee=newStringBuilder();
                                codeIndex=DecodedBitStreamParser$2.textCompaction(codewords,codeIndex+1,addressee);
                                resultMetadata.setAddressee(addressee.toString());
                                break;
                            caseDecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                                letsegmentCount=newStringBuilder();
                                codeIndex=DecodedBitStreamParser$2.numericCompaction(codewords,codeIndex+1,segmentCount);
                                resultMetadata.setSegmentCount(Integer.parseInt(segmentCount.toString()));
                                break;
                            caseDecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                                lettimestamp=newStringBuilder();
                                codeIndex=DecodedBitStreamParser$2.numericCompaction(codewords,codeIndex+1,timestamp);
                                resultMetadata.setTimestamp(Long.parseLong(timestamp.toString()));
                                break;
                            caseDecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                                letchecksum=newStringBuilder();
                                codeIndex=DecodedBitStreamParser$2.numericCompaction(codewords,codeIndex+1,checksum);
                                resultMetadata.setChecksum(Integer.parseInt(checksum.toString()));
                                break;
                            caseDecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                                letfileSize=newStringBuilder();
                                codeIndex=DecodedBitStreamParser$2.numericCompaction(codewords,codeIndex+1,fileSize);
                                resultMetadata.setFileSize(Long.parseLong(fileSize.toString()));
                                break;
                            default:
                                throwFormatException.getFormatInstance();
                        }
                        break;
                    caseDecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                        codeIndex++;
                        resultMetadata.setLastSegment(true);
                        break;
                    default:
                        throwFormatException.getFormatInstance();
                }
            }
            //copyoptionalfieldstoadditionaloptions
            if(optionalFieldsStart!==-1){
                letoptionalFieldsLength=codeIndex-optionalFieldsStart;
                if(resultMetadata.isLastSegment()){
                    //donotincludeterminator
                    optionalFieldsLength--;
                }
                resultMetadata.setOptionalData(Arrays.copyOfRange(codewords,optionalFieldsStart,optionalFieldsStart+optionalFieldsLength));
            }
            returncodeIndex;
        }
        /**
         *TextCompactionmode(see5.4.1.5)permitsallprintableASCIIcharacterstobe
         *encoded,i.e.values32-126inclusiveinaccordancewithISO/IEC646(IRV),as
         *wellasselectedcontrolcharacters.
         *
         *@paramcodewordsThearrayofcodewords(data+error)
         *@paramcodeIndexThecurrentindexintothecodewordarray.
         *@paramresult   Thedecodeddataisappendedtotheresult.
         *@returnThenextindexintothecodewordarray.
         */
        statictextCompaction(codewords,codeIndex,result){
            //2characterpercodeword
            lettextCompactionData=newInt32Array((codewords[0]-codeIndex)*2);
            //Usedtoholdthebytecompactionvalueifthereisamodeshift
            letbyteCompactionData=newInt32Array((codewords[0]-codeIndex)*2);
            letindex=0;
            letend=false;
            while((codeIndex<codewords[0])&&!end){
                letcode=codewords[codeIndex++];
                if(code<DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH){
                    textCompactionData[index]=code/30;
                    textCompactionData[index+1]=code%30;
                    index+=2;
                }
                else{
                    switch(code){
                        caseDecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                            //reinitializetextcompactionmodetoalphasubmode
                            textCompactionData[index++]=DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH;
                            break;
                        caseDecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                        caseDecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                        caseDecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                        caseDecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                        caseDecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                        caseDecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                            codeIndex--;
                            end=true;
                            break;
                        caseDecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                            //TheModeShiftcodeword913shallcauseatemporary
                            //switchfromTextCompactionmodetoByteCompactionmode.
                            //Thisswitchshallbeineffectforonlythenextcodeword,
                            //afterwhichthemodeshallreverttotheprevailingsub-mode
                            //oftheTextCompactionmode.Codeword913isonlyavailable
                            //inTextCompactionmode;itsuseisdescribedin5.4.2.4.
                            textCompactionData[index]=DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
                            code=codewords[codeIndex++];
                            byteCompactionData[index]=code;
                            index++;
                            break;
                    }
                }
            }
            DecodedBitStreamParser$2.decodeTextCompaction(textCompactionData,byteCompactionData,index,result);
            returncodeIndex;
        }
        /**
         *TheTextCompactionmodeincludesalltheprintableASCIIcharacters
         *(i.e.valuesfrom32to126)andthreeASCIIcontrolcharacters:HTortab
         *(9:e),LForlinefeed(10:e),andCRorcarriage
         *return(13:e).TheTextCompactionmodealsoincludesvariouslatch
         *andshiftcharacterswhichareusedexclusivelywithinthemode.TheText
         *Compactionmodeencodesupto2characterspercodeword.Thecompactionrules
         *forconvertingdataintoPDF417codewordsaredefinedin5.4.2.2.Thesub-mode
         *switchesaredefinedin5.4.2.3.
         *
         *@paramtextCompactionDataThetextcompactiondata.
         *@parambyteCompactionDataThebytecompactiondataifthere
         *                          wasamodeshift.
         *@paramlength            Thesizeofthetextcompactionandbytecompactiondata.
         *@paramresult            Thedecodeddataisappendedtotheresult.
         */
        staticdecodeTextCompaction(textCompactionData,byteCompactionData,length,result){
            //BeginningfromaninitialstateoftheAlphasub-mode
            //ThedefaultcompactionmodeforPDF417ineffectatthestartofeachsymbolshallalwaysbeText
            //CompactionmodeAlphasub-mode(alphabetic:uppercase).AlatchcodewordfromanothermodetotheText
            //CompactionmodeshallalwaysswitchtotheTextCompactionAlphasub-mode.
            letsubMode=Mode$2.ALPHA;
            letpriorToShiftMode=Mode$2.ALPHA;
            leti=0;
            while(i<length){
                letsubModeCh=textCompactionData[i];
                letch=/*char*/'';
                switch(subMode){
                    caseMode$2.ALPHA:
                        //Alpha(alphabetic:uppercase)
                        if(subModeCh<26){
                            //UppercaseAlphaCharacter
                            //Note:65='A'ASCII->thereisbytecodeofsymbol
                            ch=/*(char)('A'+subModeCh)*/String.fromCharCode(65+subModeCh);
                        }
                        else{
                            switch(subModeCh){
                                case26:
                                    ch='';
                                    break;
                                caseDecodedBitStreamParser$2.LL:
                                    subMode=Mode$2.LOWER;
                                    break;
                                caseDecodedBitStreamParser$2.ML:
                                    subMode=Mode$2.MIXED;
                                    break;
                                caseDecodedBitStreamParser$2.PS:
                                    //Shifttopunctuation
                                    priorToShiftMode=subMode;
                                    subMode=Mode$2.PUNCT_SHIFT;
                                    break;
                                caseDecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                    result.append(/*(char)*/byteCompactionData[i]);
                                    break;
                                caseDecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                    subMode=Mode$2.ALPHA;
                                    break;
                            }
                        }
                        break;
                    caseMode$2.LOWER:
                        //Lower(alphabetic:lowercase)
                        if(subModeCh<26){
                            ch=/*(char)('a'+subModeCh)*/String.fromCharCode(97+subModeCh);
                        }
                        else{
                            switch(subModeCh){
                                case26:
                                    ch='';
                                    break;
                                caseDecodedBitStreamParser$2.AS:
                                    //Shifttoalpha
                                    priorToShiftMode=subMode;
                                    subMode=Mode$2.ALPHA_SHIFT;
                                    break;
                                caseDecodedBitStreamParser$2.ML:
                                    subMode=Mode$2.MIXED;
                                    break;
                                caseDecodedBitStreamParser$2.PS:
                                    //Shifttopunctuation
                                    priorToShiftMode=subMode;
                                    subMode=Mode$2.PUNCT_SHIFT;
                                    break;
                                caseDecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                    //TODODoesthisneedtousethecurrentcharacterencoding?Seeotheroccurrencesbelow
                                    result.append(/*(char)*/byteCompactionData[i]);
                                    break;
                                caseDecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                    subMode=Mode$2.ALPHA;
                                    break;
                            }
                        }
                        break;
                    caseMode$2.MIXED:
                        //Mixed(punctuation:e)
                        if(subModeCh<DecodedBitStreamParser$2.PL){
                            ch=DecodedBitStreamParser$2.MIXED_CHARS[subModeCh];
                        }
                        else{
                            switch(subModeCh){
                                caseDecodedBitStreamParser$2.PL:
                                    subMode=Mode$2.PUNCT;
                                    break;
                                case26:
                                    ch='';
                                    break;
                                caseDecodedBitStreamParser$2.LL:
                                    subMode=Mode$2.LOWER;
                                    break;
                                caseDecodedBitStreamParser$2.AL:
                                    subMode=Mode$2.ALPHA;
                                    break;
                                caseDecodedBitStreamParser$2.PS:
                                    //Shifttopunctuation
                                    priorToShiftMode=subMode;
                                    subMode=Mode$2.PUNCT_SHIFT;
                                    break;
                                caseDecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                    result.append(/*(char)*/byteCompactionData[i]);
                                    break;
                                caseDecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                    subMode=Mode$2.ALPHA;
                                    break;
                            }
                        }
                        break;
                    caseMode$2.PUNCT:
                        //Punctuation
                        if(subModeCh<DecodedBitStreamParser$2.PAL){
                            ch=DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
                        }
                        else{
                            switch(subModeCh){
                                caseDecodedBitStreamParser$2.PAL:
                                    subMode=Mode$2.ALPHA;
                                    break;
                                caseDecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                    result.append(/*(char)*/byteCompactionData[i]);
                                    break;
                                caseDecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                    subMode=Mode$2.ALPHA;
                                    break;
                            }
                        }
                        break;
                    caseMode$2.ALPHA_SHIFT:
                        //Restoresub-mode
                        subMode=priorToShiftMode;
                        if(subModeCh<26){
                            ch=/*(char)('A'+subModeCh)*/String.fromCharCode(65+subModeCh);
                        }
                        else{
                            switch(subModeCh){
                                case26:
                                    ch='';
                                    break;
                                caseDecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                    subMode=Mode$2.ALPHA;
                                    break;
                            }
                        }
                        break;
                    caseMode$2.PUNCT_SHIFT:
                        //Restoresub-mode
                        subMode=priorToShiftMode;
                        if(subModeCh<DecodedBitStreamParser$2.PAL){
                            ch=DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
                        }
                        else{
                            switch(subModeCh){
                                caseDecodedBitStreamParser$2.PAL:
                                    subMode=Mode$2.ALPHA;
                                    break;
                                caseDecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                    //PSbeforeShift-to-Byteisusedasapaddingcharacter,
                                    //see5.4.2.4ofthespecification
                                    result.append(/*(char)*/byteCompactionData[i]);
                                    break;
                                caseDecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                    subMode=Mode$2.ALPHA;
                                    break;
                            }
                        }
                        break;
                }
                //if(ch!==0){
                if(ch!==''){
                    //Appenddecodedcharactertoresult
                    result.append(ch);
                }
                i++;
            }
        }
        /**
         *ByteCompactionmode(see5.4.3)permitsall256possible8-bitbytevaluestobeencoded.
         *ThisincludesallASCIIcharactersvalue0to127inclusiveandprovidesforinternational
         *charactersetsupport.
         *
         *@parammode     Thebytecompactionmodei.e.901or924
         *@paramcodewordsThearrayofcodewords(data+error)
         *@paramencoding Currentlyactivecharacterencoding
         *@paramcodeIndexThecurrentindexintothecodewordarray.
         *@paramresult   Thedecodeddataisappendedtotheresult.
         *@returnThenextindexintothecodewordarray.
         */
        static/*int*/byteCompaction(mode,codewords,encoding,codeIndex,result){
            letdecodedBytes=newByteArrayOutputStream();
            letcount=0;
            letvalue=/*long*/0;
            letend=false;
            switch(mode){
                caseDecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                    //TotalnumberofByteCompactioncharacterstobeencoded
                    //isnotamultipleof6
                    letbyteCompactedCodewords=newInt32Array(6);
                    letnextCode=codewords[codeIndex++];
                    while((codeIndex<codewords[0])&&!end){
                        byteCompactedCodewords[count++]=nextCode;
                        //Base900
                        value=900*value+nextCode;
                        nextCode=codewords[codeIndex++];
                        //perhapsitshouldbeoktocheckonlynextCode>=TEXT_COMPACTION_MODE_LATCH
                        switch(nextCode){
                            caseDecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                            caseDecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                            caseDecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                            caseDecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                            caseDecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                            caseDecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                            caseDecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                                codeIndex--;
                                end=true;
                                break;
                            default:
                                if((count%5===0)&&(count>0)){
                                    //Decodeevery5codewords
                                    //ConverttoBase256
                                    for(letj/*int*/=0;j<6;++j){
                                        /*@note
                                         *JavaScriptstoresnumbersas64bitsfloatingpointnumbers,butallbitwiseoperationsareperformedon32bitsbinarynumbers.
                                         *Sothenextbitwiseoperationcouldnotbedonewithsimplenumbers
                                         */
                                        decodedBytes.write(/*(byte)*/Number(createBigInt(value)>>createBigInt(8*(5-j))));
                                    }
                                    value=0;
                                    count=0;
                                }
                                break;
                        }
                    }
                    //iftheendofallcodewordsisreachedthelastcodewordneedstobeadded
                    if(codeIndex===codewords[0]&&nextCode<DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH){
                        byteCompactedCodewords[count++]=nextCode;
                    }
                    //IfByteCompactionmodeisinvokedwithcodeword901,
                    //thelastgroupofcodewordsisinterpreteddirectly
                    //asonebytepercodeword,withoutcompaction.
                    for(leti/*int*/=0;i<count;i++){
                        decodedBytes.write(/*(byte)*/byteCompactedCodewords[i]);
                    }
                    break;
                caseDecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                    //TotalnumberofByteCompactioncharacterstobeencoded
                    //isanintegermultipleof6
                    while(codeIndex<codewords[0]&&!end){
                        letcode=codewords[codeIndex++];
                        if(code<DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH){
                            count++;
                            //Base900
                            value=900*value+code;
                        }
                        else{
                            switch(code){
                                caseDecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                caseDecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                                caseDecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                                caseDecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                                caseDecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                                caseDecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                                caseDecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                                    codeIndex--;
                                    end=true;
                                    break;
                            }
                        }
                        if((count%5===0)&&(count>0)){
                            //Decodeevery5codewords
                            //ConverttoBase256
                            /*@note
                             *JavaScriptstoresnumbersas64bitsfloatingpointnumbers,butallbitwiseoperationsareperformedon32bitsbinarynumbers.
                             *Sothenextbitwiseoperationcouldnotbedonewithsimplenumbers
                            */
                            for(letj/*int*/=0;j<6;++j){
                                decodedBytes.write(/*(byte)*/Number(createBigInt(value)>>createBigInt(8*(5-j))));
                            }
                            value=0;
                            count=0;
                        }
                    }
                    break;
            }
            result.append(StringEncoding.decode(decodedBytes.toByteArray(),encoding));
            returncodeIndex;
        }
        /**
         *NumericCompactionmode(see5.4.4)permitsefficientencodingofnumericdatastrings.
         *
         *@paramcodewordsThearrayofcodewords(data+error)
         *@paramcodeIndexThecurrentindexintothecodewordarray.
         *@paramresult   Thedecodeddataisappendedtotheresult.
         *@returnThenextindexintothecodewordarray.
         *
         *@throwsFormatException
         */
        staticnumericCompaction(codewords,codeIndex/*int*/,result){
            letcount=0;
            letend=false;
            letnumericCodewords=newInt32Array(DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS);
            while(codeIndex<codewords[0]&&!end){
                letcode=codewords[codeIndex++];
                if(codeIndex===codewords[0]){
                    end=true;
                }
                if(code<DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH){
                    numericCodewords[count]=code;
                    count++;
                }
                else{
                    switch(code){
                        caseDecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                        caseDecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                        caseDecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                        caseDecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                        caseDecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                        caseDecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                            codeIndex--;
                            end=true;
                            break;
                    }
                }
                if((count%DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS===0||code===DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH||end)&&count>0){
                    //Re-invokingNumericCompactionmode(byusingcodeword902
                    //whileinNumericCompactionmode)serves toterminatethe
                    //currentNumericCompactionmodegroupingasdescribedin5.4.4.2,
                    //andthentostartanewonegrouping.
                    result.append(DecodedBitStreamParser$2.decodeBase900toBase10(numericCodewords,count));
                    count=0;
                }
            }
            returncodeIndex;
        }
        /**
         *ConvertalistofNumericCompactedcodewordsfromBase900toBase10.
         *
         *@paramcodewordsThearrayofcodewords
         *@paramcount    Thenumberofcodewords
         *@returnThedecodedstringrepresentingtheNumericdata.
         *
         *EXAMPLE
         *Encodethefifteendigitnumericstring000213298174000
         *Prefixthenumericstringwitha1andsettheinitialvalueof
         *t=1000213298174000
         *Calculatecodeword0
         *d0=1000213298174000mod900=200
         *
         *t=1000213298174000div900=1111348109082
         *Calculatecodeword1
         *d1=1111348109082mod900=282
         *
         *t=1111348109082div900=1234831232
         *Calculatecodeword2
         *d2=1234831232mod900=632
         *
         *t=1234831232div900=1372034
         *Calculatecodeword3
         *d3=1372034mod900=434
         *
         *t=1372034div900=1524
         *Calculatecodeword4
         *d4=1524mod900=624
         *
         *t=1524div900=1
         *Calculatecodeword5
         *d5=1mod900=1
         *t=1div900=0
         *Codewordsequenceis:1,624,434,632,282,200
         *
         *Decodetheabovecodewordsinvolves
         *  1x900powerof5+624x900powerof4+434x900powerof3+
         *632x900powerof2+282x900powerof1+200x900powerof0=1000213298174000
         *
         *Removeleading1=> Resultis000213298174000
         *
         *@throwsFormatException
         */
        staticdecodeBase900toBase10(codewords,count){
            letresult=createBigInt(0);
            for(leti/*int*/=0;i<count;i++){
                result+=DecodedBitStreamParser$2.EXP900[count-i-1]*createBigInt(codewords[i]);
            }
            letresultString=result.toString();
            if(resultString.charAt(0)!=='1'){
                thrownewFormatException();
            }
            returnresultString.substring(1);
        }
    }
    DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH=900;
    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH=901;
    DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH=902;
    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6=924;
    DecodedBitStreamParser$2.ECI_USER_DEFINED=925;
    DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE=926;
    DecodedBitStreamParser$2.ECI_CHARSET=927;
    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK=928;
    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD=923;
    DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR=922;
    DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE=913;
    DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS=15;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME=0;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT=1;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP=2;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER=3;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE=4;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE=5;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM=6;
    DecodedBitStreamParser$2.PL=25;
    DecodedBitStreamParser$2.LL=27;
    DecodedBitStreamParser$2.AS=27;
    DecodedBitStreamParser$2.ML=28;
    DecodedBitStreamParser$2.AL=28;
    DecodedBitStreamParser$2.PS=29;
    DecodedBitStreamParser$2.PAL=29;
    DecodedBitStreamParser$2.PUNCT_CHARS=';<>@[\\]_`~!\r\t,:\n-.$/"|*()?{}\'';
    DecodedBitStreamParser$2.MIXED_CHARS='0123456789&\r\t,:#-.$/+%*=^';
    /**
     *Tablecontainingvaluesfortheexponentof900.
     *Thisisusedinthenumericcompactiondecodealgorithm.
     */
    DecodedBitStreamParser$2.EXP900=getBigIntConstructor()?getEXP900():[];
    DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS=2;

    /*
    *Copyright2013ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    //importjava.util.ArrayList;
    //importjava.util.Collection;
    //importjava.util.Formatter;
    //importjava.util.List;
    /**
     *@authorGuentherGrau
     */
    /*publicfinal*/classPDF417ScanningDecoder{
        constructor(){}
        /**
         *@TODOdon'tpassinminCodewordWidthandmaxCodewordWidth,passinbarcodecolumnsforstartandstoppattern
         *
         *columns.Thatwaywidthcanbedeductedfromthepatterncolumn.
         *Thisapproachalsoallowstodetectmoredetailsaboutthebarcode,e.g.ifabartype(whiteorblack)iswider
         *thanitshouldbe.Thiscanhappenifthescannerusedabadblackpoint.
         *
         *@paramBitMatrix
         *@paramimage
         *@paramResultPoint
         *@paramimageTopLeft
         *@paramResultPoint
         *@paramimageBottomLeft
         *@paramResultPoint
         *@paramimageTopRight
         *@paramResultPoint
         *@paramimageBottomRight
         *@paramint
         *@paramminCodewordWidth
         *@paramint
         *@parammaxCodewordWidth
         *
         *@throwsNotFoundException
         *@throwsFormatException
         *@throwsChecksumException
         */
        staticdecode(image,imageTopLeft,imageBottomLeft,imageTopRight,imageBottomRight,minCodewordWidth,maxCodewordWidth){
            letboundingBox=newBoundingBox(image,imageTopLeft,imageBottomLeft,imageTopRight,imageBottomRight);
            letleftRowIndicatorColumn=null;
            letrightRowIndicatorColumn=null;
            letdetectionResult;
            for(letfirstPass/*boolean*/=true;;firstPass=false){
                if(imageTopLeft!=null){
                    leftRowIndicatorColumn=PDF417ScanningDecoder.getRowIndicatorColumn(image,boundingBox,imageTopLeft,true,minCodewordWidth,maxCodewordWidth);
                }
                if(imageTopRight!=null){
                    rightRowIndicatorColumn=PDF417ScanningDecoder.getRowIndicatorColumn(image,boundingBox,imageTopRight,false,minCodewordWidth,maxCodewordWidth);
                }
                detectionResult=PDF417ScanningDecoder.merge(leftRowIndicatorColumn,rightRowIndicatorColumn);
                if(detectionResult==null){
                    throwNotFoundException.getNotFoundInstance();
                }
                letresultBox=detectionResult.getBoundingBox();
                if(firstPass&&resultBox!=null&&
                    (resultBox.getMinY()<boundingBox.getMinY()||resultBox.getMaxY()>boundingBox.getMaxY())){
                    boundingBox=resultBox;
                }
                else{
                    break;
                }
            }
            detectionResult.setBoundingBox(boundingBox);
            letmaxBarcodeColumn=detectionResult.getBarcodeColumnCount()+1;
            detectionResult.setDetectionResultColumn(0,leftRowIndicatorColumn);
            detectionResult.setDetectionResultColumn(maxBarcodeColumn,rightRowIndicatorColumn);
            letleftToRight=leftRowIndicatorColumn!=null;
            for(letbarcodeColumnCount/*int*/=1;barcodeColumnCount<=maxBarcodeColumn;barcodeColumnCount++){
                letbarcodeColumn=leftToRight?barcodeColumnCount:maxBarcodeColumn-barcodeColumnCount;
                if(detectionResult.getDetectionResultColumn(barcodeColumn)!==/*null*/undefined){
                    //Thiswillbethecasefortheoppositerowindicatorcolumn,whichdoesn'tneedtobedecodedagain.
                    continue;
                }
                letdetectionResultColumn;
                if(barcodeColumn===0||barcodeColumn===maxBarcodeColumn){
                    detectionResultColumn=newDetectionResultRowIndicatorColumn(boundingBox,barcodeColumn===0);
                }
                else{
                    detectionResultColumn=newDetectionResultColumn(boundingBox);
                }
                detectionResult.setDetectionResultColumn(barcodeColumn,detectionResultColumn);
                letstartColumn=-1;
                letpreviousStartColumn=startColumn;
                //TODOstartatarowforwhichweknowthestartposition,thendetectupwardsanddownwardsfromthere.
                for(letimageRow/*int*/=boundingBox.getMinY();imageRow<=boundingBox.getMaxY();imageRow++){
                    startColumn=PDF417ScanningDecoder.getStartColumn(detectionResult,barcodeColumn,imageRow,leftToRight);
                    if(startColumn<0||startColumn>boundingBox.getMaxX()){
                        if(previousStartColumn===-1){
                            continue;
                        }
                        startColumn=previousStartColumn;
                    }
                    letcodeword=PDF417ScanningDecoder.detectCodeword(image,boundingBox.getMinX(),boundingBox.getMaxX(),leftToRight,startColumn,imageRow,minCodewordWidth,maxCodewordWidth);
                    if(codeword!=null){
                        detectionResultColumn.setCodeword(imageRow,codeword);
                        previousStartColumn=startColumn;
                        minCodewordWidth=Math.min(minCodewordWidth,codeword.getWidth());
                        maxCodewordWidth=Math.max(maxCodewordWidth,codeword.getWidth());
                    }
                }
            }
            returnPDF417ScanningDecoder.createDecoderResult(detectionResult);
        }
        /**
         *
         *@paramleftRowIndicatorColumn
         *@paramrightRowIndicatorColumn
         *
         *@throwsNotFoundException
         */
        staticmerge(leftRowIndicatorColumn,rightRowIndicatorColumn){
            if(leftRowIndicatorColumn==null&&rightRowIndicatorColumn==null){
                returnnull;
            }
            letbarcodeMetadata=PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn,rightRowIndicatorColumn);
            if(barcodeMetadata==null){
                returnnull;
            }
            letboundingBox=BoundingBox.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn),PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));
            returnnewDetectionResult(barcodeMetadata,boundingBox);
        }
        /**
         *
         *@paramrowIndicatorColumn
         *
         *@throwsNotFoundException
         */
        staticadjustBoundingBox(rowIndicatorColumn){
            if(rowIndicatorColumn==null){
                returnnull;
            }
            letrowHeights=rowIndicatorColumn.getRowHeights();
            if(rowHeights==null){
                returnnull;
            }
            letmaxRowHeight=PDF417ScanningDecoder.getMax(rowHeights);
            letmissingStartRows=0;
            for(letrowHeight/*int*/ofrowHeights){
                missingStartRows+=maxRowHeight-rowHeight;
                if(rowHeight>0){
                    break;
                }
            }
            letcodewords=rowIndicatorColumn.getCodewords();
            for(letrow/*int*/=0;missingStartRows>0&&codewords[row]==null;row++){
                missingStartRows--;
            }
            letmissingEndRows=0;
            for(letrow/*int*/=rowHeights.length-1;row>=0;row--){
                missingEndRows+=maxRowHeight-rowHeights[row];
                if(rowHeights[row]>0){
                    break;
                }
            }
            for(letrow/*int*/=codewords.length-1;missingEndRows>0&&codewords[row]==null;row--){
                missingEndRows--;
            }
            returnrowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows,missingEndRows,rowIndicatorColumn.isLeft());
        }
        staticgetMax(values){
            letmaxValue=-1;
            for(letvalue/*int*/ofvalues){
                maxValue=Math.max(maxValue,value);
            }
            returnmaxValue;
        }
        staticgetBarcodeMetadata(leftRowIndicatorColumn,rightRowIndicatorColumn){
            letleftBarcodeMetadata;
            if(leftRowIndicatorColumn==null||
                (leftBarcodeMetadata=leftRowIndicatorColumn.getBarcodeMetadata())==null){
                returnrightRowIndicatorColumn==null?null:rightRowIndicatorColumn.getBarcodeMetadata();
            }
            letrightBarcodeMetadata;
            if(rightRowIndicatorColumn==null||
                (rightBarcodeMetadata=rightRowIndicatorColumn.getBarcodeMetadata())==null){
                returnleftBarcodeMetadata;
            }
            if(leftBarcodeMetadata.getColumnCount()!==rightBarcodeMetadata.getColumnCount()&&
                leftBarcodeMetadata.getErrorCorrectionLevel()!==rightBarcodeMetadata.getErrorCorrectionLevel()&&
                leftBarcodeMetadata.getRowCount()!==rightBarcodeMetadata.getRowCount()){
                returnnull;
            }
            returnleftBarcodeMetadata;
        }
        staticgetRowIndicatorColumn(image,boundingBox,startPoint,leftToRight,minCodewordWidth,maxCodewordWidth){
            letrowIndicatorColumn=newDetectionResultRowIndicatorColumn(boundingBox,leftToRight);
            for(leti/*int*/=0;i<2;i++){
                letincrement=i===0?1:-1;
                letstartColumn=Math.trunc(Math.trunc(startPoint.getX()));
                for(letimageRow/*int*/=Math.trunc(Math.trunc(startPoint.getY()));imageRow<=boundingBox.getMaxY()&&
                    imageRow>=boundingBox.getMinY();imageRow+=increment){
                    letcodeword=PDF417ScanningDecoder.detectCodeword(image,0,image.getWidth(),leftToRight,startColumn,imageRow,minCodewordWidth,maxCodewordWidth);
                    if(codeword!=null){
                        rowIndicatorColumn.setCodeword(imageRow,codeword);
                        if(leftToRight){
                            startColumn=codeword.getStartX();
                        }
                        else{
                            startColumn=codeword.getEndX();
                        }
                    }
                }
            }
            returnrowIndicatorColumn;
        }
        /**
         *
         *@paramdetectionResult
         *@paramBarcodeValue
         *@paramparam2
         *@paramparam3
         *@parambarcodeMatrix
         *
         *@throwsNotFoundException
         */
        staticadjustCodewordCount(detectionResult,barcodeMatrix){
            letbarcodeMatrix01=barcodeMatrix[0][1];
            letnumberOfCodewords=barcodeMatrix01.getValue();
            letcalculatedNumberOfCodewords=detectionResult.getBarcodeColumnCount()*
                detectionResult.getBarcodeRowCount()-
                PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());
            if(numberOfCodewords.length===0){
                if(calculatedNumberOfCodewords<1||calculatedNumberOfCodewords>PDF417Common.MAX_CODEWORDS_IN_BARCODE){
                    throwNotFoundException.getNotFoundInstance();
                }
                barcodeMatrix01.setValue(calculatedNumberOfCodewords);
            }
            elseif(numberOfCodewords[0]!==calculatedNumberOfCodewords){
                //Thecalculatedoneismorereliableasitisderivedfromtherowindicatorcolumns
                barcodeMatrix01.setValue(calculatedNumberOfCodewords);
            }
        }
        /**
         *
         *@paramdetectionResult
         *
         *@throwsFormatException
         *@throwsChecksumException
         *@throwsNotFoundException
         */
        staticcreateDecoderResult(detectionResult){
            letbarcodeMatrix=PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);
            PDF417ScanningDecoder.adjustCodewordCount(detectionResult,barcodeMatrix);
            leterasures/*Collection<Integer>*/=newArray();
            letcodewords=newInt32Array(detectionResult.getBarcodeRowCount()*detectionResult.getBarcodeColumnCount());
            letambiguousIndexValuesList=/*List<int[]>*/[];
            letambiguousIndexesList=/*Collection<Integer>*/newArray();
            for(letrow/*int*/=0;row<detectionResult.getBarcodeRowCount();row++){
                for(letcolumn/*int*/=0;column<detectionResult.getBarcodeColumnCount();column++){
                    letvalues=barcodeMatrix[row][column+1].getValue();
                    letcodewordIndex=row*detectionResult.getBarcodeColumnCount()+column;
                    if(values.length===0){
                        erasures.push(codewordIndex);
                    }
                    elseif(values.length===1){
                        codewords[codewordIndex]=values[0];
                    }
                    else{
                        ambiguousIndexesList.push(codewordIndex);
                        ambiguousIndexValuesList.push(values);
                    }
                }
            }
            letambiguousIndexValues=newArray(ambiguousIndexValuesList.length);
            for(leti/*int*/=0;i<ambiguousIndexValues.length;i++){
                ambiguousIndexValues[i]=ambiguousIndexValuesList[i];
            }
            returnPDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(),codewords,PDF417Common.toIntArray(erasures),PDF417Common.toIntArray(ambiguousIndexesList),ambiguousIndexValues);
        }
        /**
         *Thismethoddealswiththefact,thatthedecodingprocessdoesn'talwaysyieldasinglemostlikelyvalue.The
         *currenterrorcorrectionimplementationdoesn'tdealwitherasuresverywell,soit'sbettertoprovideavalue
         *fortheseambiguouscodewordsinsteadoftreatingitasanerasure.Theproblemisthatwedon'tknowwhichof
         *theambiguousvaluestochoose.Wetrydecodeusingthefirstvalue,andifthatfails,weuseanotherofthe
         *ambiguousvaluesandtrytodecodeagain.Thisusuallyonlyhappensonveryhardtoreadanddecodebarcodes,
         *sodecodingthenormalbarcodesisnotaffectedbythis.
         *
         *@paramerasureArraycontainstheindexesoferasures
         *@paramambiguousIndexesarraywiththeindexesthathavemorethanonemostlikelyvalue
         *@paramambiguousIndexValuestwodimensionalarraythatcontainstheambiguousvalues.Thefirstdimensionmust
         *bethesamelengthastheambiguousIndexesarray
         *
         *@throwsFormatException
         *@throwsChecksumException
         */
        staticcreateDecoderResultFromAmbiguousValues(ecLevel,codewords,erasureArray,ambiguousIndexes,ambiguousIndexValues){
            letambiguousIndexCount=newInt32Array(ambiguousIndexes.length);
            lettries=100;
            while(tries-->0){
                for(leti/*int*/=0;i<ambiguousIndexCount.length;i++){
                    codewords[ambiguousIndexes[i]]=ambiguousIndexValues[i][ambiguousIndexCount[i]];
                }
                try{
                    returnPDF417ScanningDecoder.decodeCodewords(codewords,ecLevel,erasureArray);
                }
                catch(err){
                    letignored=errinstanceofChecksumException;
                    if(!ignored){
                        throwerr;
                    }
                }
                if(ambiguousIndexCount.length===0){
                    throwChecksumException.getChecksumInstance();
                }
                for(leti/*int*/=0;i<ambiguousIndexCount.length;i++){
                    if(ambiguousIndexCount[i]<ambiguousIndexValues[i].length-1){
                        ambiguousIndexCount[i]++;
                        break;
                    }
                    else{
                        ambiguousIndexCount[i]=0;
                        if(i===ambiguousIndexCount.length-1){
                            throwChecksumException.getChecksumInstance();
                        }
                    }
                }
            }
            throwChecksumException.getChecksumInstance();
        }
        staticcreateBarcodeMatrix(detectionResult){
            //letbarcodeMatrix:BarcodeValue[][]=
            //newBarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount()+2];
            letbarcodeMatrix=Array.from({length:detectionResult.getBarcodeRowCount()},()=>newArray(detectionResult.getBarcodeColumnCount()+2));
            for(letrow/*int*/=0;row<barcodeMatrix.length;row++){
                for(letcolumn/*int*/=0;column<barcodeMatrix[row].length;column++){
                    barcodeMatrix[row][column]=newBarcodeValue();
                }
            }
            letcolumn=0;
            for(letdetectionResultColumn/*DetectionResultColumn*/ofdetectionResult.getDetectionResultColumns()){
                if(detectionResultColumn!=null){
                    for(letcodeword/*Codeword*/ofdetectionResultColumn.getCodewords()){
                        if(codeword!=null){
                            letrowNumber=codeword.getRowNumber();
                            if(rowNumber>=0){
                                if(rowNumber>=barcodeMatrix.length){
                                    //Wehavemorerowsthanthebarcodemetadataallowsfor,ignorethem.
                                    continue;
                                }
                                barcodeMatrix[rowNumber][column].setValue(codeword.getValue());
                            }
                        }
                    }
                }
                column++;
            }
            returnbarcodeMatrix;
        }
        staticisValidBarcodeColumn(detectionResult,barcodeColumn){
            returnbarcodeColumn>=0&&barcodeColumn<=detectionResult.getBarcodeColumnCount()+1;
        }
        staticgetStartColumn(detectionResult,barcodeColumn,imageRow,leftToRight){
            letoffset=leftToRight?1:-1;
            letcodeword=null;
            if(PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult,barcodeColumn-offset)){
                codeword=detectionResult.getDetectionResultColumn(barcodeColumn-offset).getCodeword(imageRow);
            }
            if(codeword!=null){
                returnleftToRight?codeword.getEndX():codeword.getStartX();
            }
            codeword=detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);
            if(codeword!=null){
                returnleftToRight?codeword.getStartX():codeword.getEndX();
            }
            if(PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult,barcodeColumn-offset)){
                codeword=detectionResult.getDetectionResultColumn(barcodeColumn-offset).getCodewordNearby(imageRow);
            }
            if(codeword!=null){
                returnleftToRight?codeword.getEndX():codeword.getStartX();
            }
            letskippedColumns=0;
            while(PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult,barcodeColumn-offset)){
                barcodeColumn-=offset;
                for(letpreviousRowCodeword/*Codeword*/ofdetectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()){
                    if(previousRowCodeword!=null){
                        return(leftToRight?previousRowCodeword.getEndX():previousRowCodeword.getStartX())+
                            offset*
                                skippedColumns*
                                (previousRowCodeword.getEndX()-previousRowCodeword.getStartX());
                    }
                }
                skippedColumns++;
            }
            returnleftToRight?detectionResult.getBoundingBox().getMinX():detectionResult.getBoundingBox().getMaxX();
        }
        staticdetectCodeword(image,minColumn,maxColumn,leftToRight,startColumn,imageRow,minCodewordWidth,maxCodewordWidth){
            startColumn=PDF417ScanningDecoder.adjustCodewordStartColumn(image,minColumn,maxColumn,leftToRight,startColumn,imageRow);
            //weusuallyknowfairlyexactnowhowlongacodewordis.Weshouldprovideminimumandmaximumexpectedlength
            //andtrytoadjustthereadpixels,e.g.removesinglepixelerrorsortrytocutoffexceedingpixels.
            //minandmaxCodewordWidthshouldnotbeusedastheyarecalculatedforthewholebarcodeancanbeinaccurate
            //forthecurrentposition
            letmoduleBitCount=PDF417ScanningDecoder.getModuleBitCount(image,minColumn,maxColumn,leftToRight,startColumn,imageRow);
            if(moduleBitCount==null){
                returnnull;
            }
            letendColumn;
            letcodewordBitCount=MathUtils.sum(moduleBitCount);
            if(leftToRight){
                endColumn=startColumn+codewordBitCount;
            }
            else{
                for(leti/*int*/=0;i<moduleBitCount.length/2;i++){
                    lettmpCount=moduleBitCount[i];
                    moduleBitCount[i]=moduleBitCount[moduleBitCount.length-1-i];
                    moduleBitCount[moduleBitCount.length-1-i]=tmpCount;
                }
                endColumn=startColumn;
                startColumn=endColumn-codewordBitCount;
            }
            //TODOimplementcheckforwidthandcorrectionofblackandwhitebars
            //usestart(andmaybestoppattern)todetermineifblackbarsarewiderthanwhitebars.Ifso,adjust.
            //shouldprobablydoneonlyforcodewordswithalotmorethan17bits.
            //Thefollowingfixes10-1.png,whichhaswideblackbarsandsmallwhitebars
            //   for(leti/*int*/=0;i<moduleBitCount.length;i++){
            //     if(i%2===0){
            //       moduleBitCount[i]--;
            //     }else{
            //       moduleBitCount[i]++;
            //     }
            //   }
            //Wecouldalsousethewidthofsurroundingcodewordsformoreaccurateresults,butthisseems
            //sufficientfornow
            if(!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount,minCodewordWidth,maxCodewordWidth)){
                //WecouldtrytousethestartXandendXpositionofthecodewordinthesamecolumninthepreviousrow,
                //createthebitcountfromitandnormalizeitto8.Thiswouldhelpwithsinglepixelerrors.
                returnnull;
            }
            letdecodedValue=PDF417CodewordDecoder.getDecodedValue(moduleBitCount);
            letcodeword=PDF417Common.getCodeword(decodedValue);
            if(codeword===-1){
                returnnull;
            }
            returnnewCodeword(startColumn,endColumn,PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue),codeword);
        }
        staticgetModuleBitCount(image,minColumn,maxColumn,leftToRight,startColumn,imageRow){
            letimageColumn=startColumn;
            letmoduleBitCount=newInt32Array(8);
            letmoduleNumber=0;
            letincrement=leftToRight?1:-1;
            letpreviousPixelValue=leftToRight;
            while((leftToRight?imageColumn<maxColumn:imageColumn>=minColumn)&&
                moduleNumber<moduleBitCount.length){
                if(image.get(imageColumn,imageRow)===previousPixelValue){
                    moduleBitCount[moduleNumber]++;
                    imageColumn+=increment;
                }
                else{
                    moduleNumber++;
                    previousPixelValue=!previousPixelValue;
                }
            }
            if(moduleNumber===moduleBitCount.length||
                ((imageColumn===(leftToRight?maxColumn:minColumn))&&
                    moduleNumber===moduleBitCount.length-1)){
                returnmoduleBitCount;
            }
            returnnull;
        }
        staticgetNumberOfECCodeWords(barcodeECLevel){
            return2<<barcodeECLevel;
        }
        staticadjustCodewordStartColumn(image,minColumn,maxColumn,leftToRight,codewordStartColumn,imageRow){
            letcorrectedStartColumn=codewordStartColumn;
            letincrement=leftToRight?-1:1;
            //thereshouldbenoblackpixelsbeforethestartcolumn.Ifthereare,thenweneedtostartearlier.
            for(leti/*int*/=0;i<2;i++){
                while((leftToRight?correctedStartColumn>=minColumn:correctedStartColumn<maxColumn)&&
                    leftToRight===image.get(correctedStartColumn,imageRow)){
                    if(Math.abs(codewordStartColumn-correctedStartColumn)>PDF417ScanningDecoder.CODEWORD_SKEW_SIZE){
                        returncodewordStartColumn;
                    }
                    correctedStartColumn+=increment;
                }
                increment=-increment;
                leftToRight=!leftToRight;
            }
            returncorrectedStartColumn;
        }
        staticcheckCodewordSkew(codewordSize,minCodewordWidth,maxCodewordWidth){
            returnminCodewordWidth-PDF417ScanningDecoder.CODEWORD_SKEW_SIZE<=codewordSize&&
                codewordSize<=maxCodewordWidth+PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;
        }
        /**
         *@throwsFormatException,
         *@throwsChecksumException
         */
        staticdecodeCodewords(codewords,ecLevel,erasures){
            if(codewords.length===0){
                throwFormatException.getFormatInstance();
            }
            letnumECCodewords=1<<(ecLevel+1);
            letcorrectedErrorsCount=PDF417ScanningDecoder.correctErrors(codewords,erasures,numECCodewords);
            PDF417ScanningDecoder.verifyCodewordCount(codewords,numECCodewords);
            //Decodethecodewords
            letdecoderResult=DecodedBitStreamParser$2.decode(codewords,''+ecLevel);
            decoderResult.setErrorsCorrected(correctedErrorsCount);
            decoderResult.setErasures(erasures.length);
            returndecoderResult;
        }
        /**
         *<p>Givendataanderror-correctioncodewordsreceived,possiblycorruptedbyerrors,attemptsto
         *correcttheerrorsin-place.</p>
         *
         *@paramcodewords  dataanderrorcorrectioncodewords
         *@paramerasurespositionsofanyknownerasures
         *@paramnumECCodewordsnumberoferrorcorrectioncodewordsthatareavailableincodewords
         *@throwsChecksumExceptioniferrorcorrectionfails
         */
        staticcorrectErrors(codewords,erasures,numECCodewords){
            if(erasures!=null&&
                erasures.length>numECCodewords/2+PDF417ScanningDecoder.MAX_ERRORS||
                numECCodewords<0||
                numECCodewords>PDF417ScanningDecoder.MAX_EC_CODEWORDS){
                //ToomanyerrorsorECCodewordsiscorrupted
                throwChecksumException.getChecksumInstance();
            }
            returnPDF417ScanningDecoder.errorCorrection.decode(codewords,numECCodewords,erasures);
        }
        /**
         *VerifythatallisOKwiththecodewordarray.
         *@throwsFormatException
         */
        staticverifyCodewordCount(codewords,numECCodewords){
            if(codewords.length<4){
                //Codewordarraysizeshouldbeatleast4allowingfor
                //CountCW,AtleastoneDataCW,ErrorCorrectionCW,ErrorCorrectionCW
                throwFormatException.getFormatInstance();
            }
            //Thefirstcodeword,theSymbolLengthDescriptor,shallalwaysencodethetotalnumberofdata
            //codewordsinthesymbol,includingtheSymbolLengthDescriptoritself,datacodewordsandpad
            //codewords,butexcludingthenumberoferrorcorrectioncodewords.
            letnumberOfCodewords=codewords[0];
            if(numberOfCodewords>codewords.length){
                throwFormatException.getFormatInstance();
            }
            if(numberOfCodewords===0){
                //Resettothelengthofthearray-8(Allowforatleastlevel3ErrorCorrection(8ErrorCodewords)
                if(numECCodewords<codewords.length){
                    codewords[0]=codewords.length-numECCodewords;
                }
                else{
                    throwFormatException.getFormatInstance();
                }
            }
        }
        staticgetBitCountForCodeword(codeword){
            letresult=newInt32Array(8);
            letpreviousValue=0;
            leti=result.length-1;
            while(true){
                if((codeword&0x1)!==previousValue){
                    previousValue=codeword&0x1;
                    i--;
                    if(i<0){
                        break;
                    }
                }
                result[i]++;
                codeword>>=1;
            }
            returnresult;
        }
        staticgetCodewordBucketNumber(codeword){
            if(codewordinstanceofInt32Array){
                returnthis.getCodewordBucketNumber_Int32Array(codeword);
            }
            returnthis.getCodewordBucketNumber_number(codeword);
        }
        staticgetCodewordBucketNumber_number(codeword){
            returnPDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));
        }
        staticgetCodewordBucketNumber_Int32Array(moduleBitCount){
            return(moduleBitCount[0]-moduleBitCount[2]+moduleBitCount[4]-moduleBitCount[6]+9)%9;
        }
        statictoString(barcodeMatrix){
            letformatter=newFormatter();
            //try(letformatter=newFormatter()){
            for(letrow/*int*/=0;row<barcodeMatrix.length;row++){
                formatter.format('Row%2d:',row);
                for(letcolumn/*int*/=0;column<barcodeMatrix[row].length;column++){
                    letbarcodeValue=barcodeMatrix[row][column];
                    if(barcodeValue.getValue().length===0){
                        formatter.format('       ',null);
                    }
                    else{
                        formatter.format('%4d(%2d)',barcodeValue.getValue()[0],barcodeValue.getConfidence(barcodeValue.getValue()[0]));
                    }
                }
                formatter.format('%n');
            }
            returnformatter.toString();
            //}
        }
    }
    /*final*/PDF417ScanningDecoder.CODEWORD_SKEW_SIZE=2;
    /*final*/PDF417ScanningDecoder.MAX_ERRORS=3;
    /*final*/PDF417ScanningDecoder.MAX_EC_CODEWORDS=512;
    /*final*/PDF417ScanningDecoder.errorCorrection=newErrorCorrection();

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    //importjava.util.ArrayList;
    //importjava.util.List;
    //importjava.util.Map;
    /**
     *ThisimplementationcandetectanddecodePDF417codesinanimage.
     *
     *@authorGuentherGrau
     */
    /*publicfinal*/classPDF417Reader{
        //privatestatic/*finalResult[]*/EMPTY_RESULT_ARRAY:Result[]=newResult([0]);
        /**
         *LocatesanddecodesaPDF417codeinanimage.
         *
         *@returnaStringrepresentingthecontentencodedbythePDF417code
         *@throwsNotFoundExceptionifaPDF417codecannotbefound,
         *@throwsFormatExceptionifaPDF417cannotbedecoded
         *@throwsChecksumException
         */
        //@Override
        decode(image,hints=null){
            letresult=PDF417Reader.decode(image,hints,false);
            if(result==null||result.length===0||result[0]==null){
                throwNotFoundException.getNotFoundInstance();
            }
            returnresult[0];
        }
        /**
         *
         *@paramBinaryBitmap
         *@paramimage
         *@throwsNotFoundException
         */
        //  @Override
        decodeMultiple(image,hints=null){
            try{
                returnPDF417Reader.decode(image,hints,true);
            }
            catch(ignored){
                if(ignoredinstanceofFormatException||ignoredinstanceofChecksumException){
                    throwNotFoundException.getNotFoundInstance();
                }
                throwignored;
            }
        }
        /**
         *
         *@paramimage
         *@paramhints
         *@parammultiple
         *
         *@throwsNotFoundException
         *@throwsFormatExceptionß
         *@throwsChecksumException
         */
        staticdecode(image,hints,multiple){
            constresults=newArray();
            constdetectorResult=Detector$3.detectMultiple(image,hints,multiple);
            for(constpointsofdetectorResult.getPoints()){
                constdecoderResult=PDF417ScanningDecoder.decode(detectorResult.getBits(),points[4],points[5],points[6],points[7],PDF417Reader.getMinCodewordWidth(points),PDF417Reader.getMaxCodewordWidth(points));
                constresult=newResult(decoderResult.getText(),decoderResult.getRawBytes(),undefined,points,BarcodeFormat$1.PDF_417);
                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL,decoderResult.getECLevel());
                constpdf417ResultMetadata=decoderResult.getOther();
                if(pdf417ResultMetadata!=null){
                    result.putMetadata(ResultMetadataType$1.PDF417_EXTRA_METADATA,pdf417ResultMetadata);
                }
                results.push(result);
            }
            returnresults.map(x=>x);
        }
        staticgetMaxWidth(p1,p2){
            if(p1==null||p2==null){
                return0;
            }
            returnMath.trunc(Math.abs(p1.getX()-p2.getX()));
        }
        staticgetMinWidth(p1,p2){
            if(p1==null||p2==null){
                returnInteger.MAX_VALUE;
            }
            returnMath.trunc(Math.abs(p1.getX()-p2.getX()));
        }
        staticgetMaxCodewordWidth(p){
            returnMath.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p[0],p[4]),PDF417Reader.getMaxWidth(p[6],p[2])*PDF417Common.MODULES_IN_CODEWORD/
                PDF417Common.MODULES_IN_STOP_PATTERN),Math.max(PDF417Reader.getMaxWidth(p[1],p[5]),PDF417Reader.getMaxWidth(p[7],p[3])*PDF417Common.MODULES_IN_CODEWORD/
                PDF417Common.MODULES_IN_STOP_PATTERN)));
        }
        staticgetMinCodewordWidth(p){
            returnMath.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p[0],p[4]),PDF417Reader.getMinWidth(p[6],p[2])*PDF417Common.MODULES_IN_CODEWORD/
                PDF417Common.MODULES_IN_STOP_PATTERN),Math.min(PDF417Reader.getMinWidth(p[1],p[5]),PDF417Reader.getMinWidth(p[7],p[3])*PDF417Common.MODULES_IN_CODEWORD/
                PDF417Common.MODULES_IN_STOP_PATTERN)));
        }
        //@Override
        reset(){
            //nothingneedstobereset
        }
    }

    /**
     *CustomErrorclassoftypeException.
     */
    classReaderExceptionextendsException{
    }
    ReaderException.kind='ReaderException';

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*namespacecom.google.zxing{*/
    /**
     *MultiFormatReaderisaconvenienceclassandthemainentrypointintothelibraryformostuses.
     *Bydefaultitattemptstodecodeallbarcodeformatsthatthelibrarysupports.Optionally,you
     *canprovideahintsobjecttorequestdifferentbehavior,forexampleonlydecodingQRcodes.
     *
     *@authorSeanOwen
     *@authordswitkin@google.com(DanielSwitkin)
     */
    classMultiFormatReader{
        /**
         *ThisversionofdecodehonorstheintentofReader.decode(BinaryBitmap)inthatit
         *passesnullasahinttothedecoders.However,thatmakesitinefficienttocallrepeatedly.
         *UsesetHints()followedbydecodeWithState()forcontinuousscanapplications.
         *
         *@paramimageThepixeldatatodecode
         *@returnThecontentsoftheimage
         *
         *@throwsNotFoundExceptionAnyerrorswhichoccurred
         */
        /*@Override*/
        //publicdecode(image:BinaryBitmap):Result{
        //  setHints(null)
        //  returndecodeInternal(image)
        //}
        /**
         *Decodeanimageusingthehintsprovided.Doesnothonorexistingstate.
         *
         *@paramimageThepixeldatatodecode
         *@paramhintsThehintstouse,clearingthepreviousstate.
         *@returnThecontentsoftheimage
         *
         *@throwsNotFoundExceptionAnyerrorswhichoccurred
         */
        /*@Override*/
        decode(image,hints){
            this.setHints(hints);
            returnthis.decodeInternal(image);
        }
        /**
         *DecodeanimageusingthestatesetupbycallingsetHints()previously.Continuousscan
         *clientswillgeta<b>large</b>speedincreasebyusingthisinsteadofdecode().
         *
         *@paramimageThepixeldatatodecode
         *@returnThecontentsoftheimage
         *
         *@throwsNotFoundExceptionAnyerrorswhichoccurred
         */
        decodeWithState(image){
            //Makesuretosetupthedefaultstatesowedon'tcrash
            if(this.readers===null||this.readers===undefined){
                this.setHints(null);
            }
            returnthis.decodeInternal(image);
        }
        /**
         *ThismethodaddsstatetotheMultiFormatReader.Bysettingthehintsonce,subsequentcalls
         *todecodeWithState(image)canreusethesamesetofreaderswithoutreallocatingmemory.This
         *isimportantforperformanceincontinuousscanclients.
         *
         *@paramhintsThesetofhintstouseforsubsequentcallstodecode(image)
         */
        setHints(hints){
            this.hints=hints;
            consttryHarder=hints!==null&&hints!==undefined&&undefined!==hints.get(DecodeHintType$1.TRY_HARDER);
            /*@SuppressWarnings("unchecked")*/
            constformats=hints===null||hints===undefined?null:hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
            constreaders=newArray();
            if(formats!==null&&formats!==undefined){
                constaddOneDReader=formats.some(f=>f===BarcodeFormat$1.UPC_A||
                    f===BarcodeFormat$1.UPC_E||
                    f===BarcodeFormat$1.EAN_13||
                    f===BarcodeFormat$1.EAN_8||
                    f===BarcodeFormat$1.CODABAR||
                    f===BarcodeFormat$1.CODE_39||
                    f===BarcodeFormat$1.CODE_93||
                    f===BarcodeFormat$1.CODE_128||
                    f===BarcodeFormat$1.ITF||
                    f===BarcodeFormat$1.RSS_14||
                    f===BarcodeFormat$1.RSS_EXPANDED);
                //Put1Dreadersupfrontin"normal"mode
                //TYPESCRIPTPORT:TODO:uncommentbelowastheyareported
                if(addOneDReader&&!tryHarder){
                    readers.push(newMultiFormatOneDReader(hints));
                }
                if(formats.includes(BarcodeFormat$1.QR_CODE)){
                    readers.push(newQRCodeReader());
                }
                if(formats.includes(BarcodeFormat$1.DATA_MATRIX)){
                    readers.push(newDataMatrixReader());
                }
                if(formats.includes(BarcodeFormat$1.AZTEC)){
                    readers.push(newAztecReader());
                }
                if(formats.includes(BarcodeFormat$1.PDF_417)){
                    readers.push(newPDF417Reader());
                }
                //if(formats.includes(BarcodeFormat.MAXICODE)){
                //   readers.push(newMaxiCodeReader())
                //}
                //Atendin"tryharder"mode
                if(addOneDReader&&tryHarder){
                    readers.push(newMultiFormatOneDReader(hints));
                }
            }
            if(readers.length===0){
                if(!tryHarder){
                    readers.push(newMultiFormatOneDReader(hints));
                }
                readers.push(newQRCodeReader());
                readers.push(newDataMatrixReader());
                readers.push(newAztecReader());
                readers.push(newPDF417Reader());
                //readers.push(newMaxiCodeReader())
                if(tryHarder){
                    readers.push(newMultiFormatOneDReader(hints));
                }
            }
            this.readers=readers;//.toArray(newReader[readers.size()])
        }
        /*@Override*/
        reset(){
            if(this.readers!==null){
                for(constreaderofthis.readers){
                    reader.reset();
                }
            }
        }
        /**
         *@throwsNotFoundException
         */
        decodeInternal(image){
            if(this.readers===null){
                thrownewReaderException('Noreaderswhereselected,nothingcanberead.');
            }
            for(constreaderofthis.readers){
                //Tryingtodecodewith${reader}reader.
                try{
                    returnreader.decode(image,this.hints);
                }
                catch(ex){
                    if(exinstanceofReaderException){
                        continue;
                    }
                    //BadException.
                }
            }
            thrownewNotFoundException('NoMultiFormatReaderswereabletodetectthecode.');
        }
    }

    classBrowserMultiFormatReaderextendsBrowserCodeReader{
        constructor(hints=null,timeBetweenScansMillis=500){
            constreader=newMultiFormatReader();
            reader.setHints(hints);
            super(reader,timeBetweenScansMillis);
        }
        /**
         *OverwritedecodeBitmaptocalldecodeWithState,whichwillpay
         *attentiontothehintssetintheconstructorfunction
         */
        decodeBitmap(binaryBitmap){
            returnthis.reader.decodeWithState(binaryBitmap);
        }
    }

    /**
     *@deprecatedMovingto@zxing/browser
     *
     *QRCodereadertousefrombrowser.
     */
    classBrowserPDF417ReaderextendsBrowserCodeReader{
        /**
         *CreatesaninstanceofBrowserPDF417Reader.
         *@param{number}[timeBetweenScansMillis=500]thetimedelaybetweensubsequentdecodetries
         */
        constructor(timeBetweenScansMillis=500){
            super(newPDF417Reader(),timeBetweenScansMillis);
        }
    }

    /**
     *@deprecatedMovingto@zxing/browser
     *
     *QRCodereadertousefrombrowser.
     */
    classBrowserQRCodeReaderextendsBrowserCodeReader{
        /**
         *CreatesaninstanceofBrowserQRCodeReader.
         *@param{number}[timeBetweenScansMillis=500]thetimedelaybetweensubsequentdecodetries
         */
        constructor(timeBetweenScansMillis=500){
            super(newQRCodeReader(),timeBetweenScansMillis);
        }
    }

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*namespacecom.google.zxing{*/
    /**
     *TheseareasetofhintsthatyoumaypasstoWriterstospecifytheirbehavior.
     *
     *@authordswitkin@google.com(DanielSwitkin)
     */
    varEncodeHintType;
    (function(EncodeHintType){
        /**
         *Specifieswhatdegreeoferrorcorrectiontouse,forexampleinQRCodes.
         *Typedependsontheencoder.ForexampleforQRcodesit'stype
         *{@linkcom.google.zxing.qrcode.decoder.ErrorCorrectionLevelErrorCorrectionLevel}.
         *ForAztecitisoftype{@linkInteger},representingtheminimalpercentageoferrorcorrectionwords.
         *ForPDF417itisoftype{@linkInteger},validvaluesbeing0to8.
         *Inallcases,itcanalsobea{@linkString}representationofthedesiredvalueaswell.
         *Note:anAztecsymbolshouldhaveaminimumof25%ECwords.
         */
        EncodeHintType[EncodeHintType["ERROR_CORRECTION"]=0]="ERROR_CORRECTION";
        /**
         *Specifieswhatcharacterencodingtousewhereapplicable(type{@linkString})
         */
        EncodeHintType[EncodeHintType["CHARACTER_SET"]=1]="CHARACTER_SET";
        /**
         *SpecifiesthematrixshapeforDataMatrix(type{@linkcom.google.zxing.datamatrix.encoder.SymbolShapeHint})
         */
        EncodeHintType[EncodeHintType["DATA_MATRIX_SHAPE"]=2]="DATA_MATRIX_SHAPE";
        /**
         *Specifiesaminimumbarcodesize(type{@linkDimension}).OnlyapplicabletoDataMatrixnow.
         *
         *@deprecatedusewidth/heightparamsin
         *{@linkcom.google.zxing.datamatrix.DataMatrixWriter#encode(String,BarcodeFormat,int,int)}
         */
        /*@Deprecated*/
        EncodeHintType[EncodeHintType["MIN_SIZE"]=3]="MIN_SIZE";
        /**
         *Specifiesamaximumbarcodesize(type{@linkDimension}).OnlyapplicabletoDataMatrixnow.
         *
         *@deprecatedwithoutreplacement
         */
        /*@Deprecated*/
        EncodeHintType[EncodeHintType["MAX_SIZE"]=4]="MAX_SIZE";
        /**
         *Specifiesmargin,inpixels,tousewhengeneratingthebarcode.Themeaningcanvary
         *byformat;forexampleitcontrolsmarginbeforeandafterthebarcodehorizontallyfor
         *most1Dformats.(Type{@linkInteger},or{@linkString}representationoftheintegervalue).
         */
        EncodeHintType[EncodeHintType["MARGIN"]=5]="MARGIN";
        /**
         *SpecifieswhethertousecompactmodeforPDF417(type{@linkBoolean},or"true"or"false"
         *{@linkString}value).
         */
        EncodeHintType[EncodeHintType["PDF417_COMPACT"]=6]="PDF417_COMPACT";
        /**
         *SpecifieswhatcompactionmodetouseforPDF417(type
         *{@linkcom.google.zxing.pdf417.encoder.CompactionCompaction}or{@linkString}valueofoneofits
         *enumvalues).
         */
        EncodeHintType[EncodeHintType["PDF417_COMPACTION"]=7]="PDF417_COMPACTION";
        /**
         *SpecifiestheminimumandmaximumnumberofrowsandcolumnsforPDF417(type
         *{@linkcom.google.zxing.pdf417.encoder.DimensionsDimensions}).
         */
        EncodeHintType[EncodeHintType["PDF417_DIMENSIONS"]=8]="PDF417_DIMENSIONS";
        /**
         *SpecifiestherequirednumberoflayersforanAzteccode.
         *Anegativenumber(-1,-2,-3,-4)specifiesacompactAzteccode.
         *0indicatestousetheminimumnumberoflayers(thedefault).
         *Apositivenumber(1,2,..32)specifiesanormal(non-compact)Azteccode.
         *(Type{@linkInteger},or{@linkString}representationoftheintegervalue).
         */
        EncodeHintType[EncodeHintType["AZTEC_LAYERS"]=9]="AZTEC_LAYERS";
        /**
         *SpecifiestheexactversionofQRcodetobeencoded.
         *(Type{@linkInteger},or{@linkString}representationoftheintegervalue).
         */
        EncodeHintType[EncodeHintType["QR_VERSION"]=10]="QR_VERSION";
    })(EncodeHintType||(EncodeHintType={}));
    varEncodeHintType$1=EncodeHintType;

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *<p>ImplementsReed-Solomonencoding,asthenameimplies.</p>
     *
     *@authorSeanOwen
     *@authorWilliamRucklidge
     */
    classReedSolomonEncoder{
        /**
         *Areedsolomonerror-correctingencodingconstructoriscreatedby
         *passingasGaloisFieldwithofsizeequaltothenumberofcode
         *words(symbols)inthealphabet(thenumberofvaluesineach
         *elementofarraysthatareencoded/decoded).
         *@paramfieldAgaloisfieldwithanumberofelementsequaltothesize
         *ofthealphabetofsymbolstoencode.
         */
        constructor(field){
            this.field=field;
            this.cachedGenerators=[];
            this.cachedGenerators.push(newGenericGFPoly(field,Int32Array.from([1])));
        }
        buildGenerator(degree/*int*/){
            constcachedGenerators=this.cachedGenerators;
            if(degree>=cachedGenerators.length){
                letlastGenerator=cachedGenerators[cachedGenerators.length-1];
                constfield=this.field;
                for(letd=cachedGenerators.length;d<=degree;d++){
                    constnextGenerator=lastGenerator.multiply(newGenericGFPoly(field,Int32Array.from([1,field.exp(d-1+field.getGeneratorBase())])));
                    cachedGenerators.push(nextGenerator);
                    lastGenerator=nextGenerator;
                }
            }
            returncachedGenerators[degree];
        }
        /**
         *<p>Encodeasequenceofcodewords(symbols)usingReed-Solomontoallowdecoders
         *todetectandcorrecterrorsthatmayhavebeenintroducedwhentheresulting
         *dataisstoredortransmitted.</p>
         *
         *@paramtoEncodearrayusedforbothandoutput.Callerinitializesthearraywith
         *thecodewords(symbols)tobeencodedfollowedbyemptyelementsallocatedtomake
         *spaceforerror-correctioncodewordsintheencodedoutput.Thearraycontains
         *theencdodedoutputwhenencodereturns.Codewordsareencodedasnumbersfrom
         *0ton-1,wherenisthenumberofpossiblecodewords(symbols),asdetermined
         *bythesizeoftheGaloisFieldpassedintheconstructorofthisobject.
         *@paramecBytesthenumberofelementsreservedinthearray(firstparameter)
         *tostoreerror-correctioncodewords.Thus,thenumberofcodewords(symbols)
         *toencodeinthefirstparameteristhustoEncode.length-ecBytes.
         *Note,theuseof"bytes"inthenameofthisparameterismisleading,astheremay
         *bemoreorfewerthan256symbolsbeingencoded,asdeterminedbythenumberof
         *elementsintheGaloisFieldpassedasaconstructortothisobject.
         *@throwsIllegalArgumentExceptionthrowninresponsetovalidationerrros.
         */
        encode(toEncode,ecBytes/*int*/){
            if(ecBytes===0){
                thrownewIllegalArgumentException('Noerrorcorrectionbytes');
            }
            constdataBytes=toEncode.length-ecBytes;
            if(dataBytes<=0){
                thrownewIllegalArgumentException('Nodatabytesprovided');
            }
            constgenerator=this.buildGenerator(ecBytes);
            constinfoCoefficients=newInt32Array(dataBytes);
            System.arraycopy(toEncode,0,infoCoefficients,0,dataBytes);
            letinfo=newGenericGFPoly(this.field,infoCoefficients);
            info=info.multiplyByMonomial(ecBytes,1);
            constremainder=info.divide(generator)[1];
            constcoefficients=remainder.getCoefficients();
            constnumZeroCoefficients=ecBytes-coefficients.length;
            for(leti=0;i<numZeroCoefficients;i++){
                toEncode[dataBytes+i]=0;
            }
            System.arraycopy(coefficients,0,toEncode,dataBytes+numZeroCoefficients,coefficients.length);
        }
    }

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *@authorSatoruTakabayashi
     *@authorDanielSwitkin
     *@authorSeanOwen
     */
    classMaskUtil{
        constructor(){
            //donothing
        }
        /**
         *Applymaskpenaltyrule1andreturnthepenalty.Findrepetitivecellswiththesamecolorand
         *givepenaltytothem.Example:00000or11111.
         */
        staticapplyMaskPenaltyRule1(matrix){
            returnMaskUtil.applyMaskPenaltyRule1Internal(matrix,true)+MaskUtil.applyMaskPenaltyRule1Internal(matrix,false);
        }
        /**
         *Applymaskpenaltyrule2andreturnthepenalty.Find2x2blockswiththesamecolorandgive
         *penaltytothem.Thisisactuallyequivalenttothespec'srule,whichistofindMxNblocksandgivea
         *penaltyproportionalto(M-1)x(N-1),becausethisisthenumberof2x2blocksinsidesuchablock.
         */
        staticapplyMaskPenaltyRule2(matrix){
            letpenalty=0;
            constarray=matrix.getArray();
            constwidth=matrix.getWidth();
            constheight=matrix.getHeight();
            for(lety=0;y<height-1;y++){
                constarrayY=array[y];
                for(letx=0;x<width-1;x++){
                    constvalue=arrayY[x];
                    if(value===arrayY[x+1]&&value===array[y+1][x]&&value===array[y+1][x+1]){
                        penalty++;
                    }
                }
            }
            returnMaskUtil.N2*penalty;
        }
        /**
         *Applymaskpenaltyrule3andreturnthepenalty.Findconsecutiverunsof1:1:3:1:1:4
         *startingwithblack,or4:1:1:3:1:1startingwithwhite,andgivepenaltytothem. Ifwe
         *findpatternslike000010111010000,wegivepenaltyonce.
         */
        staticapplyMaskPenaltyRule3(matrix){
            letnumPenalties=0;
            constarray=matrix.getArray();
            constwidth=matrix.getWidth();
            constheight=matrix.getHeight();
            for(lety=0;y<height;y++){
                for(letx=0;x<width;x++){
                    constarrayY=array[y];//Wecanatleastoptimizethisaccess
                    if(x+6<width&&
                        arrayY[x]===1&&
                        arrayY[x+1]===0&&
                        arrayY[x+2]===1&&
                        arrayY[x+3]===1&&
                        arrayY[x+4]===1&&
                        arrayY[x+5]===0&&
                        arrayY[x+6]===1&&
                        (MaskUtil.isWhiteHorizontal(arrayY,x-4,x)||MaskUtil.isWhiteHorizontal(arrayY,x+7,x+11))){
                        numPenalties++;
                    }
                    if(y+6<height&&
                        array[y][x]===1&&
                        array[y+1][x]===0&&
                        array[y+2][x]===1&&
                        array[y+3][x]===1&&
                        array[y+4][x]===1&&
                        array[y+5][x]===0&&
                        array[y+6][x]===1&&
                        (MaskUtil.isWhiteVertical(array,x,y-4,y)||MaskUtil.isWhiteVertical(array,x,y+7,y+11))){
                        numPenalties++;
                    }
                }
            }
            returnnumPenalties*MaskUtil.N3;
        }
        staticisWhiteHorizontal(rowArray,from/*int*/,to/*int*/){
            from=Math.max(from,0);
            to=Math.min(to,rowArray.length);
            for(leti=from;i<to;i++){
                if(rowArray[i]===1){
                    returnfalse;
                }
            }
            returntrue;
        }
        staticisWhiteVertical(array,col/*int*/,from/*int*/,to/*int*/){
            from=Math.max(from,0);
            to=Math.min(to,array.length);
            for(leti=from;i<to;i++){
                if(array[i][col]===1){
                    returnfalse;
                }
            }
            returntrue;
        }
        /**
         *Applymaskpenaltyrule4andreturnthepenalty.Calculatetheratioofdarkcellsandgive
         *penaltyiftheratioisfarfrom50%.Itgives10penaltyfor5%distance.
         */
        staticapplyMaskPenaltyRule4(matrix){
            letnumDarkCells=0;
            constarray=matrix.getArray();
            constwidth=matrix.getWidth();
            constheight=matrix.getHeight();
            for(lety=0;y<height;y++){
                constarrayY=array[y];
                for(letx=0;x<width;x++){
                    if(arrayY[x]===1){
                        numDarkCells++;
                    }
                }
            }
            constnumTotalCells=matrix.getHeight()*matrix.getWidth();
            constfivePercentVariances=Math.floor(Math.abs(numDarkCells*2-numTotalCells)*10/numTotalCells);
            returnfivePercentVariances*MaskUtil.N4;
        }
        /**
         *Returnthemaskbitfor"getMaskPattern"at"x"and"y".See8.8ofJISX0510:2004formask
         *patternconditions.
         */
        staticgetDataMaskBit(maskPattern/*int*/,x/*int*/,y/*int*/){
            letintermediate;/*int*/
            lettemp;/*int*/
            switch(maskPattern){
                case0:
                    intermediate=(y+x)&0x1;
                    break;
                case1:
                    intermediate=y&0x1;
                    break;
                case2:
                    intermediate=x%3;
                    break;
                case3:
                    intermediate=(y+x)%3;
                    break;
                case4:
                    intermediate=(Math.floor(y/2)+Math.floor(x/3))&0x1;
                    break;
                case5:
                    temp=y*x;
                    intermediate=(temp&0x1)+(temp%3);
                    break;
                case6:
                    temp=y*x;
                    intermediate=((temp&0x1)+(temp%3))&0x1;
                    break;
                case7:
                    temp=y*x;
                    intermediate=((temp%3)+((y+x)&0x1))&0x1;
                    break;
                default:
                    thrownewIllegalArgumentException('Invalidmaskpattern:'+maskPattern);
            }
            returnintermediate===0;
        }
        /**
         *HelperfunctionforapplyMaskPenaltyRule1.Weneedthisfordoingthiscalculationinboth
         *verticalandhorizontalordersrespectively.
         */
        staticapplyMaskPenaltyRule1Internal(matrix,isHorizontal){
            letpenalty=0;
            constiLimit=isHorizontal?matrix.getHeight():matrix.getWidth();
            constjLimit=isHorizontal?matrix.getWidth():matrix.getHeight();
            constarray=matrix.getArray();
            for(leti=0;i<iLimit;i++){
                letnumSameBitCells=0;
                letprevBit=-1;
                for(letj=0;j<jLimit;j++){
                    constbit=isHorizontal?array[i][j]:array[j][i];
                    if(bit===prevBit){
                        numSameBitCells++;
                    }
                    else{
                        if(numSameBitCells>=5){
                            penalty+=MaskUtil.N1+(numSameBitCells-5);
                        }
                        numSameBitCells=1;//Includethecellitself.
                        prevBit=bit;
                    }
                }
                if(numSameBitCells>=5){
                    penalty+=MaskUtil.N1+(numSameBitCells-5);
                }
            }
            returnpenalty;
        }
    }
    //Penaltyweightsfromsection6.8.2.1
    MaskUtil.N1=3;
    MaskUtil.N2=3;
    MaskUtil.N3=40;
    MaskUtil.N4=10;

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *JAVAPORT:Theoriginalcodewasa2Darrayofints,butsinceitonlyevergetsassigned
     *-1,0,and1,I'mgoingtouselessmemoryandgowithbytes.
     *
     *@authordswitkin@google.com(DanielSwitkin)
     */
    classByteMatrix{
        constructor(width/*int*/,height/*int*/){
            this.width=width;
            this.height=height;
            constbytes=newArray(height);//[height][width]
            for(leti=0;i!==height;i++){
                bytes[i]=newUint8Array(width);
            }
            this.bytes=bytes;
        }
        getHeight(){
            returnthis.height;
        }
        getWidth(){
            returnthis.width;
        }
        get(x/*int*/,y/*int*/){
            returnthis.bytes[y][x];
        }
        /**
         *@returnaninternalrepresentationasbytes,inrow-majororder.array[y][x]representspoint(x,y)
         */
        getArray(){
            returnthis.bytes;
        }
        //TYPESCRIPTPORT:preffertolettwomethodsinsteadofoverridetoavoidtypecomparisoninside
        setNumber(x/*int*/,y/*int*/,value/*byte|int*/){
            this.bytes[y][x]=value;
        }
        //publicset(x:number/*int*/,y:number/*int*/,value:number/*int*/):void{
        //  bytes[y][x]=(byte)value
        //}
        setBoolean(x/*int*/,y/*int*/,value){
            this.bytes[y][x]=/*(byte)*/(value?1:0);
        }
        clear(value/*byte*/){
            for(constaByteofthis.bytes){
                Arrays.fill(aByte,value);
            }
        }
        equals(o){
            if(!(oinstanceofByteMatrix)){
                returnfalse;
            }
            constother=o;
            if(this.width!==other.width){
                returnfalse;
            }
            if(this.height!==other.height){
                returnfalse;
            }
            for(lety=0,height=this.height;y<height;++y){
                constbytesY=this.bytes[y];
                constotherBytesY=other.bytes[y];
                for(letx=0,width=this.width;x<width;++x){
                    if(bytesY[x]!==otherBytesY[x]){
                        returnfalse;
                    }
                }
            }
            returntrue;
        }
        /*@Override*/
        toString(){
            constresult=newStringBuilder();//(2*width*height+2)
            for(lety=0,height=this.height;y<height;++y){
                constbytesY=this.bytes[y];
                for(letx=0,width=this.width;x<width;++x){
                    switch(bytesY[x]){
                        case0:
                            result.append('0');
                            break;
                        case1:
                            result.append('1');
                            break;
                        default:
                            result.append(' ');
                            break;
                    }
                }
                result.append('\n');
            }
            returnresult.toString();
        }
    }

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *@authorsatorux@google.com(SatoruTakabayashi)-creator
     *@authordswitkin@google.com(DanielSwitkin)-portedfromC++
     */
    classQRCode{
        constructor(){
            this.maskPattern=-1;
        }
        getMode(){
            returnthis.mode;
        }
        getECLevel(){
            returnthis.ecLevel;
        }
        getVersion(){
            returnthis.version;
        }
        getMaskPattern(){
            returnthis.maskPattern;
        }
        getMatrix(){
            returnthis.matrix;
        }
        /*@Override*/
        toString(){
            constresult=newStringBuilder();//(200)
            result.append('<<\n');
            result.append('mode:');
            result.append(this.mode?this.mode.toString():'null');
            result.append('\necLevel:');
            result.append(this.ecLevel?this.ecLevel.toString():'null');
            result.append('\nversion:');
            result.append(this.version?this.version.toString():'null');
            result.append('\nmaskPattern:');
            result.append(this.maskPattern.toString());
            if(this.matrix){
                result.append('\nmatrix:\n');
                result.append(this.matrix.toString());
            }
            else{
                result.append('\nmatrix:null\n');
            }
            result.append('>>\n');
            returnresult.toString();
        }
        setMode(value){
            this.mode=value;
        }
        setECLevel(value){
            this.ecLevel=value;
        }
        setVersion(version){
            this.version=version;
        }
        setMaskPattern(value/*int*/){
            this.maskPattern=value;
        }
        setMatrix(value){
            this.matrix=value;
        }
        //Checkif"mask_pattern"isvalid.
        staticisValidMaskPattern(maskPattern/*int*/){
            returnmaskPattern>=0&&maskPattern<QRCode.NUM_MASK_PATTERNS;
        }
    }
    QRCode.NUM_MASK_PATTERNS=8;

    /**
     *CustomErrorclassoftypeException.
     */
    classWriterExceptionextendsException{
    }
    WriterException.kind='WriterException';

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *@authorsatorux@google.com(SatoruTakabayashi)-creator
     *@authordswitkin@google.com(DanielSwitkin)-portedfromC++
     */
    classMatrixUtil{
        constructor(){
            //donothing
        }
        //Setallcellsto-1(TYPESCRIPTPORT:255). -1(TYPESCRIPTPORT:255)meansthatthecellisempty(notsetyet).
        //
        //JAVAPORT:Weshouldn'tneedtodothisatall.Thecodeshouldberewrittentobeginencoding
        //withtheByteMatrixinitializedalltozero.
        staticclearMatrix(matrix){
            //TYPESCRIPTPORT:weuseUintArraysechangedherefrom-1to255
            matrix.clear(/*(byte)*//*-1*/255);
        }
        //Build2DmatrixofQRCodefrom"dataBits"with"ecLevel","version"and"getMaskPattern".On
        //success,storetheresultin"matrix"andreturntrue.
        staticbuildMatrix(dataBits,ecLevel,version,maskPattern/*int*/,matrix){
            MatrixUtil.clearMatrix(matrix);
            MatrixUtil.embedBasicPatterns(version,matrix);
            //Typeinformationappearwithanyversion.
            MatrixUtil.embedTypeInfo(ecLevel,maskPattern,matrix);
            //Versioninfoappearifversion>=7.
            MatrixUtil.maybeEmbedVersionInfo(version,matrix);
            //Datashouldbeembeddedatend.
            MatrixUtil.embedDataBits(dataBits,maskPattern,matrix);
        }
        //Embedbasicpatterns.Onsuccess,modifythematrixandreturntrue.
        //Thebasicpatternsare:
        //-Positiondetectionpatterns
        //-Timingpatterns
        //-Darkdotattheleftbottomcorner
        //-Positionadjustmentpatterns,ifneedbe
        staticembedBasicPatterns(version,matrix){
            //Let'sgetstartedwithembeddingbigsquaresatcorners.
            MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);
            //Then,embedthedarkdotattheleftbottomcorner.
            MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);
            //Positionadjustmentpatternsappearifversion>=2.
            MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version,matrix);
            //Timingpatternsshouldbeembeddedafterpositionadj.patterns.
            MatrixUtil.embedTimingPatterns(matrix);
        }
        //Embedtypeinformation.Onsuccess,modifythematrix.
        staticembedTypeInfo(ecLevel,maskPattern/*int*/,matrix){
            consttypeInfoBits=newBitArray();
            MatrixUtil.makeTypeInfoBits(ecLevel,maskPattern,typeInfoBits);
            for(leti=0,size=typeInfoBits.getSize();i<size;++i){
                //PlacebitsinLSBtoMSBorder. LSB(leastsignificantbit)isthelastvaluein
                //"typeInfoBits".
                constbit=typeInfoBits.get(typeInfoBits.getSize()-1-i);
                //Typeinfobitsatthelefttopcorner.See8.9ofJISX0510:2004(p.46).
                constcoordinates=MatrixUtil.TYPE_INFO_COORDINATES[i];
                constx1=coordinates[0];
                consty1=coordinates[1];
                matrix.setBoolean(x1,y1,bit);
                if(i<8){
                    //Righttopcorner.
                    constx2=matrix.getWidth()-i-1;
                    consty2=8;
                    matrix.setBoolean(x2,y2,bit);
                }
                else{
                    //Leftbottomcorner.
                    constx2=8;
                    consty2=matrix.getHeight()-7+(i-8);
                    matrix.setBoolean(x2,y2,bit);
                }
            }
        }
        //Embedversioninformationifneedbe.Onsuccess,modifythematrixandreturntrue.
        //See8.10ofJISX0510:2004(p.47)forhowtoembedversioninformation.
        staticmaybeEmbedVersionInfo(version,matrix){
            if(version.getVersionNumber()<7){//Versioninfoisnecessaryifversion>=7.
                return;//Don'tneedversioninfo.
            }
            constversionInfoBits=newBitArray();
            MatrixUtil.makeVersionInfoBits(version,versionInfoBits);
            letbitIndex=6*3-1;//Itwilldecreasefrom17to0.
            for(leti=0;i<6;++i){
                for(letj=0;j<3;++j){
                    //PlacebitsinLSB(leastsignificantbit)toMSBorder.
                    constbit=versionInfoBits.get(bitIndex);
                    bitIndex--;
                    //Leftbottomcorner.
                    matrix.setBoolean(i,matrix.getHeight()-11+j,bit);
                    //Rightbottomcorner.
                    matrix.setBoolean(matrix.getHeight()-11+j,i,bit);
                }
            }
        }
        //Embed"dataBits"using"getMaskPattern".Onsuccess,modifythematrixandreturntrue.
        //Fordebuggingpurposes,itskipsmaskingprocessif"getMaskPattern"is-1(TYPESCRIPTPORT:255).
        //See8.7ofJISX0510:2004(p.38)forhowtoembeddatabits.
        staticembedDataBits(dataBits,maskPattern/*int*/,matrix){
            letbitIndex=0;
            letdirection=-1;
            //Startfromtherightbottomcell.
            letx=matrix.getWidth()-1;
            lety=matrix.getHeight()-1;
            while(x>0){
                //Skiptheverticaltimingpattern.
                if(x===6){
                    x-=1;
                }
                while(y>=0&&y<matrix.getHeight()){
                    for(leti=0;i<2;++i){
                        constxx=x-i;
                        //Skipthecellifit'snotempty.
                        if(!MatrixUtil.isEmpty(matrix.get(xx,y))){
                            continue;
                        }
                        letbit;
                        if(bitIndex<dataBits.getSize()){
                            bit=dataBits.get(bitIndex);
                            ++bitIndex;
                        }
                        else{
                            //Paddingbit.Ifthereisnobitleft,we'llfilltheleftcellswith0,asdescribed
                            //in8.4.9ofJISX0510:2004(p.24).
                            bit=false;
                        }
                        //Skipmaskingifmask_patternis-1(TYPESCRIPTPORT:255).
                        if(maskPattern!==255&&MaskUtil.getDataMaskBit(maskPattern,xx,y)){
                            bit=!bit;
                        }
                        matrix.setBoolean(xx,y,bit);
                    }
                    y+=direction;
                }
                direction=-direction;//Reversethedirection.
                y+=direction;
                x-=2;//Movetotheleft.
            }
            //Allbitsshouldbeconsumed.
            if(bitIndex!==dataBits.getSize()){
                thrownewWriterException('Notallbitsconsumed:'+bitIndex+'/'+dataBits.getSize());
            }
        }
        //Returnthepositionofthemostsignificantbitset(one:to)inthe"value".Themost
        //significantbitisposition32.Ifthereisnobitset,return0.Examples:
        //-findMSBSet(0)=>0
        //-findMSBSet(1)=>1
        //-findMSBSet(255)=>8
        staticfindMSBSet(value/*int*/){
            return32-Integer.numberOfLeadingZeros(value);
        }
        //CalculateBCH(Bose-Chaudhuri-Hocquenghem)codefor"value"usingpolynomial"poly".TheBCH
        //codeisusedforencodingtypeinformationandversioninformation.
        //Example:Calculationofversioninformationof7.
        //f(x)iscreatedfrom7.
        //  -7=000111in6bits
        //  -f(x)=x^2+x^1+x^0
        //g(x)isgivenbythestandard(p.67)
        //  -g(x)=x^12+x^11+x^10+x^9+x^8+x^5+x^2+1
        //Multiplyf(x)byx^(18-6)
        //  -f'(x)=f(x)*x^(18-6)
        //  -f'(x)=x^14+x^13+x^12
        //Calculatetheremainderoff'(x)/g(x)
        //        x^2
        //        __________________________________________________
        //  g(x))x^14+x^13+x^12
        //        x^14+x^13+x^12+x^11+x^10+x^7+x^4+x^2
        //        --------------------------------------------------
        //                             x^11+x^10+x^7+x^4+x^2
        //
        //Theremainderisx^11+x^10+x^7+x^4+x^2
        //Encodeitinbinary:110010010100
        //Thereturnvalueis0xc94(110010010100)
        //
        //Sinceallcoefficientsinthepolynomialsare1or0,wecandothecalculationbybit
        //operations.Wedon'tcareifcoefficientsarepositiveornegative.
        staticcalculateBCHCode(value/*int*/,poly/*int*/){
            if(poly===0){
                thrownewIllegalArgumentException('0polynomial');
            }
            //Ifpolyis"1111100100101"(versioninfopoly),msbSetInPolyis13.We'llsubtract1
            //from13tomakeit12.
            constmsbSetInPoly=MatrixUtil.findMSBSet(poly);
            value<<=msbSetInPoly-1;
            //Dothedivisionbusinessusingexclusive-oroperations.
            while(MatrixUtil.findMSBSet(value)>=msbSetInPoly){
                value^=poly<<(MatrixUtil.findMSBSet(value)-msbSetInPoly);
            }
            //Nowthe"value"istheremainder(i.e.theBCHcode)
            returnvalue;
        }
        //Makebitvectoroftypeinformation.Onsuccess,storetheresultin"bits"andreturntrue.
        //Encodeerrorcorrectionlevelandmaskpattern.See8.9of
        //JISX0510:2004(p.45)fordetails.
        staticmakeTypeInfoBits(ecLevel,maskPattern/*int*/,bits){
            if(!QRCode.isValidMaskPattern(maskPattern)){
                thrownewWriterException('Invalidmaskpattern');
            }
            consttypeInfo=(ecLevel.getBits()<<3)|maskPattern;
            bits.appendBits(typeInfo,5);
            constbchCode=MatrixUtil.calculateBCHCode(typeInfo,MatrixUtil.TYPE_INFO_POLY);
            bits.appendBits(bchCode,10);
            constmaskBits=newBitArray();
            maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN,15);
            bits.xor(maskBits);
            if(bits.getSize()!==15){//Justincase.
                thrownewWriterException('shouldnothappenbutwegot:'+bits.getSize());
            }
        }
        //Makebitvectorofversioninformation.Onsuccess,storetheresultin"bits"andreturntrue.
        //See8.10ofJISX0510:2004(p.45)fordetails.
        staticmakeVersionInfoBits(version,bits){
            bits.appendBits(version.getVersionNumber(),6);
            constbchCode=MatrixUtil.calculateBCHCode(version.getVersionNumber(),MatrixUtil.VERSION_INFO_POLY);
            bits.appendBits(bchCode,12);
            if(bits.getSize()!==18){//Justincase.
                thrownewWriterException('shouldnothappenbutwegot:'+bits.getSize());
            }
        }
        //Checkif"value"isempty.
        staticisEmpty(value/*int*/){
            returnvalue===255;//-1
        }
        staticembedTimingPatterns(matrix){
            //-8isforskippingpositiondetectionpatterns(7:size),andtwohorizontal/vertical
            //separationpatterns(1:size).Thus,8=7+1.
            for(leti=8;i<matrix.getWidth()-8;++i){
                constbit=(i+1)%2;
                //Horizontalline.
                if(MatrixUtil.isEmpty(matrix.get(i,6))){
                    matrix.setNumber(i,6,bit);
                }
                //Verticalline.
                if(MatrixUtil.isEmpty(matrix.get(6,i))){
                    matrix.setNumber(6,i,bit);
                }
            }
        }
        //Embedthelonelydarkdotatleftbottomcorner.JISX0510:2004(p.46)
        staticembedDarkDotAtLeftBottomCorner(matrix){
            if(matrix.get(8,matrix.getHeight()-8)===0){
                thrownewWriterException();
            }
            matrix.setNumber(8,matrix.getHeight()-8,1);
        }
        staticembedHorizontalSeparationPattern(xStart/*int*/,yStart/*int*/,matrix){
            for(letx=0;x<8;++x){
                if(!MatrixUtil.isEmpty(matrix.get(xStart+x,yStart))){
                    thrownewWriterException();
                }
                matrix.setNumber(xStart+x,yStart,0);
            }
        }
        staticembedVerticalSeparationPattern(xStart/*int*/,yStart/*int*/,matrix){
            for(lety=0;y<7;++y){
                if(!MatrixUtil.isEmpty(matrix.get(xStart,yStart+y))){
                    thrownewWriterException();
                }
                matrix.setNumber(xStart,yStart+y,0);
            }
        }
        staticembedPositionAdjustmentPattern(xStart/*int*/,yStart/*int*/,matrix){
            for(lety=0;y<5;++y){
                constpatternY=MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y];
                for(letx=0;x<5;++x){
                    matrix.setNumber(xStart+x,yStart+y,patternY[x]);
                }
            }
        }
        staticembedPositionDetectionPattern(xStart/*int*/,yStart/*int*/,matrix){
            for(lety=0;y<7;++y){
                constpatternY=MatrixUtil.POSITION_DETECTION_PATTERN[y];
                for(letx=0;x<7;++x){
                    matrix.setNumber(xStart+x,yStart+y,patternY[x]);
                }
            }
        }
        //Embedpositiondetectionpatternsandsurroundingvertical/horizontalseparators.
        staticembedPositionDetectionPatternsAndSeparators(matrix){
            //Embedthreebigsquaresatcorners.
            constpdpWidth=MatrixUtil.POSITION_DETECTION_PATTERN[0].length;
            //Lefttopcorner.
            MatrixUtil.embedPositionDetectionPattern(0,0,matrix);
            //Righttopcorner.
            MatrixUtil.embedPositionDetectionPattern(matrix.getWidth()-pdpWidth,0,matrix);
            //Leftbottomcorner.
            MatrixUtil.embedPositionDetectionPattern(0,matrix.getWidth()-pdpWidth,matrix);
            //Embedhorizontalseparationpatternsaroundthesquares.
            consthspWidth=8;
            //Lefttopcorner.
            MatrixUtil.embedHorizontalSeparationPattern(0,hspWidth-1,matrix);
            //Righttopcorner.
            MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth()-hspWidth,hspWidth-1,matrix);
            //Leftbottomcorner.
            MatrixUtil.embedHorizontalSeparationPattern(0,matrix.getWidth()-hspWidth,matrix);
            //Embedverticalseparationpatternsaroundthesquares.
            constvspSize=7;
            //Lefttopcorner.
            MatrixUtil.embedVerticalSeparationPattern(vspSize,0,matrix);
            //Righttopcorner.
            MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight()-vspSize-1,0,matrix);
            //Leftbottomcorner.
            MatrixUtil.embedVerticalSeparationPattern(vspSize,matrix.getHeight()-vspSize,matrix);
        }
        //Embedpositionadjustmentpatternsifneedbe.
        staticmaybeEmbedPositionAdjustmentPatterns(version,matrix){
            if(version.getVersionNumber()<2){//Thepatternsappearifversion>=2
                return;
            }
            constindex=version.getVersionNumber()-1;
            constcoordinates=MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];
            for(leti=0,length=coordinates.length;i!==length;i++){
                consty=coordinates[i];
                if(y>=0){
                    for(letj=0;j!==length;j++){
                        constx=coordinates[j];
                        if(x>=0&&MatrixUtil.isEmpty(matrix.get(x,y))){
                            //Ifthecellisunset,weembedthepositionadjustmentpatternhere.
                            //-2isnecessarysincethex/ycoordinatespointtothecenterofthepattern,notthe
                            //lefttopcorner.
                            MatrixUtil.embedPositionAdjustmentPattern(x-2,y-2,matrix);
                        }
                    }
                }
            }
        }
    }
    MatrixUtil.POSITION_DETECTION_PATTERN=Array.from([
        Int32Array.from([1,1,1,1,1,1,1]),
        Int32Array.from([1,0,0,0,0,0,1]),
        Int32Array.from([1,0,1,1,1,0,1]),
        Int32Array.from([1,0,1,1,1,0,1]),
        Int32Array.from([1,0,1,1,1,0,1]),
        Int32Array.from([1,0,0,0,0,0,1]),
        Int32Array.from([1,1,1,1,1,1,1]),
    ]);
    MatrixUtil.POSITION_ADJUSTMENT_PATTERN=Array.from([
        Int32Array.from([1,1,1,1,1]),
        Int32Array.from([1,0,0,0,1]),
        Int32Array.from([1,0,1,0,1]),
        Int32Array.from([1,0,0,0,1]),
        Int32Array.from([1,1,1,1,1]),
    ]);
    //FromAppendixE.Table1,JIS0510X:2004(71:p).Thetablewasdouble-checkedbykomatsu.
    MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE=Array.from([
        Int32Array.from([-1,-1,-1,-1,-1,-1,-1]),
        Int32Array.from([6,18,-1,-1,-1,-1,-1]),
        Int32Array.from([6,22,-1,-1,-1,-1,-1]),
        Int32Array.from([6,26,-1,-1,-1,-1,-1]),
        Int32Array.from([6,30,-1,-1,-1,-1,-1]),
        Int32Array.from([6,34,-1,-1,-1,-1,-1]),
        Int32Array.from([6,22,38,-1,-1,-1,-1]),
        Int32Array.from([6,24,42,-1,-1,-1,-1]),
        Int32Array.from([6,26,46,-1,-1,-1,-1]),
        Int32Array.from([6,28,50,-1,-1,-1,-1]),
        Int32Array.from([6,30,54,-1,-1,-1,-1]),
        Int32Array.from([6,32,58,-1,-1,-1,-1]),
        Int32Array.from([6,34,62,-1,-1,-1,-1]),
        Int32Array.from([6,26,46,66,-1,-1,-1]),
        Int32Array.from([6,26,48,70,-1,-1,-1]),
        Int32Array.from([6,26,50,74,-1,-1,-1]),
        Int32Array.from([6,30,54,78,-1,-1,-1]),
        Int32Array.from([6,30,56,82,-1,-1,-1]),
        Int32Array.from([6,30,58,86,-1,-1,-1]),
        Int32Array.from([6,34,62,90,-1,-1,-1]),
        Int32Array.from([6,28,50,72,94,-1,-1]),
        Int32Array.from([6,26,50,74,98,-1,-1]),
        Int32Array.from([6,30,54,78,102,-1,-1]),
        Int32Array.from([6,28,54,80,106,-1,-1]),
        Int32Array.from([6,32,58,84,110,-1,-1]),
        Int32Array.from([6,30,58,86,114,-1,-1]),
        Int32Array.from([6,34,62,90,118,-1,-1]),
        Int32Array.from([6,26,50,74,98,122,-1]),
        Int32Array.from([6,30,54,78,102,126,-1]),
        Int32Array.from([6,26,52,78,104,130,-1]),
        Int32Array.from([6,30,56,82,108,134,-1]),
        Int32Array.from([6,34,60,86,112,138,-1]),
        Int32Array.from([6,30,58,86,114,142,-1]),
        Int32Array.from([6,34,62,90,118,146,-1]),
        Int32Array.from([6,30,54,78,102,126,150]),
        Int32Array.from([6,24,50,76,102,128,154]),
        Int32Array.from([6,28,54,80,106,132,158]),
        Int32Array.from([6,32,58,84,110,136,162]),
        Int32Array.from([6,26,54,82,110,138,166]),
        Int32Array.from([6,30,58,86,114,142,170]),
    ]);
    //Typeinfocellsatthelefttopcorner.
    MatrixUtil.TYPE_INFO_COORDINATES=Array.from([
        Int32Array.from([8,0]),
        Int32Array.from([8,1]),
        Int32Array.from([8,2]),
        Int32Array.from([8,3]),
        Int32Array.from([8,4]),
        Int32Array.from([8,5]),
        Int32Array.from([8,7]),
        Int32Array.from([8,8]),
        Int32Array.from([7,8]),
        Int32Array.from([5,8]),
        Int32Array.from([4,8]),
        Int32Array.from([3,8]),
        Int32Array.from([2,8]),
        Int32Array.from([1,8]),
        Int32Array.from([0,8]),
    ]);
    //FromAppendixDinJISX0510:2004(p.67)
    MatrixUtil.VERSION_INFO_POLY=0x1f25;//1111100100101
    //FromAppendixCinJISX0510:2004(p.65).
    MatrixUtil.TYPE_INFO_POLY=0x537;
    MatrixUtil.TYPE_INFO_MASK_PATTERN=0x5412;

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*namespacecom.google.zxing.qrcode.encoder{*/
    classBlockPair{
        constructor(dataBytes,errorCorrectionBytes){
            this.dataBytes=dataBytes;
            this.errorCorrectionBytes=errorCorrectionBytes;
        }
        getDataBytes(){
            returnthis.dataBytes;
        }
        getErrorCorrectionBytes(){
            returnthis.errorCorrectionBytes;
        }
    }

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*importjava.io.UnsupportedEncodingException;*/
    /*importjava.util.ArrayList;*/
    /*importjava.util.Collection;*/
    /*importjava.util.Map;*/
    /**
     *@authorsatorux@google.com(SatoruTakabayashi)-creator
     *@authordswitkin@google.com(DanielSwitkin)-portedfromC++
     */
    classEncoder{
        //TYPESCRIPTPORT:changedtoUTF8,thedefaultforjs
        constructor(){}
        //Themaskpenaltycalculationiscomplicated. SeeTable21ofJISX0510:2004(p.45)fordetails.
        //Basicallyitappliesfourrulesandsummateallpenalties.
        staticcalculateMaskPenalty(matrix){
            returnMaskUtil.applyMaskPenaltyRule1(matrix)
                +MaskUtil.applyMaskPenaltyRule2(matrix)
                +MaskUtil.applyMaskPenaltyRule3(matrix)
                +MaskUtil.applyMaskPenaltyRule4(matrix);
        }
        /**
         *@paramcontenttexttoencode
         *@paramecLevelerrorcorrectionleveltouse
         *@return{@linkQRCode}representingtheencodedQRcode
         *@throwsWriterExceptionifencodingcan'tsucceed,becauseofforexampleinvalidcontent
         *  orconfiguration
         */
        //publicstaticencode(content:string,ecLevel:ErrorCorrectionLevel):QRCode/*throwsWriterException*/{
        //  returnencode(content,ecLevel,null)
        //}
        staticencode(content,ecLevel,hints=null){
            //Determinewhatcharacterencodinghasbeenspecifiedbythecaller,ifany
            letencoding=Encoder.DEFAULT_BYTE_MODE_ENCODING;
            consthasEncodingHint=hints!==null&&undefined!==hints.get(EncodeHintType$1.CHARACTER_SET);
            if(hasEncodingHint){
                encoding=hints.get(EncodeHintType$1.CHARACTER_SET).toString();
            }
            //Pickanencodingmodeappropriateforthecontent.Notethatthiswillnotattempttouse
            //multiplemodes/segmentsevenifthatweremoreefficient.Twouldbenice.
            constmode=this.chooseMode(content,encoding);
            //Thiswillstoretheheaderinformation,likemodeand
            //length,aswellas"header"segmentslikeanECIsegment.
            constheaderBits=newBitArray();
            //AppendECIsegmentifapplicable
            if(mode===Mode$1.BYTE&&(hasEncodingHint||Encoder.DEFAULT_BYTE_MODE_ENCODING!==encoding)){
                consteci=CharacterSetECI.getCharacterSetECIByName(encoding);
                if(eci!==undefined){
                    this.appendECI(eci,headerBits);
                }
            }
            //(WithECIinplace,)Writethemodemarker
            this.appendModeInfo(mode,headerBits);
            //Collectdatawithinthemainsegment,separately,tocountitssizeifneeded.Don'tadditto
            //mainpayloadyet.
            constdataBits=newBitArray();
            this.appendBytes(content,mode,dataBits,encoding);
            letversion;
            if(hints!==null&&undefined!==hints.get(EncodeHintType$1.QR_VERSION)){
                constversionNumber=Number.parseInt(hints.get(EncodeHintType$1.QR_VERSION).toString(),10);
                version=Version$1.getVersionForNumber(versionNumber);
                constbitsNeeded=this.calculateBitsNeeded(mode,headerBits,dataBits,version);
                if(!this.willFit(bitsNeeded,version,ecLevel)){
                    thrownewWriterException('Datatoobigforrequestedversion');
                }
            }
            else{
                version=this.recommendVersion(ecLevel,mode,headerBits,dataBits);
            }
            constheaderAndDataBits=newBitArray();
            headerAndDataBits.appendBitArray(headerBits);
            //Find"length"ofmainsegmentandwriteit
            constnumLetters=mode===Mode$1.BYTE?dataBits.getSizeInBytes():content.length;
            this.appendLengthInfo(numLetters,version,mode,headerAndDataBits);
            //Putdatatogetherintotheoverallpayload
            headerAndDataBits.appendBitArray(dataBits);
            constecBlocks=version.getECBlocksForLevel(ecLevel);
            constnumDataBytes=version.getTotalCodewords()-ecBlocks.getTotalECCodewords();
            //Terminatethebitsproperly.
            this.terminateBits(numDataBytes,headerAndDataBits);
            //Interleavedatabitswitherrorcorrectioncode.
            constfinalBits=this.interleaveWithECBytes(headerAndDataBits,version.getTotalCodewords(),numDataBytes,ecBlocks.getNumBlocks());
            constqrCode=newQRCode();
            qrCode.setECLevel(ecLevel);
            qrCode.setMode(mode);
            qrCode.setVersion(version);
            // Choosethemaskpatternandsetto"qrCode".
            constdimension=version.getDimensionForVersion();
            constmatrix=newByteMatrix(dimension,dimension);
            constmaskPattern=this.chooseMaskPattern(finalBits,ecLevel,version,matrix);
            qrCode.setMaskPattern(maskPattern);
            //Buildthematrixandsetitto"qrCode".
            MatrixUtil.buildMatrix(finalBits,ecLevel,version,maskPattern,matrix);
            qrCode.setMatrix(matrix);
            returnqrCode;
        }
        /**
         *DecidesthesmallestversionofQRcodethatwillcontainalloftheprovideddata.
         *
         *@throwsWriterExceptionifthedatacannotfitinanyversion
         */
        staticrecommendVersion(ecLevel,mode,headerBits,dataBits){
            //Hardpart:needtoknowversiontoknowhowmanybitslengthtakes.Butneedtoknowhowmany
            //bitsittakestoknowversion.Firstwetakeaguessatversionbyassumingversionwillbe
            //theminimum,1:
            constprovisionalBitsNeeded=this.calculateBitsNeeded(mode,headerBits,dataBits,Version$1.getVersionForNumber(1));
            constprovisionalVersion=this.chooseVersion(provisionalBitsNeeded,ecLevel);
            //Usethatguesstocalculatetherightversion.Iamstillnotsurethisworksin100%ofcases.
            constbitsNeeded=this.calculateBitsNeeded(mode,headerBits,dataBits,provisionalVersion);
            returnthis.chooseVersion(bitsNeeded,ecLevel);
        }
        staticcalculateBitsNeeded(mode,headerBits,dataBits,version){
            returnheaderBits.getSize()+mode.getCharacterCountBits(version)+dataBits.getSize();
        }
        /**
         *@returnthecodepointofthetableusedinalphanumericmodeor
         * -1ifthereisnocorrespondingcodeinthetable.
         */
        staticgetAlphanumericCode(code/*int*/){
            if(code<Encoder.ALPHANUMERIC_TABLE.length){
                returnEncoder.ALPHANUMERIC_TABLE[code];
            }
            return-1;
        }
        //publicstaticchooseMode(content:string):Mode{
        //  returnchooseMode(content,null);
        //}
        /**
         *Choosethebestmodebyexaminingthecontent.Notethat'encoding'isusedasahint;
         *ifitisShift_JIS,andtheinputisonlydouble-byteKanji,thenwereturn{@linkMode#KANJI}.
         */
        staticchooseMode(content,encoding=null){
            if(CharacterSetECI.SJIS.getName()===encoding&&this.isOnlyDoubleByteKanji(content)){
                //ChooseKanjimodeifallinputaredouble-bytecharacters
                returnMode$1.KANJI;
            }
            lethasNumeric=false;
            lethasAlphanumeric=false;
            for(leti=0,length=content.length;i<length;++i){
                constc=content.charAt(i);
                if(Encoder.isDigit(c)){
                    hasNumeric=true;
                }
                elseif(this.getAlphanumericCode(c.charCodeAt(0))!==-1){
                    hasAlphanumeric=true;
                }
                else{
                    returnMode$1.BYTE;
                }
            }
            if(hasAlphanumeric){
                returnMode$1.ALPHANUMERIC;
            }
            if(hasNumeric){
                returnMode$1.NUMERIC;
            }
            returnMode$1.BYTE;
        }
        staticisOnlyDoubleByteKanji(content){
            letbytes;
            try{
                bytes=StringEncoding.encode(content,CharacterSetECI.SJIS);//content.getBytes("Shift_JIS"))
            }
            catch(ignored/*:UnsupportedEncodingException*/){
                returnfalse;
            }
            constlength=bytes.length;
            if(length%2!==0){
                returnfalse;
            }
            for(leti=0;i<length;i+=2){
                constbyte1=bytes[i]&0xFF;
                if((byte1<0x81||byte1>0x9F)&&(byte1<0xE0||byte1>0xEB)){
                    returnfalse;
                }
            }
            returntrue;
        }
        staticchooseMaskPattern(bits,ecLevel,version,matrix){
            letminPenalty=Number.MAX_SAFE_INTEGER;//Lowerpenaltyisbetter.
            letbestMaskPattern=-1;
            //Wetryallmaskpatternstochoosethebestone.
            for(letmaskPattern=0;maskPattern<QRCode.NUM_MASK_PATTERNS;maskPattern++){
                MatrixUtil.buildMatrix(bits,ecLevel,version,maskPattern,matrix);
                letpenalty=this.calculateMaskPenalty(matrix);
                if(penalty<minPenalty){
                    minPenalty=penalty;
                    bestMaskPattern=maskPattern;
                }
            }
            returnbestMaskPattern;
        }
        staticchooseVersion(numInputBits/*int*/,ecLevel){
            for(letversionNum=1;versionNum<=40;versionNum++){
                constversion=Version$1.getVersionForNumber(versionNum);
                if(Encoder.willFit(numInputBits,version,ecLevel)){
                    returnversion;
                }
            }
            thrownewWriterException('Datatoobig');
        }
        /**
         *@returntrueifthenumberofinputbitswillfitinacodewiththespecifiedversionand
         *errorcorrectionlevel.
         */
        staticwillFit(numInputBits/*int*/,version,ecLevel){
            //Inthefollowingcomments,weusenumbersofVersion7-H.
            //numBytes=196
            constnumBytes=version.getTotalCodewords();
            //getNumECBytes=130
            constecBlocks=version.getECBlocksForLevel(ecLevel);
            constnumEcBytes=ecBlocks.getTotalECCodewords();
            //getNumDataBytes=196-130=66
            constnumDataBytes=numBytes-numEcBytes;
            consttotalInputBytes=(numInputBits+7)/8;
            returnnumDataBytes>=totalInputBytes;
        }
        /**
         *Terminatebitsasdescribedin8.4.8and8.4.9ofJISX0510:2004(p.24).
         */
        staticterminateBits(numDataBytes/*int*/,bits){
            constcapacity=numDataBytes*8;
            if(bits.getSize()>capacity){
                thrownewWriterException('databitscannotfitintheQRCode'+bits.getSize()+'>'+
                    capacity);
            }
            for(leti=0;i<4&&bits.getSize()<capacity;++i){
                bits.appendBit(false);
            }
            //Appendterminationbits.See8.4.8ofJISX0510:2004(p.24)fordetails.
            //Ifthelastbyteisn't8-bitaligned,we'lladdpaddingbits.
            constnumBitsInLastByte=bits.getSize()&0x07;
            if(numBitsInLastByte>0){
                for(leti=numBitsInLastByte;i<8;i++){
                    bits.appendBit(false);
                }
            }
            //Ifwehavemorespace,we'llfillthespacewithpaddingpatternsdefinedin8.4.9(p.24).
            constnumPaddingBytes=numDataBytes-bits.getSizeInBytes();
            for(leti=0;i<numPaddingBytes;++i){
                bits.appendBits((i&0x01)===0?0xEC:0x11,8);
            }
            if(bits.getSize()!==capacity){
                thrownewWriterException('Bitssizedoesnotequalcapacity');
            }
        }
        /**
         *Getnumberofdatabytesandnumberoferrorcorrectionbytesforblockid"blockID".Store
         *theresultin"numDataBytesInBlock",and"numECBytesInBlock".Seetable12in8.5.1of
         *JISX0510:2004(p.30)
         */
        staticgetNumDataBytesAndNumECBytesForBlockID(numTotalBytes/*int*/,numDataBytes/*int*/,numRSBlocks/*int*/,blockID/*int*/,numDataBytesInBlock,numECBytesInBlock){
            if(blockID>=numRSBlocks){
                thrownewWriterException('BlockIDtoolarge');
            }
            //numRsBlocksInGroup2=196%5=1
            constnumRsBlocksInGroup2=numTotalBytes%numRSBlocks;
            //numRsBlocksInGroup1=5-1=4
            constnumRsBlocksInGroup1=numRSBlocks-numRsBlocksInGroup2;
            //numTotalBytesInGroup1=196/5=39
            constnumTotalBytesInGroup1=Math.floor(numTotalBytes/numRSBlocks);
            //numTotalBytesInGroup2=39+1=40
            constnumTotalBytesInGroup2=numTotalBytesInGroup1+1;
            //numDataBytesInGroup1=66/5=13
            constnumDataBytesInGroup1=Math.floor(numDataBytes/numRSBlocks);
            //numDataBytesInGroup2=13+1=14
            constnumDataBytesInGroup2=numDataBytesInGroup1+1;
            //numEcBytesInGroup1=39-13=26
            constnumEcBytesInGroup1=numTotalBytesInGroup1-numDataBytesInGroup1;
            //numEcBytesInGroup2=40-14=26
            constnumEcBytesInGroup2=numTotalBytesInGroup2-numDataBytesInGroup2;
            //Sanitychecks.
            //26=26
            if(numEcBytesInGroup1!==numEcBytesInGroup2){
                thrownewWriterException('ECbytesmismatch');
            }
            //5=4+1.
            if(numRSBlocks!==numRsBlocksInGroup1+numRsBlocksInGroup2){
                thrownewWriterException('RSblocksmismatch');
            }
            //196=(13+26)*4+(14+26)*1
            if(numTotalBytes!==
                ((numDataBytesInGroup1+numEcBytesInGroup1)*
                    numRsBlocksInGroup1)+
                    ((numDataBytesInGroup2+numEcBytesInGroup2)*
                        numRsBlocksInGroup2)){
                thrownewWriterException('Totalbytesmismatch');
            }
            if(blockID<numRsBlocksInGroup1){
                numDataBytesInBlock[0]=numDataBytesInGroup1;
                numECBytesInBlock[0]=numEcBytesInGroup1;
            }
            else{
                numDataBytesInBlock[0]=numDataBytesInGroup2;
                numECBytesInBlock[0]=numEcBytesInGroup2;
            }
        }
        /**
         *Interleave"bits"withcorrespondingerrorcorrectionbytes.Onsuccess,storetheresultin
         *"result".Theinterleaveruleiscomplicated.See8.6ofJISX0510:2004(p.37)fordetails.
         */
        staticinterleaveWithECBytes(bits,numTotalBytes/*int*/,numDataBytes/*int*/,numRSBlocks/*int*/){
            //"bits"musthave"getNumDataBytes"bytesofdata.
            if(bits.getSizeInBytes()!==numDataBytes){
                thrownewWriterException('Numberofbitsanddatabytesdoesnotmatch');
            }
            //Step1. Dividedatabytesintoblocksandgenerateerrorcorrectionbytesforthem.We'll
            //storethedivideddatabytesblocksanderrorcorrectionbytesblocksinto"blocks".
            letdataBytesOffset=0;
            letmaxNumDataBytes=0;
            letmaxNumEcBytes=0;
            //Since,weknowthenumberofreedsolmonblocks,wecaninitializethevectorwiththenumber.
            constblocks=newArray();//newArray<BlockPair>(numRSBlocks)
            for(leti=0;i<numRSBlocks;++i){
                constnumDataBytesInBlock=newInt32Array(1);
                constnumEcBytesInBlock=newInt32Array(1);
                Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes,numDataBytes,numRSBlocks,i,numDataBytesInBlock,numEcBytesInBlock);
                constsize=numDataBytesInBlock[0];
                constdataBytes=newUint8Array(size);
                bits.toBytes(8*dataBytesOffset,dataBytes,0,size);
                constecBytes=Encoder.generateECBytes(dataBytes,numEcBytesInBlock[0]);
                blocks.push(newBlockPair(dataBytes,ecBytes));
                maxNumDataBytes=Math.max(maxNumDataBytes,size);
                maxNumEcBytes=Math.max(maxNumEcBytes,ecBytes.length);
                dataBytesOffset+=numDataBytesInBlock[0];
            }
            if(numDataBytes!==dataBytesOffset){
                thrownewWriterException('Databytesdoesnotmatchoffset');
            }
            constresult=newBitArray();
            //First,placedatablocks.
            for(leti=0;i<maxNumDataBytes;++i){
                for(constblockofblocks){
                    constdataBytes=block.getDataBytes();
                    if(i<dataBytes.length){
                        result.appendBits(dataBytes[i],8);
                    }
                }
            }
            //Then,placeerrorcorrectionblocks.
            for(leti=0;i<maxNumEcBytes;++i){
                for(constblockofblocks){
                    constecBytes=block.getErrorCorrectionBytes();
                    if(i<ecBytes.length){
                        result.appendBits(ecBytes[i],8);
                    }
                }
            }
            if(numTotalBytes!==result.getSizeInBytes()){//Shouldbesame.
                thrownewWriterException('Interleavingerror:'+numTotalBytes+'and'+
                    result.getSizeInBytes()+'differ.');
            }
            returnresult;
        }
        staticgenerateECBytes(dataBytes,numEcBytesInBlock/*int*/){
            constnumDataBytes=dataBytes.length;
            consttoEncode=newInt32Array(numDataBytes+numEcBytesInBlock);//int[numDataBytes+numEcBytesInBlock]
            for(leti=0;i<numDataBytes;i++){
                toEncode[i]=dataBytes[i]&0xFF;
            }
            newReedSolomonEncoder(GenericGF.QR_CODE_FIELD_256).encode(toEncode,numEcBytesInBlock);
            constecBytes=newUint8Array(numEcBytesInBlock);
            for(leti=0;i<numEcBytesInBlock;i++){
                ecBytes[i]=/*(byte)*/toEncode[numDataBytes+i];
            }
            returnecBytes;
        }
        /**
         *Appendmodeinfo.Onsuccess,storetheresultin"bits".
         */
        staticappendModeInfo(mode,bits){
            bits.appendBits(mode.getBits(),4);
        }
        /**
         *Appendlengthinfo.Onsuccess,storetheresultin"bits".
         */
        staticappendLengthInfo(numLetters/*int*/,version,mode,bits){
            constnumBits=mode.getCharacterCountBits(version);
            if(numLetters>=(1<<numBits)){
                thrownewWriterException(numLetters+'isbiggerthan'+((1<<numBits)-1));
            }
            bits.appendBits(numLetters,numBits);
        }
        /**
         *Append"bytes"in"mode"mode(encoding)into"bits".Onsuccess,storetheresultin"bits".
         */
        staticappendBytes(content,mode,bits,encoding){
            switch(mode){
                caseMode$1.NUMERIC:
                    Encoder.appendNumericBytes(content,bits);
                    break;
                caseMode$1.ALPHANUMERIC:
                    Encoder.appendAlphanumericBytes(content,bits);
                    break;
                caseMode$1.BYTE:
                    Encoder.append8BitBytes(content,bits,encoding);
                    break;
                caseMode$1.KANJI:
                    Encoder.appendKanjiBytes(content,bits);
                    break;
                default:
                    thrownewWriterException('Invalidmode:'+mode);
            }
        }
        staticgetDigit(singleCharacter){
            returnsingleCharacter.charCodeAt(0)-48;
        }
        staticisDigit(singleCharacter){
            constcn=Encoder.getDigit(singleCharacter);
            returncn>=0&&cn<=9;
        }
        staticappendNumericBytes(content,bits){
            constlength=content.length;
            leti=0;
            while(i<length){
                constnum1=Encoder.getDigit(content.charAt(i));
                if(i+2<length){
                    //Encodethreenumericlettersintenbits.
                    constnum2=Encoder.getDigit(content.charAt(i+1));
                    constnum3=Encoder.getDigit(content.charAt(i+2));
                    bits.appendBits(num1*100+num2*10+num3,10);
                    i+=3;
                }
                elseif(i+1<length){
                    //Encodetwonumericlettersinsevenbits.
                    constnum2=Encoder.getDigit(content.charAt(i+1));
                    bits.appendBits(num1*10+num2,7);
                    i+=2;
                }
                else{
                    //Encodeonenumericletterinfourbits.
                    bits.appendBits(num1,4);
                    i++;
                }
            }
        }
        staticappendAlphanumericBytes(content,bits){
            constlength=content.length;
            leti=0;
            while(i<length){
                constcode1=Encoder.getAlphanumericCode(content.charCodeAt(i));
                if(code1===-1){
                    thrownewWriterException();
                }
                if(i+1<length){
                    constcode2=Encoder.getAlphanumericCode(content.charCodeAt(i+1));
                    if(code2===-1){
                        thrownewWriterException();
                    }
                    //Encodetwoalphanumericlettersin11bits.
                    bits.appendBits(code1*45+code2,11);
                    i+=2;
                }
                else{
                    //Encodeonealphanumericletterinsixbits.
                    bits.appendBits(code1,6);
                    i++;
                }
            }
        }
        staticappend8BitBytes(content,bits,encoding){
            letbytes;
            try{
                bytes=StringEncoding.encode(content,encoding);
            }
            catch(uee/*:UnsupportedEncodingException*/){
                thrownewWriterException(uee);
            }
            for(leti=0,length=bytes.length;i!==length;i++){
                constb=bytes[i];
                bits.appendBits(b,8);
            }
        }
        /**
         *@throwsWriterException
         */
        staticappendKanjiBytes(content,bits){
            letbytes;
            try{
                bytes=StringEncoding.encode(content,CharacterSetECI.SJIS);
            }
            catch(uee/*:UnsupportedEncodingException*/){
                thrownewWriterException(uee);
            }
            constlength=bytes.length;
            for(leti=0;i<length;i+=2){
                constbyte1=bytes[i]&0xFF;
                constbyte2=bytes[i+1]&0xFF;
                constcode=((byte1<<8)&0xFFFFFFFF)|byte2;
                letsubtracted=-1;
                if(code>=0x8140&&code<=0x9ffc){
                    subtracted=code-0x8140;
                }
                elseif(code>=0xe040&&code<=0xebbf){
                    subtracted=code-0xc140;
                }
                if(subtracted===-1){
                    thrownewWriterException('Invalidbytesequence');
                }
                constencoded=((subtracted>>8)*0xc0)+(subtracted&0xff);
                bits.appendBits(encoded,13);
            }
        }
        staticappendECI(eci,bits){
            bits.appendBits(Mode$1.ECI.getBits(),4);
            //Thisiscorrectforvaluesupto127,whichisallweneednow.
            bits.appendBits(eci.getValue(),8);
        }
    }
    //Theoriginaltableisdefinedinthetable5ofJISX0510:2004(p.19).
    Encoder.ALPHANUMERIC_TABLE=Int32Array.from([
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        36,-1,-1,-1,37,38,-1,-1,-1,-1,39,40,-1,41,42,43,
        0,1,2,3,4,5,6,7,8,9,44,-1,-1,-1,-1,-1,
        -1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
        25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,-1,
    ]);
    Encoder.DEFAULT_BYTE_MODE_ENCODING=CharacterSetECI.UTF8.getName();//"ISO-8859-1"

    /**
     *@deprecatedMovingto@zxing/browser
     */
    classBrowserQRCodeSvgWriter{
        /**
         *WritesandrendersaQRCodeSVGelement.
         *
         *@paramcontents
         *@paramwidth
         *@paramheight
         *@paramhints
         */
        write(contents,width,height,hints=null){
            if(contents.length===0){
                thrownewIllegalArgumentException('Foundemptycontents');
            }
            //if(format!=BarcodeFormat.QR_CODE){
            //  thrownewIllegalArgumentException("CanonlyencodeQR_CODE,butgot"+format)
            //}
            if(width<0||height<0){
                thrownewIllegalArgumentException('Requesteddimensionsaretoosmall:'+width+'x'+height);
            }
            leterrorCorrectionLevel=ErrorCorrectionLevel.L;
            letquietZone=BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;
            if(hints!==null){
                if(undefined!==hints.get(EncodeHintType$1.ERROR_CORRECTION)){
                    errorCorrectionLevel=ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
                }
                if(undefined!==hints.get(EncodeHintType$1.MARGIN)){
                    quietZone=Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(),10);
                }
            }
            constcode=Encoder.encode(contents,errorCorrectionLevel,hints);
            returnthis.renderResult(code,width,height,quietZone);
        }
        /**
         *RenderstheresultandthenappendsittotheDOM.
         */
        writeToDom(containerElement,contents,width,height,hints=null){
            if(typeofcontainerElement==='string'){
                containerElement=document.querySelector(containerElement);
            }
            constsvgElement=this.write(contents,width,height,hints);
            if(containerElement)
                containerElement.appendChild(svgElement);
        }
        /**
         *Notethattheinputmatrixuses0==white,1==black.
         *Theoutputmatrixuses0==black,255==white(i.e.an8bitgreyscalebitmap).
         */
        renderResult(code,width/*int*/,height/*int*/,quietZone/*int*/){
            constinput=code.getMatrix();
            if(input===null){
                thrownewIllegalStateException();
            }
            constinputWidth=input.getWidth();
            constinputHeight=input.getHeight();
            constqrWidth=inputWidth+(quietZone*2);
            constqrHeight=inputHeight+(quietZone*2);
            constoutputWidth=Math.max(width,qrWidth);
            constoutputHeight=Math.max(height,qrHeight);
            constmultiple=Math.min(Math.floor(outputWidth/qrWidth),Math.floor(outputHeight/qrHeight));
            //Paddingincludesboththequietzoneandtheextrawhitepixelstoaccommodatetherequested
            //dimensions.Forexample,ifinputis25x25theQRwillbe33x33includingthequietzone.
            //Iftherequestedsizeis200x160,themultiplewillbe4,foraQRof132x132.Thesewill
            //handleallthepaddingfrom100x100(theactualQR)upto200x160.
            constleftPadding=Math.floor((outputWidth-(inputWidth*multiple))/2);
            consttopPadding=Math.floor((outputHeight-(inputHeight*multiple))/2);
            constsvgElement=this.createSVGElement(outputWidth,outputHeight);
            for(letinputY=0,outputY=topPadding;inputY<inputHeight;inputY++,outputY+=multiple){
                //Writethecontentsofthisrowofthebarcode
                for(letinputX=0,outputX=leftPadding;inputX<inputWidth;inputX++,outputX+=multiple){
                    if(input.get(inputX,inputY)===1){
                        constsvgRectElement=this.createSvgRectElement(outputX,outputY,multiple,multiple);
                        svgElement.appendChild(svgRectElement);
                    }
                }
            }
            returnsvgElement;
        }
        /**
         *CreatesaSVGelement.
         *
         *@paramwSVG'swidthattribute
         *@paramhSVG'sheightattribute
         */
        createSVGElement(w,h){
            constsvgElement=document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS,'svg');
            svgElement.setAttributeNS(null,'height',w.toString());
            svgElement.setAttributeNS(null,'width',h.toString());
            returnsvgElement;
        }
        /**
         *CreatesaSVGrectelement.
         *
         *@paramxElement'sxcoordinate
         *@paramyElement'sycoordinate
         *@paramwElement'swidthattribute
         *@paramhElement'sheightattribute
         */
        createSvgRectElement(x,y,w,h){
            constrect=document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS,'rect');
            rect.setAttributeNS(null,'x',x.toString());
            rect.setAttributeNS(null,'y',y.toString());
            rect.setAttributeNS(null,'height',w.toString());
            rect.setAttributeNS(null,'width',h.toString());
            rect.setAttributeNS(null,'fill','#000000');
            returnrect;
        }
    }
    BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE=4;
    /**
     *SVGmarkupNameSpace
     */
    BrowserQRCodeSvgWriter.SVG_NS='http://www.w3.org/2000/svg';

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*importjava.util.Map;*/
    /**
     *ThisobjectrendersaQRCodeasaBitMatrix2Darrayofgreyscalevalues.
     *
     *@authordswitkin@google.com(DanielSwitkin)
     */
    classQRCodeWriter{
        /*@Override*/
        //publicencode(contents:string,format:BarcodeFormat,width:number/*int*/,height:number/*int*/):BitMatrix
        //    /*throwsWriterException*/{
        //  returnencode(contents,format,width,height,null)
        //}
        /*@Override*/
        encode(contents,format,width/*int*/,height/*int*/,hints){
            if(contents.length===0){
                thrownewIllegalArgumentException('Foundemptycontents');
            }
            if(format!==BarcodeFormat$1.QR_CODE){
                thrownewIllegalArgumentException('CanonlyencodeQR_CODE,butgot'+format);
            }
            if(width<0||height<0){
                thrownewIllegalArgumentException(`Requesteddimensionsaretoosmall:${width}x${height}`);
            }
            leterrorCorrectionLevel=ErrorCorrectionLevel.L;
            letquietZone=QRCodeWriter.QUIET_ZONE_SIZE;
            if(hints!==null){
                if(undefined!==hints.get(EncodeHintType$1.ERROR_CORRECTION)){
                    errorCorrectionLevel=ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
                }
                if(undefined!==hints.get(EncodeHintType$1.MARGIN)){
                    quietZone=Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(),10);
                }
            }
            constcode=Encoder.encode(contents,errorCorrectionLevel,hints);
            returnQRCodeWriter.renderResult(code,width,height,quietZone);
        }
        //Notethattheinputmatrixuses0==white,1==black,whiletheoutputmatrixuses
        //0==black,255==white(i.e.an8bitgreyscalebitmap).
        staticrenderResult(code,width/*int*/,height/*int*/,quietZone/*int*/){
            constinput=code.getMatrix();
            if(input===null){
                thrownewIllegalStateException();
            }
            constinputWidth=input.getWidth();
            constinputHeight=input.getHeight();
            constqrWidth=inputWidth+(quietZone*2);
            constqrHeight=inputHeight+(quietZone*2);
            constoutputWidth=Math.max(width,qrWidth);
            constoutputHeight=Math.max(height,qrHeight);
            constmultiple=Math.min(Math.floor(outputWidth/qrWidth),Math.floor(outputHeight/qrHeight));
            //Paddingincludesboththequietzoneandtheextrawhitepixelstoaccommodatetherequested
            //dimensions.Forexample,ifinputis25x25theQRwillbe33x33includingthequietzone.
            //Iftherequestedsizeis200x160,themultiplewillbe4,foraQRof132x132.Thesewill
            //handleallthepaddingfrom100x100(theactualQR)upto200x160.
            constleftPadding=Math.floor((outputWidth-(inputWidth*multiple))/2);
            consttopPadding=Math.floor((outputHeight-(inputHeight*multiple))/2);
            constoutput=newBitMatrix(outputWidth,outputHeight);
            for(letinputY=0,outputY=topPadding;inputY<inputHeight;inputY++,outputY+=multiple){
                //Writethecontentsofthisrowofthebarcode
                for(letinputX=0,outputX=leftPadding;inputX<inputWidth;inputX++,outputX+=multiple){
                    if(input.get(inputX,inputY)===1){
                        output.setRegion(outputX,outputY,multiple,multiple);
                    }
                }
            }
            returnoutput;
        }
    }
    QRCodeWriter.QUIET_ZONE_SIZE=4;

    /*
     *Copyright2008ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /*importjava.util.Map;*/
    /**
     *ThisisafactoryclasswhichfindstheappropriateWritersubclassfortheBarcodeFormat
     *requestedandencodesthebarcodewiththesuppliedcontents.
     *
     *@authordswitkin@google.com(DanielSwitkin)
     */
    classMultiFormatWriter{
        /*@Override*/
        //publicencode(contents:string,
        //                        format:BarcodeFormat,
        //                        width:number/*int*/,
        //                        height:number/*int*/):BitMatrix/*throwsWriterException*/{
        //  returnencode(contents,format,width,height,null)
        //}
        /*@Override*/
        encode(contents,format,width/*int*/,height/*int*/,hints){
            letwriter;
            switch(format){
                //caseBarcodeFormat.EAN_8:
                //  writer=newEAN8Writer()
                //  break
                //caseBarcodeFormat.UPC_E:
                //  writer=newUPCEWriter()
                //  break
                //caseBarcodeFormat.EAN_13:
                //  writer=newEAN13Writer()
                //  break
                //caseBarcodeFormat.UPC_A:
                //  writer=newUPCAWriter()
                //  break
                caseBarcodeFormat$1.QR_CODE:
                    writer=newQRCodeWriter();
                    break;
                //caseBarcodeFormat.CODE_39:
                //  writer=newCode39Writer()
                //  break
                //caseBarcodeFormat.CODE_93:
                //  writer=newCode93Writer()
                //  break
                //caseBarcodeFormat.CODE_128:
                //  writer=newCode128Writer()
                //  break
                //caseBarcodeFormat.ITF:
                //  writer=newITFWriter()
                //  break
                //caseBarcodeFormat.PDF_417:
                //  writer=newPDF417Writer()
                //  break
                //caseBarcodeFormat.CODABAR:
                //  writer=newCodaBarWriter()
                //  break
                //caseBarcodeFormat.DATA_MATRIX:
                //  writer=newDataMatrixWriter()
                //  break
                //caseBarcodeFormat.AZTEC:
                //  writer=newAztecWriter()
                //  break
                default:
                    thrownewIllegalArgumentException('Noencoderavailableforformat'+format);
            }
            returnwriter.encode(contents,format,width,height,hints);
        }
    }

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *ThisobjectextendsLuminanceSourcearoundanarrayofYUVdatareturnedfromthecameradriver,
     *withtheoptiontocroptoarectanglewithinthefulldata.Thiscanbeusedtoexclude
     *superfluouspixelsaroundtheperimeterandspeedupdecoding.
     *
     *ItworksforanypixelformatwheretheYchannelisplanarandappearsfirst,including
     *YCbCr_420_SPandYCbCr_422_SP.
     *
     *@authordswitkin@google.com(DanielSwitkin)
     */
    classPlanarYUVLuminanceSourceextendsLuminanceSource{
        constructor(yuvData,dataWidth/*int*/,dataHeight/*int*/,left/*int*/,top/*int*/,width/*int*/,height/*int*/,reverseHorizontal){
            super(width,height);
            this.yuvData=yuvData;
            this.dataWidth=dataWidth;
            this.dataHeight=dataHeight;
            this.left=left;
            this.top=top;
            if(left+width>dataWidth||top+height>dataHeight){
                thrownewIllegalArgumentException('Croprectangledoesnotfitwithinimagedata.');
            }
            if(reverseHorizontal){
                this.reverseHorizontal(width,height);
            }
        }
        /*@Override*/
        getRow(y/*int*/,row){
            if(y<0||y>=this.getHeight()){
                thrownewIllegalArgumentException('Requestedrowisoutsidetheimage:'+y);
            }
            constwidth=this.getWidth();
            if(row===null||row===undefined||row.length<width){
                row=newUint8ClampedArray(width);
            }
            constoffset=(y+this.top)*this.dataWidth+this.left;
            System.arraycopy(this.yuvData,offset,row,0,width);
            returnrow;
        }
        /*@Override*/
        getMatrix(){
            constwidth=this.getWidth();
            constheight=this.getHeight();
            //Ifthecallerasksfortheentireunderlyingimage,savethecopyandgivethemthe
            //originaldata.Thedocsspecificallywarnthatresult.lengthmustbeignored.
            if(width===this.dataWidth&&height===this.dataHeight){
                returnthis.yuvData;
            }
            constarea=width*height;
            constmatrix=newUint8ClampedArray(area);
            letinputOffset=this.top*this.dataWidth+this.left;
            //Ifthewidthmatchesthefullwidthoftheunderlyingdata,performasinglecopy.
            if(width===this.dataWidth){
                System.arraycopy(this.yuvData,inputOffset,matrix,0,area);
                returnmatrix;
            }
            //Otherwisecopyonecroppedrowatatime.
            for(lety=0;y<height;y++){
                constoutputOffset=y*width;
                System.arraycopy(this.yuvData,inputOffset,matrix,outputOffset,width);
                inputOffset+=this.dataWidth;
            }
            returnmatrix;
        }
        /*@Override*/
        isCropSupported(){
            returntrue;
        }
        /*@Override*/
        crop(left/*int*/,top/*int*/,width/*int*/,height/*int*/){
            returnnewPlanarYUVLuminanceSource(this.yuvData,this.dataWidth,this.dataHeight,this.left+left,this.top+top,width,height,false);
        }
        renderThumbnail(){
            constwidth=this.getWidth()/PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
            constheight=this.getHeight()/PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
            constpixels=newInt32Array(width*height);
            constyuv=this.yuvData;
            letinputOffset=this.top*this.dataWidth+this.left;
            for(lety=0;y<height;y++){
                constoutputOffset=y*width;
                for(letx=0;x<width;x++){
                    constgrey=yuv[inputOffset+x*PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR]&0xff;
                    pixels[outputOffset+x]=0xFF000000|(grey*0x00010101);
                }
                inputOffset+=this.dataWidth*PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
            }
            returnpixels;
        }
        /**
         *@returnwidthofimagefrom{@link#renderThumbnail()}
         */
        getThumbnailWidth(){
            returnthis.getWidth()/PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        }
        /**
         *@returnheightofimagefrom{@link#renderThumbnail()}
         */
        getThumbnailHeight(){
            returnthis.getHeight()/PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        }
        reverseHorizontal(width/*int*/,height/*int*/){
            constyuvData=this.yuvData;
            for(lety=0,rowStart=this.top*this.dataWidth+this.left;y<height;y++,rowStart+=this.dataWidth){
                constmiddle=rowStart+width/2;
                for(letx1=rowStart,x2=rowStart+width-1;x1<middle;x1++,x2--){
                    consttemp=yuvData[x1];
                    yuvData[x1]=yuvData[x2];
                    yuvData[x2]=temp;
                }
            }
        }
        invert(){
            returnnewInvertedLuminanceSource(this);
        }
    }
    PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR=2;

    /*
     *Copyright2009ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *ThisclassisusedtohelpdecodeimagesfromfileswhicharriveasRGBdatafrom
     *anARGBpixelarray.Itdoesnotsupportrotation.
     *
     *@authordswitkin@google.com(DanielSwitkin)
     *@authorBetaminos
     */
    classRGBLuminanceSourceextendsLuminanceSource{
        constructor(luminances,width/*int*/,height/*int*/,dataWidth/*int*/,dataHeight/*int*/,left/*int*/,top/*int*/){
            super(width,height);
            this.dataWidth=dataWidth;
            this.dataHeight=dataHeight;
            this.left=left;
            this.top=top;
            if(luminances.BYTES_PER_ELEMENT===4){//Int32Array
                constsize=width*height;
                constluminancesUint8Array=newUint8ClampedArray(size);
                for(letoffset=0;offset<size;offset++){
                    constpixel=luminances[offset];
                    constr=(pixel>>16)&0xff;//red
                    constg2=(pixel>>7)&0x1fe;//2*green
                    constb=pixel&0xff;//blue
                    //Calculategreen-favouringaveragecheaply
                    luminancesUint8Array[offset]=/*(byte)*/((r+g2+b)/4)&0xFF;
                }
                this.luminances=luminancesUint8Array;
            }
            else{
                this.luminances=luminances;
            }
            if(undefined===dataWidth){
                this.dataWidth=width;
            }
            if(undefined===dataHeight){
                this.dataHeight=height;
            }
            if(undefined===left){
                this.left=0;
            }
            if(undefined===top){
                this.top=0;
            }
            if(this.left+width>this.dataWidth||this.top+height>this.dataHeight){
                thrownewIllegalArgumentException('Croprectangledoesnotfitwithinimagedata.');
            }
        }
        /*@Override*/
        getRow(y/*int*/,row){
            if(y<0||y>=this.getHeight()){
                thrownewIllegalArgumentException('Requestedrowisoutsidetheimage:'+y);
            }
            constwidth=this.getWidth();
            if(row===null||row===undefined||row.length<width){
                row=newUint8ClampedArray(width);
            }
            constoffset=(y+this.top)*this.dataWidth+this.left;
            System.arraycopy(this.luminances,offset,row,0,width);
            returnrow;
        }
        /*@Override*/
        getMatrix(){
            constwidth=this.getWidth();
            constheight=this.getHeight();
            //Ifthecallerasksfortheentireunderlyingimage,savethecopyandgivethemthe
            //originaldata.Thedocsspecificallywarnthatresult.lengthmustbeignored.
            if(width===this.dataWidth&&height===this.dataHeight){
                returnthis.luminances;
            }
            constarea=width*height;
            constmatrix=newUint8ClampedArray(area);
            letinputOffset=this.top*this.dataWidth+this.left;
            //Ifthewidthmatchesthefullwidthoftheunderlyingdata,performasinglecopy.
            if(width===this.dataWidth){
                System.arraycopy(this.luminances,inputOffset,matrix,0,area);
                returnmatrix;
            }
            //Otherwisecopyonecroppedrowatatime.
            for(lety=0;y<height;y++){
                constoutputOffset=y*width;
                System.arraycopy(this.luminances,inputOffset,matrix,outputOffset,width);
                inputOffset+=this.dataWidth;
            }
            returnmatrix;
        }
        /*@Override*/
        isCropSupported(){
            returntrue;
        }
        /*@Override*/
        crop(left/*int*/,top/*int*/,width/*int*/,height/*int*/){
            returnnewRGBLuminanceSource(this.luminances,width,height,this.dataWidth,this.dataHeight,this.left+left,this.top+top);
        }
        invert(){
            returnnewInvertedLuminanceSource(this);
        }
    }

    /**
     *JusttomakeashortcutbetweenJavacodeandTScode.
     */
    classCharsetextendsCharacterSetECI{
        staticforName(name){
            returnthis.getCharacterSetECIByName(name);
        }
    }

    /**
     *JusttomakeashortcutbetweenJavacodeandTScode.
     */
    classStandardCharsets{
    }
    StandardCharsets.ISO_8859_1=CharacterSetECI.ISO8859_1;

    /*
    *Copyright2013ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    /**
     *Aztec2Dcoderepresentation
     *
     *@authorRustamAbdullaev
     */
    /*publicfinal*/classAztecCode{
        /**
         *@return{@codetrue}ifcompactinsteadoffullmode
         */
        isCompact(){
            returnthis.compact;
        }
        setCompact(compact){
            this.compact=compact;
        }
        /**
         *@returnsizeinpixels(widthandheight)
         */
        getSize(){
            returnthis.size;
        }
        setSize(size){
            this.size=size;
        }
        /**
         *@returnnumberoflevels
         */
        getLayers(){
            returnthis.layers;
        }
        setLayers(layers){
            this.layers=layers;
        }
        /**
         *@returnnumberofdatacodewords
         */
        getCodeWords(){
            returnthis.codeWords;
        }
        setCodeWords(codeWords){
            this.codeWords=codeWords;
        }
        /**
         *@returnthesymbolimage
         */
        getMatrix(){
            returnthis.matrix;
        }
        setMatrix(matrix){
            this.matrix=matrix;
        }
    }

    classCollections{
        /**
         *ThesingletonList(T)methodisusedtoreturnanimmutablelistcontainingonlythespecifiedobject.
         */
        staticsingletonList(item){
            return[item];
        }
        /**
         *Themin(Collection<?extendsT>,Comparator<?superT>)methodisusedtoreturntheminimumelementofthegivencollection,accordingtotheorderinducedbythespecifiedcomparator.
         */
        staticmin(collection,comparator){
            returncollection.sort(comparator)[0];
        }
    }

    /*
    *Copyright2013ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    classToken{
        constructor(previous){
            this.previous=previous;
        }
        getPrevious(){
            returnthis.previous;
        }
    }

    /*
    *Copyright2013ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    /*final*/classSimpleTokenextendsToken{
        constructor(previous,value,bitCount){
            super(previous);
            this.value=value;
            this.bitCount=bitCount;
        }
        /**
         *@Override
         */
        appendTo(bitArray,text){
            bitArray.appendBits(this.value,this.bitCount);
        }
        add(value,bitCount){
            returnnewSimpleToken(this,value,bitCount);
        }
        addBinaryShift(start,byteCount){
            //no-opcan'tbinaryshiftasimpletoken
            console.warn('addBinaryShiftonSimpleToken,thissimplyreturnsacopyofthistoken');
            returnnewSimpleToken(this,start,byteCount);
        }
        /**
         *@Override
         */
        toString(){
            letvalue=this.value&((1<<this.bitCount)-1);
            value|=1<<this.bitCount;
            return'<'+Integer.toBinaryString(value|(1<<this.bitCount)).substring(1)+'>';
        }
    }

    /*
    *Copyright2013ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    /*final*/classBinaryShiftTokenextendsSimpleToken{
        constructor(previous,binaryShiftStart,binaryShiftByteCount){
            super(previous,0,0);
            this.binaryShiftStart=binaryShiftStart;
            this.binaryShiftByteCount=binaryShiftByteCount;
        }
        /**
         *@Override
         */
        appendTo(bitArray,text){
            for(leti=0;i<this.binaryShiftByteCount;i++){
                if(i===0||(i===31&&this.binaryShiftByteCount<=62)){
                    //Weneedaheaderbeforethefirstcharacter,andbefore
                    //character31whenthetotalbytecodeis<=62
                    bitArray.appendBits(31,5);//BINARY_SHIFT
                    if(this.binaryShiftByteCount>62){
                        bitArray.appendBits(this.binaryShiftByteCount-31,16);
                    }
                    elseif(i===0){
                        //1<=binaryShiftByteCode<=62
                        bitArray.appendBits(Math.min(this.binaryShiftByteCount,31),5);
                    }
                    else{
                        //32<=binaryShiftCount<=62andi==31
                        bitArray.appendBits(this.binaryShiftByteCount-31,5);
                    }
                }
                bitArray.appendBits(text[this.binaryShiftStart+i],8);
            }
        }
        addBinaryShift(start,byteCount){
            //intbitCount=(byteCount*8)+(byteCount<=31?10:byteCount<=62?20:21);
            returnnewBinaryShiftToken(this,start,byteCount);
        }
        /**
         *@Override
         */
        toString(){
            return'<'+this.binaryShiftStart+'::'+(this.binaryShiftStart+this.binaryShiftByteCount-1)+'>';
        }
    }

    functionaddBinaryShift(token,start,byteCount){
        //intbitCount=(byteCount*8)+(byteCount<=31?10:byteCount<=62?20:21);
        returnnewBinaryShiftToken(token,start,byteCount);
    }
    functionadd(token,value,bitCount){
        returnnewSimpleToken(token,value,bitCount);
    }

    const/*final*/MODE_NAMES=[
        'UPPER',
        'LOWER',
        'DIGIT',
        'MIXED',
        'PUNCT'
    ];
    const/*final*/MODE_UPPER=0;//5bits
    const/*final*/MODE_LOWER=1;//5bits
    const/*final*/MODE_DIGIT=2;//4bits
    const/*final*/MODE_MIXED=3;//5bits
    const/*final*/MODE_PUNCT=4;//5bits
    constEMPTY_TOKEN=newSimpleToken(null,0,0);

    //TheLatchTableshows,foreachpairofModes,theoptimalmethodfor
    //gettingfromonemodetoanother. Intheworstpossiblecase,thiscan
    //beupto14bits. Inthebestpossiblecase,wearealreadythere!
    //Thehighhalf-wordofeachentrygivesthenumberofbits.
    //Thelowhalf-wordofeachentryaretheactualbitsnecessarytochange
    constLATCH_TABLE=[
        Int32Array.from([
            0,
            (5<<16)+28,
            (5<<16)+30,
            (5<<16)+29,
            (10<<16)+(29<<5)+30//UPPER->MIXED->PUNCT
        ]),
        Int32Array.from([
            (9<<16)+(30<<4)+14,
            0,
            (5<<16)+30,
            (5<<16)+29,
            (10<<16)+(29<<5)+30//LOWER->MIXED->PUNCT
        ]),
        Int32Array.from([
            (4<<16)+14,
            (9<<16)+(14<<5)+28,
            0,
            (9<<16)+(14<<5)+29,
            (14<<16)+(14<<10)+(29<<5)+30
            //DIGIT->UPPER->MIXED->PUNCT
        ]),
        Int32Array.from([
            (5<<16)+29,
            (5<<16)+28,
            (10<<16)+(29<<5)+30,
            0,
            (5<<16)+30//MIXED->PUNCT
        ]),
        Int32Array.from([
            (5<<16)+31,
            (10<<16)+(31<<5)+28,
            (10<<16)+(31<<5)+30,
            (10<<16)+(31<<5)+29,
            0
        ])
    ];

    functionstatic_SHIFT_TABLE(SHIFT_TABLE){
        for(lettable/*Int32Array*/ofSHIFT_TABLE){
            Arrays.fill(table,-1);
        }
        SHIFT_TABLE[MODE_UPPER][MODE_PUNCT]=0;
        SHIFT_TABLE[MODE_LOWER][MODE_PUNCT]=0;
        SHIFT_TABLE[MODE_LOWER][MODE_UPPER]=28;
        SHIFT_TABLE[MODE_MIXED][MODE_PUNCT]=0;
        SHIFT_TABLE[MODE_DIGIT][MODE_PUNCT]=0;
        SHIFT_TABLE[MODE_DIGIT][MODE_UPPER]=15;
        returnSHIFT_TABLE;
    }
    const/*final*/SHIFT_TABLE=static_SHIFT_TABLE(Arrays.createInt32Array(6,6));//modeshiftcodes,pertable

    /*
     *Copyright2013ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *Staterepresentsallinformationaboutasequencenecessarytogeneratethecurrentoutput.
     *Notethatastateisimmutable.
     */
    /*final*/classState{
        constructor(token,mode,binaryBytes,bitCount){
            this.token=token;
            this.mode=mode;
            this.binaryShiftByteCount=binaryBytes;
            this.bitCount=bitCount;
            //Makesurewematchthetoken
            //intbinaryShiftBitCount=(binaryShiftByteCount*8)+
            //   (binaryShiftByteCount===0?0:
            //    binaryShiftByteCount<=31?10:
            //    binaryShiftByteCount<=62?20:21);
            //assertthis.bitCount===token.getTotalBitCount()+binaryShiftBitCount;
        }
        getMode(){
            returnthis.mode;
        }
        getToken(){
            returnthis.token;
        }
        getBinaryShiftByteCount(){
            returnthis.binaryShiftByteCount;
        }
        getBitCount(){
            returnthis.bitCount;
        }
        //Createanewstaterepresentingthisstatewithalatchtoa(not
        //necessarydifferent)mode,andthenacode.
        latchAndAppend(mode,value){
            //assertbinaryShiftByteCount===0;
            letbitCount=this.bitCount;
            lettoken=this.token;
            if(mode!==this.mode){
                letlatch=LATCH_TABLE[this.mode][mode];
                token=add(token,latch&0xffff,latch>>16);
                bitCount+=latch>>16;
            }
            letlatchModeBitCount=mode===MODE_DIGIT?4:5;
            token=add(token,value,latchModeBitCount);
            returnnewState(token,mode,0,bitCount+latchModeBitCount);
        }
        //Createanewstaterepresentingthisstate,withatemporaryshift
        //toadifferentmodetooutputasinglevalue.
        shiftAndAppend(mode,value){
            //assertbinaryShiftByteCount===0&&this.mode!==mode;
            lettoken=this.token;
            letthisModeBitCount=this.mode===MODE_DIGIT?4:5;
            //ShiftsexistonlytoUPPERandPUNCT,bothwithtokenssize5.
            token=add(token,SHIFT_TABLE[this.mode][mode],thisModeBitCount);
            token=add(token,value,5);
            returnnewState(token,this.mode,0,this.bitCount+thisModeBitCount+5);
        }
        //Createanewstaterepresentingthisstate,butanadditionalcharacter
        //outputinBinaryShiftmode.
        addBinaryShiftChar(index){
            lettoken=this.token;
            letmode=this.mode;
            letbitCount=this.bitCount;
            if(this.mode===MODE_PUNCT||this.mode===MODE_DIGIT){
                //assertbinaryShiftByteCount===0;
                letlatch=LATCH_TABLE[mode][MODE_UPPER];
                token=add(token,latch&0xffff,latch>>16);
                bitCount+=latch>>16;
                mode=MODE_UPPER;
            }
            letdeltaBitCount=this.binaryShiftByteCount===0||this.binaryShiftByteCount===31
                ?18
                :this.binaryShiftByteCount===62
                    ?9
                    :8;
            letresult=newState(token,mode,this.binaryShiftByteCount+1,bitCount+deltaBitCount);
            if(result.binaryShiftByteCount===2047+31){
                //Thestringisaslongasit'sallowedtobe. Weshouldendit.
                result=result.endBinaryShift(index+1);
            }
            returnresult;
        }
        //Createthestateidenticaltothisone,butwearenolongerin
        //BinaryShiftmode.
        endBinaryShift(index){
            if(this.binaryShiftByteCount===0){
                returnthis;
            }
            lettoken=this.token;
            token=addBinaryShift(token,index-this.binaryShiftByteCount,this.binaryShiftByteCount);
            //asserttoken.getTotalBitCount()===this.bitCount;
            returnnewState(token,this.mode,0,this.bitCount);
        }
        //Returnstrueif"this"stateisbetter(equal:or)tobeinthan"that"
        //stateunderallpossiblecircumstances.
        isBetterThanOrEqualTo(other){
            letnewModeBitCount=this.bitCount+(LATCH_TABLE[this.mode][other.mode]>>16);
            if(this.binaryShiftByteCount<other.binaryShiftByteCount){
                //addadditionalB/Sencodingcostofother,ifany
                newModeBitCount+=
                    State.calculateBinaryShiftCost(other)-
                        State.calculateBinaryShiftCost(this);
            }
            elseif(this.binaryShiftByteCount>other.binaryShiftByteCount&&
                other.binaryShiftByteCount>0){
                //maximumpossibleadditionalcost(it:h)
                newModeBitCount+=10;
            }
            returnnewModeBitCount<=other.bitCount;
        }
        toBitArray(text){
            //Reversethetokens,sothattheyareintheorderthattheyshould
            //beoutput
            letsymbols=[];
            for(lettoken=this.endBinaryShift(text.length).token;token!==null;token=token.getPrevious()){
                symbols.unshift(token);
            }
            letbitArray=newBitArray();
            //Addeachtokentotheresult.
            for(constsymbolofsymbols){
                symbol.appendTo(bitArray,text);
            }
            //assertbitArray.getSize()===this.bitCount;
            returnbitArray;
        }
        /**
         *@Override
         */
        toString(){
            returnStringUtils.format('%sbits=%dbytes=%d',MODE_NAMES[this.mode],this.bitCount,this.binaryShiftByteCount);
        }
        staticcalculateBinaryShiftCost(state){
            if(state.binaryShiftByteCount>62){
                return21;//B/Swithextendedlength
            }
            if(state.binaryShiftByteCount>31){
                return20;//twoB/S
            }
            if(state.binaryShiftByteCount>0){
                return10;//oneB/S
            }
            return0;
        }
    }
    State.INITIAL_STATE=newState(EMPTY_TOKEN,MODE_UPPER,0,0);

    functionstatic_CHAR_MAP(CHAR_MAP){
        constspaceCharCode=StringUtils.getCharCode('');
        constpointCharCode=StringUtils.getCharCode('.');
        constcommaCharCode=StringUtils.getCharCode(',');
        CHAR_MAP[MODE_UPPER][spaceCharCode]=1;
        constzUpperCharCode=StringUtils.getCharCode('Z');
        constaUpperCharCode=StringUtils.getCharCode('A');
        for(letc=aUpperCharCode;c<=zUpperCharCode;c++){
            CHAR_MAP[MODE_UPPER][c]=c-aUpperCharCode+2;
        }
        CHAR_MAP[MODE_LOWER][spaceCharCode]=1;
        constzLowerCharCode=StringUtils.getCharCode('z');
        constaLowerCharCode=StringUtils.getCharCode('a');
        for(letc=aLowerCharCode;c<=zLowerCharCode;c++){
            CHAR_MAP[MODE_LOWER][c]=c-aLowerCharCode+2;
        }
        CHAR_MAP[MODE_DIGIT][spaceCharCode]=1;
        constnineCharCode=StringUtils.getCharCode('9');
        constzeroCharCode=StringUtils.getCharCode('0');
        for(letc=zeroCharCode;c<=nineCharCode;c++){
            CHAR_MAP[MODE_DIGIT][c]=c-zeroCharCode+2;
        }
        CHAR_MAP[MODE_DIGIT][commaCharCode]=12;
        CHAR_MAP[MODE_DIGIT][pointCharCode]=13;
        constmixedTable=[
            '\x00',
            '',
            '\x01',
            '\x02',
            '\x03',
            '\x04',
            '\x05',
            '\x06',
            '\x07',
            '\b',
            '\t',
            '\n',
            '\x0b',
            '\f',
            '\r',
            '\x1b',
            '\x1c',
            '\x1d',
            '\x1e',
            '\x1f',
            '@',
            '\\',
            '^',
            '_',
            '`',
            '|',
            '~',
            '\x7f'
        ];
        for(leti=0;i<mixedTable.length;i++){
            CHAR_MAP[MODE_MIXED][StringUtils.getCharCode(mixedTable[i])]=i;
        }
        constpunctTable=[
            '\x00',
            '\r',
            '\x00',
            '\x00',
            '\x00',
            '\x00',
            '!',
            '\'',
            '#',
            '$',
            '%',
            '&',
            '\'',
            '(',
            ')',
            '*',
            '+',
            ',',
            '-',
            '.',
            '/',
            ':',
            ';',
            '<',
            '=',
            '>',
            '?',
            '[',
            ']',
            '{',
            '}'
        ];
        for(leti=0;i<punctTable.length;i++){
            if(StringUtils.getCharCode(punctTable[i])>0){
                CHAR_MAP[MODE_PUNCT][StringUtils.getCharCode(punctTable[i])]=i;
            }
        }
        returnCHAR_MAP;
    }
    constCHAR_MAP=static_CHAR_MAP(Arrays.createInt32Array(5,256));

    /*
     *Copyright2013ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    /**
     *Thisproducesnearlyoptimalencodingsoftextintothefirst-levelof
     *encodingusedbyAzteccode.
     *
     *Itusesadynamicalgorithm. Foreachprefixofthestring,itdetermines
     *asetofencodingsthatcouldleadtothisprefix. Werepeatedlyadda
     *characterandgenerateanewsetofoptimalencodingsuntilwehaveread
     *throughtheentireinput.
     *
     *@authorFrankYellin
     *@authorRustamAbdullaev
     */
    /*publicfinal*/classHighLevelEncoder{
        constructor(text){
            this.text=text;
        }
        /**
         *@returntextrepresentedbythisencoderencodedasa{@linkBitArray}
         */
        encode(){
            constspaceCharCode=StringUtils.getCharCode('');
            constlineBreakCharCode=StringUtils.getCharCode('\n');
            letstates=Collections.singletonList(State.INITIAL_STATE);
            for(letindex=0;index<this.text.length;index++){
                letpairCode;
                letnextChar=index+1<this.text.length?this.text[index+1]:0;
                switch(this.text[index]){
                    caseStringUtils.getCharCode('\r'):
                        pairCode=nextChar===lineBreakCharCode?2:0;
                        break;
                    caseStringUtils.getCharCode('.'):
                        pairCode=nextChar===spaceCharCode?3:0;
                        break;
                    caseStringUtils.getCharCode(','):
                        pairCode=nextChar===spaceCharCode?4:0;
                        break;
                    caseStringUtils.getCharCode(':'):
                        pairCode=nextChar===spaceCharCode?5:0;
                        break;
                    default:
                        pairCode=0;
                }
                if(pairCode>0){
                    //WehaveoneofthefourspecialPUNCTpairs. Treatthemspecially.
                    //Getanewsetofstatesforthetwonewcharacters.
                    states=HighLevelEncoder.updateStateListForPair(states,index,pairCode);
                    index++;
                }
                else{
                    //Getanewsetofstatesforthenewcharacter.
                    states=this.updateStateListForChar(states,index);
                }
            }
            //Weareleftwithasetofstates. Findtheshortestone.
            constminState=Collections.min(states,(a,b)=>{
                returna.getBitCount()-b.getBitCount();
            });
            //Convertittoabitarray,andreturn.
            returnminState.toBitArray(this.text);
        }
        //Weupdateasetofstatesforanewcharacterbyupdatingeachstate
        //forthenewcharacter,mergingtheresults,andthenremovingthe
        //non-optimalstates.
        updateStateListForChar(states,index){
            constresult=[];
            for(letstate/*State*/ofstates){
                this.updateStateForChar(state,index,result);
            }
            returnHighLevelEncoder.simplifyStates(result);
        }
        //Returnasetofstatesthatrepresentthepossiblewaysofupdatingthis
        //stateforthenextcharacter. Theresultingsetofstatesareaddedto
        //the"result"list.
        updateStateForChar(state,index,result){
            letch=(this.text[index]&0xff);
            letcharInCurrentTable=CHAR_MAP[state.getMode()][ch]>0;
            letstateNoBinary=null;
            for(letmode/*int*/=0;mode<=MODE_PUNCT;mode++){
                letcharInMode=CHAR_MAP[mode][ch];
                if(charInMode>0){
                    if(stateNoBinary==null){
                        //OnlycreatestateNoBinarythefirsttimeit'srequired.
                        stateNoBinary=state.endBinaryShift(index);
                    }
                    //Trygeneratingthecharacterbylatchingtoitsmode
                    if(!charInCurrentTable||
                        mode===state.getMode()||
                        mode===MODE_DIGIT){
                        //Ifthecharacterisinthecurrenttable,wedon'twanttolatchto
                        //anyothermodeexceptpossiblydigit(whichusesonly4bits). Any
                        //otherlatchwouldbeequallysuccessful*after*thischaracter,and
                        //sowouldn'tsaveanybits.
                        constlatchState=stateNoBinary.latchAndAppend(mode,charInMode);
                        result.push(latchState);
                    }
                    //Trygeneratingthecharacterbyswitchingtoitsmode.
                    if(!charInCurrentTable&&
                        SHIFT_TABLE[state.getMode()][mode]>=0){
                        //Itnevermakessensetotemporarilyshifttoanothermodeifthe
                        //characterexistsinthecurrentmode. Thatcanneversavebits.
                        constshiftState=stateNoBinary.shiftAndAppend(mode,charInMode);
                        result.push(shiftState);
                    }
                }
            }
            if(state.getBinaryShiftByteCount()>0||
                CHAR_MAP[state.getMode()][ch]===0){
                //It'sneverworthwhiletogointobinaryshiftmodeifyou'renotalready
                //inbinaryshiftmode,andthecharacterexistsinyourcurrentmode.
                //Thatcanneversavebitsoverjustoutputtingthecharinthecurrentmode.
                letbinaryState=state.addBinaryShiftChar(index);
                result.push(binaryState);
            }
        }
        staticupdateStateListForPair(states,index,pairCode){
            constresult=[];
            for(letstate/*State*/ofstates){
                this.updateStateForPair(state,index,pairCode,result);
            }
            returnthis.simplifyStates(result);
        }
        staticupdateStateForPair(state,index,pairCode,result){
            letstateNoBinary=state.endBinaryShift(index);
            //Possibility1. LatchtoC.MODE_PUNCT,andthenappendthiscode
            result.push(stateNoBinary.latchAndAppend(MODE_PUNCT,pairCode));
            if(state.getMode()!==MODE_PUNCT){
                //Possibility2. ShifttoC.MODE_PUNCT,andthenappendthiscode.
                //EverystateexceptC.MODE_PUNCT(handledabove)canshift
                result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT,pairCode));
            }
            if(pairCode===3||pairCode===4){
                //bothcharactersareinDIGITS. Sometimesbettertojustaddtwodigits
                letdigitState=stateNoBinary
                    .latchAndAppend(MODE_DIGIT,16-pairCode)//periodorcommainDIGIT
                    .latchAndAppend(MODE_DIGIT,1);//spaceinDIGIT
                result.push(digitState);
            }
            if(state.getBinaryShiftByteCount()>0){
                //Itonlymakessensetodothecharactersasbinaryifwe'realready
                //inbinarymode.
                letbinaryState=state
                    .addBinaryShiftChar(index)
                    .addBinaryShiftChar(index+1);
                result.push(binaryState);
            }
        }
        staticsimplifyStates(states){
            letresult=[];
            for(constnewStateofstates){
                letadd=true;
                for(constoldStateofresult){
                    if(oldState.isBetterThanOrEqualTo(newState)){
                        add=false;
                        break;
                    }
                    if(newState.isBetterThanOrEqualTo(oldState)){
                        //iterator.remove();
                        result=result.filter(x=>x!==oldState);//removeoldstate
                    }
                }
                if(add){
                    result.push(newState);
                }
            }
            returnresult;
        }
    }

    /*
     *Copyright2013ZXingauthors
     *
     *LicensedundertheApacheLicense,Version2.0(the"License");
     *youmaynotusethisfileexceptincompliancewiththeLicense.
     *YoumayobtainacopyoftheLicenseat
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
     *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
     *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
     *SeetheLicenseforthespecificlanguagegoverningpermissionsand
     *limitationsundertheLicense.
     */
    //packagecom.google.zxing.aztec.encoder;
    //importcom.google.zxing.common.BitArray;
    //importcom.google.zxing.common.BitMatrix;
    //importcom.google.zxing.common.reedsolomon.GenericGF;
    //importcom.google.zxing.common.reedsolomon.ReedSolomonEncoder;
    /**
     *GeneratesAztec2Dbarcodes.
     *
     *@authorRustamAbdullaev
     */
    /*publicfinal*/classEncoder$1{
        constructor(){
        }
        /**
         *EncodesthegivenbinarycontentasanAztecsymbol
         *
         *@paramdatainputdatastring
         *@returnAztecsymbolmatrixwithmetadata
         */
        staticencodeBytes(data){
            returnEncoder$1.encode(data,Encoder$1.DEFAULT_EC_PERCENT,Encoder$1.DEFAULT_AZTEC_LAYERS);
        }
        /**
         *EncodesthegivenbinarycontentasanAztecsymbol
         *
         *@paramdatainputdatastring
         *@paramminECCPercentminimalpercentageoferrorcheckwords(AccordingtoISO/IEC24778:2008,
         *                     aminimumof23%+3wordsisrecommended)
         *@paramuserSpecifiedLayersifnon-zero,auser-specifiedvalueforthenumberoflayers
         *@returnAztecsymbolmatrixwithmetadata
         */
        staticencode(data,minECCPercent,userSpecifiedLayers){
            //High-levelencode
            letbits=newHighLevelEncoder(data).encode();
            //stuffbitsandchoosesymbolsize
            leteccBits=Integer.truncDivision((bits.getSize()*minECCPercent),100)+11;
            lettotalSizeBits=bits.getSize()+eccBits;
            letcompact;
            letlayers;
            lettotalBitsInLayer;
            letwordSize;
            letstuffedBits;
            if(userSpecifiedLayers!==Encoder$1.DEFAULT_AZTEC_LAYERS){
                compact=userSpecifiedLayers<0;
                layers=Math.abs(userSpecifiedLayers);
                if(layers>(compact?Encoder$1.MAX_NB_BITS_COMPACT:Encoder$1.MAX_NB_BITS)){
                    thrownewIllegalArgumentException(StringUtils.format('Illegalvalue%sforlayers',userSpecifiedLayers));
                }
                totalBitsInLayer=Encoder$1.totalBitsInLayer(layers,compact);
                wordSize=Encoder$1.WORD_SIZE[layers];
                letusableBitsInLayers=totalBitsInLayer-(totalBitsInLayer%wordSize);
                stuffedBits=Encoder$1.stuffBits(bits,wordSize);
                if(stuffedBits.getSize()+eccBits>usableBitsInLayers){
                    thrownewIllegalArgumentException('Datatolargeforuserspecifiedlayer');
                }
                if(compact&&stuffedBits.getSize()>wordSize*64){
                    //Compactformatonlyallows64datawords,thoughC4canholdmorewordsthanthat
                    thrownewIllegalArgumentException('Datatolargeforuserspecifiedlayer');
                }
            }
            else{
                wordSize=0;
                stuffedBits=null;
                //WelookatthepossibletablesizesintheorderCompact1,Compact2,Compact3,
                //Compact4,Normal4,... Normal(i)fori<4isn'ttypicallyusedsinceCompact(i+1)
                //isthesamesize,buthasmoredata.
                for(leti/*int*/=0;;i++){
                    if(i>Encoder$1.MAX_NB_BITS){
                        thrownewIllegalArgumentException('DatatoolargeforanAzteccode');
                    }
                    compact=i<=3;
                    layers=compact?i+1:i;
                    totalBitsInLayer=Encoder$1.totalBitsInLayer(layers,compact);
                    if(totalSizeBits>totalBitsInLayer){
                        continue;
                    }
                    //[Re]stuffthebitsifthisisthefirstopportunity,orifthe
                    //wordSizehaschanged
                    if(stuffedBits==null||wordSize!==Encoder$1.WORD_SIZE[layers]){
                        wordSize=Encoder$1.WORD_SIZE[layers];
                        stuffedBits=Encoder$1.stuffBits(bits,wordSize);
                    }
                    letusableBitsInLayers=totalBitsInLayer-(totalBitsInLayer%wordSize);
                    if(compact&&stuffedBits.getSize()>wordSize*64){
                        //Compactformatonlyallows64datawords,thoughC4canholdmorewordsthanthat
                        continue;
                    }
                    if(stuffedBits.getSize()+eccBits<=usableBitsInLayers){
                        break;
                    }
                }
            }
            letmessageBits=Encoder$1.generateCheckWords(stuffedBits,totalBitsInLayer,wordSize);
            //generatemodemessage
            letmessageSizeInWords=stuffedBits.getSize()/wordSize;
            letmodeMessage=Encoder$1.generateModeMessage(compact,layers,messageSizeInWords);
            //allocatesymbol
            letbaseMatrixSize=(compact?11:14)+layers*4;//notincludingalignmentlines
            letalignmentMap=newInt32Array(baseMatrixSize);
            letmatrixSize;
            if(compact){
                //noalignmentmarksincompactmode,alignmentMapisano-op
                matrixSize=baseMatrixSize;
                for(leti/*int*/=0;i<alignmentMap.length;i++){
                    alignmentMap[i]=i;
                }
            }
            else{
                matrixSize=baseMatrixSize+1+2*Integer.truncDivision((Integer.truncDivision(baseMatrixSize,2)-1),15);
                letorigCenter=Integer.truncDivision(baseMatrixSize,2);
                letcenter=Integer.truncDivision(matrixSize,2);
                for(leti/*int*/=0;i<origCenter;i++){
                    letnewOffset=i+Integer.truncDivision(i,15);
                    alignmentMap[origCenter-i-1]=center-newOffset-1;
                    alignmentMap[origCenter+i]=center+newOffset+1;
                }
            }
            letmatrix=newBitMatrix(matrixSize);
            //drawdatabits
            for(leti/*int*/=0,rowOffset=0;i<layers;i++){
                letrowSize=(layers-i)*4+(compact?9:12);
                for(letj/*int*/=0;j<rowSize;j++){
                    letcolumnOffset=j*2;
                    for(letk/*int*/=0;k<2;k++){
                        if(messageBits.get(rowOffset+columnOffset+k)){
                            matrix.set(alignmentMap[i*2+k],alignmentMap[i*2+j]);
                        }
                        if(messageBits.get(rowOffset+rowSize*2+columnOffset+k)){
                            matrix.set(alignmentMap[i*2+j],alignmentMap[baseMatrixSize-1-i*2-k]);
                        }
                        if(messageBits.get(rowOffset+rowSize*4+columnOffset+k)){
                            matrix.set(alignmentMap[baseMatrixSize-1-i*2-k],alignmentMap[baseMatrixSize-1-i*2-j]);
                        }
                        if(messageBits.get(rowOffset+rowSize*6+columnOffset+k)){
                            matrix.set(alignmentMap[baseMatrixSize-1-i*2-j],alignmentMap[i*2+k]);
                        }
                    }
                }
                rowOffset+=rowSize*8;
            }
            //drawmodemessage
            Encoder$1.drawModeMessage(matrix,compact,matrixSize,modeMessage);
            //drawalignmentmarks
            if(compact){
                Encoder$1.drawBullsEye(matrix,Integer.truncDivision(matrixSize,2),5);
            }
            else{
                Encoder$1.drawBullsEye(matrix,Integer.truncDivision(matrixSize,2),7);
                for(leti/*int*/=0,j=0;i<Integer.truncDivision(baseMatrixSize,2)-1;i+=15,j+=16){
                    for(letk/*int*/=Integer.truncDivision(matrixSize,2)&1;k<matrixSize;k+=2){
                        matrix.set(Integer.truncDivision(matrixSize,2)-j,k);
                        matrix.set(Integer.truncDivision(matrixSize,2)+j,k);
                        matrix.set(k,Integer.truncDivision(matrixSize,2)-j);
                        matrix.set(k,Integer.truncDivision(matrixSize,2)+j);
                    }
                }
            }
            letaztec=newAztecCode();
            aztec.setCompact(compact);
            aztec.setSize(matrixSize);
            aztec.setLayers(layers);
            aztec.setCodeWords(messageSizeInWords);
            aztec.setMatrix(matrix);
            returnaztec;
        }
        staticdrawBullsEye(matrix,center,size){
            for(leti/*int*/=0;i<size;i+=2){
                for(letj/*int*/=center-i;j<=center+i;j++){
                    matrix.set(j,center-i);
                    matrix.set(j,center+i);
                    matrix.set(center-i,j);
                    matrix.set(center+i,j);
                }
            }
            matrix.set(center-size,center-size);
            matrix.set(center-size+1,center-size);
            matrix.set(center-size,center-size+1);
            matrix.set(center+size,center-size);
            matrix.set(center+size,center-size+1);
            matrix.set(center+size,center+size-1);
        }
        staticgenerateModeMessage(compact,layers,messageSizeInWords){
            letmodeMessage=newBitArray();
            if(compact){
                modeMessage.appendBits(layers-1,2);
                modeMessage.appendBits(messageSizeInWords-1,6);
                modeMessage=Encoder$1.generateCheckWords(modeMessage,28,4);
            }
            else{
                modeMessage.appendBits(layers-1,5);
                modeMessage.appendBits(messageSizeInWords-1,11);
                modeMessage=Encoder$1.generateCheckWords(modeMessage,40,4);
            }
            returnmodeMessage;
        }
        staticdrawModeMessage(matrix,compact,matrixSize,modeMessage){
            letcenter=Integer.truncDivision(matrixSize,2);
            if(compact){
                for(leti/*int*/=0;i<7;i++){
                    letoffset=center-3+i;
                    if(modeMessage.get(i)){
                        matrix.set(offset,center-5);
                    }
                    if(modeMessage.get(i+7)){
                        matrix.set(center+5,offset);
                    }
                    if(modeMessage.get(20-i)){
                        matrix.set(offset,center+5);
                    }
                    if(modeMessage.get(27-i)){
                        matrix.set(center-5,offset);
                    }
                }
            }
            else{
                for(leti/*int*/=0;i<10;i++){
                    letoffset=center-5+i+Integer.truncDivision(i,5);
                    if(modeMessage.get(i)){
                        matrix.set(offset,center-7);
                    }
                    if(modeMessage.get(i+10)){
                        matrix.set(center+7,offset);
                    }
                    if(modeMessage.get(29-i)){
                        matrix.set(offset,center+7);
                    }
                    if(modeMessage.get(39-i)){
                        matrix.set(center-7,offset);
                    }
                }
            }
        }
        staticgenerateCheckWords(bitArray,totalBits,wordSize){
            //bitArrayisguaranteedtobeamultipleofthewordSize,sonopaddingneeded
            letmessageSizeInWords=bitArray.getSize()/wordSize;
            letrs=newReedSolomonEncoder(Encoder$1.getGF(wordSize));
            lettotalWords=Integer.truncDivision(totalBits,wordSize);
            letmessageWords=Encoder$1.bitsToWords(bitArray,wordSize,totalWords);
            rs.encode(messageWords,totalWords-messageSizeInWords);
            letstartPad=totalBits%wordSize;
            letmessageBits=newBitArray();
            messageBits.appendBits(0,startPad);
            for(constmessageWord/*:int*/ofArray.from(messageWords)){
                messageBits.appendBits(messageWord,wordSize);
            }
            returnmessageBits;
        }
        staticbitsToWords(stuffedBits,wordSize,totalWords){
            letmessage=newInt32Array(totalWords);
            leti;
            letn;
            for(i=0,n=stuffedBits.getSize()/wordSize;i<n;i++){
                letvalue=0;
                for(letj/*int*/=0;j<wordSize;j++){
                    value|=stuffedBits.get(i*wordSize+j)?(1<<wordSize-j-1):0;
                }
                message[i]=value;
            }
            returnmessage;
        }
        staticgetGF(wordSize){
            switch(wordSize){
                case4:
                    returnGenericGF.AZTEC_PARAM;
                case6:
                    returnGenericGF.AZTEC_DATA_6;
                case8:
                    returnGenericGF.AZTEC_DATA_8;
                case10:
                    returnGenericGF.AZTEC_DATA_10;
                case12:
                    returnGenericGF.AZTEC_DATA_12;
                default:
                    thrownewIllegalArgumentException('Unsupportedwordsize'+wordSize);
            }
        }
        staticstuffBits(bits,wordSize){
            letout=newBitArray();
            letn=bits.getSize();
            letmask=(1<<wordSize)-2;
            for(leti/*int*/=0;i<n;i+=wordSize){
                letword=0;
                for(letj/*int*/=0;j<wordSize;j++){
                    if(i+j>=n||bits.get(i+j)){
                        word|=1<<(wordSize-1-j);
                    }
                }
                if((word&mask)===mask){
                    out.appendBits(word&mask,wordSize);
                    i--;
                }
                elseif((word&mask)===0){
                    out.appendBits(word|1,wordSize);
                    i--;
                }
                else{
                    out.appendBits(word,wordSize);
                }
            }
            returnout;
        }
        statictotalBitsInLayer(layers,compact){
            return((compact?88:112)+16*layers)*layers;
        }
    }
    Encoder$1.DEFAULT_EC_PERCENT=33;//defaultminimalpercentageoferrorcheckwords
    Encoder$1.DEFAULT_AZTEC_LAYERS=0;
    Encoder$1.MAX_NB_BITS=32;
    Encoder$1.MAX_NB_BITS_COMPACT=4;
    Encoder$1.WORD_SIZE=Int32Array.from([
        4,6,6,8,8,8,8,8,8,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
        12,12,12,12,12,12,12,12,12,12
    ]);

    /*
    *Copyright2013ZXingauthors
    *
    *LicensedundertheApacheLicense,Version2.0(the"License");
    *youmaynotusethisfileexceptincompliancewiththeLicense.
    *YoumayobtainacopyoftheLicenseat
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    *Unlessrequiredbyapplicablelaworagreedtoinwriting,software
    *distributedundertheLicenseisdistributedonan"ASIS"BASIS,
    *WITHOUTWARRANTIESORCONDITIONSOFANYKIND,eitherexpressorimplied.
    *SeetheLicenseforthespecificlanguagegoverningpermissionsand
    *limitationsundertheLicense.
    */
    /**
     *RendersanAzteccodeasa{@linkBitMatrix}.
     */
    /*publicfinal*/classAztecWriter{
        //@Override
        encode(contents,format,width,height){
            returnthis.encodeWithHints(contents,format,width,height,null);
        }
        //@Override
        encodeWithHints(contents,format,width,height,hints){
            letcharset=StandardCharsets.ISO_8859_1;
            leteccPercent=Encoder$1.DEFAULT_EC_PERCENT;
            letlayers=Encoder$1.DEFAULT_AZTEC_LAYERS;
            if(hints!=null){
                if(hints.has(EncodeHintType$1.CHARACTER_SET)){
                    charset=Charset.forName(hints.get(EncodeHintType$1.CHARACTER_SET).toString());
                }
                if(hints.has(EncodeHintType$1.ERROR_CORRECTION)){
                    eccPercent=Integer.parseInt(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
                }
                if(hints.has(EncodeHintType$1.AZTEC_LAYERS)){
                    layers=Integer.parseInt(hints.get(EncodeHintType$1.AZTEC_LAYERS).toString());
                }
            }
            returnAztecWriter.encodeLayers(contents,format,width,height,charset,eccPercent,layers);
        }
        staticencodeLayers(contents,format,width,height,charset,eccPercent,layers){
            if(format!==BarcodeFormat$1.AZTEC){
                thrownewIllegalArgumentException('CanonlyencodeAZTEC,butgot'+format);
            }
            letaztec=Encoder$1.encode(StringUtils.getBytes(contents,charset),eccPercent,layers);
            returnAztecWriter.renderResult(aztec,width,height);
        }
        staticrenderResult(code,width,height){
            letinput=code.getMatrix();
            if(input==null){
                thrownewIllegalStateException();
            }
            letinputWidth=input.getWidth();
            letinputHeight=input.getHeight();
            letoutputWidth=Math.max(width,inputWidth);
            letoutputHeight=Math.max(height,inputHeight);
            letmultiple=Math.min(outputWidth/inputWidth,outputHeight/inputHeight);
            letleftPadding=(outputWidth-(inputWidth*multiple))/2;
            lettopPadding=(outputHeight-(inputHeight*multiple))/2;
            letoutput=newBitMatrix(outputWidth,outputHeight);
            for(letinputY/*int*/=0,outputY=topPadding;inputY<inputHeight;inputY++,outputY+=multiple){
                //Writethecontentsofthisrowofthebarcode
                for(letinputX/*int*/=0,outputX=leftPadding;inputX<inputWidth;inputX++,outputX+=multiple){
                    if(input.get(inputX,inputY)){
                        output.setRegion(outputX,outputY,multiple,multiple);
                    }
                }
            }
            returnoutput;
        }
    }

    exports.AbstractExpandedDecoder=AbstractExpandedDecoder;
    exports.ArgumentException=ArgumentException;
    exports.ArithmeticException=ArithmeticException;
    exports.AztecCode=AztecCode;
    exports.AztecCodeReader=AztecReader;
    exports.AztecCodeWriter=AztecWriter;
    exports.AztecDecoder=Decoder;
    exports.AztecDetector=Detector;
    exports.AztecDetectorResult=AztecDetectorResult;
    exports.AztecEncoder=Encoder$1;
    exports.AztecHighLevelEncoder=HighLevelEncoder;
    exports.AztecPoint=Point;
    exports.BarcodeFormat=BarcodeFormat$1;
    exports.Binarizer=Binarizer;
    exports.BinaryBitmap=BinaryBitmap;
    exports.BitArray=BitArray;
    exports.BitMatrix=BitMatrix;
    exports.BitSource=BitSource;
    exports.BrowserAztecCodeReader=BrowserAztecCodeReader;
    exports.BrowserBarcodeReader=BrowserBarcodeReader;
    exports.BrowserCodeReader=BrowserCodeReader;
    exports.BrowserDatamatrixCodeReader=BrowserDatamatrixCodeReader;
    exports.BrowserMultiFormatReader=BrowserMultiFormatReader;
    exports.BrowserPDF417Reader=BrowserPDF417Reader;
    exports.BrowserQRCodeReader=BrowserQRCodeReader;
    exports.BrowserQRCodeSvgWriter=BrowserQRCodeSvgWriter;
    exports.CharacterSetECI=CharacterSetECI;
    exports.ChecksumException=ChecksumException;
    exports.Code128Reader=Code128Reader;
    exports.Code39Reader=Code39Reader;
    exports.DataMatrixDecodedBitStreamParser=DecodedBitStreamParser;
    exports.DataMatrixReader=DataMatrixReader;
    exports.DecodeHintType=DecodeHintType$1;
    exports.DecoderResult=DecoderResult;
    exports.DefaultGridSampler=DefaultGridSampler;
    exports.DetectorResult=DetectorResult;
    exports.EAN13Reader=EAN13Reader;
    exports.EncodeHintType=EncodeHintType$1;
    exports.Exception=Exception;
    exports.FormatException=FormatException;
    exports.GenericGF=GenericGF;
    exports.GenericGFPoly=GenericGFPoly;
    exports.GlobalHistogramBinarizer=GlobalHistogramBinarizer;
    exports.GridSampler=GridSampler;
    exports.GridSamplerInstance=GridSamplerInstance;
    exports.HTMLCanvasElementLuminanceSource=HTMLCanvasElementLuminanceSource;
    exports.HybridBinarizer=HybridBinarizer;
    exports.ITFReader=ITFReader;
    exports.IllegalArgumentException=IllegalArgumentException;
    exports.IllegalStateException=IllegalStateException;
    exports.InvertedLuminanceSource=InvertedLuminanceSource;
    exports.LuminanceSource=LuminanceSource;
    exports.MathUtils=MathUtils;
    exports.MultiFormatOneDReader=MultiFormatOneDReader;
    exports.MultiFormatReader=MultiFormatReader;
    exports.MultiFormatWriter=MultiFormatWriter;
    exports.NotFoundException=NotFoundException;
    exports.OneDReader=OneDReader;
    exports.PDF417DecodedBitStreamParser=DecodedBitStreamParser$2;
    exports.PDF417DecoderErrorCorrection=ErrorCorrection;
    exports.PDF417Reader=PDF417Reader;
    exports.PDF417ResultMetadata=PDF417ResultMetadata;
    exports.PerspectiveTransform=PerspectiveTransform;
    exports.PlanarYUVLuminanceSource=PlanarYUVLuminanceSource;
    exports.QRCodeByteMatrix=ByteMatrix;
    exports.QRCodeDataMask=DataMask;
    exports.QRCodeDecodedBitStreamParser=DecodedBitStreamParser$1;
    exports.QRCodeDecoderErrorCorrectionLevel=ErrorCorrectionLevel;
    exports.QRCodeDecoderFormatInformation=FormatInformation;
    exports.QRCodeEncoder=Encoder;
    exports.QRCodeEncoderQRCode=QRCode;
    exports.QRCodeMaskUtil=MaskUtil;
    exports.QRCodeMatrixUtil=MatrixUtil;
    exports.QRCodeMode=Mode$1;
    exports.QRCodeReader=QRCodeReader;
    exports.QRCodeVersion=Version$1;
    exports.QRCodeWriter=QRCodeWriter;
    exports.RGBLuminanceSource=RGBLuminanceSource;
    exports.RSS14Reader=RSS14Reader;
    exports.RSSExpandedReader=RSSExpandedReader;
    exports.ReaderException=ReaderException;
    exports.ReedSolomonDecoder=ReedSolomonDecoder;
    exports.ReedSolomonEncoder=ReedSolomonEncoder;
    exports.ReedSolomonException=ReedSolomonException;
    exports.Result=Result;
    exports.ResultMetadataType=ResultMetadataType$1;
    exports.ResultPoint=ResultPoint;
    exports.StringUtils=StringUtils;
    exports.UnsupportedOperationException=UnsupportedOperationException;
    exports.VideoInputDevice=VideoInputDevice;
    exports.WhiteRectangleDetector=WhiteRectangleDetector;
    exports.WriterException=WriterException;
    exports.ZXingArrays=Arrays;
    exports.ZXingCharset=Charset;
    exports.ZXingInteger=Integer;
    exports.ZXingStandardCharsets=StandardCharsets;
    exports.ZXingStringBuilder=StringBuilder;
    exports.ZXingStringEncoding=StringEncoding;
    exports.ZXingSystem=System;
    exports.createAbstractExpandedDecoder=createDecoder;

    Object.defineProperty(exports,'__esModule',{value:true});

})));

flectra.define('pos_restaurant.SplitBillScreen',function(require){
    'usestrict';

    constPosComponent=require('point_of_sale.PosComponent');
    const{useState}=owl.hooks;
    const{useListener}=require('web.custom_hooks');
    constmodels=require('point_of_sale.models');
    constRegistries=require('point_of_sale.Registries');

    classSplitBillScreenextendsPosComponent{
        constructor(){
            super(...arguments);
            useListener('click-line',this.onClickLine);
            this.splitlines=useState(this._initSplitLines(this.env.pos.get_order()));
            this.newOrderLines={};
            this.newOrder=newmodels.Order(
                {},
                {
                    pos:this.env.pos,
                    temporary:true,
                }
            );
            this._isFinal=false;
        }
        mounted(){
            this.env.pos.on('change:selectedOrder',this._resetState,this);
        }
        willUnmount(){
            this.env.pos.off('change:selectedOrder',null,this);
        }
        getcurrentOrder(){
            returnthis.env.pos.get_order();
        }
        getorderlines(){
            returnthis.currentOrder.get_orderlines();
        }
        onClickLine(event){
            constline=event.detail;
            this._splitQuantity(line);
            this._updateNewOrder(line);
        }
        back(){
            this.showScreen('ProductScreen');
        }
        proceed(){
            if(_.isEmpty(this.splitlines))
                //Splitlinesisempty
                return;

            this._isFinal=true;
            deletethis.newOrder.temporary;

            if(this._isFullPayOrder()){
                this.showScreen('PaymentScreen');
            }else{
                this._setQuantityOnCurrentOrder();

                this.newOrder.set_screen_data({name:'PaymentScreen'});

                //forthekitchenprinterweassumethateverything
                //hasalreadybeensenttothekitchenbeforesplitting
                //thebill.Sowesaveallchangesbothfortheold
                //orderandforthenewone.Thisisnotentirelycorrect
                //butavoidsfloodingthekitchenwithunnecessaryorders.
                //Notsurewhattodointhiscase.

                if(this.newOrder.saveChanges){
                    this.currentOrder.saveChanges();
                    this.newOrder.saveChanges();
                }

                this.newOrder.set_customer_count(1);
                constnewCustomerCount=this.currentOrder.get_customer_count()-1;
                this.currentOrder.set_customer_count(newCustomerCount||1);
                this.currentOrder.set_screen_data({name:'ProductScreen'});

                this.env.pos.get('orders').add(this.newOrder);
                this.env.pos.set('selectedOrder',this.newOrder);
            }
        }
        /**
         *@param{models.Order}order
         *@returns{Object<{quantity:number}>}splitlines
         */
        _initSplitLines(order){
            constsplitlines={};
            for(letlineoforder.get_orderlines()){
                splitlines[line.id]={product:line.get_product().id,quantity:0};
            }
            returnsplitlines;
        }
        _splitQuantity(line){
            constsplit=this.splitlines[line.id];

            lettotalQuantity=0;

            this.env.pos.get_order().get_orderlines().forEach(function(orderLine){
                if(orderLine.get_product().id===split.product)
                    totalQuantity+=orderLine.get_quantity();
            });

            if(line.get_quantity()>0){
                if(!line.get_unit().is_pos_groupable){
                    if(split.quantity!==line.get_quantity()){
                        split.quantity=line.get_quantity();
                    }else{
                        split.quantity=0;
                    }
                }else{
                    if(split.quantity<totalQuantity){
                        split.quantity+=line.get_unit().is_pos_groupable?1:line.get_unit().rounding;
                        if(split.quantity>line.get_quantity()){
                            split.quantity=line.get_quantity();
                        }
                    }else{
                        split.quantity=0;
                    }
                }
            }
        }
        _updateNewOrder(line){
            constsplit=this.splitlines[line.id];
            letorderline=this.newOrderLines[line.id];
            if(split.quantity){
                if(!orderline){
                    orderline=line.clone();
                    this.newOrder.add_orderline(orderline);
                    this.newOrderLines[line.id]=orderline;
                }
                orderline.set_quantity(split.quantity,'donotrecomputeunitprice');
            }elseif(orderline){
                this.newOrder.remove_orderline(orderline);
                this.newOrderLines[line.id]=null;
            }
        }
        _isFullPayOrder(){
            letorder=this.env.pos.get_order();
            letfull=true;
            letsplitlines=this.splitlines;
            letgroupedLines=_.groupBy(order.get_orderlines(),line=>line.get_product().id);

            Object.keys(groupedLines).forEach(function(lineId){
                varmaxQuantity=groupedLines[lineId].reduce(((quantity,line)=>quantity+line.get_quantity()),0);
                Object.keys(splitlines).forEach(id=>{
                    letsplit=splitlines[id];
                    if(split.product===groupedLines[lineId][0].get_product().id)
                        maxQuantity-=split.quantity;
                });
                if(maxQuantity!==0)
                    full=false;
            });

            returnfull;
        }
        _setQuantityOnCurrentOrder(){
            letorder=this.env.pos.get_order();
            for(varidinthis.splitlines){
                varsplit=this.splitlines[id];
                varline=this.currentOrder.get_orderline(parseInt(id));

                if(!this.props.disallow){
                    line.set_quantity(
                        line.get_quantity()-split.quantity,
                        'donotrecomputeunitprice'
                    );
                    if(Math.abs(line.get_quantity())<0.00001){
                        this.currentOrder.remove_orderline(line);
                    }
                }else{
                    if(split.quantity){
                        letdecreaseLine=line.clone();
                        decreaseLine.order=order;
                        decreaseLine.noDecrease=true;
                        decreaseLine.set_quantity(-split.quantity);
                        order.add_orderline(decreaseLine);
                    }
                }
            }
        }
        _resetState(){
            if(this._isFinal)return;

            for(letidinthis.splitlines){
                deletethis.splitlines[id];
            }
            for(letlineofthis.currentOrder.get_orderlines()){
                this.splitlines[line.id]={quantity:0};
            }
            this.newOrder.orderlines.reset();
        }
    }
    SplitBillScreen.template='SplitBillScreen';

    Registries.Component.add(SplitBillScreen);

    returnSplitBillScreen;
});

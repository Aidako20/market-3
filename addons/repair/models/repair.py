#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

fromcollectionsimportdefaultdict
fromrandomimportrandint

fromflectraimportapi,fields,models,_
fromflectra.exceptionsimportUserError,ValidationError
fromflectra.toolsimportfloat_compare


classStockMove(models.Model):
    _inherit='stock.move'

    repair_id=fields.Many2one('repair.order',check_company=True)


classRepair(models.Model):
    _name='repair.order'
    _description='RepairOrder'
    _inherit=['mail.thread','mail.activity.mixin']
    _order='create_datedesc'

    name=fields.Char(
        'RepairReference',
        default='/',
        copy=False,required=True,
        states={'confirmed':[('readonly',True)]})
    product_id=fields.Many2one(
        'product.product',string='ProducttoRepair',
        domain="[('type','in',['product','consu']),'|',('company_id','=',company_id),('company_id','=',False)]",
        readonly=True,required=True,states={'draft':[('readonly',False)]},check_company=True)
    product_qty=fields.Float(
        'ProductQuantity',
        default=1.0,digits='ProductUnitofMeasure',
        readonly=True,required=True,states={'draft':[('readonly',False)]})
    product_uom=fields.Many2one(
        'uom.uom','ProductUnitofMeasure',
        readonly=True,required=True,states={'draft':[('readonly',False)]},domain="[('category_id','=',product_uom_category_id)]")
    product_uom_category_id=fields.Many2one(related='product_id.uom_id.category_id')
    partner_id=fields.Many2one(
        'res.partner','Customer',
        index=True,states={'confirmed':[('readonly',True)]},check_company=True,change_default=True,
        help='Choosepartnerforwhomtheorderwillbeinvoicedanddelivered.YoucanfindapartnerbyitsName,TIN,EmailorInternalReference.')
    address_id=fields.Many2one(
        'res.partner','DeliveryAddress',
        domain="[('parent_id','=',partner_id)]",check_company=True,
        states={'confirmed':[('readonly',True)]})
    default_address_id=fields.Many2one('res.partner',compute='_compute_default_address_id')
    state=fields.Selection([
        ('draft','Quotation'),
        ('confirmed','Confirmed'),
        ('under_repair','UnderRepair'),
        ('ready','ReadytoRepair'),
        ('2binvoiced','TobeInvoiced'),
        ('invoice_except','InvoiceException'),
        ('done','Repaired'),
        ('cancel','Cancelled')],string='Status',
        copy=False,default='draft',readonly=True,tracking=True,
        help="*The\'Draft\'statusisusedwhenauserisencodinganewandunconfirmedrepairorder.\n"
             "*The\'Confirmed\'statusisusedwhenauserconfirmstherepairorder.\n"
             "*The\'ReadytoRepair\'statusisusedtostarttorepairing,usercanstartrepairingonlyafterrepairorderisconfirmed.\n"
             "*The\'TobeInvoiced\'statusisusedtogeneratetheinvoicebeforeorafterrepairingdone.\n"
             "*The\'Done\'statusissetwhenrepairingiscompleted.\n"
             "*The\'Cancelled\'statusisusedwhenusercancelrepairorder.")
    location_id=fields.Many2one(
        'stock.location','Location',
        index=True,readonly=True,required=True,check_company=True,
        help="Thisisthelocationwheretheproducttorepairislocated.",
        states={'draft':[('readonly',False)],'confirmed':[('readonly',True)]})
    lot_id=fields.Many2one(
        'stock.production.lot','Lot/Serial',
        domain="[('product_id','=',product_id),('company_id','=',company_id)]",check_company=True,
        help="Productsrepairedareallbelongingtothislot")
    guarantee_limit=fields.Date('WarrantyExpiration',states={'confirmed':[('readonly',True)]})
    operations=fields.One2many(
        'repair.line','repair_id','Parts',
        copy=True,readonly=True,states={'draft':[('readonly',False)]})
    pricelist_id=fields.Many2one(
        'product.pricelist','Pricelist',
        default=lambdaself:self.env['product.pricelist'].search([('company_id','in',[self.env.company.id,False])],limit=1).id,
        help='Pricelistoftheselectedpartner.',check_company=True)
    currency_id=fields.Many2one(related='pricelist_id.currency_id')
    partner_invoice_id=fields.Many2one('res.partner','InvoicingAddress',check_company=True)
    invoice_method=fields.Selection([
        ("none","NoInvoice"),
        ("b4repair","BeforeRepair"),
        ("after_repair","AfterRepair")],string="InvoiceMethod",
        default='none',index=True,readonly=True,required=True,
        states={'draft':[('readonly',False)]},
        help='Selecting\'BeforeRepair\'or\'AfterRepair\'willallowyoutogenerateinvoicebeforeoraftertherepairisdonerespectively.\'Noinvoice\'meansyoudon\'twanttogenerateinvoiceforthisrepairorder.')
    invoice_id=fields.Many2one(
        'account.move','Invoice',
        copy=False,readonly=True,tracking=True,
        domain=[('move_type','=','out_invoice')])
    move_id=fields.Many2one(
        'stock.move','Move',
        copy=False,readonly=True,tracking=True,check_company=True,
        help="Movecreatedbytherepairorder")
    fees_lines=fields.One2many(
        'repair.fee','repair_id','Operations',
        copy=True,readonly=True,states={'draft':[('readonly',False)]})
    internal_notes=fields.Text('InternalNotes')
    quotation_notes=fields.Text('QuotationNotes')
    user_id=fields.Many2one('res.users',string="Responsible",default=lambdaself:self.env.user,check_company=True)
    company_id=fields.Many2one(
        'res.company','Company',
        readonly=True,required=True,index=True,
        default=lambdaself:self.env.company)
    tag_ids=fields.Many2many('repair.tags',string="Tags")
    invoiced=fields.Boolean('Invoiced',copy=False,readonly=True)
    repaired=fields.Boolean('Repaired',copy=False,readonly=True)
    amount_untaxed=fields.Float('UntaxedAmount',compute='_amount_untaxed',store=True)
    amount_tax=fields.Float('Taxes',compute='_amount_tax',store=True)
    amount_total=fields.Float('Total',compute='_amount_total',store=True)
    tracking=fields.Selection(string='ProductTracking',related="product_id.tracking",readonly=False)
    invoice_state=fields.Selection(string='InvoiceState',related='invoice_id.state')

    @api.depends('partner_id')
    def_compute_default_address_id(self):
        fororderinself:
            iforder.partner_id:
                order.default_address_id=order.partner_id.address_get(['contact'])['contact']

    @api.depends('operations.price_subtotal','invoice_method','fees_lines.price_subtotal','pricelist_id.currency_id')
    def_amount_untaxed(self):
        fororderinself:
            total=sum(operation.price_subtotalforoperationinorder.operations)
            total+=sum(fee.price_subtotalforfeeinorder.fees_lines)
            currency=order.pricelist_id.currency_idorself.env.company.currency_id
            order.amount_untaxed=currency.round(total)

    @api.depends('operations.price_unit','operations.product_uom_qty','operations.product_id',
                 'fees_lines.price_unit','fees_lines.product_uom_qty','fees_lines.product_id',
                 'pricelist_id.currency_id','partner_id')
    def_amount_tax(self):
        fororderinself:
            val=0.0
            currency=order.pricelist_id.currency_idorself.env.company.currency_id
            foroperationinorder.operations:
                ifoperation.tax_id:
                    tax_calculate=operation.tax_id.compute_all(operation.price_unit,currency,operation.product_uom_qty,operation.product_id,order.partner_id)
                    forcintax_calculate['taxes']:
                        val+=c['amount']
            forfeeinorder.fees_lines:
                iffee.tax_id:
                    tax_calculate=fee.tax_id.compute_all(fee.price_unit,currency,fee.product_uom_qty,fee.product_id,order.partner_id)
                    forcintax_calculate['taxes']:
                        val+=c['amount']
            order.amount_tax=val

    @api.depends('amount_untaxed','amount_tax')
    def_amount_total(self):
        fororderinself:
            currency=order.pricelist_id.currency_idorself.env.company.currency_id
            order.amount_total=currency.round(order.amount_untaxed+order.amount_tax)

    _sql_constraints=[
        ('name','unique(name)','ThenameoftheRepairOrdermustbeunique!'),
    ]

    @api.onchange('product_id')
    defonchange_product_id(self):
        self.guarantee_limit=False
        if(self.product_idandself.lot_idandself.lot_id.product_id!=self.product_id)ornotself.product_id:
            self.lot_id=False
        ifself.product_id:
            self.product_uom=self.product_id.uom_id.id

    @api.onchange('product_uom')
    defonchange_product_uom(self):
        res={}
        ifnotself.product_idornotself.product_uom:
            returnres
        ifself.product_uom.category_id!=self.product_id.uom_id.category_id:
            res['warning']={'title':_('Warning'),'message':_('Theproductunitofmeasureyouchosehasadifferentcategorythantheproductunitofmeasure.')}
            self.product_uom=self.product_id.uom_id.id
        returnres

    @api.onchange('partner_id')
    defonchange_partner_id(self):
        self=self.with_company(self.company_id)
        ifnotself.partner_id:
            self.address_id=False
            self.partner_invoice_id=False
            self.pricelist_id=self.env['product.pricelist'].search([
                ('company_id','in',[self.env.company.id,False]),
            ],limit=1)
        else:
            addresses=self.partner_id.address_get(['delivery','invoice','contact'])
            self.address_id=addresses['delivery']oraddresses['contact']
            self.partner_invoice_id=addresses['invoice']
            self.pricelist_id=self.partner_id.property_product_pricelist.id

    @api.onchange('company_id')
    def_onchange_company_id(self):
        ifself.company_id:
            ifself.location_id.company_id!=self.company_id:
                warehouse=self.env['stock.warehouse'].search([('company_id','=',self.company_id.id)],limit=1)
                self.location_id=warehouse.lot_stock_id
        else:
            self.location_id=False

    defunlink(self):
        fororderinself:
            iforder.state=='done':
                raiseUserError(_('Youcannotdeleteacompletedrepairorder.'))
            iforder.statenotin('draft','cancel'):
                raiseUserError(_('Youcannotdeletearepairorderonceithasbeenconfirmed.Youmustfirstcancelit.'))
            iforder.state=='cancel'andorder.invoice_idandorder.invoice_id.posted_before:
                raiseUserError(_('Youcannotdeletearepairorderwhichislinkedtoaninvoicewhichhasbeenpostedonce.'))
        returnsuper().unlink()

    @api.model
    defcreate(self,vals):
        #Toavoidconsumingasequencenumberwhenclickingon'Create',wepreprenditifthe
        #thenamestartswith'/'.
        vals['name']=vals.get('name')or'/'
        ifvals['name'].startswith('/'):
            vals['name']=(self.env['ir.sequence'].next_by_code('repair.order')or'/')+vals['name']
            vals['name']=vals['name'][:-1]ifvals['name'].endswith('/')andvals['name']!='/'elsevals['name']
        returnsuper(Repair,self).create(vals)

    defbutton_dummy(self):
        #TDEFIXME:thisbuttonisveryinteresting
        returnTrue

    defaction_repair_cancel_draft(self):
        ifself.filtered(lambdarepair:repair.state!='cancel'):
            raiseUserError(_("Repairmustbecanceledinordertoresetittodraft."))
        self.mapped('operations').write({'state':'draft'})
        returnself.write({'state':'draft','invoice_id':False})

    defaction_validate(self):
        self.ensure_one()
        ifself.filtered(lambdarepair:any(op.product_uom_qty<0foropinrepair.operations)):
            raiseUserError(_("Youcannotenternegativequantities."))
        self._check_product_tracking()
        ifself.product_id.type=='consu':
            returnself.action_repair_confirm()
        precision=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')
        available_qty_owner=self.env['stock.quant']._get_available_quantity(self.product_id,self.location_id,self.lot_id,owner_id=self.partner_id,strict=True)
        available_qty_noown=self.env['stock.quant']._get_available_quantity(self.product_id,self.location_id,self.lot_id,strict=True)
        repair_qty=self.product_uom._compute_quantity(self.product_qty,self.product_id.uom_id)
        foravailable_qtyin[available_qty_owner,available_qty_noown]:
            iffloat_compare(available_qty,repair_qty,precision_digits=precision)>=0:
                returnself.action_repair_confirm()
        else:
            return{
                'name':self.product_id.display_name+_(':InsufficientQuantityToRepair'),
                'view_mode':'form',
                'res_model':'stock.warn.insufficient.qty.repair',
                'view_id':self.env.ref('repair.stock_warn_insufficient_qty_repair_form_view').id,
                'type':'ir.actions.act_window',
                'context':{
                    'default_product_id':self.product_id.id,
                    'default_location_id':self.location_id.id,
                    'default_repair_id':self.id,
                    'default_quantity':repair_qty,
                    'default_product_uom_name':self.product_id.uom_name
                },
                'target':'new'
            }

    defaction_repair_confirm(self):
        """Repairorderstateissetto'Tobeinvoiced'wheninvoicemethod
        is'Beforerepair'elsestatebecomes'Confirmed'.
        @param*arg:Arguments
        @return:True
        """
        ifself.filtered(lambdarepair:repair.state!='draft'):
            raiseUserError(_("Onlydraftrepairscanbeconfirmed."))
        self._check_company()
        self.operations._check_company()
        self.fees_lines._check_company()
        before_repair=self.filtered(lambdarepair:repair.invoice_method=='b4repair')
        before_repair.write({'state':'2binvoiced'})
        to_confirm=self-before_repair
        to_confirm_operations=to_confirm.mapped('operations')
        to_confirm_operations.write({'state':'confirmed'})
        to_confirm.write({'state':'confirmed'})
        returnTrue

    defaction_repair_cancel(self):
        ifany(repair.state=='done'forrepairinself):
            raiseUserError(_("Youcannotcancelacompletedrepairorder."))
        invoice_to_cancel=self.filtered(lambdarepair:repair.invoice_id.state=='draft').invoice_id
        ifinvoice_to_cancel:
            invoice_to_cancel.button_cancel()
        self.mapped('operations').write({'state':'cancel'})
        returnself.write({'state':'cancel'})

    defaction_send_mail(self):
        self.ensure_one()
        template_id=self.env.ref('repair.mail_template_repair_quotation').id
        ctx={
            'default_model':'repair.order',
            'default_res_id':self.id,
            'default_use_template':bool(template_id),
            'default_template_id':template_id,
            'default_composition_mode':'comment',
            'custom_layout':'mail.mail_notification_light',
        }
        return{
            'type':'ir.actions.act_window',
            'view_mode':'form',
            'res_model':'mail.compose.message',
            'target':'new',
            'context':ctx,
        }

    defprint_repair_order(self):
        returnself.env.ref('repair.action_report_repair_order').report_action(self)

    defaction_repair_invoice_create(self):
        forrepairinself:
            repair._create_invoices()
            ifrepair.invoice_method=='b4repair':
                repair.action_repair_ready()
            elifrepair.invoice_method=='after_repair':
                repair.write({'state':'done'})
        returnTrue

    def_create_invoices(self,group=False):
        """Createsinvoice(s)forrepairorder.
        @paramgroup:Itissettotruewhengroupinvoiceistobegenerated.
        @return:InvoiceIds.
        """
        grouped_invoices_vals={}
        repairs=self.filtered(lambdarepair:repair.statenotin('draft','cancel')
                                               andnotrepair.invoice_id
                                               andrepair.invoice_method!='none')
        forrepairinrepairs:
            repair=repair.with_company(repair.company_id)
            partner_invoice=repair.partner_invoice_idorrepair.partner_id
            ifnotpartner_invoice:
                raiseUserError(_('Youhavetoselectaninvoiceaddressintherepairform.'))

            narration=repair.quotation_notes
            currency=repair.pricelist_id.currency_id
            company=repair.env.company

            journal=repair.env['account.move'].with_context(move_type='out_invoice')._get_default_journal()
            ifnotjournal:
                raiseUserError(_('Pleasedefineanaccountingsalesjournalforthecompany%s(%s).')%(company.name,company.id))

            if(partner_invoice.id,currency.id,company.id)notingrouped_invoices_vals:
                grouped_invoices_vals[(partner_invoice.id,currency.id,company.id)]=[]
            current_invoices_list=grouped_invoices_vals[(partner_invoice.id,currency.id,company.id)]

            ifnotgrouporlen(current_invoices_list)==0:
                fpos=self.env['account.fiscal.position'].get_fiscal_position(partner_invoice.id,delivery_id=repair.address_id.id)
                invoice_vals={
                    'move_type':'out_invoice',
                    'partner_id':partner_invoice.id,
                    'partner_shipping_id':repair.address_id.id,
                    'currency_id':currency.id,
                    'narration':narration,
                    'invoice_origin':repair.name,
                    'repair_ids':[(4,repair.id)],
                    'invoice_line_ids':[],
                    'fiscal_position_id':fpos.id
                }
                ifpartner_invoice.property_payment_term_id:
                    invoice_vals['invoice_payment_term_id']=partner_invoice.property_payment_term_id.id
                current_invoices_list.append(invoice_vals)
            else:
                #ifgroup==True:concatenateinvoicesbypartnerandcurrency
                invoice_vals=current_invoices_list[0]
                invoice_vals['invoice_origin']+=','+repair.name
                invoice_vals['repair_ids'].append((4,repair.id))
                ifnotinvoice_vals['narration']:
                    invoice_vals['narration']=narration
                else:
                    invoice_vals['narration']+='\n'+narration

            #Createinvoicelinesfromoperations.
            foroperationinrepair.operations.filtered(lambdaop:op.type=='add'):
                ifgroup:
                    name=repair.name+'-'+operation.name
                else:
                    name=operation.name

                account=operation.product_id.product_tmpl_id.get_product_accounts(fiscal_pos=fpos)['income']
                ifnotaccount:
                    raiseUserError(_('Noaccountdefinedforproduct"%s".',operation.product_id.name))

                invoice_line_vals={
                    'name':name,
                    'account_id':account.id,
                    'quantity':operation.product_uom_qty,
                    'tax_ids':[(6,0,operation.tax_id.ids)],
                    'product_uom_id':operation.product_uom.id,
                    'price_unit':operation.price_unit,
                    'product_id':operation.product_id.id,
                    'repair_line_ids':[(4,operation.id)],
                }

                ifcurrency==company.currency_id:
                    balance=-(operation.product_uom_qty*operation.price_unit)
                    invoice_line_vals.update({
                        'debit':balance>0.0andbalanceor0.0,
                        'credit':balance<0.0and-balanceor0.0,
                    })
                else:
                    amount_currency=-(operation.product_uom_qty*operation.price_unit)
                    balance=currency._convert(amount_currency,company.currency_id,company,fields.Date.today())
                    invoice_line_vals.update({
                        'amount_currency':amount_currency,
                        'debit':balance>0.0andbalanceor0.0,
                        'credit':balance<0.0and-balanceor0.0,
                        'currency_id':currency.id,
                    })
                invoice_vals['invoice_line_ids'].append((0,0,invoice_line_vals))

            #Createinvoicelinesfromfees.
            forfeeinrepair.fees_lines:
                ifgroup:
                    name=repair.name+'-'+fee.name
                else:
                    name=fee.name

                ifnotfee.product_id:
                    raiseUserError(_('Noproductdefinedonfees.'))

                account=fee.product_id.product_tmpl_id.get_product_accounts(fiscal_pos=fpos)['income']
                ifnotaccount:
                    raiseUserError(_('Noaccountdefinedforproduct"%s".',fee.product_id.name))

                invoice_line_vals={
                    'name':name,
                    'account_id':account.id,
                    'quantity':fee.product_uom_qty,
                    'tax_ids':[(6,0,fee.tax_id.ids)],
                    'product_uom_id':fee.product_uom.id,
                    'price_unit':fee.price_unit,
                    'product_id':fee.product_id.id,
                    'repair_fee_ids':[(4,fee.id)],
                }

                ifcurrency==company.currency_id:
                    balance=-(fee.product_uom_qty*fee.price_unit)
                    invoice_line_vals.update({
                        'debit':balance>0.0andbalanceor0.0,
                        'credit':balance<0.0and-balanceor0.0,
                    })
                else:
                    amount_currency=-(fee.product_uom_qty*fee.price_unit)
                    balance=currency._convert(amount_currency,company.currency_id,company,
                                                fields.Date.today())
                    invoice_line_vals.update({
                        'amount_currency':amount_currency,
                        'debit':balance>0.0andbalanceor0.0,
                        'credit':balance<0.0and-balanceor0.0,
                        'currency_id':currency.id,
                    })
                invoice_vals['invoice_line_ids'].append((0,0,invoice_line_vals))

        #Createinvoices.
        invoices_vals_list_per_company=defaultdict(list)
        for(partner_invoice_id,currency_id,company_id),invoicesingrouped_invoices_vals.items():
            forinvoiceininvoices:
                invoices_vals_list_per_company[company_id].append(invoice)

        forcompany_id,invoices_vals_listininvoices_vals_list_per_company.items():
            #VFETODOremovethedefault_company_idctxtkey?
            #Accountfallbacksonself.env.company,whichiscorrectwithwith_company
            self.env['account.move'].with_company(company_id).with_context(default_company_id=company_id,default_move_type='out_invoice').create(invoices_vals_list)

        repairs.write({'invoiced':True})
        repairs.mapped('operations').filtered(lambdaop:op.type=='add').write({'invoiced':True})
        repairs.mapped('fees_lines').write({'invoiced':True})

        returndict((repair.id,repair.invoice_id.id)forrepairinrepairs)

    defaction_created_invoice(self):
        self.ensure_one()
        return{
            'name':_('Invoicecreated'),
            'type':'ir.actions.act_window',
            'view_mode':'form',
            'res_model':'account.move',
            'view_id':self.env.ref('account.view_move_form').id,
            'target':'current',
            'res_id':self.invoice_id.id,
            }

    defaction_repair_ready(self):
        self.mapped('operations').write({'state':'confirmed'})
        returnself.write({'state':'ready'})

    defaction_repair_start(self):
        """Writesrepairorderstateto'UnderRepair'
        @return:True
        """
        ifself.filtered(lambdarepair:repair.statenotin['confirmed','ready']):
            raiseUserError(_("Repairmustbeconfirmedbeforestartingreparation."))
        self.mapped('operations').write({'state':'confirmed'})
        returnself.write({'state':'under_repair'})

    defaction_repair_end(self):
        """Writesrepairorderstateto'Tobeinvoiced'ifinvoicemethodis
        Afterrepairelsestateissetto'Ready'.
        @return:True
        """
        ifself.filtered(lambdarepair:repair.state!='under_repair'):
            raiseUserError(_("Repairmustbeunderrepairinordertoendreparation."))
        forrepairinself:
            repair.write({'repaired':True})
            vals={'state':'done'}
            vals['move_id']=repair.action_repair_done().get(repair.id)
            ifnotrepair.invoice_idandrepair.invoice_method=='after_repair':
                vals['state']='2binvoiced'
            repair.write(vals)
        returnTrue

    defaction_repair_done(self):
        """Createsstockmoveforoperationandstockmoveforfinalproductofrepairorder.
        @return:Moveidsoffinalproducts

        """
        ifself.filtered(lambdarepair:notrepair.repaired):
            raiseUserError(_("Repairmustberepairedinordertomaketheproductmoves."))
        self._check_company()
        self.operations._check_company()
        self.fees_lines._check_company()
        res={}
        precision=self.env['decimal.precision'].precision_get('ProductUnitofMeasure')
        Move=self.env['stock.move']
        forrepairinself:
            #Trytocreatemovewiththeappropriateowner
            owner_id=False
            available_qty_owner=self.env['stock.quant']._get_available_quantity(repair.product_id,repair.location_id,repair.lot_id,owner_id=repair.partner_id,strict=True)
            iffloat_compare(available_qty_owner,repair.product_qty,precision_digits=precision)>=0:
                owner_id=repair.partner_id.id

            moves=self.env['stock.move']
            foroperationinrepair.operations:
                move=Move.create({
                    'name':repair.name,
                    'product_id':operation.product_id.id,
                    'product_uom_qty':operation.product_uom_qty,
                    'product_uom':operation.product_uom.id,
                    'partner_id':repair.address_id.id,
                    'location_id':operation.location_id.id,
                    'location_dest_id':operation.location_dest_id.id,
                    'repair_id':repair.id,
                    'origin':repair.name,
                    'company_id':repair.company_id.id,
                })

                #Bestefforttoreservetheproductina(sub)-locationwhereitisavailable
                product_qty=move.product_uom._compute_quantity(
                    operation.product_uom_qty,move.product_id.uom_id,rounding_method='HALF-UP')
                available_quantity=self.env['stock.quant']._get_available_quantity(
                    move.product_id,
                    move.location_id,
                    lot_id=operation.lot_id,
                    strict=False,
                )
                move._update_reserved_quantity(
                    product_qty,
                    available_quantity,
                    move.location_id,
                    lot_id=operation.lot_id,
                    strict=False,
                )
                #Then,setthequantitydone.Iftherequiredquantitywasnotreserved,negative
                #quantiscreatedinoperation.location_id.
                move._set_quantity_done(operation.product_uom_qty)

                ifoperation.lot_id:
                    move.move_line_ids.lot_id=operation.lot_id

                moves|=move
                operation.write({'move_id':move.id,'state':'done'})
            move=Move.create({
                'name':repair.name,
                'product_id':repair.product_id.id,
                'product_uom':repair.product_uom.idorrepair.product_id.uom_id.id,
                'product_uom_qty':repair.product_qty,
                'partner_id':repair.address_id.id,
                'location_id':repair.location_id.id,
                'location_dest_id':repair.location_id.id,
                'move_line_ids':[(0,0,{'product_id':repair.product_id.id,
                                           'lot_id':repair.lot_id.id,
                                           'product_uom_qty':0, #bypassreservationhere
                                           'product_uom_id':repair.product_uom.idorrepair.product_id.uom_id.id,
                                           'qty_done':repair.product_qty,
                                           'package_id':False,
                                           'result_package_id':False,
                                           'owner_id':owner_id,
                                           'location_id':repair.location_id.id,#TODO:ownerstuff
                                           'company_id':repair.company_id.id,
                                           'location_dest_id':repair.location_id.id,})],
                'repair_id':repair.id,
                'origin':repair.name,
                'company_id':repair.company_id.id,
            })
            consumed_lines=moves.mapped('move_line_ids')
            produced_lines=move.move_line_ids
            moves|=move
            moves._action_done()
            produced_lines.write({'consume_line_ids':[(6,0,consumed_lines.ids)]})
            res[repair.id]=move.id
        returnres

    def_check_product_tracking(self):
        invalid_lines=self.operations.filtered(lambdax:x.product_id.tracking!='none'andnotx.lot_id)
        ifinvalid_lines:
            products=invalid_lines.product_id
            raiseValidationError(_(
                "Serialnumberisrequiredforoperationlineswithproducts:%s",
                ",".join(products.mapped('display_name')),
            ))


classRepairLine(models.Model):
    _name='repair.line'
    _description='RepairLine(parts)'

    name=fields.Text('Description',required=True)
    repair_id=fields.Many2one(
        'repair.order','RepairOrderReference',required=True,
        index=True,ondelete='cascade',check_company=True)
    company_id=fields.Many2one(
        related='repair_id.company_id',store=True,index=True)
    currency_id=fields.Many2one(
        related='repair_id.currency_id')
    type=fields.Selection([
        ('add','Add'),
        ('remove','Remove')],'Type',default='add',required=True)
    product_id=fields.Many2one(
        'product.product','Product',required=True,check_company=True,
        domain="[('type','in',['product','consu']),'|',('company_id','=',company_id),('company_id','=',False)]")
    invoiced=fields.Boolean('Invoiced',copy=False,readonly=True)
    price_unit=fields.Float('UnitPrice',required=True,digits='ProductPrice')
    price_subtotal=fields.Float('Subtotal',compute='_compute_price_subtotal',store=True,digits=0)
    price_total=fields.Float('Total',compute='_compute_price_total',compute_sudo=True,digits=0)
    tax_id=fields.Many2many(
        'account.tax','repair_operation_line_tax','repair_operation_line_id','tax_id','Taxes',
        domain="[('type_tax_use','=','sale'),('company_id','=',company_id)]",check_company=True)
    product_uom_qty=fields.Float(
        'Quantity',default=1.0,
        digits='ProductUnitofMeasure',required=True)
    product_uom=fields.Many2one(
        'uom.uom','ProductUnitofMeasure',
        required=True,domain="[('category_id','=',product_uom_category_id)]")
    product_uom_category_id=fields.Many2one(related='product_id.uom_id.category_id')
    invoice_line_id=fields.Many2one(
        'account.move.line','InvoiceLine',
        copy=False,readonly=True,check_company=True)
    location_id=fields.Many2one(
        'stock.location','SourceLocation',
        index=True,required=True,check_company=True)
    location_dest_id=fields.Many2one(
        'stock.location','Dest.Location',
        index=True,required=True,check_company=True)
    move_id=fields.Many2one(
        'stock.move','InventoryMove',
        copy=False,readonly=True)
    lot_id=fields.Many2one(
        'stock.production.lot','Lot/Serial',
        domain="[('product_id','=',product_id),('company_id','=',company_id)]",check_company=True)
    state=fields.Selection([
        ('draft','Draft'),
        ('confirmed','Confirmed'),
        ('done','Done'),
        ('cancel','Cancelled')],'Status',default='draft',
        copy=False,readonly=True,required=True,
        help='Thestatusofarepairlineissetautomaticallytotheoneofthelinkedrepairorder.')

    @api.depends('price_unit','repair_id','product_uom_qty','product_id','repair_id.invoice_method')
    def_compute_price_subtotal(self):
        forlineinself:
            taxes=line.tax_id.compute_all(line.price_unit,line.repair_id.pricelist_id.currency_id,line.product_uom_qty,line.product_id,line.repair_id.partner_id)
            line.price_subtotal=taxes['total_excluded']

    @api.depends('price_unit','repair_id','product_uom_qty','product_id','tax_id','repair_id.invoice_method')
    def_compute_price_total(self):
        forlineinself:
            taxes=line.tax_id.compute_all(line.price_unit,line.repair_id.pricelist_id.currency_id,line.product_uom_qty,line.product_id,line.repair_id.partner_id)
            line.price_total=taxes['total_included']

    @api.onchange('type')
    defonchange_operation_type(self):
        """Onchangeofoperationtypeitsetssourcelocation,destinationlocation
        andtoinvoicefield.
        @paramproduct:Changedoperationtype.
        @paramguarantee_limit:Guaranteelimitofcurrentrecord.
        @return:Dictionaryofvalues.
        """
        ifnotself.type:
            self.location_id=False
            self.location_dest_id=False
        elifself.type=='add':
            self.onchange_product_id()
            args=self.repair_id.company_idand[('company_id','=',self.repair_id.company_id.id)]or[]
            warehouse=self.env['stock.warehouse'].search(args,limit=1)
            self.location_id=warehouse.lot_stock_id
            self.location_dest_id=self.env['stock.location'].search([('usage','=','production'),('company_id','=',self.repair_id.company_id.id)],limit=1)
        else:
            self.price_unit=0.0
            self.tax_id=False
            self.location_id=self.env['stock.location'].search([('usage','=','production'),('company_id','=',self.repair_id.company_id.id)],limit=1).id
            self.location_dest_id=self.env['stock.location'].search([('scrap_location','=',True),('company_id','in',[self.repair_id.company_id.id,False])],limit=1).id

    @api.onchange('repair_id','product_id','product_uom_qty')
    defonchange_product_id(self):
        """Onchangeofproductitsetsproductquantity,taxaccount,name,
        uomofproduct,unitpriceandpricesubtotal."""
        ifnotself.product_idornotself.product_uom_qty:
            return
        self=self.with_company(self.company_id)
        partner=self.repair_id.partner_id
        partner_invoice=self.repair_id.partner_invoice_idorpartner
        ifpartner:
            self=self.with_context(lang=partner.lang)
        product=self.product_id
        self.name=product.display_name
        ifproduct.description_sale:
            ifpartner:
                self.name+='\n'+self.product_id.with_context(lang=partner.lang).description_sale
            else:
                self.name+='\n'+self.product_id.description_sale
        self.product_uom=product.uom_id.id
        ifself.type!='remove':
            ifpartner:
                fpos=self.env['account.fiscal.position'].get_fiscal_position(partner_invoice.id,delivery_id=self.repair_id.address_id.id)
                taxes=self.product_id.taxes_id.filtered(lambdax:x.company_id==self.repair_id.company_id)
                self.tax_id=fpos.map_tax(taxes,self.product_id,partner).ids
            warning=False
            pricelist=self.repair_id.pricelist_id
            ifnotpricelist:
                warning={
                    'title':_('Nopricelistfound.'),
                    'message':
                        _('YouhavetoselectapricelistintheRepairform!\nPleasesetonebeforechoosingaproduct.')}
                return{'warning':warning}
            else:
                self._onchange_product_uom()

    @api.onchange('product_uom')
    def_onchange_product_uom(self):
        partner=self.repair_id.partner_id
        pricelist=self.repair_id.pricelist_id
        ifpricelistandself.product_idandself.type!='remove':
            price=pricelist.get_product_price(self.product_id,self.product_uom_qty,partner,uom_id=self.product_uom.id)
            ifpriceisFalse:
                warning={
                    'title':_('Novalidpricelistlinefound.'),
                    'message':
                        _("Couldn'tfindapricelistlinematchingthisproductandquantity.\nYouhavetochangeeithertheproduct,thequantityorthepricelist.")}
                return{'warning':warning}
            else:
                self.price_unit=price


classRepairFee(models.Model):
    _name='repair.fee'
    _description='RepairFees'

    repair_id=fields.Many2one(
        'repair.order','RepairOrderReference',
        index=True,ondelete='cascade',required=True)
    company_id=fields.Many2one(
        related="repair_id.company_id",index=True,store=True)
    currency_id=fields.Many2one(
        related="repair_id.currency_id")
    name=fields.Text('Description',index=True,required=True)
    product_id=fields.Many2one(
        'product.product','Product',check_company=True,
        domain="[('type','=','service'),'|',('company_id','=',company_id),('company_id','=',False)]")
    product_uom_qty=fields.Float('Quantity',digits='ProductUnitofMeasure',required=True,default=1.0)
    price_unit=fields.Float('UnitPrice',required=True,digits='ProductPrice')
    product_uom=fields.Many2one('uom.uom','ProductUnitofMeasure',required=True,domain="[('category_id','=',product_uom_category_id)]")
    product_uom_category_id=fields.Many2one(related='product_id.uom_id.category_id')
    price_subtotal=fields.Float('Subtotal',compute='_compute_price_subtotal',store=True,digits=0)
    price_total=fields.Float('Total',compute='_compute_price_total',compute_sudo=True,digits=0)
    tax_id=fields.Many2many(
        'account.tax','repair_fee_line_tax','repair_fee_line_id','tax_id','Taxes',
        domain="[('type_tax_use','=','sale'),('company_id','=',company_id)]",check_company=True)
    invoice_line_id=fields.Many2one('account.move.line','InvoiceLine',copy=False,readonly=True,check_company=True)
    invoiced=fields.Boolean('Invoiced',copy=False,readonly=True)

    @api.depends('price_unit','repair_id','product_uom_qty','product_id')
    def_compute_price_subtotal(self):
        forfeeinself:
            taxes=fee.tax_id.compute_all(fee.price_unit,fee.repair_id.pricelist_id.currency_id,fee.product_uom_qty,fee.product_id,fee.repair_id.partner_id)
            fee.price_subtotal=taxes['total_excluded']

    @api.depends('price_unit','repair_id','product_uom_qty','product_id','tax_id')
    def_compute_price_total(self):
        forfeeinself:
            taxes=fee.tax_id.compute_all(fee.price_unit,fee.repair_id.pricelist_id.currency_id,fee.product_uom_qty,fee.product_id,fee.repair_id.partner_id)
            fee.price_total=taxes['total_included']

    @api.onchange('repair_id','product_id','product_uom_qty')
    defonchange_product_id(self):
        """Onchangeofproductitsetsproductquantity,taxaccount,name,
        uomofproduct,unitpriceandpricesubtotal."""
        ifnotself.product_id:
            return

        self=self.with_company(self.company_id)

        partner=self.repair_id.partner_id
        partner_invoice=self.repair_id.partner_invoice_idorpartner
        pricelist=self.repair_id.pricelist_id

        ifpartnerandself.product_id:
            fpos=self.env['account.fiscal.position'].get_fiscal_position(partner_invoice.id,delivery_id=self.repair_id.address_id.id)
            taxes=self.product_id.taxes_id.filtered(lambdax:x.company_id==self.repair_id.company_id)
            self.tax_id=fpos.map_tax(taxes,self.product_id,partner).ids
        ifpartner:
            self.name=self.product_id.with_context(lang=partner.lang).display_name
        else:
            self.name=self.product_id.display_name
        self.product_uom=self.product_id.uom_id.id
        ifself.product_id.description_sale:
            ifpartner:
                self.name+='\n'+self.product_id.with_context(lang=partner.lang).description_sale
            else:
                self.name+='\n'+self.product_id.description_sale

        warning=False
        ifnotpricelist:
            warning={
                'title':_('Nopricelistfound.'),
                'message':
                    _('YouhavetoselectapricelistintheRepairform!\nPleasesetonebeforechoosingaproduct.')}
            return{'warning':warning}
        else:
            self._onchange_product_uom()

    @api.onchange('product_uom')
    def_onchange_product_uom(self):
        partner=self.repair_id.partner_id
        pricelist=self.repair_id.pricelist_id
        ifpricelistandself.product_id:
            price=pricelist.get_product_price(self.product_id,self.product_uom_qty,partner,uom_id=self.product_uom.id)
            ifpriceisFalse:
                warning={
                    'title':_('Novalidpricelistlinefound.'),
                    'message':
                        _("Couldn'tfindapricelistlinematchingthisproductandquantity.\nYouhavetochangeeithertheproduct,thequantityorthepricelist.")}
                return{'warning':warning}
            else:
                self.price_unit=price


classRepairTags(models.Model):
    """TagsofRepair'stasks"""
    _name="repair.tags"
    _description="RepairTags"

    def_get_default_color(self):
        returnrandint(1,11)

    name=fields.Char('TagName',required=True)
    color=fields.Integer(string='ColorIndex',default=_get_default_color)

    _sql_constraints=[
        ('name_uniq','unique(name)',"Tagnamealreadyexists!"),
    ]

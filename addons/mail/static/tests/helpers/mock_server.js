flectra.define('mail.MockServer',function(require){
"usestrict";

const{nextAnimationFrame}=require('mail/static/src/utils/test_utils.js');

constMockServer=require('web.MockServer');

MockServer.include({
    /**
     *Param'data'mayhavekeysforthedifferentmagicpartners/users.
     *
     *Note:wemustdeletethesekeys,sothatthisisnot
     *handledasamodeldefinition.
     *
     *@override
     *@param{Object}[data.currentPartnerId]
     *@param{Object}[data.currentUserId]
     *@param{Object}[data.partnerRootId]
     *@param{Object}[data.publicPartnerId]
     *@param{Object}[data.publicUserId]
     *@param{Widget}[options.widget]mockedwidget(usetocallservices)
     */
    init(data,options){
        if(data&&data.currentPartnerId){
            this.currentPartnerId=data.currentPartnerId;
            deletedata.currentPartnerId;
        }
        if(data&&data.currentUserId){
            this.currentUserId=data.currentUserId;
            deletedata.currentUserId;
        }
        if(data&&data.partnerRootId){
            this.partnerRootId=data.partnerRootId;
            deletedata.partnerRootId;
        }
        if(data&&data.publicPartnerId){
            this.publicPartnerId=data.publicPartnerId;
            deletedata.publicPartnerId;
        }
        if(data&&data.publicUserId){
            this.publicUserId=data.publicUserId;
            deletedata.publicUserId;
        }
        this._widget=options.widget;

        this._super(...arguments);
    },

    //--------------------------------------------------------------------------
    //Private
    //--------------------------------------------------------------------------

    /**
     *@override
     */
    async_performFetch(resource,init){
        if(resource==='/web/binary/upload_attachment'){
            constformData=init.body;
            constmodel=formData.get('model');
            constid=parseInt(formData.get('id'));
            constufiles=formData.getAll('ufile');
            constcallback=formData.get('callback');

            constattachmentIds=[];
            for(constufileofufiles){
                constattachmentId=this._mockCreate('ir.attachment',{
                    //datas,
                    mimetype:ufile.type,
                    name:ufile.name,
                    res_id:id,
                    res_model:model,
                });
                attachmentIds.push(attachmentId);
            }
            constattachments=this._getRecords('ir.attachment',[['id','in',attachmentIds]]);
            constformattedAttachments=attachments.map(attachment=>{
                return{
                    'filename':attachment.name,
                    'id':attachment.id,
                    'mimetype':attachment.mimetype,
                    'size':attachment.file_size
                };
            });
            return{
                text(){
                    return`
                        <scriptlanguage="javascript"type="text/javascript">
                            varwin=window.top.window;
                            win.jQuery(win).trigger('${callback}',${JSON.stringify(formattedAttachments)});
                        </script>
                    `;
                },
            };
        }
        returnthis._super(...arguments);
    },
    /**
     *@override
     */
    async_performRpc(route,args){
        //routes
        if(route==='/mail/chat_post'){
            constuuid=args.uuid;
            constmessage_content=args.message_content;
            constcontext=args.context;
            returnthis._mockRouteMailChatPost(uuid,message_content,context);
        }
        if(route==='/mail/get_suggested_recipients'){
            constmodel=args.model;
            constres_ids=args.res_ids;
            returnthis._mockRouteMailGetSuggestedRecipient(model,res_ids);
        }
        if(route==='/mail/init_messaging'){
            returnthis._mockRouteMailInitMessaging();
        }
        if(route==='/mail/read_followers'){
            returnthis._mockRouteMailReadFollowers(args);
        }
        if(route==='/mail/read_subscription_data'){
            constfollower_id=args.follower_id;
            returnthis._mockRouteMailReadSubscriptionData(follower_id);
        }
        if(route==='/mail/thread/data'){
            returnthis._mockRouteMailThreadData(args.thread_model,args.thread_id,args.request_list);
        }
        //mail.activitymethods
        if(args.model==='mail.activity'&&args.method==='activity_format'){
            letres=this._mockRead(args.model,args.args,args.kwargs);
            res=res.map(function(record){
                if(record.mail_template_ids){
                    record.mail_template_ids=record.mail_template_ids.map(function(template_id){
                        return{id:template_id,name:"template"+template_id};
                    });
                }
                returnrecord;
            });
            returnres;
        }
        if(args.model==='mail.activity'&&args.method==='get_activity_data'){
            constres_model=args.args[0]||args.kwargs.res_model;
            constdomain=args.args[1]||args.kwargs.domain;
            returnthis._mockMailActivityGetActivityData(res_model,domain);
        }
        //mail.channelmethods
        if(args.model==='mail.channel'&&args.method==='channel_fetched'){
            constids=args.args[0];
            returnthis._mockMailChannelChannelFetched(ids);
        }
        if(args.model==='mail.channel'&&args.method==='channel_fetch_listeners'){
            return[];
        }
        if(args.model==='mail.channel'&&args.method==='channel_fetch_preview'){
            constids=args.args[0];
            returnthis._mockMailChannelChannelFetchPreview(ids);
        }
        if(args.model==='mail.channel'&&args.method==='channel_fold'){
            constuuid=args.args[0]||args.kwargs.uuid;
            conststate=args.args[1]||args.kwargs.state;
            returnthis._mockMailChannelChannelFold(uuid,state);
        }
        if(args.model==='mail.channel'&&args.method==='channel_get'){
            constpartners_to=args.args[0]||args.kwargs.partners_to;
            constpin=args.args[1]!==undefined
                ?args.args[1]
                :args.kwargs.pin!==undefined
                    ?args.kwargs.pin
                    :undefined;
            returnthis._mockMailChannelChannelGet(partners_to,pin);
        }
        if(args.model==='mail.channel'&&args.method==='channel_info'){
            constids=args.args[0];
            returnthis._mockMailChannelChannelInfo(ids);
        }
        if(args.model==='mail.channel'&&args.method==='channel_join_and_get_info'){
            constids=args.args[0];
            returnthis._mockMailChannelChannelJoinAndGetInfo(ids);
        }
        if(args.model==='mail.channel'&&args.method==='channel_minimize'){
            return;
        }
        if(args.model==='mail.channel'&&args.method==='channel_seen'){
            constchannel_ids=args.args[0];
            constlast_message_id=args.args[1]||args.kwargs.last_message_id;
            returnthis._mockMailChannelChannelSeen(channel_ids,last_message_id);
        }
        if(args.model==='mail.channel'&&args.method==='channel_set_custom_name'){
            constchannel_id=args.args[0]||args.kwargs.channel_id;
            constname=args.args[1]||args.kwargs.name;
            returnthis._mockMailChannelChannelSetCustomName(channel_id,name);
        }
        if(args.model==='mail.channel'&&args.method==='execute_command'){
            returnthis._mockMailChannelExecuteCommand(args);
        }
        if(args.model==='mail.channel'&&args.method==='message_post'){
            constid=args.args[0];
            constkwargs=args.kwargs;
            constcontext=kwargs.context;
            deletekwargs.context;
            returnthis._mockMailChannelMessagePost(id,kwargs,context);
        }
        if(args.model==='mail.channel'&&args.method==='notify_typing'){
            constids=args.args[0];
            constis_typing=args.args[1]||args.kwargs.is_typing;
            constcontext=args.kwargs.context;
            returnthis._mockMailChannelNotifyTyping(ids,is_typing,context);
        }
        //mail.messagemethods
        if(args.model==='mail.message'&&args.method==='mark_all_as_read'){
            constdomain=args.args[0]||args.kwargs.domain;
            returnthis._mockMailMessageMarkAllAsRead(domain);
        }
        if(args.model==='mail.message'&&args.method==='message_fetch'){
            //TODOFIXMEdelayRPCuntilnextpotentialrenderasaworkaround
            //toissuehttps://github.com/flectra/owl/pull/724
            awaitnextAnimationFrame();
            constdomain=args.args[0]||args.kwargs.domain;
            constlimit=args.args[1]||args.kwargs.limit;
            constmoderated_channel_ids=args.args[2]||args.kwargs.moderated_channel_ids;
            returnthis._mockMailMessageMessageFetch(domain,limit,moderated_channel_ids);
        }
        if(args.model==='mail.message'&&args.method==='message_format'){
            constids=args.args[0];
            returnthis._mockMailMessageMessageFormat(ids);
        }
        if(args.model==='mail.message'&&args.method==='moderate'){
            returnthis._mockMailMessageModerate(args);
        }
        if(args.model==='mail.message'&&args.method==='set_message_done'){
            constids=args.args[0];
            returnthis._mockMailMessageSetMessageDone(ids);
        }
        if(args.model==='mail.message'&&args.method==='toggle_message_starred'){
            constids=args.args[0];
            returnthis._mockMailMessageToggleMessageStarred(ids);
        }
        if(args.model==='mail.message'&&args.method==='unstar_all'){
            returnthis._mockMailMessageUnstarAll();
        }
        //res.partnermethods
        if(args.method==='get_mention_suggestions'){
            if(args.model==='mail.channel'){
                returnthis._mockMailChannelGetMentionSuggestions(args);
            }
            if(args.model==='res.partner'){
                returnthis._mockResPartnerGetMentionSuggestions(args);
            }
        }
        if(args.model==='res.partner'&&args.method==='im_search'){
            constname=args.args[0]||args.kwargs.search;
            constlimit=args.args[1]||args.kwargs.limit;
            returnthis._mockResPartnerImSearch(name,limit);
        }
        //mail.threadmethods(canworkonanymodel)
        if(args.method==='message_subscribe'){
            constids=args.args[0];
            constpartner_ids=args.args[1]||args.kwargs.partner_ids;
            constchannel_ids=args.args[2]||args.kwargs.channel_ids;
            constsubtype_ids=args.args[3]||args.kwargs.subtype_ids;
            returnthis._mockMailThreadMessageSubscribe(args.model,ids,partner_ids,channel_ids,subtype_ids);
        }
        if(args.method==='message_unsubscribe'){
            constids=args.args[0];
            constpartner_ids=args.args[1]||args.kwargs.partner_ids;
            constchannel_ids=args.args[2]||args.kwargs.channel_ids;
            returnthis._mockMailThreadMessageUnsubscribe(args.model,ids,partner_ids,channel_ids);
        }
        if(args.method==='message_post'){
            constid=args.args[0];
            constkwargs=args.kwargs;
            constcontext=kwargs.context;
            deletekwargs.context;
            returnthis._mockMailThreadMessagePost(args.model,[id],kwargs,context);
        }
        returnthis._super(route,args);
    },

    //--------------------------------------------------------------------------
    //PrivateMockedRoutes
    //--------------------------------------------------------------------------

    /**
     *Simulatesthe`/mail/chat_post`route.
     *
     *@private
     *@param{string}uuid
     *@param{string}message_content
     *@param{Object}[context={}]
     *@returns{Object}onekeyforlistoffollowersandoneforsubtypes
     */
    async_mockRouteMailChatPost(uuid,message_content,context={}){
        constmailChannel=this._getRecords('mail.channel',[['uuid','=',uuid]])[0];
        if(!mailChannel){
            returnfalse;
        }

        letuser_id;
        //findtheauthorfromtheusersession
        if('mockedUserId'incontext){
            //canbefalsytosimulatenotbeingloggedin
            user_id=context.mockedUserId;
        }else{
            user_id=this.currentUserId;
        }
        letauthor_id;
        letemail_from;
        if(user_id){
            constauthor=this._getRecords('res.users',[['id','=',user_id]])[0];
            author_id=author.partner_id;
            email_from=`${author.display_name}<${author.email}>`;
        }else{
            author_id=false;
            //simplerfallbackthancatchall_formatted
            email_from=mailChannel.anonymous_name||"catchall@example.com";
        }
        //supposedlyshouldconvertplaintexttohtml
        constbody=message_content;
        //ideallyshouldbepostedwithmail_create_nosubscribe=True
        returnthis._mockMailChannelMessagePost(
            mailChannel.id,
            {
                author_id,
                email_from,
                body,
                message_type:'comment',
                subtype_xmlid:'mail.mt_comment',
            },
            context
        );
    },
    /**
     *Simulates`/mail/get_suggested_recipients`route.
     *
     *@private
     *@returns{string}model
     *@returns{integer[]}res_ids
     *@returns{Object}
     */
    _mockRouteMailGetSuggestedRecipient(model,res_ids){
        if(model==='res.fake'){
            returnthis._mockResFake_MessageGetSuggestedRecipients(model,res_ids);
        }
        returnthis._mockMailThread_MessageGetSuggestedRecipients(model,res_ids);
    },
    /**
     *Simulatesthe`/mail/init_messaging`route.
     *
     *@private
     *@returns{Object}
     */
    _mockRouteMailInitMessaging(){
        constchannels=this._getRecords('mail.channel',[
            ['channel_type','=','channel'],
            ['members','in',this.currentPartnerId],
            ['public','in',['public','groups']],
        ]);
        constchannelInfos=this._mockMailChannelChannelInfo(channels.map(channel=>channel.id));

        constdirectMessages=this._getRecords('mail.channel',[
            ['channel_type','=','chat'],
            ['is_pinned','=',true],
            ['members','in',this.currentPartnerId],
        ]);
        constdirectMessageInfos=this._mockMailChannelChannelInfo(directMessages.map(channel=>channel.id));

        constprivateGroups=this._getRecords('mail.channel',[
            ['channel_type','=','channel'],
            ['members','in',this.currentPartnerId],
            ['public','=','private'],
        ]);
        constprivateGroupInfos=this._mockMailChannelChannelInfo(privateGroups.map(channel=>channel.id));

        constmoderation_channel_ids=this._getRecords('mail.channel',[['is_moderator','=',true]]).map(channel=>channel.id);
        constmoderation_counter=this._getRecords('mail.message',[
            ['model','=','mail.channel'],
            ['res_id','in',moderation_channel_ids],
            ['moderation_status','=','pending_moderation'],
        ]).length;

        constpartnerRoot=this._getRecords(
            'res.partner',
            [['id','=',this.partnerRootId]],
            {active_test:false}
        )[0];
        constpartnerRootFormat=this._mockResPartnerMailPartnerFormat(partnerRoot.id);

        constpublicPartner=this._getRecords(
            'res.partner',
            [['id','=',this.publicPartnerId]],
            {active_test:false}
        )[0];
        constpublicPartnerFormat=this._mockResPartnerMailPartnerFormat(publicPartner.id);

        constcurrentPartner=this._getRecords('res.partner',[['id','=',this.currentPartnerId]])[0];
        constcurrentPartnerFormat=this._mockResPartnerMailPartnerFormat(currentPartner.id);

        constneedaction_inbox_counter=this._mockResPartnerGetNeedactionCount();

        constmailFailures=this._mockMailMessageMessageFetchFailed();

        constshortcodes=this._getRecords('mail.shortcode',[]);

        constcommands=this._getRecords('mail.channel_command',[]);

        conststarredCounter=this._getRecords('mail.message',[
            ['starred_partner_ids','in',this.currentPartnerId],
        ]).length;

        return{
            channel_slots:{
                channel_channel:channelInfos,
                channel_direct_message:directMessageInfos,
                channel_private_group:privateGroupInfos,
            },
            commands,
            current_partner:currentPartnerFormat,
            current_user_id:this.currentUserId,
            mail_failures:mailFailures,
            mention_partner_suggestions:[],
            menu_id:false,
            moderation_channel_ids,
            moderation_counter,
            needaction_inbox_counter,
            partner_root:partnerRootFormat,
            public_partner:publicPartnerFormat,
            shortcodes,
            starred_counter:starredCounter,
        };
    },
    /**
     *Simulatesthe`/mail/read_followers`route.
     *
     *@private
     *@param{integer[]}follower_ids
     *@returns{Object}onekeyforlistoffollowersandoneforsubtypes
     */
    async_mockRouteMailReadFollowers(args){
        constres_id=args.res_id;//idofrecordtoreadthefollowers
        constres_model=args.res_model;//modelofrecordtoreadthefollowers
        constfollowers=this._getRecords('mail.followers',[['res_id','=',res_id],['res_model','=',res_model]]);
        constcurrentPartnerFollower=followers.find(follower=>follower.id===this.currentPartnerId);
        constsubtypes=currentPartnerFollower
            ?this._mockRouteMailReadSubscriptionData(currentPartnerFollower.id)
            :false;
        return{followers,subtypes};
    },
    /**
     *Simulatesthe`/mail/read_subscription_data`route.
     *
     *@private
     *@param{integer}follower_id
     *@returns{Object[]}listoffollowedsubtypes
     */
    async_mockRouteMailReadSubscriptionData(follower_id){
        constfollower=this._getRecords('mail.followers',[['id','=',follower_id]])[0];
        constsubtypes=this._getRecords('mail.message.subtype',[
            '&',
            ['hidden','=',false],
            '|',
            ['res_model','=',follower.res_model],
            ['res_model','=',false],
        ]);
        constsubtypes_list=subtypes.map(subtype=>{
            constparent=this._getRecords('mail.message.subtype',[
                ['id','=',subtype.parent_id],
            ])[0];
            return{
                'default':subtype.default,
                'followed':follower.subtype_ids.includes(subtype.id),
                'id':subtype.id,
                'internal':subtype.internal,
                'name':subtype.name,
                'parent_model':parent?parent.res_model:false,
                'res_model':subtype.res_model,
                'sequence':subtype.sequence,
            };
        });
        //NOTE:serverisalsodoingasorthere,notreproducedforsimplicity
        returnsubtypes_list;
    },

    /**
      *Simulatesthe`/mail/thread/data`route.
      *
      *@param{string}thread_model
      *@param{integer}thread_id
      *@param{string[]}request_list
      *@returns{Object}
      */
    async_mockRouteMailThreadData(thread_model,thread_id,request_list){
        constres={};
        constthread=this._mockSearchRead(thread_model,[[['id','=',thread_id]]],{})[0];
        if(request_list.includes('attachments')){
            constattachments=this._mockSearchRead('ir.attachment',[
                [['res_id','=',thread_id],['res_model','=',thread_model]],
            ],{});//ordernotdoneforsimplicity
            res['attachments']=this._mockIrAttachment_attachmentFormat(attachments.map(attachment=>attachment.id),true);
        }
        returnres;
    },

    //--------------------------------------------------------------------------
    //PrivateMockedMethods
    //--------------------------------------------------------------------------

    /**
     *Simulates`_attachment_format`on`ir.attachment`.
     *
     *@private
     *@param{string}res_model
     *@param{string}domain
     *@returns{Object}
     */
    _mockIrAttachment_attachmentFormat(ids,commands=false){
        constattachments=this._mockRead('ir.attachment',[ids]);
        returnattachments.map(attachment=>{
            constres={
                'checksum':attachment.checksum,
                'filename':attachment.name,
                'id':attachment.id,
                'mimetype':attachment.mimetype,
                'name':attachment.name,
            };
            if(commands){
                res['originThread']=[['insert',{
                    'id':attachment.res_id,
                    'model':attachment.res_model,
                }]];
            }else{
                Object.assign(res,{
                    'res_id':attachment.res_id,
                    'res_model':attachment.res_model,
                });
            }
            returnres;
        });
    },

    /**
     *Simulates`get_activity_data`on`mail.activity`.
     *
     *@private
     *@param{string}res_model
     *@param{string}domain
     *@returns{Object}
     */
    _mockMailActivityGetActivityData(res_model,domain){
        constself=this;
        constrecords=this._getRecords(res_model,domain);

        constactivityTypes=this._getRecords('mail.activity.type',[]);
        constactivityIds=_.pluck(records,'activity_ids').flat();

        constgroupedActivities={};
        constresIdToDeadline={};
        constgroups=self._mockReadGroup('mail.activity',{
            domain:[['id','in',activityIds]],
            fields:['res_id','activity_type_id','ids:array_agg(id)','date_deadline:min(date_deadline)'],
            groupby:['res_id','activity_type_id'],
            lazy:false,
        });
        groups.forEach(function(group){
            //mockReadGroupdoesn'tcorrectlyreturnallaskedfields
            constactivites=self._getRecords('mail.activity',group.__domain);
            group.activity_type_id=group.activity_type_id[0];
            letminDate;
            activites.forEach(function(activity){
                if(!minDate||moment(activity.date_deadline)<moment(minDate)){
                    minDate=activity.date_deadline;
                }
            });
            group.date_deadline=minDate;
            resIdToDeadline[group.res_id]=minDate;
            letstate;
            if(group.date_deadline===moment().format("YYYY-MM-DD")){
                state='today';
            }elseif(moment(group.date_deadline)>moment()){
                state='planned';
            }else{
                state='overdue';
            }
            if(!groupedActivities[group.res_id]){
                groupedActivities[group.res_id]={};
            }
            groupedActivities[group.res_id][group.activity_type_id]={
                count:group.__count,
                state:state,
                o_closest_deadline:group.date_deadline,
                ids:_.pluck(activites,'id'),
            };
        });

        return{
            activity_types:activityTypes.map(function(type){
                letmailTemplates=[];
                if(type.mail_template_ids){
                    mailTemplates=type.mail_template_ids.map(function(id){
                        consttemplate=_.findWhere(self.data['mail.template'].records,{id:id});
                        return{
                            id:id,
                            name:template.name,
                        };
                    });
                }
                return[type.id,type.display_name,mailTemplates];
            }),
            activity_res_ids:_.sortBy(_.pluck(records,'id'),function(id){
                returnmoment(resIdToDeadline[id]);
            }),
            grouped_activities:groupedActivities,
        };
    },
    /**
     *Simulates`_broadcast`on`mail.channel`.
     *
     *@private
     *@param{integer}id
     *@param{integer[]}partner_ids
     *@returns{Object}
     */
    _mockMailChannel_broadcast(ids,partner_ids){
        constnotifications=this._mockMailChannel_channelChannelNotifications(ids,partner_ids);
        this._widget.call('bus_service','trigger','notification',notifications);
    },
    /**
     *Simulates`_channel_channel_notifications`on`mail.channel`.
     *
     *@private
     *@param{integer}id
     *@param{integer[]}partner_ids
     *@returns{Object}
     */
    _mockMailChannel_channelChannelNotifications(ids,partner_ids){
        constnotifications=[];
        for(constpartner_idofpartner_ids){
            constuser=this._getRecords('res.users',[['partner_id','in',partner_id]])[0];
            if(!user){
                continue;
            }
            //Note:`channel_info`ontheserverissupposedtobecalledwith
            //theproperusercontext,butthisisnotdonehereforsimplicity
            //ofnothaving`channel.partner`.
            constchannelInfos=this._mockMailChannelChannelInfo(ids);
            for(constchannelInfoofchannelInfos){
                notifications.push([[false,'res.partner',partner_id],channelInfo]);
            }
        }
        returnnotifications;
    },
    /**
     *Simulates`channel_fetched`on`mail.channel`.
     *
     *@private
     *@param{integer[]}ids
     *@param{string}extra_info
     */
    _mockMailChannelChannelFetched(ids){
        constchannels=this._getRecords('mail.channel',[['id','in',ids]]);
        for(constchannelofchannels){
            constchannelMessages=this._getRecords('mail.message',[['channel_ids','in',channel.id]]);
            constlastMessage=channelMessages.reduce((lastMessage,message)=>{
                if(message.id>lastMessage.id){
                    returnmessage;
                }
                returnlastMessage;
            },channelMessages[0]);
            if(!lastMessage){
                continue;
            }
            this._mockWrite('mail.channel',[
                [channel.id],
                {fetched_message_id:lastMessage.id},
            ]);
            constnotification=[
                ["dbName",'mail.channel',channel.id],
                {
                    id:`${channel.id}/${this.currentPartnerId}`,//simulatechannel.partnerid
                    info:'channel_fetched',
                    last_message_id:lastMessage.id,
                    partner_id:this.currentPartnerId,
                },
            ];
            this._widget.call('bus_service','trigger','notification',[notification]);
        }
    },
    /**
     *Simulates`channel_fetch_preview`on`mail.channel`.
     *
     *@private
     *@param{integer[]}ids
     *@returns{Object[]}listofchannelspreviews
     */
    _mockMailChannelChannelFetchPreview(ids){
        constchannels=this._getRecords('mail.channel',[['id','in',ids]]);
        returnchannels.map(channel=>{
            constchannelMessages=this._getRecords('mail.message',[['channel_ids','in',channel.id]]);
            constlastMessage=channelMessages.reduce((lastMessage,message)=>{
                if(message.id>lastMessage.id){
                    returnmessage;
                }
                returnlastMessage;
            },channelMessages[0]);
            return{
                id:channel.id,
                last_message:lastMessage?this._mockMailMessageMessageFormat([lastMessage.id])[0]:false,
            };
        });
    },
    /**
     *Simulatesthe'channel_fold'routeon`mail.channel`.
     *Inparticularsendsanotificationonthebus.
     *
     *@private
     *@param{string}uuid
     *@param{state}[state]
     */
    _mockMailChannelChannelFold(uuid,state){
        constchannel=this._getRecords('mail.channel',[['uuid','=',uuid]])[0];
        this._mockWrite('mail.channel',[
            [channel.id],
            {
                is_minimized:state!=='closed',
                state,
            }
        ]);
        constnotifConfirmFold=[
            ["dbName",'res.partner',this.currentPartnerId],
            this._mockMailChannelChannelInfo([channel.id])[0]
        ];
        this._widget.call('bus_service','trigger','notification',[notifConfirmFold]);
    },
    /**
     *Simulates'channel_get'on'mail.channel'.
     *
     *@private
     *@param{integer[]}[partners_to=[]]
     *@param{boolean}[pin=true]
     *@returns{Object}
     */
    _mockMailChannelChannelGet(partners_to=[],pin=true){
        if(partners_to.length===0){
            returnfalse;
        }
        if(!partners_to.includes(this.currentPartnerId)){
            partners_to.push(this.currentPartnerId);
        }
        constpartners=this._getRecords('res.partner',[['id','in',partners_to]]);

        //NOTE:thismockisnotcomplete,whichisdoneforsimplicity.
        //Indeedifachatalreadyexistsforthegivenpartners,theserver
        //issupposedtoreturnthisexistingchat.Butthemockiscurrently
        //alwayscreatinganewchat,becausenotestisrelyingonreceiving
        //anexistingchat.
        constid=this._mockCreate('mail.channel',{
            channel_type:'chat',
            mass_mailing:false,
            is_minimized:true,
            is_pinned:true,
            members:[[6,0,partners_to]],
            name:partners.map(partner=>partner.name).join(","),
            public:'private',
            state:'open',
        });
        returnthis._mockMailChannelChannelInfo([id])[0];
    },
    /**
     *Simulates`channel_info`on`mail.channel`.
     *
     *@private
     *@param{integer[]}ids
     *@param{string}[extra_info]
     *@returns{Object[]}
     */
    _mockMailChannelChannelInfo(ids,extra_info){
        constchannels=this._getRecords('mail.channel',[['id','in',ids]]);
        constall_partners=[...newSet(channels.reduce((all_partners,channel)=>{
            return[...all_partners,...channel.members];
        },[]))];
        constdirect_partners=[...newSet(channels.reduce((all_partners,channel)=>{
            if(channel.channel_type==='chat'){
                return[...all_partners,...channel.members];
            }
            returnall_partners;
        },[]))];
        constpartnerInfos=this._mockMailChannelPartnerInfo(all_partners,direct_partners);
        returnchannels.map(channel=>{
            constmembers=channel.members.map(partnerId=>partnerInfos[partnerId]);
            constmessages=this._getRecords('mail.message',[
                ['channel_ids','in',[channel.id]],
            ]);
            constlastMessageId=messages.reduce((lastMessageId,message)=>{
                if(!lastMessageId||message.id>lastMessageId){
                    returnmessage.id;
                }
                returnlastMessageId;
            },undefined);
            constmessageNeedactionCounter=this._getRecords('mail.notification',[
                ['res_partner_id','=',this.currentPartnerId],
                ['is_read','=',false],
                ['mail_message_id','in',messages.map(message=>message.id)],
            ]).length;
            constres=Object.assign({},channel,{
                info:extra_info,
                last_message_id:lastMessageId,
                members,
                message_needaction_counter:messageNeedactionCounter,
            });
            if(channel.channel_type==='channel'){
                deleteres.members;
            }
            returnres;
        });
    },
    /**
     *Simulates`channel_join_and_get_info`on`mail.channel`.
     *
     *@private
     *@param{integer[]}ids
     *@returns{Object[]}
     */
    _mockMailChannelChannelJoinAndGetInfo(ids){
        constid=ids[0];//ensureone
        constchannel=this._getRecords('mail.channel',[['id','=',id]])[0];
        //channel.partnernothandledhereforsimplicity
        if(!channel.is_pinned){
            this._mockWrite('mail.channel',[
                [channel.id],
                {is_pinned:true},
            ]);
            constbody=`<divclass="o_mail_notification">joined<ahref="#"class="o_channel_redirect"data-oe-id="${channel.id}">#${channel.name}</a></div>`;
            constmessage_type="notification";
            constsubtype_xmlid="mail.mt_comment";
            this._mockMailChannelMessagePost(
                'mail.channel',
                [channel.id],
                {body,message_type,subtype_xmlid},
            );
        }
        //moderation_guidelinesnothandledhereforsimplicity
        constchannelInfo=this._mockMailChannelChannelInfo([channel.id],'join')[0];
        constnotification=[[false,'res.partner',this.currentPartnerId],channelInfo];
        this._widget.call('bus_service','trigger','notification',[notification]);
        returnchannelInfo;
    },
    /**
     *Simulatesthe`channel_seen`methodof`mail.channel`.
     *
     *@private
     *@paraminteger[]ids
     *@param{integer}last_message_id
     */
    async_mockMailChannelChannelSeen(ids,last_message_id){
        //Updaterecord
        constchannel_id=ids[0];
        if(!channel_id){
            thrownewError('Shouldonlybeonechannelinchannel_seenmockparams');
        }
        constchannel=this._getRecords('mail.channel',[['id','=',channel_id]])[0];
        constmessagesBeforeGivenLastMessage=this._getRecords('mail.message',[
            ['channel_ids','in',[channel.id]],
            ['id','<=',last_message_id],
        ]);
        if(!messagesBeforeGivenLastMessage||messagesBeforeGivenLastMessage.length===0){
            return;
        }
        if(!channel){
            return;
        }
        if(channel.seen_message_id&&channel.seen_message_id>=last_message_id){
            return;
        }
        this._mockMailChannel_SetLastSeenMessage([channel.id],last_message_id);

        //Sendnotification
        constpayload={
            channel_id,
            info:'channel_seen',
            last_message_id,
            partner_id:this.currentPartnerId,
        };
        letnotification;
        if(channel.channel_type==='chat'){
            notification=[[false,'mail.channel',channel_id],payload];
        }else{
            notification=[[false,'res.partner',this.currentPartnerId],payload];
        }
        this._widget.call('bus_service','trigger','notification',[notification]);
    },
    /**
     *Simulates`channel_set_custom_name`on`mail.channel`.
     *
     *@private
     *@param{integer}channel_id
     *@returns{string}[name]
     */
    _mockMailChannelChannelSetCustomName(channel_id,name){
        this._mockWrite('mail.channel',[
            [channel_id],
            {custom_channel_name:name},
        ]);
    },
    /**
     *Simulates`execute_command`on`mail.channel`.
     *Inparticularsendsanotificationonthebus.
     *
     *@private
     */
    _mockMailChannelExecuteCommand(args){
        constids=args.args[0];
        constcommandName=args.kwargs.command||args.args[1];
        constchannels=this._getRecords('mail.channel',[['id','in',ids]]);
        if(commandName==='leave'){
            for(constchannelofchannels){
                this._mockWrite('mail.channel',[
                    [channel.id],
                    {is_pinned:false},
                ]);
                constnotifConfirmUnpin=[
                    ["dbName",'res.partner',this.currentPartnerId],
                    Object.assign({},channel,{info:'unsubscribe'})
                ];
                this._widget.call('bus_service','trigger','notification',[notifConfirmUnpin]);
            }
            return;
        }elseif(commandName==='who'){
            for(constchannelofchannels){
                constmembers=channel.members.map(memberId=>this._getRecords('res.partner',[['id','=',memberId]])[0].name);
                letmessage="Youarealoneinthischannel.";
                if(members.length>0){
                    message=`Usersinthischannel:${members.join(',')}andyou`;
                }
                constnotification=[
                    ["dbName",'res.partner',this.currentPartnerId],
                    {
                        'body':`<spanclass="o_mail_notification">${message}</span>`,
                        'channel_ids':[channel.id],
                        'info':'transient_message',
                    }
                ];
                this._widget.call('bus_service','trigger','notification',[notification]);
            }
            return;
        }
        thrownewError(`mail/mock_server:therouteexecute_commanddoesn'timplementthecommand"${commandName}"`);
    },
    /**
     *Simulates`get_mention_suggestions`on`mail.channel`.
     *
     *@private
     *@returns{Array[]}
     */
    _mockMailChannelGetMentionSuggestions(args){
        constsearch=args.kwargs.search||'';
        constlimit=args.kwargs.limit||8;

        /**
         *Returnsthegivenlistofchannelsafterfilteringitaccordingto
         *thelogicofthePythonmethod`get_mention_suggestions`forthe
         *givensearchterm.Theresultistruncatedtothegivenlimitand
         *formattedasexpectedbytheoriginalmethod.
         *
         *@param{Object[]}channels
         *@param{string}search
         *@param{integer}limit
         *@returns{Object[]}
         */
        constmentionSuggestionsFilter=function(channels,search,limit){
            constmatchingChannels=channels
                .filter(channel=>{
                    //nosearchtermisconsideredasreturnall
                    if(!search){
                        returntrue;
                    }
                    //otherwisenameoremailmustmatchsearchterm
                    if(channel.name&&channel.name.includes(search)){
                        returntrue;
                    }
                    returnfalse;
                }).map(channel=>{
                    //expectedformat
                    return{
                        id:channel.id,
                        name:channel.name,
                        public:channel.public,
                    };
                });
            //reduceresultstomaxlimit
            matchingChannels.length=Math.min(matchingChannels.length,limit);
            returnmatchingChannels;
        };

        constmentionSuggestions=mentionSuggestionsFilter(this.data['mail.channel'].records,search,limit);

        returnmentionSuggestions;
    },
    /**
     *Simulates`message_post`on`mail.channel`.
     *
     *Forsimplicitythismockhandlesasimplecaseinregardtomoderation:
     *-messagesfromJSareassumedtobealwayssentbythecurrentpartner,
     *-moderationwhitelistandblacklistarenotchecked.
     *
     *@private
     *@param{integer}id
     *@param{Object}kwargs
     *@param{Object}[context]
     *@returns{integer|false}
     */
    _mockMailChannelMessagePost(id,kwargs,context){
        constmessage_type=kwargs.message_type||'notification';
        constchannel=this._getRecords('mail.channel',[['id','=',id]])[0];
        if(channel.channel_type!=='channel'&&!channel.is_pinned){
            //channel.partnernothandledhereforsimplicity
            this._mockWrite('mail.channel',[
                [channel.id],
                {is_pinned:true},
            ]);
        }
        letmoderation_status='accepted';
        if(channel.moderation&&['email','comment'].includes(message_type)){
            if(!channel.is_moderator){
                moderation_status='pending_moderation';
            }
        }
        letchannel_ids=[];
        if(moderation_status==='accepted'){
            channel_ids=[[4,channel.id]];
        }
        constmessageId=this._mockMailThreadMessagePost(
            'mail.channel',
            [id],
            Object.assign(kwargs,{
                channel_ids,
                message_type,
                moderation_status,
            }),
            context,
        );
        if(kwargs.author_id===this.currentPartnerId){
            this._mockMailChannel_SetLastSeenMessage([channel.id],messageId);
        }else{
            this._mockWrite('mail.channel',[
                [channel.id],
                {message_unread_counter:(channel.message_unread_counter||0)+1},
            ]);
        }
        returnmessageId;
    },
    /**
     *Simulates`notify_typing`on`mail.channel`.
     *
     *@private
     *@param{integer[]}ids
     *@param{boolean}is_typing
     *@param{Object}[context={}]
     */
    _mockMailChannelNotifyTyping(ids,is_typing,context={}){
        constchannels=this._getRecords('mail.channel',[['id','in',ids]]);
        letpartner_id;
        if('mockedPartnerId'incontext){
            partner_id=context.mockedPartnerId;
        }else{
            partner_id=this.currentPartnerId;
        }
        constpartner=this._getRecords('res.partner',[['id','=',partner_id]]);
        constdata={
            'info':'typing_status',
            'is_typing':is_typing,
            'partner_id':partner_id,
            'partner_name':partner.name,
        };
        constnotifications=[];
        for(constchannelofchannels){
            notifications.push([[false,'mail.channel',channel.id],data]);
            notifications.push([channel.uuid,data]);//notifylivechatusers
        }
        this._widget.call('bus_service','trigger','notification',notifications);
    },
    /**
     *Simulates`partner_info`on`mail.channel`.
     *
     *@private
     *@param{integer[]}all_partners
     *@param{integer[]}direct_partners
     *@returns{Object[]}
     */
    _mockMailChannelPartnerInfo(all_partners,direct_partners){
        constpartners=this._getRecords(
            'res.partner',
            [['id','in',all_partners]],
            {active_test:false},
        );
        constpartnerInfos={};
        for(constpartnerofpartners){
            constpartnerInfo={
                email:partner.email,
                id:partner.id,
                name:partner.name,
            };
            if(direct_partners.includes(partner.id)){
                partnerInfo.im_status=partner.im_status;
            }
            partnerInfos[partner.id]=partnerInfo;
        }
        returnpartnerInfos;
    },
    /**
     *Simulatesthe`_set_last_seen_message`methodof`mail.channel`.
     *
     *@private
     *@param{integer[]}ids
     *@param{integer}message_id
     */
    _mockMailChannel_SetLastSeenMessage(ids,message_id){
        this._mockWrite('mail.channel',[ids,{
            fetched_message_id:message_id,
            seen_message_id:message_id,
        }]);
    },
    /**
     *Simulates`mark_all_as_read`on`mail.message`.
     *
     *@private
     *@param{Array[]}[domain]
     *@returns{integer[]}
     */
    _mockMailMessageMarkAllAsRead(domain){
        constnotifDomain=[
            ['res_partner_id','=',this.currentPartnerId],
            ['is_read','=',false],
        ];
        if(domain){
            constmessages=this._getRecords('mail.message',domain);
            constids=messages.map(messages=>messages.id);
            this._mockMailMessageSetMessageDone(ids);
            returnids;
        }
        constnotifications=this._getRecords('mail.notification',notifDomain);
        this._mockWrite('mail.notification',[
            notifications.map(notification=>notification.id),
            {is_read:true},
        ]);
        constmessageIds=[];
        for(constnotificationofnotifications){
            if(!messageIds.includes(notification.mail_message_id)){
                messageIds.push(notification.mail_message_id);
            }
        }
        constmessages=this._getRecords('mail.message',[['id','in',messageIds]]);
        //simulatecomputethatshouldbedonebasedonnotifications
        for(constmessageofmessages){
            this._mockWrite('mail.message',[
                [message.id],
                {
                    needaction:false,
                    needaction_partner_ids:message.needaction_partner_ids.filter(
                        partnerId=>partnerId!==this.currentPartnerId
                    ),
                },
            ]);
        }
        constnotificationData={type:'mark_as_read',message_ids:messageIds,needaction_inbox_counter:this._mockResPartnerGetNeedactionCount()};
        constnotification=[[false,'res.partner',this.currentPartnerId],notificationData];
        this._widget.call('bus_service','trigger','notification',[notification]);
        returnmessageIds;
    },
    /**
     *Simulates`message_fetch`on`mail.message`.
     *
     *@private
     *@param{Array[]}domain
     *@param{string}[limit=20]
     *@param{Object}[moderated_channel_ids]
     *@returns{Object[]}
     */
    _mockMailMessageMessageFetch(domain,limit=20,moderated_channel_ids){
        letmessages=this._getRecords('mail.message',domain);
        if(moderated_channel_ids){
            constmod_messages=this._getRecords('mail.message',[
                ['model','=','mail.channel'],
                ['res_id','in',moderated_channel_ids],
                '|',
                ['author_id','=',this.currentPartnerId],
                ['moderation_status','=','pending_moderation'],
            ]);
            messages=[...newSet([...messages,...mod_messages])];
        }
        //sortedfromhighestIDtolowestID(i.e.fromyoungesttooldest)
        messages.sort(function(m1,m2){
            returnm1.id<m2.id?1:-1;
        });
        //pickatmost'limit'messages
        messages.length=Math.min(messages.length,limit);
        returnthis._mockMailMessageMessageFormat(messages.map(message=>message.id));
    },
    /**
     *Simulates`message_fetch_failed`on`mail.message`.
     *
     *@private
     *@returns{Object[]}
     */
    _mockMailMessageMessageFetchFailed(){
        constmessages=this._getRecords('mail.message',[
            ['author_id','=',this.currentPartnerId],
            ['res_id','!=',0],
            ['model','!=',false],
            ['message_type','!=','user_notification'],
        ]).filter(message=>{
            //Purposeistosimulatethefollowingdomainonmail.message:
            //['notification_ids.notification_status','in',['bounce','exception']],
            //Butit'snotsupportedby_getRecordsdomaintofollowarelation.
            constnotifications=this._getRecords('mail.notification',[
                ['mail_message_id','=',message.id],
                ['notification_status','in',['bounce','exception']],
            ]);
            returnnotifications.length>0;
        });
        returnthis._mockMailMessage_MessageNotificationFormat(messages.map(message=>message.id));
    },
    /**
     *Simulates`message_format`on`mail.message`.
     *
     *@private
     *@returns{integer[]}ids
     *@returns{Object[]}
     */
    _mockMailMessageMessageFormat(ids){
        constmessages=this._getRecords('mail.message',[['id','in',ids]]);
        //sortedfromhighestIDtolowestID(i.e.frommosttoleastrecent)
        messages.sort(function(m1,m2){
            returnm1.id<m2.id?1:-1;
        });
        returnmessages.map(message=>{
            constthread=message.model&&this._getRecords(message.model,[
                ['id','=',message.res_id],
            ])[0];
            letformattedAuthor;
            if(message.author_id){
                constauthor=this._getRecords(
                    'res.partner',
                    [['id','=',message.author_id]],
                    {active_test:false}
                )[0];
                formattedAuthor=[author.id,author.display_name];
            }else{
                formattedAuthor=[0,message.email_from];
            }
            constattachments=this._getRecords('ir.attachment',[
                ['id','in',message.attachment_ids],
            ]);
            constformattedAttachments=attachments.map(attachment=>{
                returnObject.assign({
                    'checksum':attachment.checksum,
                    'id':attachment.id,
                    'filename':attachment.name,
                    'name':attachment.name,
                    'mimetype':attachment.mimetype,
                    'is_main':thread&&thread.message_main_attachment_id===attachment.id,
                    'res_id':attachment.res_id,
                    'res_model':attachment.res_model,
                });
            });
            constallNotifications=this._getRecords('mail.notification',[
                ['mail_message_id','=',message.id],
            ]);
            consthistoryPartnerIds=allNotifications
                .filter(notification=>notification.is_read)
                .map(notification=>notification.res_partner_id);
            constneedactionPartnerIds=allNotifications
                .filter(notification=>!notification.is_read)
                .map(notification=>notification.res_partner_id);
            letnotifications=this._mockMailNotification_FilteredForWebClient(
                allNotifications.map(notification=>notification.id)
            );
            notifications=this._mockMailNotification_NotificationFormat(
                notifications.map(notification=>notification.id)
            );
            consttrackingValueIds=this._getRecords('mail.tracking.value',[
                ['id','in',message.tracking_value_ids],
            ]);
            constresponse=Object.assign({},message,{
                attachment_ids:formattedAttachments,
                author_id:formattedAuthor,
                history_partner_ids:historyPartnerIds,
                needaction_partner_ids:needactionPartnerIds,
                notifications,
                tracking_value_ids:trackingValueIds,
            });
            if(message.subtype_id){
                constsubtype=this._getRecords('mail.message.subtype',[
                    ['id','=',message.subtype_id],
                ])[0];
                response.subtype_description=subtype.description;
            }
            returnresponse;
        });
    },
    /**
     *Simulates`moderate`on`mail.message`.
     *
     *@private
     */
    _mockMailMessageModerate(args){
        constmessageIDs=args.args[0];
        constdecision=args.args[1];
        constmodel=this.data['mail.message'];
        if(decision==='reject'||decision==='discard'){
            model.records=_.reject(model.records,function(rec){
                return_.contains(messageIDs,rec.id);
            });
            //simulatenotificationback(deletionofrejected/discarded
            //messageinchannel)
            constdbName=undefined;//uselessfortests
            constnotifData={
                message_ids:messageIDs,
                type:"deletion",
            };
            constmetaData=[dbName,'res.partner',this.currentPartnerId];
            constnotification=[metaData,notifData];
            this._widget.call('bus_service','trigger','notification',[notification]);
        }elseif(decision==='accept'){
            //simulatenotificationback(newacceptedmessageinchannel)
            constmessages=this._getRecords('mail.message',[['id','in',messageIDs]]);
            for(constmessageofmessages){
                this._mockWrite('mail.message',[[message.id],{
                    moderation_status:'accepted',
                }]);
                this._mockMailThread_NotifyThread(model,message.channel_ids,message.id);
            }
        }
    },
    /**
     *Simulates`_message_notification_format`on`mail.message`.
     *
     *@private
     *@returns{integer[]}ids
     *@returns{Object[]}
     */
    _mockMailMessage_MessageNotificationFormat(ids){
        constmessages=this._getRecords('mail.message',[['id','in',ids]]);
        returnmessages.map(message=>{
            letnotifications=this._getRecords('mail.notification',[
                ['mail_message_id','=',message.id],
            ]);
            notifications=this._mockMailNotification_FilteredForWebClient(
                notifications.map(notification=>notification.id)
            );
            notifications=this._mockMailNotification_NotificationFormat(
                notifications.map(notification=>notification.id)
            );
            return{
                'date':message.date,
                'id':message.id,
                'message_type':message.message_type,
                'model':message.model,
                'notifications':notifications,
                'res_id':message.res_id,
                'res_model_name':message.res_model_name,
            };
        });
    },
    /**
     *Simulates`set_message_done`on`mail.message`,whichturnsprovided
     *needactionmessagetonon-needaction(i.e.theyaremarkedasreadfrom
     *fromtheInboxmailbox).Alsonotifyonthelongpollbusthatthe
     *messageshavebeenmarkedasread,sothatUIisupdated.
     *
     *@private
     *@param{integer[]}ids
     */
    _mockMailMessageSetMessageDone(ids){
        constmessages=this._getRecords('mail.message',[['id','in',ids]]);

        constnotifications=this._getRecords('mail.notification',[
            ['res_partner_id','=',this.currentPartnerId],
            ['is_read','=',false],
            ['mail_message_id','in',messages.map(messages=>messages.id)]
        ]);
        this._mockWrite('mail.notification',[
            notifications.map(notification=>notification.id),
            {is_read:true},
        ]);
        //simulatecomputethatshouldbedonebasedonnotifications
        for(constmessageofmessages){
            this._mockWrite('mail.message',[
                [message.id],
                {
                    needaction:false,
                    needaction_partner_ids:message.needaction_partner_ids.filter(
                        partnerId=>partnerId!==this.currentPartnerId
                    ),
                },
            ]);
            //NOTEserverissendinggroupednotificationsperchannel_idsbut
            //thisoptimizationisnotneededhere.
            constdata={type:'mark_as_read',message_ids:[message.id],channel_ids:message.channel_ids,needaction_inbox_counter:this._mockResPartnerGetNeedactionCount()};
            constbusNotifications=[[[false,'res.partner',this.currentPartnerId],data]];
            this._widget.call('bus_service','trigger','notification',busNotifications);
        }
    },
    /**
     *Simulates`toggle_message_starred`on`mail.message`.
     *
     *@private
     *@returns{integer[]}ids
     */
    _mockMailMessageToggleMessageStarred(ids){
        constmessages=this._getRecords('mail.message',[['id','in',ids]]);
        for(constmessageofmessages){
            constwasStared=message.starred_partner_ids.includes(this.currentPartnerId);
            this._mockWrite('mail.message',[
                [message.id],
                {starred_partner_ids:[[wasStared?3:4,this.currentPartnerId]]}
            ]);
            constnotificationData={
                message_ids:[message.id],
                starred:!wasStared,
                type:'toggle_star',
            };
            constnotifications=[[[false,'res.partner',this.currentPartnerId],notificationData]];
            this._widget.call('bus_service','trigger','notification',notifications);
        }
    },
    /**
     *Simulates`unstar_all`on`mail.message`.
     *
     *@private
     */
    _mockMailMessageUnstarAll(){
        constmessages=this._getRecords('mail.message',[
            ['starred_partner_ids','in',this.currentPartnerId],
        ]);
        this._mockWrite('mail.message',[
            messages.map(message=>message.id),
            {starred_partner_ids:[[3,this.currentPartnerId]]}
        ]);
        constnotificationData={
            message_ids:messages.map(message=>message.id),
            starred:false,
            type:'toggle_star',
        };
        constnotification=[[false,'res.partner',this.currentPartnerId],notificationData];
        this._widget.call('bus_service','trigger','notification',[notification]);
    },
    /**
     *Simulates`_filtered_for_web_client`on`mail.notification`.
     *
     *@private
     *@returns{integer[]}ids
     *@returns{Object[]}
     */
    _mockMailNotification_FilteredForWebClient(ids){
        returnthis._getRecords('mail.notification',[
            ['id','in',ids],
            ['notification_type','!=','inbox'],
            ['notification_status','in',['bounce','exception','canceled']],
            //or"res_partner_id.partner_share"notdonehereforsimplicity
        ]);
    },
    /**
     *Simulates`_notification_format`on`mail.notification`.
     *
     *@private
     *@returns{integer[]}ids
     *@returns{Object[]}
     */
    _mockMailNotification_NotificationFormat(ids){
        constnotifications=this._getRecords('mail.notification',[['id','in',ids]]);
        returnnotifications.map(notification=>{
            constpartner=this._getRecords('res.partner',[['id','=',notification.res_partner_id]])[0];
            return{
                'id':notification.id,
                'notification_type':notification.notification_type,
                'notification_status':notification.notification_status,
                'failure_type':notification.failure_type,
                'res_partner_id':[partner&&partner.id,partner&&partner.display_name],
            };
        });
    },
    /**
     *Simulates`_message_compute_author`on`mail.thread`.
     *
     *@private
     *@param{string}model
     *@param{integer[]}ids
     *@param{Object}[context={}]
     *@returns{Array}
     */
    _MockMailThread_MessageComputeAuthor(model,ids,author_id,email_from,context={}){
        if(author_id===undefined){
            //Forsimplicitypartnerisnotguessedfromemail_fromhere,but
            //thatwouldbethefirststepontheserver.
            letuser_id;
            if('mockedUserId'incontext){
                //canbefalsytosimulatenotbeingloggedin
                user_id=context.mockedUserId
                    ?context.mockedUserId
                    :this.publicUserId;
            }else{
                user_id=this.currentUserId;
            }
            constuser=this._getRecords(
                'res.users',
                [['id','=',user_id]],
                {active_test:false},
            )[0];
            constauthor=this._getRecords(
                'res.partner',
                [['id','=',user.partner_id]],
                {active_test:false},
            )[0];
            author_id=author.id;
            email_from=`${author.display_name}<${author.email}>`;
        }

        if(email_from===undefined){
            if(author_id){
                constauthor=this._getRecords(
                    'res.partner',
                    [['id','=',author_id]],
                    {active_test:false},
                )[0];
                email_from=`${author.display_name}<${author.email}>`;
            }
        }

        if(!email_from){
            throwError("Unabletologmessageduetomissingauthoremail.");
        }

        return[author_id,email_from];
    },
    /**
     *Simulates`_message_add_suggested_recipient`on`mail.thread`.
     *
     *@private
     *@param{string}model
     *@param{integer[]}ids
     *@param{Object}result
     *@param{Object}[param3={}]
     *@param{string}[param3.email]
     *@param{integer}[param3.partner]
     *@param{string}[param3.reason]
     *@returns{Object}
     */
    _mockMailThread_MessageAddSuggestedRecipient(model,ids,result,{email,partner,reason=''}={}){
        constrecord=this._getRecords(model,[['id','in','ids']])[0];
        //forsimplicity
        result[record.id].push([partner,email,reason]);
        returnresult;
    },
    /**
     *Simulates`_message_get_suggested_recipients`on`mail.thread`.
     *
     *@private
     *@param{string}model
     *@param{integer[]}ids
     *@returns{Object}
     */
    _mockMailThread_MessageGetSuggestedRecipients(model,ids){
        constresult=ids.reduce((result,id)=>result[id]=[],{});
        constrecords=this._getRecords(model,[['id','in',ids]]);
        for(constrecordinrecords){
            if(record.user_id){
                constuser=this._getRecords('res.users',[['id','=',record.user_id]]);
                if(user.partner_id){
                    constreason=this.data[model].fields['user_id'].string;
                    this._mockMailThread_MessageAddSuggestedRecipient(result,user.partner_id,reason);
                }
            }
        }
        returnresult;
    },
    /**
     *Simulates`_message_get_suggested_recipients`on`res.fake`.
     *
     *@private
     *@param{string}model
     *@param{integer[]}ids
     *@returns{Object}
     */
    _mockResFake_MessageGetSuggestedRecipients(model,ids){
        constresult={};
        constrecords=this._getRecords(model,[['id','in',ids]]);

        for(constrecordofrecords){
            result[record.id]=[];
            if(record.email_cc){
                result[record.id].push([
                    false,
                    record.email_cc,
                    'CCemail',
                ]);
            }
            constpartners=this._getRecords(
                'res.partner',
                [['id','in',record.partner_ids]],
            );
            if(partners.length){
                for(constpartnerofpartners){
                    result[record.id].push([
                        partner.id,
                        partner.display_name,
                        'Emailpartner',
                    ]);
                }
            }
        }

        returnresult;
    },
    /**
     *Simulates`message_post`on`mail.thread`.
     *
     *@private
     *@param{string}model
     *@param{integer[]}ids
     *@param{Object}kwargs
     *@param{Object}[context]
     *@returns{integer}
     */
    _mockMailThreadMessagePost(model,ids,kwargs,context){
        constid=ids[0];//ensure_one
        if(kwargs.attachment_ids){
            constattachments=this._getRecords('ir.attachment',[
                ['id','in',kwargs.attachment_ids],
                ['res_model','=','mail.compose.message'],
                ['res_id','=',0],
            ]);
            constattachmentIds=attachments.map(attachment=>attachment.id);
            this._mockWrite('ir.attachment',[
                attachmentIds,
                {
                    res_id:id,
                    res_model:model,
                },
            ]);
            kwargs.attachment_ids=attachmentIds.map(attachmentId=>[4,attachmentId]);
        }
        constsubtype_xmlid=kwargs.subtype_xmlid||'mail.mt_note';
        const[author_id,email_from]=this._MockMailThread_MessageComputeAuthor(
            model,
            ids,
            kwargs.author_id,
            kwargs.email_from,context,
        );
        constvalues=Object.assign({},kwargs,{
            author_id,
            email_from,
            is_discussion:subtype_xmlid==='mail.mt_comment',
            is_note:subtype_xmlid==='mail.mt_note',
            model,
            res_id:id,
        });
        deletevalues.subtype_xmlid;
        constmessageId=this._mockCreate('mail.message',values);
        this._mockMailThread_NotifyThread(model,ids,messageId);
        returnmessageId;
    },
    /**
     *Simulates`message_subscribe`on`mail.thread`.
     *
     *@private
     *@param{string}modelnotinservermethodbutnecessaryforthreadmock
     *@param{integer[]}ids
     *@param{integer[]}partner_ids
     *@param{integer[]}channel_ids
     *@param{integer[]}subtype_ids
     *@returns{boolean}
     */
    _mockMailThreadMessageSubscribe(model,ids,partner_ids,channel_ids,subtype_ids){
        //message_subscribeistoocomplexforagenericmock.
        //mockRPCshouldbeconsideredforaspecificresult.
    },
    /**
     *Simulates`_notify_thread`on`mail.thread`.
     *Simplifiedversionthatsendsnotificationtoauthorandchannel.
     *
     *@private
     *@param{string}modelnotinservermethodbutnecessaryforthreadmock
     *@param{integer[]}ids
     *@param{integer}messageId
     *@returns{boolean}
     */
    _mockMailThread_NotifyThread(model,ids,messageId){
        constmessage=this._getRecords('mail.message',[['id','=',messageId]])[0];
        constmessageFormat=this._mockMailMessageMessageFormat([messageId])[0];
        constnotifications=[];
        //author
        constnotificationData={
            type:'author',
            message:messageFormat,
        };
        if(message.author_id){
            notifications.push([[false,'res.partner',message.author_id],notificationData]);
        }
        //members
        constchannels=this._getRecords('mail.channel',[['id','in',message.channel_ids]]);
        for(constchannelofchannels){
            notifications.push([[false,'mail.channel',channel.id],messageFormat]);
        }
        this._widget.call('bus_service','trigger','notification',notifications);
    },
    /**
     *Simulates`message_unsubscribe`on`mail.thread`.
     *
     *@private
     *@param{string}modelnotinservermethodbutnecessaryforthreadmock
     *@param{integer[]}ids
     *@param{integer[]}partner_ids
     *@param{integer[]}channel_ids
     *@returns{boolean|undefined}
     */
    _mockMailThreadMessageUnsubscribe(model,ids,partner_ids,channel_ids){
        if(!partner_ids&&!channel_ids){
            returntrue;
        }
        constfollowers=this._getRecords('mail.followers',[
            ['res_model','=',model],
            ['res_id','in',ids],
            '|',
            ['partner_id','in',partner_ids||[]],
            ['channel_id','in',channel_ids||[]],
        ]);
        this._mockUnlink('mail.followers',[followers.map(follower=>follower.id)]);
    },
    /**
     *Simulates`get_mention_suggestions`on`res.partner`.
     *
     *@private
     *@returns{Array[]}
     */
    _mockResPartnerGetMentionSuggestions(args){
        constsearch=(args.args[0]||args.kwargs.search||'').toLowerCase();
        constlimit=args.args[1]||args.kwargs.limit||8;

        /**
         *Returnsthegivenlistofpartnersafterfilteringitaccordingto
         *thelogicofthePythonmethod`get_mention_suggestions`forthe
         *givensearchterm.Theresultistruncatedtothegivenlimitand
         *formattedasexpectedbytheoriginalmethod.
         *
         *@param{Object[]}partners
         *@param{string}search
         *@param{integer}limit
         *@returns{Object[]}
         */
        constmentionSuggestionsFilter=function(partners,search,limit){
            constmatchingPartners=partners
                .filter(partner=>{
                    //nosearchtermisconsideredasreturnall
                    if(!search){
                        returntrue;
                    }
                    //otherwisenameoremailmustmatchsearchterm
                    if(partner.name&&partner.name.toLowerCase().includes(search)){
                        returntrue;
                    }
                    if(partner.email&&partner.email.toLowerCase().includes(search)){
                        returntrue;
                    }
                    returnfalse;
                }).map(partner=>{
                    //expectedformat
                    return{
                        email:partner.email,
                        id:partner.id,
                        name:partner.name,
                    };
                });
            //reduceresultstomaxlimit
            matchingPartners.length=Math.min(matchingPartners.length,limit);
            returnmatchingPartners;
        };

        //addmainsuggestionsbasedonusers
        constpartnersFromUsers=this._getRecords('res.users',[])
            .map(user=>this._getRecords('res.partner',[['id','=',user.partner_id]])[0])
            .filter(partner=>partner);
        constmainMatchingPartners=mentionSuggestionsFilter(partnersFromUsers,search,limit);

        letextraMatchingPartners=[];
        //ifnotenoughresultsaddextrasuggestionsbasedonpartners
        if(mainMatchingPartners.length<limit){
            constpartners=this._getRecords('res.partner',[['id','notin',mainMatchingPartners.map(partner=>partner.id)]]);
            extraMatchingPartners=mentionSuggestionsFilter(partners,search,limit);
        }
        return[mainMatchingPartners,extraMatchingPartners];
    },
    /**
     *Simulates`get_needaction_count`on`res.partner`.
     *
     *@private
     */
    _mockResPartnerGetNeedactionCount(){
        returnthis._getRecords('mail.notification',[
            ['res_partner_id','=',this.currentPartnerId],
            ['is_read','=',false],
        ]).length;
    },
    /**
     *Simulates`im_search`on`res.partner`.
     *
     *@private
     *@param{string}[name='']
     *@param{integer}[limit=20]
     *@returns{Object[]}
     */
    _mockResPartnerImSearch(name='',limit=20){
        name=name.toLowerCase();//simulatesILIKE
        //simulatesdomainwithrelationalparts(notsupportedbymockserver)
        constmatchingPartners=this._getRecords('res.users',[])
            .filter(user=>{
                constpartner=this._getRecords('res.partner',[['id','=',user.partner_id]])[0];
                //usermusthaveapartner
                if(!partner){
                    returnfalse;
                }
                //notcurrentpartner
                if(partner.id===this.currentPartnerId){
                    returnfalse;
                }
                //nonameisconsideredasreturnall
                if(!name){
                    returntrue;
                }
                if(partner.name&&partner.name.toLowerCase().includes(name)){
                    returntrue;
                }
                returnfalse;
            }).map(user=>{
                constpartner=this._getRecords('res.partner',[['id','=',user.partner_id]])[0];
                return{
                    id:partner.id,
                    im_status:user.im_status||'offline',
                    name:partner.name,
                    user_id:user.id,
                };
            });
        matchingPartners.length=Math.min(matchingPartners.length,limit);
        returnmatchingPartners;
    },
    /**
     *Simulates`mail_partner_format`on`res.partner`.
     *
     *@private
     *@returns{integer}id
     *@returns{Object}
     */
    _mockResPartnerMailPartnerFormat(id){
        constpartner=this._getRecords(
            'res.partner',
            [['id','=',id]],
            {active_test:false}
        )[0];
        return{
            "active":partner.active,
            "display_name":partner.display_name,
            "id":partner.id,
            "im_status":partner.im_status,
            "name":partner.name,
        };
    },
});

});

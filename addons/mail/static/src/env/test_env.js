flectra.define('mail/static/src/env/test_env.js',function(require){
'usestrict';

const{makeDeferred}=require('mail/static/src/utils/deferred/deferred.js');
const{nextTick}=require('mail/static/src/utils/utils.js');

const{Store}=owl;
const{EventBus}=owl.core;

/**
 *@param{Object}[providedEnv={}]
 *@returns{Object}
 */
functionaddMessagingToEnv(providedEnv={}){
    constenv=Object.assign(providedEnv);

    /**
     *Messagingstore
     */
    conststore=newStore({
        env,
        state:{
            messagingRevNumber:0,
        },
    });

    /**
     *Registryofmodels.
     */
    env.models={};
    /**
     *Environmentkeysusedinmessaging.
     */
    Object.assign(env,{
        autofetchPartnerImStatus:false,
        browser:Object.assign({
            innerHeight:1080,
            innerWidth:1920,
            Notification:Object.assign({
                permission:'denied',
                asyncrequestPermission(){
                    returnthis.permission;
                },
            },(env.browser&&env.browser.Notification)||{}),
        },env.browser),
        destroyMessaging(){
            if(env.modelManager){
                env.modelManager.deleteAll();
                env.messaging=undefined;
            }
        },
        disableAnimation:true,
        isMessagingInitialized(){
            if(!this.messaging){
                returnfalse;
            }
            returnthis.messaging.isInitialized;
        },
        /**
         *StateswhethertheenvironmentisinQUnittestornot.
         *
         *UsefultopreventsomebehaviourinQUnittests,likeapplying
         *styleofattachmentthatusesurl.
         */
        isQUnitTest:true,
        loadingBaseDelayDuration:providedEnv.loadingBaseDelayDuration||0,
        messaging:undefined,
        messagingCreatedPromise:makeDeferred(),
        messagingInitializedDeferred:makeDeferred(),
        messagingBus:newEventBus(),
        modelManager:undefined,
        store,
    });

    returnenv;
}

/**
 *@param{Object}[providedEnv={}]
 *@returns{Object}
 */
functionaddTimeControlToEnv(providedEnv={}){

    letenv=Object.assign({},providedEnv);

    if(!env.browser){
        env.browser={};
    }
    //listoftimeoutidsthathavetimedout.
    lettimedOutIds=[];
    //key:timeoutId,value:func+remainingduration
    consttimeouts=newMap();
    Object.assign(env.browser,{
        clearTimeout:id=>{
            timeouts.delete(id);
            timedOutIds=timedOutIds.filter(i=>i!==id);
        },
        setTimeout:(func,duration)=>{
            consttimeoutId=_.uniqueId('timeout_');
            consttimeout={
                id:timeoutId,
                isTimedOut:false,
                func,
                duration,
            };
            timeouts.set(timeoutId,timeout);
            if(duration===0){
                timedOutIds.push(timeoutId);
                timeout.isTimedOut=true;
            }
            returntimeoutId;
        },
    });
    if(!env.testUtils){
        env.testUtils={};
    }
    Object.assign(env.testUtils,{
        advanceTime:asyncduration=>{
            awaitnextTick();
            for(constidoftimeouts.keys()){
                consttimeout=timeouts.get(id);
                if(timeout.isTimedOut){
                    continue;
                }
                timeout.duration=Math.max(timeout.duration-duration,0);
                if(timeout.duration===0){
                    timedOutIds.push(id);
                }
            }
            while(timedOutIds.length>0){
                constid=timedOutIds.shift();
                consttimeout=timeouts.get(id);
                timeouts.delete(id);
                timeout.func();
                awaitnextTick();
            }
            awaitnextTick();
        },
    });
    returnenv;
}

return{
    addMessagingToEnv,
    addTimeControlToEnv,
};

});

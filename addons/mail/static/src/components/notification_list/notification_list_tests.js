flectra.define('mail/static/src/components/notification_list/notification_list_tests.js',function(require){
'usestrict';

constcomponents={
    NotificationList:require('mail/static/src/components/notification_list/notification_list.js'),
};

const{
    afterEach,
    afterNextRender,
    beforeEach,
    createRootComponent,
    start,
}=require('mail/static/src/utils/test_utils.js');

QUnit.module('mail',{},function(){
QUnit.module('components',{},function(){
QUnit.module('notification_list',{},function(){
QUnit.module('notification_list_tests.js',{
    beforeEach(){
        beforeEach(this);

        /**
         *@param{Object}param0
         *@param{string}[param0.filter='all']
         */
        this.createNotificationListComponent=async({filter='all'})=>{
            awaitcreateRootComponent(this,components.NotificationList,{
                props:{filter},
                target:this.widget.el,
            });
        };

        this.start=asyncparams=>{
            const{env,widget}=awaitstart(Object.assign({},params,{
                data:this.data,
            }));
            this.env=env;
            this.widget=widget;
        };
    },
    afterEach(){
        afterEach(this);
    },
});

QUnit.test('markedasreadthreadnotificationsareorderedbylastmessagedate',asyncfunction(assert){
    assert.expect(3);

    this.data['mail.channel'].records.push(
        {id:100,name:"Channel2019"},
        {id:200,name:"Channel2020"}
    );
    this.data['mail.message'].records.push(
        {
            channel_ids:[100],
            date:"2019-01-0100:00:00",
            id:42,
            model:'mail.channel',
            res_id:100,
        },
        {
            channel_ids:[200],
            date:"2020-01-0100:00:00",
            id:43,
            model:'mail.channel',
            res_id:200,
        }
    );
    awaitthis.start();
    awaitthis.createNotificationListComponent({filter:'all'});
    assert.containsN(
        document.body,
        '.o_ThreadPreview',
        2,
        "thereshouldbetwothreadpreviews"
    );
    constthreadPreviewElList=document.querySelectorAll('.o_ThreadPreview');
    assert.strictEqual(
        threadPreviewElList[0].querySelector(':scope.o_ThreadPreview_name').textContent,
        'Channel2020',
        "Firstchannelinthelistshouldbethechannelof2020(morerecentlastmessage)"
    );
    assert.strictEqual(
        threadPreviewElList[1].querySelector(':scope.o_ThreadPreview_name').textContent,
        'Channel2019',
        "Secondchannelinthelistshouldbethechannelof2019(leastrecentlastmessage)"
    );
});

QUnit.test('threadnotificationsarere-orderedonreceivinganewmessage',asyncfunction(assert){
    assert.expect(4);

    this.data['mail.channel'].records.push(
        {id:100,name:"Channel2019"},
        {id:200,name:"Channel2020"}
    );
    this.data['mail.message'].records.push(
        {
            channel_ids:[100],
            date:"2019-01-0100:00:00",
            id:42,
            model:'mail.channel',
            res_id:100,
        },
        {
            channel_ids:[200],
            date:"2020-01-0100:00:00",
            id:43,
            model:'mail.channel',
            res_id:200,
        }
    );
    awaitthis.start();
    awaitthis.createNotificationListComponent({filter:'all'});
    assert.containsN(
        document.body,
        '.o_ThreadPreview',
        2,
        "thereshouldbetwothreadpreviews"
    );

    awaitafterNextRender(()=>{
        constmessageData={
            author_id:[7,"DemoUser"],
            body:"<p>Newmessage!</p>",
            channel_ids:[100],
            date:"2020-03-2310:00:00",
            id:44,
            message_type:'comment',
            model:'mail.channel',
            record_name:'Channel2019',
            res_id:100,
        };
        this.widget.call('bus_service','trigger','notification',[
            [['my-db','mail.channel',100],messageData]
        ]);
    });
    assert.containsN(
        document.body,
        '.o_ThreadPreview',
        2,
        "thereshouldstillbetwothreadpreviews"
    );
    constthreadPreviewElList=document.querySelectorAll('.o_ThreadPreview');
    assert.strictEqual(
        threadPreviewElList[0].querySelector(':scope.o_ThreadPreview_name').textContent,
        'Channel2019',
        "Firstchannelinthelistshouldnowbe'Channel2019'"
    );
    assert.strictEqual(
        threadPreviewElList[1].querySelector(':scope.o_ThreadPreview_name').textContent,
        'Channel2020',
        "Secondchannelinthelistshouldnowbe'Channel2020'"
    );
});

});
});
});

});

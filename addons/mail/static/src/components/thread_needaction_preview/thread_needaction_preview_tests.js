flectra.define('mail/static/src/components/thread_needaction_preview/thread_needaction_preview_tests.js',function(require){
'usestrict';

constcomponents={
    ThreadNeedactionPreview:require('mail/static/src/components/thread_needaction_preview/thread_needaction_preview.js'),
};

const{
    afterEach,
    afterNextRender,
    beforeEach,
    createRootComponent,
    start,
}=require('mail/static/src/utils/test_utils.js');

constBus=require('web.Bus');

QUnit.module('mail',{},function(){
QUnit.module('components',{},function(){
QUnit.module('thread_needaction_preview',{},function(){
QUnit.module('thread_needaction_preview_tests.js',{
    beforeEach(){
        beforeEach(this);

        this.createThreadNeedactionPreviewComponent=asyncprops=>{
            awaitcreateRootComponent(this,components.ThreadNeedactionPreview,{
                props,
                target:this.widget.el
            });
        };

        this.start=asyncparams=>{
            const{afterEvent,env,widget}=awaitstart(Object.assign({},params,{
                data:this.data,
            }));
            this.afterEvent=afterEvent;
            this.env=env;
            this.widget=widget;
        };
    },
    afterEach(){
        afterEach(this);
    },
});

QUnit.test('markasread',asyncfunction(assert){
    assert.expect(5);

    this.data['mail.message'].records.push({
        id:21,
        model:'res.partner',
        needaction:true,
        needaction_partner_ids:[this.data.currentPartnerId],
        res_id:11,
    });
    this.data['mail.notification'].records.push({
        mail_message_id:21,
        notification_status:'sent',
        notification_type:'inbox',
        res_partner_id:this.data.currentPartnerId,
    });
    awaitthis.start({
        hasChatWindow:true,
        hasMessagingMenu:true,
        asyncmockRPC(route,args){
            if(route.includes('mark_all_as_read')){
                assert.step('mark_all_as_read');
                assert.deepEqual(
                    args.kwargs.domain,
                    [
                        ['model','=','res.partner'],
                        ['res_id','=',11],
                    ],
                    "shouldmarkallasreadthecorrectthread"
                );
            }
            returnthis._super(...arguments);
        },
    });
    awaitafterNextRender(()=>this.afterEvent({
        eventName:'o-thread-cache-loaded-messages',
        func:()=>document.querySelector('.o_MessagingMenu_toggler').click(),
        message:"shouldwaituntilinboxloadedinitialneedactionmessages",
        predicate:({threadCache})=>{
            returnthreadCache.thread.model==='mail.box'&&threadCache.thread.id==='inbox';
        },
    }));
    assert.containsOnce(
        document.body,
        '.o_ThreadNeedactionPreview_markAsRead',
        "shouldhave1markasreadbutton"
    );

    awaitafterNextRender(()=>
        document.querySelector('.o_ThreadNeedactionPreview_markAsRead').click()
    );
    assert.verifySteps(
        ['mark_all_as_read'],
        "shouldhavemarkedthethreadasread"
    );
    assert.containsNone(
        document.body,
        '.o_ChatWindow',
        "shouldnothaveopenedthethread"
    );
});

QUnit.test('clickonpreviewshouldmarkasreadandopenthethread',asyncfunction(assert){
    assert.expect(6);

    this.data['mail.message'].records.push({
        id:21,
        model:'res.partner',
        needaction:true,
        needaction_partner_ids:[this.data.currentPartnerId],
        res_id:11,
    });
    this.data['mail.notification'].records.push({
        mail_message_id:21,
        notification_status:'sent',
        notification_type:'inbox',
        res_partner_id:this.data.currentPartnerId,
    });
    awaitthis.start({
        hasChatWindow:true,
        hasMessagingMenu:true,
        asyncmockRPC(route,args){
            if(route.includes('mark_all_as_read')){
                assert.step('mark_all_as_read');
                assert.deepEqual(
                    args.kwargs.domain,
                    [
                        ['model','=','res.partner'],
                        ['res_id','=',11],
                    ],
                    "shouldmarkallasreadthecorrectthread"
                );
            }
            returnthis._super(...arguments);
        },
    });
    awaitafterNextRender(()=>this.afterEvent({
        eventName:'o-thread-cache-loaded-messages',
        func:()=>document.querySelector('.o_MessagingMenu_toggler').click(),
        message:"shouldwaituntilinboxloadedinitialneedactionmessages",
        predicate:({threadCache})=>{
            returnthreadCache.thread.model==='mail.box'&&threadCache.thread.id==='inbox';
        },
    }));
    assert.containsOnce(
        document.body,
        '.o_ThreadNeedactionPreview',
        "shouldhaveapreviewinitially"
    );
    assert.containsNone(
        document.body,
        '.o_ChatWindow',
        "shouldhavenochatwindowinitially"
    );

    awaitafterNextRender(()=>
        document.querySelector('.o_ThreadNeedactionPreview').click()
    );
    assert.verifySteps(
        ['mark_all_as_read'],
        "shouldhavemarkedthemessageasreadonclickingonthepreview"
    );
    assert.containsOnce(
        document.body,
        '.o_ChatWindow',
        "shouldhaveopenedthethreadonclickingonthepreview"
    );
});

QUnit.test('clickonexpandfromchatwindowshouldclosethechatwindowandopentheformview',asyncfunction(assert){
    assert.expect(8);

    constbus=newBus();
    bus.on('do-action',null,payload=>{
        assert.step('do_action');
        assert.strictEqual(
            payload.action.res_id,
            11,
            "shouldredirecttotheidofthethread"
        );
        assert.strictEqual(
            payload.action.res_model,
            'res.partner',
            "shouldredirecttothemodelofthethread"
        );
    });
    this.data['mail.message'].records.push({
        id:21,
        model:'res.partner',
        needaction:true,
        needaction_partner_ids:[this.data.currentPartnerId],
        res_id:11,
    });
    this.data['mail.notification'].records.push({
        mail_message_id:21,
        notification_status:'sent',
        notification_type:'inbox',
        res_partner_id:this.data.currentPartnerId,
    });
    awaitthis.start({
        env:{bus},
        hasChatWindow:true,
        hasMessagingMenu:true,
    });
    awaitafterNextRender(()=>this.afterEvent({
        eventName:'o-thread-cache-loaded-messages',
        func:()=>document.querySelector('.o_MessagingMenu_toggler').click(),
        message:"shouldwaituntilinboxloadedinitialneedactionmessages",
        predicate:({threadCache})=>{
            returnthreadCache.thread.model==='mail.box'&&threadCache.thread.id==='inbox';
        },
    }));
    assert.containsOnce(
        document.body,
        '.o_ThreadNeedactionPreview',
        "shouldhaveapreviewinitially"
    );
    awaitafterNextRender(()=>
        document.querySelector('.o_ThreadNeedactionPreview').click()
    );
    assert.containsOnce(
        document.body,
        '.o_ChatWindow',
        "shouldhaveopenedthethreadonclickingonthepreview"
    );
    assert.containsOnce(
        document.body,
        '.o_ChatWindowHeader_commandExpand',
        "shouldhaveanexpandbutton"
    );

    awaitafterNextRender(()=>
        document.querySelector('.o_ChatWindowHeader_commandExpand').click()
    );
    assert.containsNone(
        document.body,
        '.o_ChatWindow',
        "shouldhaveclosedthechatwindowonclickingexpand"
    );
    assert.verifySteps(
        ['do_action'],
        "shouldhavedoneanactiontoopentheformview"
    );
});

QUnit.test('[technical]openinganon-channelchatwindowshouldnotcallchannel_fold',asyncfunction(assert){
    //channel_foldshouldnotbecalledwhenopeningnon-channelsinchat
    //window,becausethereisnoserversyncoffoldstateforthem.
    assert.expect(3);

    this.data['mail.message'].records.push({
        id:21,
        model:'res.partner',
        needaction:true,
        needaction_partner_ids:[this.data.currentPartnerId],
        res_id:11,
    });
    this.data['mail.notification'].records.push({
        mail_message_id:21,
        notification_status:'sent',
        notification_type:'inbox',
        res_partner_id:this.data.currentPartnerId,
    });
    awaitthis.start({
        hasChatWindow:true,
        hasMessagingMenu:true,
        asyncmockRPC(route,args){
            if(route.includes('channel_fold')){
                constmessage="shouldnotcallchannel_foldwhenopeninganon-channelchatwindow";
                assert.step(message);
                console.error(message);
                throwError(message);
            }
            returnthis._super(...arguments);
        },
    });
    awaitafterNextRender(()=>this.afterEvent({
        eventName:'o-thread-cache-loaded-messages',
        func:()=>document.querySelector('.o_MessagingMenu_toggler').click(),
        message:"shouldwaituntilinboxloadedinitialneedactionmessages",
        predicate:({threadCache})=>{
            returnthreadCache.thread.model==='mail.box'&&threadCache.thread.id==='inbox';
        },
    }));
    assert.containsOnce(
        document.body,
        '.o_ThreadNeedactionPreview',
        "shouldhaveapreviewinitially"
    );
    assert.containsNone(
        document.body,
        '.o_ChatWindow',
        "shouldhavenochatwindowinitially"
    );

    awaitafterNextRender(()=>
        document.querySelector('.o_ThreadNeedactionPreview').click()
    );
    assert.containsOnce(
        document.body,
        '.o_ChatWindow',
        "shouldhaveopenedthechatwindowonclickingonthepreview"
    );
});

QUnit.test('previewshoulddisplaylastneedactionmessagepreviewevenifthereisamorerecentmessagethatisnotneedactioninthethread',asyncfunction(assert){
    assert.expect(2);

    this.data['res.partner'].records.push({
        id:11,
        name:"Stranger",
    });
    this.data['mail.message'].records.push({
        author_id:11,
        body:"Iamtheoldestbutneedaction",
        id:21,
        model:'res.partner',
        needaction:true,
        needaction_partner_ids:[this.data.currentPartnerId],
        res_id:11,
    });
    this.data['mail.message'].records.push({
        author_id:this.data.currentPartnerId,
        body:"Iammorerecent",
        id:22,
        model:'res.partner',
        res_id:11,
    });
    this.data['mail.notification'].records.push({
        mail_message_id:21,
        notification_status:'sent',
        notification_type:'inbox',
        res_partner_id:this.data.currentPartnerId,
    });
    awaitthis.start({
        hasChatWindow:true,
        hasMessagingMenu:true,
    });
    awaitafterNextRender(()=>this.afterEvent({
        eventName:'o-thread-cache-loaded-messages',
        func:()=>document.querySelector('.o_MessagingMenu_toggler').click(),
        message:"shouldwaituntilinboxloadedinitialneedactionmessages",
        predicate:({threadCache})=>{
            returnthreadCache.thread.model==='mail.box'&&threadCache.thread.id==='inbox';
        },
    }));
    assert.containsOnce(
        document.body,
        '.o_ThreadNeedactionPreview_inlineText',
        "shouldhaveapreviewfromthelastmessage"
    );
    assert.strictEqual(
        document.querySelector('.o_ThreadNeedactionPreview_inlineText').textContent,
        'Stranger:Iamtheoldestbutneedaction',
        "thedisplayedmessageshouldbetheonethatneedsactionevenifthereisamorerecentmessagethatisnotneedactiononthethread"
    );
});

QUnit.test('needactionpreviewshouldonlyshowonitsoriginthread',asyncfunction(assert){
    assert.expect(2);

    this.data['mail.channel'].records.push({id:12});
    this.data['mail.message'].records.push({
        channel_ids:[12],
        id:21,
        model:'res.partner',
        needaction:true,
        needaction_partner_ids:[this.data.currentPartnerId],
        res_id:11,
    });
    this.data['mail.notification'].records.push({
        mail_message_id:21,
        notification_status:'sent',
        notification_type:'inbox',
        res_partner_id:this.data.currentPartnerId,
    });
    awaitthis.start({hasMessagingMenu:true});
    awaitafterNextRender(()=>this.afterEvent({
        eventName:'o-thread-cache-loaded-messages',
        func:()=>document.querySelector('.o_MessagingMenu_toggler').click(),
        message:"shouldwaituntilinboxloadedinitialneedactionmessages",
        predicate:({threadCache})=>{
            returnthreadCache.thread.model==='mail.box'&&threadCache.thread.id==='inbox';
        },
    }));
    assert.containsOnce(
        document.body,
        '.o_ThreadNeedactionPreview',
        "shouldhaveonlyonepreview"
    );
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:11,
        model:'res.partner',
    });
    assert.containsOnce(
        document.body,
        `.o_ThreadNeedactionPreview[data-thread-local-id="${thread.localId}"]`,
        "previewshouldbeontheoriginthread"
    );
});

QUnit.test('chatwindowheadershouldnothaveunreadcounterfornon-channelthread',asyncfunction(assert){
    assert.expect(2);

    this.data['res.partner'].records.push({id:11});
    this.data['mail.message'].records.push({
        author_id:11,
        body:'notempty',
        id:21,
        model:'res.partner',
        needaction:true,
        needaction_partner_ids:[this.data.currentPartnerId],
        res_id:11,
    });
    this.data['mail.notification'].records.push({
        mail_message_id:21,
        notification_status:'sent',
        notification_type:'inbox',
        res_partner_id:this.data.currentPartnerId,
    });
    awaitthis.start({
        hasChatWindow:true,
        hasMessagingMenu:true,
    });
    awaitafterNextRender(()=>this.afterEvent({
        eventName:'o-thread-cache-loaded-messages',
        func:()=>document.querySelector('.o_MessagingMenu_toggler').click(),
        message:"shouldwaituntilinboxloadedinitialneedactionmessages",
        predicate:({threadCache})=>{
            returnthreadCache.thread.model==='mail.box'&&threadCache.thread.id==='inbox';
        },
    }));
    awaitafterNextRender(()=>
        document.querySelector('.o_ThreadNeedactionPreview').click()
    );
    assert.containsOnce(
        document.body,
        '.o_ChatWindow',
        "shouldhaveopenedthechatwindowonclickingonthepreview"
    );
    assert.containsNone(
        document.body,
        '.o_ChatWindowHeader_counter',
        "chatwindowheadershouldnothaveunreadcounterfornon-channelthread"
    );
});

});
});
});

});

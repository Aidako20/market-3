flectra.define('mail/static/src/components/follower/follower_tests.js',function(require){
'usestrict';

constcomponents={
    Follower:require('mail/static/src/components/follower/follower.js'),
};
const{makeDeferred}=require('mail/static/src/utils/deferred/deferred.js');
const{
    afterEach,
    afterNextRender,
    beforeEach,
    createRootComponent,
    start,
}=require('mail/static/src/utils/test_utils.js');

constBus=require('web.Bus');

QUnit.module('mail',{},function(){
QUnit.module('components',{},function(){
QUnit.module('follower',{},function(){
QUnit.module('follower_tests.js',{
    beforeEach(){
        beforeEach(this);

        this.createFollowerComponent=async(follower)=>{
            awaitcreateRootComponent(this,components.Follower,{
                props:{followerLocalId:follower.localId},
                target:this.widget.el,
            });
        };

        this.start=asyncparams=>{
            const{env,widget}=awaitstart(Object.assign({},params,{
                data:this.data,
            }));
            this.env=env;
            this.widget=widget;
        };
    },
    afterEach(){
        afterEach(this);
    },
});

QUnit.test('baserenderingnoteditable',asyncfunction(assert){
    assert.expect(5);

    awaitthis.start();

    constthread=this.env.models['mail.thread'].create({
        id:100,
        model:'res.partner',
    });
    constfollower=awaitthis.env.models['mail.follower'].create({
        channel:[['insert',{id:1,model:'mail.channel',name:"FrançoisPerusse"}]],
        followedThread:[['link',thread]],
        id:2,
        isActive:true,
        isEditable:false,
    });
    awaitthis.createFollowerComponent(follower);
    assert.containsOnce(
        document.body,
        '.o_Follower',
        "shouldhavefollowercomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Follower_details',
        "shoulddisplayadetailspart"
    );
    assert.containsOnce(
        document.body,
        '.o_Follower_avatar',
        "shoulddisplaytheavatarofthefollower"
    );
    assert.containsOnce(
        document.body,
        '.o_Follower_name',
        "shoulddisplaythenameofthefollower"
    );
    assert.containsNone(
        document.body,
        '.o_Follower_button',
        "shouldhavenobuttonasfollowerisnoteditable"
    );
});

QUnit.test('baserenderingeditable',asyncfunction(assert){
    assert.expect(6);

    awaitthis.start();
    constthread=this.env.models['mail.thread'].create({
        id:100,
        model:'res.partner',
    });
    constfollower=awaitthis.env.models['mail.follower'].create({
        channel:[['insert',{id:1,model:'mail.channel',name:"FrançoisPerusse"}]],
        followedThread:[['link',thread]],
        id:2,
        isActive:true,
        isEditable:true,
    });
    awaitthis.createFollowerComponent(follower);
    assert.containsOnce(
        document.body,
        '.o_Follower',
        "shouldhavefollowercomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Follower_details',
        "shoulddisplayadetailspart"
    );
    assert.containsOnce(
        document.body,
        '.o_Follower_avatar',
        "shoulddisplaytheavatarofthefollower"
    );
    assert.containsOnce(
        document.body,
        '.o_Follower_name',
        "shoulddisplaythenameofthefollower"
    );
    assert.containsOnce(
        document.body,
        '.o_Follower_editButton',
        "shouldhaveaneditbutton"
    );
    assert.containsOnce(
        document.body,
        '.o_Follower_removeButton',
        "shouldhavearemovebutton"
    );
});

QUnit.test('clickonchannelfollowerdetails',asyncfunction(assert){
    assert.expect(7);

    constbus=newBus();
    bus.on('do-action',null,payload=>{
        assert.step('do_action');
        assert.strictEqual(
            payload.action.res_id,
            10,
            "Theredirectactionshouldredirecttotherightresid(10)"
        );
        assert.strictEqual(
            payload.action.res_model,
            'mail.channel',
            "Theredirectactionshouldredirecttotherightresmodel(mail.channel)"
        );
        assert.strictEqual(
            payload.action.type,
            "ir.actions.act_window",
            "Theredirectactionshouldbeoftype'ir.actions.act_window'"
        );
    });
    this.data['res.partner'].records.push({id:100});
    this.data['mail.channel'].records.push({id:10});
    awaitthis.start({
        env:{bus},
    });
    constthread=this.env.models['mail.thread'].create({
        id:100,
        model:'res.partner',
    });
    constfollower=awaitthis.env.models['mail.follower'].create({
        channel:[['insert',{id:10,model:'mail.channel',name:"channel"}]],
        followedThread:[['link',thread]],
        id:2,
        isActive:true,
        isEditable:true,
    });
    awaitthis.createFollowerComponent(follower);
    assert.containsOnce(
        document.body,
        '.o_Follower',
        "shouldhavefollowercomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Follower_details',
        "shoulddisplayadetailspart"
    );

    document.querySelector('.o_Follower_details').click();
    assert.verifySteps(
        ['do_action'],
        "clickingonchannelshouldredirecttochannelformview"
    );
});

QUnit.test('clickonpartnerfollowerdetails',asyncfunction(assert){
    assert.expect(7);

    constopenFormDef=makeDeferred();
    constbus=newBus();
    bus.on('do-action',null,payload=>{
        assert.step('do_action');
        assert.strictEqual(
            payload.action.res_id,
            3,
            "Theredirectactionshouldredirecttotherightresid(3)"
        );
        assert.strictEqual(
            payload.action.res_model,
            'res.partner',
            "Theredirectactionshouldredirecttotherightresmodel(res.partner)"
        );
        assert.strictEqual(
            payload.action.type,
            "ir.actions.act_window",
            "Theredirectactionshouldbeoftype'ir.actions.act_window'"
        );
        openFormDef.resolve();
    });
    this.data['res.partner'].records.push({id:100});
    awaitthis.start({
        env:{bus},
    });
    constthread=this.env.models['mail.thread'].create({
        id:100,
        model:'res.partner',
    });
    constfollower=awaitthis.env.models['mail.follower'].create({
        followedThread:[['link',thread]],
        id:2,
        isActive:true,
        isEditable:true,
        partner:[['insert',{
            email:"bla@bla.bla",
            id:this.env.messaging.currentPartner.id,
            name:"FrançoisPerusse",
        }]],
    });
    awaitthis.createFollowerComponent(follower);
    assert.containsOnce(
        document.body,
        '.o_Follower',
        "shouldhavefollowercomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Follower_details',
        "shoulddisplayadetailspart"
    );

    document.querySelector('.o_Follower_details').click();
    awaitopenFormDef;
    assert.verifySteps(
        ['do_action'],
        "clickingonfollowershouldredirecttopartnerformview"
    );
});

QUnit.test('clickoneditfollower',asyncfunction(assert){
    assert.expect(5);

    this.data['res.partner'].records.push({id:100,message_follower_ids:[2]});
    this.data['mail.followers'].records.push({
        id:2,
        is_active:true,
        is_editable:true,
        partner_id:this.data.currentPartnerId,
        res_id:100,
        res_model:'res.partner',
    });
    awaitthis.start({
        hasDialog:true,
        asyncmockRPC(route,args){
            if(route.includes('/mail/read_subscription_data')){
                assert.step('fetch_subtypes');
            }
            returnthis._super(...arguments);
        },
    });
    constthread=this.env.models['mail.thread'].create({
        id:100,
        model:'res.partner',
    });
    awaitthread.refreshFollowers();
    awaitthis.createFollowerComponent(thread.followers[0]);
    assert.containsOnce(
        document.body,
        '.o_Follower',
        "shouldhavefollowercomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Follower_editButton',
        "shoulddisplayaneditbutton"
    );

    awaitafterNextRender(()=>document.querySelector('.o_Follower_editButton').click());
    assert.verifySteps(
        ['fetch_subtypes'],
        "clickingoneditfollowershouldfetchsubtypes"
    );
    assert.containsOnce(
        document.body,
        '.o_FollowerSubtypeList',
        "Adialogallowingtoeditfollowersubtypesshouldhavebeencreated"
    );
});

QUnit.test('editfollowerandclosesubtypedialog',asyncfunction(assert){
    assert.expect(6);

    this.data['res.partner'].records.push({id:100});
    awaitthis.start({
        hasDialog:true,
        asyncmockRPC(route,args){
            if(route.includes('/mail/read_subscription_data')){
                assert.step('fetch_subtypes');
                return[{
                    default:true,
                    followed:true,
                    internal:false,
                    id:1,
                    name:"Dummytest",
                    res_model:'res.partner'
                }];
            }
            returnthis._super(...arguments);
        },
    });
    constthread=this.env.models['mail.thread'].create({
        id:100,
        model:'res.partner',
    });
    constfollower=awaitthis.env.models['mail.follower'].create({
        followedThread:[['link',thread]],
        id:2,
        isActive:true,
        isEditable:true,
        partner:[['insert',{
            email:"bla@bla.bla",
            id:this.env.messaging.currentPartner.id,
            name:"FrançoisPerusse",
        }]],
    });
    awaitthis.createFollowerComponent(follower);
    assert.containsOnce(
        document.body,
        '.o_Follower',
        "shouldhavefollowercomponent"
    );
    assert.containsOnce(
        document.body,
        '.o_Follower_editButton',
        "shoulddisplayaneditbutton"
    );

    awaitafterNextRender(()=>document.querySelector('.o_Follower_editButton').click());
    assert.verifySteps(
        ['fetch_subtypes'],
        "clickingoneditfollowershouldfetchsubtypes"
    );
    assert.containsOnce(
        document.body,
        '.o_FollowerSubtypeList',
        "dialogallowingtoeditfollowersubtypesshouldhavebeencreated"
    );

    awaitafterNextRender(
        ()=>document.querySelector('.o_FollowerSubtypeList_closeButton').click()
    );
    assert.containsNone(
        document.body,
        '.o_DialogManager_dialog',
        "followersubtypedialogshouldbeclosedafterclickingonclosebutton"
    );
});

});
});
});

});

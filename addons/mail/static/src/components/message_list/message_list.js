flectra.define('mail/static/src/components/message_list/message_list.js',function(require){
'usestrict';

constcomponents={
    Message:require('mail/static/src/components/message/message.js'),
};
constuseRefs=require('mail/static/src/component_hooks/use_refs/use_refs.js');
constuseRenderedValues=require('mail/static/src/component_hooks/use_rendered_values/use_rendered_values.js');
constuseShouldUpdateBasedOnProps=require('mail/static/src/component_hooks/use_should_update_based_on_props/use_should_update_based_on_props.js');
constuseStore=require('mail/static/src/component_hooks/use_store/use_store.js');
constuseUpdate=require('mail/static/src/component_hooks/use_update/use_update.js');

const{Component}=owl;
const{useRef}=owl.hooks;

classMessageListextendsComponent{

    /**
     *@override
     */
    constructor(...args){
        super(...args);
        useShouldUpdateBasedOnProps();
        useStore(props=>{
            constthreadView=this.env.models['mail.thread_view'].get(props.threadViewLocalId);
            constthread=threadView?threadView.thread:undefined;
            constthreadCache=threadView?threadView.threadCache:undefined;
            return{
                isDeviceMobile:this.env.messaging.device.isMobile,
                thread,
                threadCache,
                threadCacheIsAllHistoryLoaded:threadCache&&threadCache.isAllHistoryLoaded,
                threadCacheIsLoaded:threadCache&&threadCache.isLoaded,
                threadCacheIsLoadingMore:threadCache&&threadCache.isLoadingMore,
                threadCacheLastMessage:threadCache&&threadCache.lastMessage,
                threadCacheOrderedMessages:threadCache?threadCache.orderedMessages:[],
                threadIsTemporary:thread&&thread.isTemporary,
                threadMainCache:thread&&thread.mainCache,
                threadMessageAfterNewMessageSeparator:thread&&thread.messageAfterNewMessageSeparator,
                threadViewComponentHintList:threadView?threadView.componentHintList:[],
                threadViewNonEmptyMessagesLength:threadView&&threadView.nonEmptyMessages.length,
            };
        },{
            compareDepth:{
                threadCacheOrderedMessages:1,
                threadViewComponentHintList:1,
            },
        });
        this._getRefs=useRefs();
        /**
         *Stateswhethertherewasatleastoneprogrammaticscrollsincethe
         *lastscrolleventwashandled(whichisparticularlyasyncdueto
         *throttledbehavior).
         *Usefultoavoidloadingmoremessagesortoincorrectlydisablingthe
         *auto-scrollfeaturewhenthescrollwasnotmadebytheuser.
         */
        this._isLastScrollProgrammatic=false;
        /**
         *Referenceofthe"loadmore"item.Usefultotriggerloadmore
         *onscrollwhenitbecomesvisible.
         */
        this._loadMoreRef=useRef('loadMore');
        /**
         *SnapshotcomputedduringwillPatch,whichisusedbypatched.
         */
        this._willPatchSnapshot=undefined;
        this._onScrollThrottled=_.throttle(this._onScrollThrottled.bind(this),100);
        /**
         *Stateusedbythecomponentatthetimeoftherender.Usefulto
         *properlyhandleasynccode.
         */
        this._lastRenderedValues=useRenderedValues(()=>{
            constthreadView=this.threadView;
            constthread=threadView&&threadView.thread;
            constthreadCache=threadView&&threadView.threadCache;
            return{
                componentHintList:threadView?[...threadView.componentHintList]:[],
                hasAutoScrollOnMessageReceived:threadView&&threadView.hasAutoScrollOnMessageReceived,
                hasScrollAdjust:this.props.hasScrollAdjust,
                mainCache:thread&&thread.mainCache,
                order:this.props.order,
                orderedMessages:threadCache?[...threadCache.orderedMessages]:[],
                thread,
                threadCache,
                threadCacheInitialScrollHeight:threadView&&threadView.threadCacheInitialScrollHeight,
                threadCacheInitialScrollPosition:threadView&&threadView.threadCacheInitialScrollPosition,
                threadView,
                threadViewer:threadView&&threadView.threadViewer,
            };
        });
        //useUpdatemustbedefinedafteruseRenderedValuestoguaranteeproper
        //callorder
        useUpdate({func:()=>this._update()});
    }

    willPatch(){
        constlastMessageRef=this.lastMessageRef;
        this._willPatchSnapshot={
            isLastMessageVisible:
                lastMessageRef&&
                lastMessageRef.isBottomVisible({offset:10}),
            scrollHeight:this._getScrollableElement().scrollHeight,
            scrollTop:this._getScrollableElement().scrollTop,
        };
    }

    //--------------------------------------------------------------------------
    //Public
    //--------------------------------------------------------------------------

    /**
     *Updatethescrollpositionofthemessagelist.
     *Thisisnotdoneinpatched/mountedhooksbecausescrollpositionis
     *dependentonUIglobally.Toillustrate,imaginefollowingUI:
     *
     *+----------+<viewporttop=scrollabletop
     *|message |
     *|  list  |
     *|         |
     *+----------+<scrolltop=viewportbottom=scrollablebottom
     *
     *Nowifacomposerismountedjustbelowthemessagelist,itisshrinked
     *andscrolltopisalteredasaresult:
     *
     *+----------+<viewporttop=scrollabletop
     *|message |
     *|  list  |<scrolltop=viewportbottom <-+
     *|         |                                 |--dist=composerheight
     *+----------+<scrollablebottom           <-+
     *+----------+
     *|composer|
     *+----------+
     *
     *Becauseofthis,thescrollpositionmustbechangedwhenwholeUI
     *isrendered.Tomakethissimpler,thisisdonewhen<ThreadView/>
     *componentispatched.Thisisacceptablewhen<ThreadView/>hasa
     *fixedheight,whichisthecaseforthemoment.task-2358066
     */
    adjustFromComponentHints(){
        const{componentHintList,threadView}=this._lastRenderedValues();
        for(consthintofcomponentHintList){
            switch(hint.type){
                case'change-of-thread-cache':
                case'home-menu-hidden':
                case'home-menu-shown':
                case'adjust-scroll':
                    //threadjustbecamevisible,thegoalistorestoreits
                    //savedpositionifitexistsorscrolltotheend
                    this._adjustScrollFromModel();
                    break;
                case'message-received':
                case'messages-loaded':
                case'new-messages-loaded':
                    //messageshavebeenaddedattheend,eitherscrolltothe
                    //endorkeepthecurrentposition
                    this._adjustScrollForExtraMessagesAtTheEnd();
                    break;
                case'more-messages-loaded':
                    //messageshavebeenaddedatthestart,keepthecurrent
                    //position
                    this._adjustScrollForExtraMessagesAtTheStart();
                    break;
            }
            if(threadView&&threadView.exists()){
                threadView.markComponentHintProcessed(hint);
            }
        }
        this._willPatchSnapshot=undefined;
    }

    /**
     *@param{mail.message}message
     *@returns{string}
     */
    getDateDay(message){
        if(!message.date){
            //Withoutadate,weassumethatit'satodaymessage.Thisis
            //mainlydonetoavoidflickerinsidetheUI.
            returnthis.env._t("Today");
        }
        constdate=message.date.format('YYYY-MM-DD');
        if(date===moment().format('YYYY-MM-DD')){
            returnthis.env._t("Today");
        }elseif(
            date===moment()
                .subtract(1,'days')
                .format('YYYY-MM-DD')
        ){
            returnthis.env._t("Yesterday");
        }
        returnmessage.date.format('LL');
    }

    /**
     *@returns{integer}
     */
    getScrollHeight(){
        returnthis._getScrollableElement().scrollHeight;
    }

    /**
     *@returns{integer}
     */
    getScrollTop(){
        returnthis._getScrollableElement().scrollTop;
    }

    /**
     *@returns{mail/static/src/components/message/message.js|undefined}
     */
    getmostRecentMessageRef(){
        const{order}=this._lastRenderedValues();
        if(order==='desc'){
            returnthis.messageRefs[0];
        }
        const{length:l,[l-1]:mostRecentMessageRef}=this.messageRefs;
        returnmostRecentMessageRef;
    }

    /**
     *@param{integer}messageId
     *@returns{mail/static/src/components/message/message.js|undefined}
     */
    messageRefFromId(messageId){
        returnthis.messageRefs.find(ref=>ref.message.id===messageId);
    }

    /**
     *Getlistofsub-componentsMessage,orderedbasedonprop`order`
     *(ASC/DESC).
     *
     *TheasynchronousnatureofOWLrenderingpipelinemayrevealdisparity
     *betweenknowledgeablestateofstorebetweencomponents.Usethisgetter
     *withextremecaution!
     *
     *Let'sillustratethedisparitywithasmallexample:
     *
     *-Supposethiscomponentisawareofordered(record)messageswith
     *  followingIDs:[1,2,3,4,5],andeach(sub-component)messagesmap
     *eachoftheserecords.
     *-Nowlet'sassumeachangeinstorethattranslatetoordered(record)
     *  messageswithfollowingIDs:[2,3,4,5,6].
     *-Becausestorechangestriggercomponentre-renderingbytheir"depth"
     *  (i.e.fromparentstochildren),thiscomponentmaybeawareof
     *  [2,3,4,5,6]butnotyetsub-components,sothatsome(component)
     *  messagesshouldbedestroyedbutaren'tyet(therefwithmessageID1)
     *  andsomedonotexistyet(norefwithmessageID6).
     *
     *@returns{mail/static/src/components/message/message.js[]}
     */
    getmessageRefs(){
        const{order}=this._lastRenderedValues();
        constrefs=this._getRefs();
        constascOrderedMessageRefs=Object.entries(refs)
            .filter(([refId,ref])=>(
                    //Messagerefshavemessagelocalidasrefid,andmessage
                    //localidscontainnameofmodel'mail.message'.
                    refId.includes(this.env.models['mail.message'].modelName)&&
                    //Componentthatshouldbedestroyedbuthaven'tjustyet.
                    ref.message
                )
            )
            .map(([refId,ref])=>ref)
            .sort((ref1,ref2)=>(ref1.message.id<ref2.message.id?-1:1));
        if(order==='desc'){
            returnascOrderedMessageRefs.reverse();
        }
        returnascOrderedMessageRefs;
    }

    /**
     *@returns{mail.message[]}
     */
    getorderedMessages(){
        constthreadCache=this.threadView.threadCache;
        if(this.props.order==='desc'){
            return[...threadCache.orderedMessages].reverse();
        }
        returnthreadCache.orderedMessages;
    }

    /**
     *@param{integer}value
     */
    setScrollTop(value){
        if(this._getScrollableElement().scrollTop===value){
            return;
        }
        this._isLastScrollProgrammatic=true;
        this._getScrollableElement().scrollTop=value;
    }

    /**
     *@param{mail.message}prevMessage
     *@param{mail.message}message
     *@returns{boolean}
     */
    shouldMessageBeSquashed(prevMessage,message){
        if(!this.props.hasSquashCloseMessages){
            returnfalse;
        }
        if(!prevMessage.date&&message.date){
            returnfalse;
        }
        if(message.date&&prevMessage.date&&Math.abs(message.date.diff(prevMessage.date))>60000){
            //morethan1min.elasped
            returnfalse;
        }
        if(prevMessage.message_type!=='comment'||message.message_type!=='comment'){
            returnfalse;
        }
        if(prevMessage.author!==message.author){
            //fromadifferentauthor
            returnfalse;
        }
        if(prevMessage.originThread!==message.originThread){
            returnfalse;
        }
        if(
            prevMessage.moderation_status==='pending_moderation'||
            message.moderation_status==='pending_moderation'
        ){
            returnfalse;
        }
        if(
            prevMessage.notifications.length>0||
            message.notifications.length>0
        ){
            //visualaboutnotificationsisrestrictedtonon-squashedmessages
            returnfalse;
        }
        constprevOriginThread=prevMessage.originThread;
        constoriginThread=message.originThread;
        if(
            prevOriginThread&&
            originThread&&
            prevOriginThread.model===originThread.model&&
            originThread.model!=='mail.channel'&&
            prevOriginThread.id!==originThread.id
        ){
            //messageslinkedtodifferentdocumentthread
            returnfalse;
        }
        returntrue;
    }

    /**
     *@returns{mail.thread_view}
     */
    getthreadView(){
        returnthis.env.models['mail.thread_view'].get(this.props.threadViewLocalId);
    }

    //--------------------------------------------------------------------------
    //Private
    //--------------------------------------------------------------------------

    /**
     *@private
     */
    _adjustScrollForExtraMessagesAtTheEnd(){
        const{
            hasAutoScrollOnMessageReceived,
            hasScrollAdjust,
            order,
        }=this._lastRenderedValues();
        if(!this._getScrollableElement()||!hasScrollAdjust){
            return;
        }
        if(!hasAutoScrollOnMessageReceived){
            if(order==='desc'&&this._willPatchSnapshot){
                const{scrollHeight,scrollTop}=this._willPatchSnapshot;
                this.setScrollTop(this._getScrollableElement().scrollHeight-scrollHeight+scrollTop);
            }
            return;
        }
        this._scrollToEnd();
    }

    /**
     *@private
     */
    _adjustScrollForExtraMessagesAtTheStart(){
        const{
            hasScrollAdjust,
            order,
        }=this._lastRenderedValues();
        if(
            !this._getScrollableElement()||
            !hasScrollAdjust||
            !this._willPatchSnapshot||
            order==='desc'
        ){
            return;
        }
        const{scrollHeight,scrollTop}=this._willPatchSnapshot;
        this.setScrollTop(this._getScrollableElement().scrollHeight-scrollHeight+scrollTop);
    }

    /**
     *@private
     */
    _adjustScrollFromModel(){
        const{
            hasScrollAdjust,
            threadCacheInitialScrollHeight,
            threadCacheInitialScrollPosition,
        }=this._lastRenderedValues();
        if(!this._getScrollableElement()||!hasScrollAdjust){
            return;
        }
        if(
            threadCacheInitialScrollPosition!==undefined&&
            this._getScrollableElement().scrollHeight===threadCacheInitialScrollHeight
        ){
            this.setScrollTop(threadCacheInitialScrollPosition);
            return;
        }
        this._scrollToEnd();
        return;
    }

    /**
     *@private
     */
    _checkMostRecentMessageIsVisible(){
        const{
            mainCache,
            threadCache,
            threadView,
        }=this._lastRenderedValues();
        if(!threadView||!threadView.exists()){
            return;
        }
        constlastMessageIsVisible=
            threadCache&&
            this.mostRecentMessageRef&&
            threadCache===mainCache&&
            this.mostRecentMessageRef.isPartiallyVisible();
        if(lastMessageIsVisible){
            threadView.handleVisibleMessage(this.mostRecentMessageRef.message);
        }
    }

    /**
     *@private
     *@returns{Element|undefined}ScrollableElement
     */
    _getScrollableElement(){
        if(this.props.getScrollableElement){
            returnthis.props.getScrollableElement();
        }else{
            returnthis.el;
        }
    }

    /**
     *@private
     *@returns{boolean}
     */
    _isLoadMoreVisible(){
        constloadMore=this._loadMoreRef.el;
        if(!loadMore){
            returnfalse;
        }
        constloadMoreRect=loadMore.getBoundingClientRect();
        constelRect=this._getScrollableElement().getBoundingClientRect();
        constisInvisible=loadMoreRect.top>elRect.bottom||loadMoreRect.bottom<elRect.top;
        return!isInvisible;
    }

    /**
     *@private
     */
    _loadMore(){
        const{threadCache}=this._lastRenderedValues();
        if(!threadCache||!threadCache.exists()){
            return;
        }
        threadCache.loadMoreMessages();
    }

    /**
     *Scrollstotheendofthelist.
     *
     *@private
     */
    _scrollToEnd(){
        const{order}=this._lastRenderedValues();
        this.setScrollTop(order==='asc'?this._getScrollableElement().scrollHeight-this._getScrollableElement().clientHeight:0);
    }

    /**
     *@private
     */
    _update(){
        this._checkMostRecentMessageIsVisible();
        this.adjustFromComponentHints();
    }

    //--------------------------------------------------------------------------
    //Handlers
    //--------------------------------------------------------------------------

    /**
     *@private
     *@param{MouseEvent}ev
     */
    _onClickLoadMore(ev){
        ev.preventDefault();
        this._loadMore();
    }

    /**
     *@private
     *@param{ScrollEvent}ev
     */
    onScroll(ev){
        this._onScrollThrottled(ev);
    }

    /**
     *@private
     *@param{ScrollEvent}ev
     */
    _onScrollThrottled(ev){
        const{
            order,
            orderedMessages,
            thread,
            threadCache,
            threadView,
            threadViewer,
        }=this._lastRenderedValues();
        if(!this._getScrollableElement()){
            //couldbeunmountedinthemeantime(duetothrottledbehavior)
            return;
        }
        constscrollTop=this._getScrollableElement().scrollTop;
        this.env.messagingBus.trigger('o-component-message-list-scrolled',{
            orderedMessages,
            scrollTop,
            thread,
            threadViewer,
        });
        if(!this._isLastScrollProgrammatic&&threadView&&threadView.exists()){
            //Margintocompensateforinaccuratescrollingtobottomandheight
            //flickerdueheightchangeofcomposerarea.
            constmargin=30;
            //Automaticallyscrolltonewreceivedmessagesonlywhenthelistis
            //currentlyfullyscrolled.
            consthasAutoScrollOnMessageReceived=(order==='asc')
                ?scrollTop>=this._getScrollableElement().scrollHeight-this._getScrollableElement().clientHeight-margin
                :scrollTop<=margin;
            threadView.update({hasAutoScrollOnMessageReceived});
        }
        if(threadViewer&&threadViewer.exists()){
            threadViewer.saveThreadCacheScrollHeightAsInitial(this._getScrollableElement().scrollHeight,threadCache);
            threadViewer.saveThreadCacheScrollPositionsAsInitial(scrollTop,threadCache);
        }
        if(!this._isLastScrollProgrammatic&&this._isLoadMoreVisible()){
            this._loadMore();
        }
        this._checkMostRecentMessageIsVisible();
        this._isLastScrollProgrammatic=false;
    }

}

Object.assign(MessageList,{
    components,
    defaultProps:{
        hasMessageCheckbox:false,
        hasScrollAdjust:true,
        hasSquashCloseMessages:false,
        haveMessagesMarkAsReadIcon:false,
        haveMessagesReplyIcon:false,
        order:'asc',
    },
    props:{
        hasMessageCheckbox:Boolean,
        hasSquashCloseMessages:Boolean,
        haveMessagesMarkAsReadIcon:Boolean,
        haveMessagesReplyIcon:Boolean,
        hasScrollAdjust:Boolean,
        /**
         *Functionreturnstheexactscrollableelementfromtheparent
         *tomanageproperscrollheightswhichaffectstheloadmoremessages.
         */
        getScrollableElement:{
            type:Function,
            optional:true,
        },
        order:{
            type:String,
            validate:prop=>['asc','desc'].includes(prop),
        },
        selectedMessageLocalId:{
            type:String,
            optional:true,
        },
        threadViewLocalId:String,
    },
    template:'mail.MessageList',
});

returnMessageList;

});

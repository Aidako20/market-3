flectra.define('mail/static/src/components/thread_view/thread_view_tests.js',function(require){
'usestrict';

constcomponents={
    ThreadView:require('mail/static/src/components/thread_view/thread_view.js'),
};
const{
    afterEach,
    afterNextRender,
    beforeEach,
    createRootComponent,
    dragenterFiles,
    isScrolledToBottom,
    start,
}=require('mail/static/src/utils/test_utils.js');

QUnit.module('mail',{},function(){
QUnit.module('components',{},function(){
QUnit.module('thread_view',{},function(){
QUnit.module('thread_view_tests.js',{
    beforeEach(){
        beforeEach(this);

        /**
         *@param{mail.thread_view}threadView
         *@param{Object}[otherProps={}]
         *@param{Object}[param2={}]
         *@param{boolean}[param2.isFixedSize=false]
         */
        this.createThreadViewComponent=async(threadView,otherProps={},{isFixedSize=false}={})=>{
            lettarget;
            if(isFixedSize){
                //neededtoallowscrollinginsometests
                constdiv=document.createElement('div');
                Object.assign(div.style,{
                    display:'flex',
                    'flex-flow':'column',
                    height:'300px',
                });
                this.widget.el.append(div);
                target=div;
            }else{
                target=this.widget.el;
            }
            constprops=Object.assign({threadViewLocalId:threadView.localId},otherProps);
            awaitcreateRootComponent(this,components.ThreadView,{props,target});
        };

        this.start=asyncparams=>{
            const{afterEvent,env,widget}=awaitstart(Object.assign({},params,{
                data:this.data,
            }));
            this.afterEvent=afterEvent;
            this.env=env;
            this.widget=widget;
        };
    },
    afterEach(){
        afterEach(this);
    },
});

QUnit.test('dragoverfilesonthreadwithcomposer',asyncfunction(assert){
    assert.expect(1);

    awaitthis.start();
    constthread=this.env.models['mail.thread'].create({
        channel_type:'channel',
        id:100,
        members:[['insert',[
            {
                email:"john@example.com",
                id:9,
                name:"John",
            },
            {
                email:"fred@example.com",
                id:10,
                name:"Fred",
            },
        ]]],
        model:'mail.channel',
        name:"General",
        public:'public',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});
    awaitafterNextRender(()=>
        dragenterFiles(document.querySelector('.o_ThreadView'))
    );
    assert.ok(
        document.querySelector('.o_Composer_dropZone'),
        "shouldhavedropzonewhendraggingfileoverthethread"
    );
});

QUnit.test('messagelistdescorder',asyncfunction(assert){
    assert.expect(5);

    for(leti=0;i<=60;i++){
        this.data['mail.message'].records.push({
            body:"notempty",
            channel_ids:[100],
            model:'mail.channel',
            res_id:100,
        });
    }
    awaitthis.start();
    constthread=this.env.models['mail.thread'].create({
        channel_type:'channel',
        id:100,
        members:[['insert',[
            {
                email:"john@example.com",
                id:9,
                name:"John",
            },
            {
                email:"fred@example.com",
                id:10,
                name:"Fred",
            },
        ]]],
        model:'mail.channel',
        name:"General",
        public:'public',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>this.createThreadViewComponent(threadViewer.threadView,{order:'desc'},{isFixedSize:true}),
        message:"shouldwaituntilchannel100loadedinitialmessages",
        predicate:({hint,threadViewer})=>{
            return(
                hint.type==='messages-loaded'&&
                threadViewer.thread.model==='mail.channel'&&
                threadViewer.thread.id===100
            );
        },
    });
    constmessageItems=document.querySelectorAll(`.o_MessageList_item`);
    assert.notOk(
        messageItems[0].classList.contains("o_MessageList_loadMore"),
        "loadmorelinkshouldNOTbebeforemessages"
    );
    assert.ok(
        messageItems[messageItems.length-1].classList.contains("o_MessageList_loadMore"),
        "loadmorelinkshouldbeaftermessages"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Message`).length,
        30,
        "shouldhave30messagesatthebeginning"
    );

    //scrolltobottom
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>{
            constmessageList=document.querySelector('.o_ThreadView_messageList');
            messageList.scrollTop=messageList.scrollHeight-messageList.clientHeight;
        },
        message:"shouldwaituntilchannel100loadedmoremessagesafterscrollingtobottom",
        predicate:({hint,threadViewer})=>{
            return(
                hint.type==='more-messages-loaded'&&
                threadViewer.thread.model==='mail.channel'&&
                threadViewer.thread.id===100
            );
        },
    });
    assert.strictEqual(
        document.querySelectorAll(`.o_Message`).length,
        60,
        "shouldhave60messagesafterscrolledtobottom"
    );

    awaitafterNextRender(()=>{
        document.querySelector(`.o_ThreadView_messageList`).scrollTop=0;
    });
    assert.strictEqual(
        document.querySelectorAll(`.o_Message`).length,
        60,
        "scrollingtotopshouldnottriggeranymessagefetching"
    );
});

QUnit.test('messagelistascorder',asyncfunction(assert){
    assert.expect(5);

    for(leti=0;i<=60;i++){
        this.data['mail.message'].records.push({
            body:"notempty",
            channel_ids:[100],
            model:'mail.channel',
            res_id:100,
        });
    }
    awaitthis.start();
    constthread=this.env.models['mail.thread'].create({
        channel_type:'channel',
        id:100,
        members:[['insert',[
            {
                email:"john@example.com",
                id:9,
                name:"John",
            },
            {
                email:"fred@example.com",
                id:10,
                name:"Fred",
            },
        ]]],
        model:'mail.channel',
        name:"General",
        public:'public',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>this.createThreadViewComponent(threadViewer.threadView,{order:'asc'},{isFixedSize:true}),
        message:"shouldwaituntilchannel100loadedinitialmessages",
        predicate:({hint,threadViewer})=>{
            return(
                hint.type==='messages-loaded'&&
                threadViewer.thread.model==='mail.channel'&&
                threadViewer.thread.id===100
            );
        },
    });
    constmessageItems=document.querySelectorAll(`.o_MessageList_item`);
    assert.notOk(
        messageItems[messageItems.length-1].classList.contains("o_MessageList_loadMore"),
        "loadmorelinkshouldbebeforemessages"
    );
    assert.ok(
        messageItems[0].classList.contains("o_MessageList_loadMore"),
        "loadmorelinkshouldNOTbeaftermessages"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Message`).length,
        30,
        "shouldhave30messagesatthebeginning"
    );

    //scrolltotop
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>document.querySelector(`.o_ThreadView_messageList`).scrollTop=0,
        message:"shouldwaituntilchannel100loadedmoremessagesafterscrollingtotop",
        predicate:({hint,threadViewer})=>{
            return(
                hint.type==='more-messages-loaded'&&
                threadViewer.thread.model==='mail.channel'&&
                threadViewer.thread.id===100
            );
        },
    });
    assert.strictEqual(
        document.querySelectorAll(`.o_Message`).length,
        60,
        "shouldhave60messagesafterscrolledtotop"
    );

    //scrolltobottom
    awaitafterNextRender(()=>{
        document.querySelector(`.o_ThreadView_messageList`).scrollTop=
            document.querySelector(`.o_ThreadView_messageList`).scrollHeight;
    });
    assert.strictEqual(
        document.querySelectorAll(`.o_Message`).length,
        60,
        "scrollingtobottomshouldnottriggeranymessagefetching"
    );
});

QUnit.test('markchannelasfetchedwhenanewmessageisloadedandasseenwhenfocusingcomposer[REQUIREFOCUS]',asyncfunction(assert){
    assert.expect(8);

    this.data['res.partner'].records.push({
        email:"fred@example.com",
        id:10,
        name:"Fred",
    });
    this.data['res.users'].records.push({
        id:10,
        partner_id:10,
    });
    this.data['mail.channel'].records.push({
        channel_type:'chat',
        id:100,
        is_pinned:true,
        members:[this.data.currentPartnerId,10],
    });
    awaitthis.start({
        mockRPC(route,args){
            if(args.method==='channel_fetched'){
                assert.strictEqual(
                    args.args[0][0],
                    100,
                    'channel_fetchediscalledontherightchannelid'
                );
                assert.strictEqual(
                    args.model,
                    'mail.channel',
                    'channel_fetchediscalledontherightchannelmodel'
                );
                assert.step('rpc:channel_fetch');
            }elseif(args.method==='channel_seen'){
                assert.strictEqual(
                    args.args[0][0],
                    100,
                    'channel_seeniscalledontherightchannelid'
                );
                assert.strictEqual(
                    args.model,
                    'mail.channel',
                    'channel_seebiscalledontherightchannelmodel'
                );
                assert.step('rpc:channel_seen');
            }
            returnthis._super(...arguments);
        }
    });
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:100,
        model:'mail.channel',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});
    awaitafterNextRender(async()=>this.env.services.rpc({
        route:'/mail/chat_post',
        params:{
            context:{
                mockedUserId:10,
            },
            message_content:"newmessage",
            uuid:thread.uuid,
        },
    }));
    assert.verifySteps(
        ['rpc:channel_fetch'],
        "Channelshouldhavebeenfetchedbutnotseenyet"
    );

    awaitafterNextRender(()=>this.afterEvent({
        eventName:'o-thread-last-seen-by-current-partner-message-id-changed',
        func:()=>document.querySelector('.o_ComposerTextInput_textarea').focus(),
        message:"shouldwaituntillastseenbycurrentpartnermessageidchangedafterfocusingthethread",
        predicate:({thread})=>{
            return(
                thread.id===100&&
                thread.model==='mail.channel'
            );
        },
    }));
    assert.verifySteps(
        ['rpc:channel_seen'],
        "ChannelshouldhavebeenmarkedasseenafterthreadViewgotthefocus"
    );
});

QUnit.test('markchannelasfetchedandseenwhenanewmessageisloadedifcomposerisfocused[REQUIREFOCUS]',asyncfunction(assert){
    assert.expect(4);

    this.data['res.partner'].records.push({
        id:10,
    });
    this.data['res.users'].records.push({
        id:10,
        partner_id:10,
    });
    this.data['mail.channel'].records.push({
        id:100,
    });
    awaitthis.start({
        mockRPC(route,args){
            if(args.method==='channel_fetched'&&args.args[0]===100){
                thrownewError("'channel_fetched'RPCmustnotbecalledforcreatedchannelasmessageisdirectlyseen");
            }elseif(args.method==='channel_seen'){
                assert.strictEqual(
                    args.args[0][0],
                    100,
                    'channel_seeniscalledontherightchannelid'
                );
                assert.strictEqual(
                    args.model,
                    'mail.channel',
                    'channel_seeniscalledontherightchannelmodel'
                );
                assert.step('rpc:channel_seen');
            }
            returnthis._super(...arguments);
        }
    });
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:100,
        model:'mail.channel',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});
    document.querySelector('.o_ComposerTextInput_textarea').focus();
    //simulatereceivingamessage
    awaitthis.afterEvent({
        eventName:'o-thread-last-seen-by-current-partner-message-id-changed',
        func:()=>this.env.services.rpc({
            route:'/mail/chat_post',
            params:{
                context:{
                    mockedUserId:10,
                },
                message_content:"<p>fdsfsd</p>",
                uuid:thread.uuid,
            },
        }),
        message:"shouldwaituntillastseenbycurrentpartnermessageidchangedafterreceivingamessagewhilethreadisfocused",
        predicate:({thread})=>{
            return(
                thread.id===100&&
                thread.model==='mail.channel'
            );
        },
    });
    assert.verifySteps(
        ['rpc:channel_seen'],
        "Channelshouldhavebeenmarkasseendirectly"
    );
});

QUnit.test('showmessagesubjectifthreadismailingchannel',asyncfunction(assert){
    assert.expect(3);

    this.data['mail.message'].records.push({
        body:"notempty",
        channel_ids:[100],
        model:'mail.channel',
        res_id:100,
        subject:"Salutations,voyageur",
    });
    awaitthis.start();
    constthread=this.env.models['mail.thread'].create({
        channel_type:'channel',
        id:100,
        mass_mailing:true,
        model:'mail.channel',
        name:"General",
        public:'public',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView);

    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplayasinglemessage"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_subject',
        "shoulddisplaysubjectofthemessage"
    );
    assert.strictEqual(
        document.querySelector('.o_Message_subject').textContent,
        "Subject:Salutations,voyageur",
        "Subjectofthemessageshouldbe'Salutations,voyageur'"
    );
});

QUnit.test('[technical]newmessagesseparatoronpostingmessage',asyncfunction(assert){
    //technicalasweneedtoremovefocusfromtextinputtoavoid`channel_seen`call
    assert.expect(4);

    this.data['mail.channel'].records=[{
        channel_type:'channel',
        id:20,
        is_pinned:true,
        message_unread_counter:0,
        seen_message_id:10,
        name:"General",
    }];
    this.data['mail.message'].records.push({
        body:"firstmessage",
        channel_ids:[20],
        id:10,
    });
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:20,
        model:'mail.channel'
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});

    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplayonemessageinthreadinitially"
    );
    assert.containsNone(
        document.body,
        '.o_MessageList_separatorNewMessages',
        "shouldnotdisplay'newmessages'separator"
    );

    document.querySelector('.o_ComposerTextInput_textarea').focus();
    awaitafterNextRender(()=>document.execCommand('insertText',false,"hey!"));
    awaitafterNextRender(()=>{
        //needtoremovefocusfromtextareatoavoidchannel_seen
        document.querySelector('.o_Composer_buttonSend').focus();
        document.querySelector('.o_Composer_buttonSend').click();

    });
    assert.containsN(
        document.body,
        '.o_Message',
        2,
        "shoulddisplay2messages(initial&newlyposted),afterpostingamessage"
    );
    assert.containsNone(
        document.body,
        '.o_MessageList_separatorNewMessages',
        "stillnoseparatorshownwhencurrentpartnerpostedamessage"
    );
});

QUnit.test('newmessagesseparatoronreceivingnewmessage[REQUIREFOCUS]',asyncfunction(assert){
    assert.expect(6);

    this.data['res.partner'].records.push({
        id:11,
        name:"Foreignerpartner",
    });
    this.data['res.users'].records.push({
        id:42,
        name:"Foreigneruser",
        partner_id:11,
    });
    this.data['mail.channel'].records.push({
        channel_type:'channel',
        id:20,
        is_pinned:true,
        message_unread_counter:0,
        name:"General",
        seen_message_id:1,
        uuid:'randomuuid',
    });
    this.data['mail.message'].records.push({
        body:"blah",
        channel_ids:[20],
        id:1,
    });
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:20,
        model:'mail.channel'
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});

    assert.containsOnce(
        document.body,
        '.o_MessageList_message',
        "shouldhaveaninitialmessage"
    );
    assert.containsNone(
        document.body,
        '.o_MessageList_separatorNewMessages',
        "shouldnotdisplay'newmessages'separator"
    );

    document.querySelector('.o_ComposerTextInput_textarea').blur();
    //simulatereceivingamessage
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>this.env.services.rpc({
            route:'/mail/chat_post',
            params:{
                context:{
                    mockedUserId:42,
                },
                message_content:"hu",
                uuid:thread.uuid,
            },
        }),
        message:"shouldwaituntilnewmessageisreceived",
        predicate:({hint,threadViewer})=>{
            return(
                threadViewer.thread.id===20&&
                threadViewer.thread.model==='mail.channel'&&
                hint.type==='message-received'
            );
        },
    });
    assert.containsN(
        document.body,
        '.o_Message',
        2,
        "shouldnowhave2messagesafterreceivinganewmessage"
    );
    assert.containsOnce(
        document.body,
        '.o_MessageList_separatorNewMessages',
        "'newmessages'separatorshouldbeshown"
    );

    assert.containsOnce(
        document.body,
        `.o_MessageList_separatorNewMessages~.o_Message[data-message-local-id="${
            this.env.models['mail.message'].findFromIdentifyingData({id:2}).localId
        }"]`,
        "'newmessages'separatorshouldbeshownabovenewmessagereceived"
    );

    awaitafterNextRender(()=>this.afterEvent({
        eventName:'o-thread-last-seen-by-current-partner-message-id-changed',
        func:()=>document.querySelector('.o_ComposerTextInput_textarea').focus(),
        message:"shouldwaituntillastseenbycurrentpartnermessageidchangedafterfocusingthethread",
        predicate:({thread})=>{
            return(
                thread.id===20&&
                thread.model==='mail.channel'
            );
        },
    }));
    assert.containsNone(
        document.body,
        '.o_MessageList_separatorNewMessages',
        "'newmessages'separatorshouldnolongerbeshownaslastmessagehasbeenseen"
    );
});

QUnit.test('newmessagesseparatoronpostingmessage',asyncfunction(assert){
    assert.expect(4);

    this.data['mail.channel'].records=[{
        channel_type:'channel',
        id:20,
        is_pinned:true,
        message_unread_counter:0,
        name:"General",
    }];
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:20,
        model:'mail.channel'
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});

    assert.containsNone(
        document.body,
        '.o_MessageList_message',
        "shouldhavenomessages"
    );
    assert.containsNone(
        document.body,
        '.o_MessageList_separatorNewMessages',
        "shouldnotdisplay'newmessages'separator"
    );

    document.querySelector('.o_ComposerTextInput_textarea').focus();
    awaitafterNextRender(()=>document.execCommand('insertText',false,"hey!"));
    awaitafterNextRender(()=>
        document.querySelector('.o_Composer_buttonSend').click()
    );
    assert.containsOnce(
        document.body,
        '.o_Message',
        "shouldhavethemessagecurrentpartnerjustposted"
    );
    assert.containsNone(
        document.body,
        '.o_MessageList_separatorNewMessages',
        "stillnoseparatorshownwhencurrentpartnerpostedamessage"
    );
});

QUnit.test('basicrenderingofcancelednotification',asyncfunction(assert){
    assert.expect(8);

    this.data['mail.channel'].records.push({id:11});
    this.data['res.partner'].records.push({id:12,name:"Someone"});
    this.data['mail.message'].records.push({
        body:"notempty",
        channel_ids:[11],
        id:10,
        message_type:'email',
        model:'mail.channel',
        notification_ids:[11],
        res_id:11,
    });
    this.data['mail.notification'].records.push({
        failure_type:'SMTP',
        id:11,
        mail_message_id:10,
        notification_status:'canceled',
        notification_type:'email',
        res_partner_id:12,
    });
    awaitthis.start();
    constthreadViewer=awaitthis.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['insert',{
            id:11,
            model:'mail.channel',
        }]],
    });
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>this.createThreadViewComponent(threadViewer.threadView),
        message:"threadbecomeloadedwithmessages",
        predicate:({hint,threadViewer})=>{
            return(
                hint.type==='messages-loaded'&&
                threadViewer.thread.model==='mail.channel'&&
                threadViewer.thread.id===11
            );
        },
    });

    assert.containsOnce(
        document.body,
        '.o_Message_notificationIconClickable',
        "shoulddisplaythenotificationiconcontaineronthemessage"
    );
    assert.containsOnce(
        document.body,
        '.o_Message_notificationIcon',
        "shoulddisplaythenotificationicononthemessage"
    );
    assert.hasClass(
        document.querySelector('.o_Message_notificationIcon'),
        'fa-envelope-o',
        "notificationiconshownonthemessageshouldrepresentemail"
    );

    awaitafterNextRender(()=>{
        document.querySelector('.o_Message_notificationIconClickable').click();
    });
    assert.containsOnce(
        document.body,
        '.o_NotificationPopover',
        "notificationpopovershouldbeopenedafternotificationhasbeenclicked"
    );
    assert.containsOnce(
        document.body,
        '.o_NotificationPopover_notificationIcon',
        "aniconshouldbeshowninnotificationpopover"
    );
    assert.containsOnce(
        document.body,
        '.o_NotificationPopover_notificationIcon.fa.fa-trash-o',
        "theiconshowninnotificationpopovershouldbethecanceledicon"
    );
    assert.containsOnce(
        document.body,
        '.o_NotificationPopover_notificationPartnerName',
        "partnernameshouldbeshowninnotificationpopover"
    );
    assert.strictEqual(
        document.querySelector('.o_NotificationPopover_notificationPartnerName').textContent.trim(),
        "Someone",
        "partnernameshowninnotificationpopovershouldbetheoneconcernedbythenotification"
    );
});

QUnit.test('shouldscrolltobottomonreceivingnewmessageifthelistisinitiallyscrolledtobottom(ascorder)',asyncfunction(assert){
    assert.expect(2);

    //Neededpartner&usertoallowsimulationofmessagereception
    this.data['res.partner'].records.push({
        id:11,
        name:"Foreignerpartner",
    });
    this.data['res.users'].records.push({
        id:42,
        name:"Foreigneruser",
        partner_id:11,
    });
    this.data['mail.channel'].records.push({id:20});
    for(leti=0;i<=10;i++){
        this.data['mail.message'].records.push({
            body:"notempty",
            channel_ids:[20],
        });
    }
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:20,
        model:'mail.channel'
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.afterEvent({
        eventName:'o-component-message-list-scrolled',
        func:()=>this.createThreadViewComponent(
            threadViewer.threadView,
            {order:'asc'},
            {isFixedSize:true},
        ),
        message:"shouldwaituntilchannel20scrolledinitially",
        predicate:data=>threadViewer===data.threadViewer,
    });
    constinitialMessageList=document.querySelector('.o_ThreadView_messageList');
    assert.ok(
        isScrolledToBottom(initialMessageList),
        "shouldhavescrolledtobottomofchannel20initially"
    );

    //simulatereceivingamessage
    awaitthis.afterEvent({
        eventName:'o-component-message-list-scrolled',
        func:()=>
            this.env.services.rpc({
                route:'/mail/chat_post',
                params:{
                    context:{
                        mockedUserId:42,
                    },
                    message_content:"hello",
                    uuid:thread.uuid,
                },
            }),
        message:"shouldwaituntilchannel20scrolledafterreceivingamessage",
        predicate:data=>threadViewer===data.threadViewer,
    });
    constmessageList=document.querySelector('.o_ThreadView_messageList');
    assert.ok(
        isScrolledToBottom(messageList),
        "shouldscrolltobottomonreceivingnewmessagebecausethelistisinitiallyscrolledtobottom"
    );
});

QUnit.test('shouldnotscrollonreceivingnewmessageifthelistisinitiallyscrolledanywhereelsethanbottom(ascorder)',asyncfunction(assert){
    assert.expect(3);

    //Neededpartner&usertoallowsimulationofmessagereception
    this.data['res.partner'].records.push({
        id:11,
        name:"Foreignerpartner",
    });
    this.data['res.users'].records.push({
        id:42,
        name:"Foreigneruser",
        partner_id:11,
    });
    this.data['mail.channel'].records.push({id:20});
    for(leti=0;i<=10;i++){
        this.data['mail.message'].records.push({
            body:"notempty",
            channel_ids:[20],
        });
    }
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:20,
        model:'mail.channel'
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.afterEvent({
        eventName:'o-component-message-list-scrolled',
        func:()=>this.createThreadViewComponent(
            threadViewer.threadView,
            {order:'asc'},
            {isFixedSize:true},
        ),
        message:"shouldwaituntilchannel20scrolledinitially",
        predicate:data=>threadViewer===data.threadViewer,
    });
    constinitialMessageList=document.querySelector('.o_ThreadView_messageList');
    assert.ok(
        isScrolledToBottom(initialMessageList),
        "shouldhavescrolledtobottomofchannel20initially"
    );

    awaitthis.afterEvent({
        eventName:'o-component-message-list-scrolled',
        func:()=>initialMessageList.scrollTop=0,
        message:"shouldwaituntilchannel20processedmanualscroll",
        predicate:data=>threadViewer===data.threadViewer,
    });
    assert.strictEqual(
        initialMessageList.scrollTop,
        0,
        "shouldhavescrolledtothetopofchannel20manually"
    );

    //simulatereceivingamessage
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>
            this.env.services.rpc({
                route:'/mail/chat_post',
                params:{
                    context:{
                        mockedUserId:42,
                    },
                    message_content:"hello",
                    uuid:thread.uuid,
                },
            }),
        message:"shouldwaituntilchannel20processednewmessagehint",
        predicate:data=>threadViewer===data.threadViewer&&data.hint.type==='message-received',
    });
    assert.strictEqual(
        document.querySelector('.o_ThreadView_messageList').scrollTop,
        0,
        "shouldnotscrollonreceivingnewmessagebecausethelistisinitiallyscrolledanywhereelsethanbottom"
    );
});

QUnit.test("deleteallattachmentsofmessagewithoutcontentshouldnolongerdisplaythemessage",asyncfunction(assert){
    assert.expect(2);

    this.data['ir.attachment'].records.push({
        id:143,
        mimetype:'text/plain',
        name:"Blah.txt",
    });
    this.data['mail.channel'].records.push({id:11});
    this.data['mail.message'].records.push(
        {
            attachment_ids:[143],
            channel_ids:[11],
            id:101,
        }
    );
    awaitthis.start();
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['insert',{id:11,model:'mail.channel'}]],
    });
    //waitformessagesofthethreadtobeloaded
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>this.createThreadViewComponent(threadViewer.threadView),
        message:"threadbecomeloadedwithmessages",
        predicate:({hint,threadViewer})=>{
            return(
                hint.type==='messages-loaded'&&
                threadViewer.thread.model==='mail.channel'&&
                threadViewer.thread.id===11
            );
        },
    });
    assert.containsOnce(
        document.body,
        '.o_Message',
        "thereshouldbe1messagedisplayedinitially"
    );

    awaitafterNextRender(()=>{
        document.querySelector(`.o_Attachment[data-attachment-local-id="${
            this.env.models['mail.attachment'].findFromIdentifyingData({id:143}).localId
        }"].o_Attachment_asideItemUnlink`).click();
    });
    awaitafterNextRender(()=>
        document.querySelector('.o_AttachmentDeleteConfirmDialog_confirmButton').click()
    );
    assert.containsNone(
        document.body,
        '.o_Message',
        "messageshouldnolongerbedisplayedafterremovingallitsattachments(emptycontent)"
    );
});

QUnit.test('deleteallattachmentsofamessagewithsometextcontentshouldstillkeepitdisplayed',asyncfunction(assert){
    assert.expect(2);

    this.data['ir.attachment'].records.push({
        id:143,
        mimetype:'text/plain',
        name:"Blah.txt",
    });
    this.data['mail.channel'].records.push({id:11});
    this.data['mail.message'].records.push(
        {
            attachment_ids:[143],
            body:"Somecontent",
            channel_ids:[11],
            id:101,
        },
    );
    awaitthis.start();
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['insert',{id:11,model:'mail.channel'}]],
    });
    //waitformessagesofthethreadtobeloaded
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>this.createThreadViewComponent(threadViewer.threadView),
        message:"threadbecomeloadedwithmessages",
        predicate:({hint,threadViewer})=>{
            return(
                hint.type==='messages-loaded'&&
                threadViewer.thread.model==='mail.channel'&&
                threadViewer.thread.id===11
            );
        },
    });
    assert.containsOnce(
        document.body,
        '.o_Message',
        "thereshouldbe1messagedisplayedinitially"
    );

    awaitafterNextRender(()=>{
        document.querySelector(`.o_Attachment[data-attachment-local-id="${
            this.env.models['mail.attachment'].findFromIdentifyingData({id:143}).localId
        }"].o_Attachment_asideItemUnlink`).click();
    });
    awaitafterNextRender(()=>
        document.querySelector('.o_AttachmentDeleteConfirmDialog_confirmButton').click()
    );
    assert.containsOnce(
        document.body,
        '.o_Message',
        "messageshouldstillbedisplayedafterremovingitsattachments(non-emptycontent)"
    );
});

QUnit.test('deleteallattachmentsofamessagewithtrackingfieldsshouldstillkeepitdisplayed',asyncfunction(assert){
    assert.expect(2);

    this.data['ir.attachment'].records.push({
        id:143,
        mimetype:'text/plain',
        name:"Blah.txt",
    });
    this.data['mail.channel'].records.push({id:11});
    this.data['mail.message'].records.push(
        {
            attachment_ids:[143],
            channel_ids:[11],
            id:101,
            tracking_value_ids:[6]
        },
    );
    this.data['mail.tracking.value'].records.push({
        changed_field:"Name",
        field_type:"char",
        id:6,
        new_value:"Newname",
        old_value:"Oldname",
    });
    awaitthis.start();
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['insert',{id:11,model:'mail.channel'}]],
    });
    //waitformessagesofthethreadtobeloaded
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>this.createThreadViewComponent(threadViewer.threadView),
        message:"threadbecomeloadedwithmessages",
        predicate:({hint,threadViewer})=>{
            return(
                hint.type==='messages-loaded'&&
                threadViewer.thread.model==='mail.channel'&&
                threadViewer.thread.id===11
            );
        },
    });
    assert.containsOnce(
        document.body,
        '.o_Message',
        "thereshouldbe1messagedisplayedinitially"
    );

    awaitafterNextRender(()=>{
        document.querySelector(`.o_Attachment[data-attachment-local-id="${
            this.env.models['mail.attachment'].findFromIdentifyingData({id:143}).localId
        }"].o_Attachment_asideItemUnlink`).click();
    });
    awaitafterNextRender(()=>
        document.querySelector('.o_AttachmentDeleteConfirmDialog_confirmButton').click()
    );
    assert.containsOnce(
        document.body,
        '.o_Message',
        "messageshouldstillbedisplayedafterremovingitsattachments(non-emptycontent)"
    );
});

QUnit.test('Postamessagecontaininganemailaddressfollowedbyamentiononanotherline',asyncfunction(assert){
    assert.expect(1);

    this.data['mail.channel'].records.push({id:11});
    this.data['res.partner'].records.push({
        id:25,
        email:"testpartner@flectrahq.com",
        name:"TestPartner",
    });
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:11,
        model:'mail.channel',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});
    document.querySelector('.o_ComposerTextInput_textarea').focus();
    awaitafterNextRender(()=>document.execCommand('insertText',false,"email@flectrahq.com\n"));
    awaitafterNextRender(()=>{
        ["@","T","e"].forEach((char)=>{
            document.execCommand('insertText',false,char);
            document.querySelector(`.o_ComposerTextInput_textarea`)
                .dispatchEvent(newwindow.KeyboardEvent('keydown'));
            document.querySelector(`.o_ComposerTextInput_textarea`)
                .dispatchEvent(newwindow.KeyboardEvent('keyup'));
        });
    });
    awaitafterNextRender(()=>
        document.querySelector('.o_ComposerSuggestion').click()
    );
    awaitafterNextRender(()=>{
        document.querySelector('.o_Composer_buttonSend').click();
    });
    assert.containsOnce(
        document.querySelector(`.o_Message_content`),
        `.o_mail_redirect[data-oe-id="25"][data-oe-model="res.partner"]:contains("@TestPartner")`,
        "Conversationshouldhaveamessagethathasbeenposted,whichcontainspartnermention"
    );
});

QUnit.test(`Mentionapartnerwithspecialcharacter(e.g.apostrophe')`,asyncfunction(assert){
    assert.expect(1);

    this.data['mail.channel'].records.push({id:11});
    this.data['res.partner'].records.push({
        id:1952,
        email:"usatyi@example.com",
        name:"Pynya'sspokesman",
    });
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:11,
        model:'mail.channel',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});
    document.querySelector('.o_ComposerTextInput_textarea').focus();
    awaitafterNextRender(()=>{
        ["@","P","y","n"].forEach((char)=>{
            document.execCommand('insertText',false,char);
            document.querySelector(`.o_ComposerTextInput_textarea`)
                .dispatchEvent(newwindow.KeyboardEvent('keydown'));
            document.querySelector(`.o_ComposerTextInput_textarea`)
                .dispatchEvent(newwindow.KeyboardEvent('keyup'));
        });
    });
    awaitafterNextRender(()=>
        document.querySelector('.o_ComposerSuggestion').click()
    );
    awaitafterNextRender(()=>{
        document.querySelector('.o_Composer_buttonSend').click();
    });
    assert.containsOnce(
        document.querySelector(`.o_Message_content`),
        `.o_mail_redirect[data-oe-id="1952"][data-oe-model="res.partner"]:contains("@Pynya'sspokesman")`,
        "Conversationshouldhaveamessagethathasbeenposted,whichcontainspartnermention"
    );
});

QUnit.test('mention2differentpartnersthathavethesamename',asyncfunction(assert){
    assert.expect(3);

    this.data['mail.channel'].records.push({id:11});
    this.data['res.partner'].records.push(
        {
            id:25,
            email:"partner1@example.com",
            name:"TestPartner",
        },{
            id:26,
            email:"partner2@example.com",
            name:"TestPartner",
        },
    );
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:11,
        model:'mail.channel',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});
    document.querySelector('.o_ComposerTextInput_textarea').focus();
    awaitafterNextRender(()=>{
        ["@","T","e"].forEach((char)=>{
            document.execCommand('insertText',false,char);
            document.querySelector(`.o_ComposerTextInput_textarea`)
                .dispatchEvent(newwindow.KeyboardEvent('keydown'));
            document.querySelector(`.o_ComposerTextInput_textarea`)
                .dispatchEvent(newwindow.KeyboardEvent('keyup'));
        });
    });
    awaitafterNextRender(()=>document.querySelectorAll('.o_ComposerSuggestion')[0].click());
    awaitafterNextRender(()=>{
        ["@","T","e"].forEach((char)=>{
            document.execCommand('insertText',false,char);
            document.querySelector(`.o_ComposerTextInput_textarea`)
                .dispatchEvent(newwindow.KeyboardEvent('keydown'));
            document.querySelector(`.o_ComposerTextInput_textarea`)
                .dispatchEvent(newwindow.KeyboardEvent('keyup'));
        });
    });
    awaitafterNextRender(()=>document.querySelectorAll('.o_ComposerSuggestion')[1].click());
    awaitafterNextRender(()=>document.querySelector('.o_Composer_buttonSend').click());
    assert.containsOnce(document.body,'.o_Message_content','shouldhaveonemessageafterpostingit');
    assert.containsOnce(
        document.querySelector(`.o_Message_content`),
        `.o_mail_redirect[data-oe-id="25"][data-oe-model="res.partner"]:contains("@TestPartner")`,
        "messageshouldcontainthefirstpartnermention"
    );
    assert.containsOnce(
        document.querySelector(`.o_Message_content`),
        `.o_mail_redirect[data-oe-id="26"][data-oe-model="res.partner"]:contains("@TestPartner")`,
        "messageshouldalsocontainthesecondpartnermention"
    );
});

QUnit.test('mentionachannelwithspaceinthename',asyncfunction(assert){
    assert.expect(2);

    this.data['mail.channel'].records.push({
        id:7,
        name:"Generalgoodboy",
    });
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:7,
        model:'mail.channel',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});

    awaitafterNextRender(()=>{
        document.querySelector(`.o_ComposerTextInput_textarea`).focus();
        document.execCommand('insertText',false,"#");
        document.querySelector(`.o_ComposerTextInput_textarea`)
            .dispatchEvent(newwindow.KeyboardEvent('keydown'));
        document.querySelector(`.o_ComposerTextInput_textarea`)
            .dispatchEvent(newwindow.KeyboardEvent('keyup'));
    });
    awaitafterNextRender(()=>
        document.querySelector('.o_ComposerSuggestion').click()
    );
    awaitafterNextRender(()=>{
        document.querySelector('.o_Composer_buttonSend').click();
    });
    assert.containsOnce(
        document.querySelector('.o_Message_content'),
        '.o_channel_redirect',
        "messagemustcontainalinktothementionedchannel"
    );
    assert.strictEqual(
        document.querySelector('.o_channel_redirect').textContent,
        '#Generalgoodboy',
        "linktothechannelmustcontains#+thechannelname"
    );
});

QUnit.test('mentionachannelwith"&"inthename',asyncfunction(assert){
    assert.expect(2);

    this.data['mail.channel'].records.push({
        id:7,
        name:"General&good",
    });
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:7,
        model:'mail.channel',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});

    awaitafterNextRender(()=>{
        document.querySelector(`.o_ComposerTextInput_textarea`).focus();
        document.execCommand('insertText',false,"#");
        document.querySelector(`.o_ComposerTextInput_textarea`)
            .dispatchEvent(newwindow.KeyboardEvent('keydown'));
        document.querySelector(`.o_ComposerTextInput_textarea`)
            .dispatchEvent(newwindow.KeyboardEvent('keyup'));
    });
    awaitafterNextRender(()=>
        document.querySelector('.o_ComposerSuggestion').click()
    );
    awaitafterNextRender(()=>{
        document.querySelector('.o_Composer_buttonSend').click();
    });
    assert.containsOnce(
        document.querySelector('.o_Message_content'),
        '.o_channel_redirect',
        "messageshouldcontainalinktothementionedchannel"
    );
    assert.strictEqual(
        document.querySelector('.o_channel_redirect').textContent,
        '#General&good',
        "linktothechannelmustcontains#+thechannelname"
    );
});

QUnit.test('mentionachannelonasecondlinewhenthefirstlinecontains#',asyncfunction(assert){
    assert.expect(2);

    this.data['mail.channel'].records.push({
        id:7,
        name:"Generalgood",
    });
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:7,
        model:'mail.channel',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});

    awaitafterNextRender(()=>{
        document.querySelector(`.o_ComposerTextInput_textarea`).focus();
        document.execCommand('insertText',false,"#blabla\n#");
        document.querySelector(`.o_ComposerTextInput_textarea`)
            .dispatchEvent(newwindow.KeyboardEvent('keydown'));
        document.querySelector(`.o_ComposerTextInput_textarea`)
            .dispatchEvent(newwindow.KeyboardEvent('keyup'));
    });
    awaitafterNextRender(()=>{
        document.querySelector('.o_ComposerSuggestion').click();
    });
    awaitafterNextRender(()=>{
        document.querySelector('.o_Composer_buttonSend').click();
    });
    assert.containsOnce(
        document.querySelector('.o_Message_content'),
        '.o_channel_redirect',
        "messageshouldcontainalinktothementionedchannel"
    );
    assert.strictEqual(
        document.querySelector('.o_channel_redirect').textContent,
        '#Generalgood',
        "linktothechannelmustcontains#+thechannelname"
    );
});

QUnit.test('mentionachannelwhenreplacingthespaceafterthementionbyanotherchar',asyncfunction(assert){
    assert.expect(2);

    this.data['mail.channel'].records.push({
        id:7,
        name:"Generalgood",
    });
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:7,
        model:'mail.channel',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});

    awaitafterNextRender(()=>{
        document.querySelector(`.o_ComposerTextInput_textarea`).focus();
        document.execCommand('insertText',false,"#");
        document.querySelector(`.o_ComposerTextInput_textarea`)
            .dispatchEvent(newwindow.KeyboardEvent('keydown'));
        document.querySelector(`.o_ComposerTextInput_textarea`)
            .dispatchEvent(newwindow.KeyboardEvent('keyup'));
    });
    awaitafterNextRender(()=>{
        document.querySelector('.o_ComposerSuggestion').click();
    });
    awaitafterNextRender(()=>{
        consttext=document.querySelector(`.o_ComposerTextInput_textarea`).value;
        document.querySelector(`.o_ComposerTextInput_textarea`).value=text.slice(0,-1);
        document.execCommand('insertText',false,",test");
        document.querySelector(`.o_ComposerTextInput_textarea`)
            .dispatchEvent(newwindow.KeyboardEvent('keydown'));
        document.querySelector(`.o_ComposerTextInput_textarea`)
            .dispatchEvent(newwindow.KeyboardEvent('keyup'));
    });
    awaitafterNextRender(()=>{
        document.querySelector('.o_Composer_buttonSend').click();
    });
    assert.containsOnce(
        document.querySelector('.o_Message_content'),
        '.o_channel_redirect',
        "messageshouldcontainalinktothementionedchannel"
    );
    assert.strictEqual(
        document.querySelector('.o_channel_redirect').textContent,
        '#Generalgood',
        "linktothechannelmustcontains#+thechannelname"
    );
});

QUnit.test('mention2differentchannelsthathavethesamename',asyncfunction(assert){
    assert.expect(3);

    this.data['mail.channel'].records.push(
        {
            id:11,
            name:"mychannel",
            public:'public',//mentioninganotherchannelispossibleonlyfromapublicchannel
        },
        {
            id:12,
            name:"mychannel",
        },
    );
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:11,
        model:'mail.channel',
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});
    document.querySelector('.o_ComposerTextInput_textarea').focus();
    awaitafterNextRender(()=>{
        ["#","m","y"].forEach((char)=>{
            document.execCommand('insertText',false,char);
            document.querySelector(`.o_ComposerTextInput_textarea`)
                .dispatchEvent(newwindow.KeyboardEvent('keydown'));
            document.querySelector(`.o_ComposerTextInput_textarea`)
                .dispatchEvent(newwindow.KeyboardEvent('keyup'));
        });
    });
    awaitafterNextRender(()=>document.querySelectorAll('.o_ComposerSuggestion')[0].click());
    awaitafterNextRender(()=>{
        ["#","m","y"].forEach((char)=>{
            document.execCommand('insertText',false,char);
            document.querySelector(`.o_ComposerTextInput_textarea`)
                .dispatchEvent(newwindow.KeyboardEvent('keydown'));
            document.querySelector(`.o_ComposerTextInput_textarea`)
                .dispatchEvent(newwindow.KeyboardEvent('keyup'));
        });
    });
    awaitafterNextRender(()=>document.querySelectorAll('.o_ComposerSuggestion')[1].click());
    awaitafterNextRender(()=>document.querySelector('.o_Composer_buttonSend').click());
    assert.containsOnce(document.body,'.o_Message_content','shouldhaveonemessageafterpostingit');
    assert.containsOnce(
        document.querySelector(`.o_Message_content`),
        `.o_channel_redirect[data-oe-id="11"][data-oe-model="mail.channel"]:contains("#mychannel")`,
        "messageshouldcontainthefirstchannelmention"
    );
    assert.containsOnce(
        document.querySelector(`.o_Message_content`),
        `.o_channel_redirect[data-oe-id="12"][data-oe-model="mail.channel"]:contains("#mychannel")`,
        "messageshouldalsocontainthesecondchannelmention"
    );
});

QUnit.test('showemptyplaceholderwhenthreadcontainsnomessage',asyncfunction(assert){
    assert.expect(2);

    this.data['mail.channel'].records.push({id:11});
    awaitthis.start();
    constthreadViewer=awaitthis.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['insert',{
            id:11,
            model:'mail.channel',
        }]],
    });
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>this.createThreadViewComponent(threadViewer.threadView),
        message:"shouldwaituntilthreadbecomesloadedwithmessages",
        predicate:({hint,threadViewer})=>{
            return(
                hint.type==='messages-loaded'&&
                threadViewer.thread.model==='mail.channel'&&
                threadViewer.thread.id===11
            );
        },
    });
    assert.containsOnce(
        document.body,
        '.o_MessageList_empty',
        "messagelistemptyplaceholdershouldbeshownasthreaddoesnotcontainanymessages"
    );
    assert.containsNone(
        document.body,
        '.o_Message',
        "nomessageshouldbeshownasthreaddoesnotcontainany"
    );
});

QUnit.test('showemptyplaceholderwhenthreadcontainsonlyemptymessages',asyncfunction(assert){
    assert.expect(2);

    this.data['mail.channel'].records.push({id:11});
    this.data['mail.message'].records.push(
        {
            channel_ids:[11],
            id:101,
        },
    );
    awaitthis.start();
    constthreadViewer=awaitthis.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['insert',{
            id:11,
            model:'mail.channel',
        }]],
    });
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>this.createThreadViewComponent(threadViewer.threadView),
        message:"threadbecomeloadedwithmessages",
        predicate:({hint,threadViewer})=>{
            return(
                hint.type==='messages-loaded'&&
                threadViewer.thread.model==='mail.channel'&&
                threadViewer.thread.id===11
            );
        },
    });
    assert.containsOnce(
        document.body,
        '.o_MessageList_empty',
        "messagelistemptyplaceholdershouldbeshownasthreadcontainonlyemptymessages"
    );
    assert.containsNone(
        document.body,
        '.o_Message',
        "nomessageshouldbeshownasthreadcontainsonlyemptyones"
    );
});

QUnit.test('messagewithsubtypeshouldbedisplayed(andnotconsideredasempty)',asyncfunction(assert){
    assert.expect(2);

    this.data['mail.channel'].records.push({id:11});
    this.data['mail.message.subtype'].records.push({
        description:"Taskcreated",
        id:10,
    });
    this.data['mail.message'].records.push(
        {
            channel_ids:[11],
            id:101,
            subtype_id:10,
        },
    );
    awaitthis.start();
    constthreadViewer=awaitthis.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['insert',{
            id:11,
            model:'mail.channel',
        }]],
    });
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>this.createThreadViewComponent(threadViewer.threadView),
        message:"shouldwaituntilthreadbecomesloadedwithmessages",
        predicate:({hint,threadViewer})=>{
            return(
                hint.type==='messages-loaded'&&
                threadViewer.thread.model==='mail.channel'&&
                threadViewer.thread.id===11
            );
        },
    });
    assert.containsOnce(
        document.body,
        '.o_Message',
        "shoulddisplay1message(messagewithsubtypedescription'taskcreated')"
    );
    assert.strictEqual(
        document.body.querySelector('.o_Message_content').textContent,
        "Taskcreated",
        "messageshouldhave'Taskcreated'(fromitssubtypedescription)"
    );
});

QUnit.test('[technical]messagelistwithafullpageofemptymessagesshouldshowloadmoreifthereareothermessages',asyncfunction(assert){
    //Technicalassumptions:
    //-message_fetchfetchingexactly30messages,
    //-emptymessagesnotbeingdisplayed
    //-auto-loadmorebeingtriggeredonscroll,notautomaticallywhenthe30firstmessagesareempty
    assert.expect(2);

    this.data['mail.channel'].records.push({
        id:11,
    });
    for(leti=0;i<=30;i++){
        this.data['mail.message'].records.push({
            body:"notempty",
            channel_ids:[11],
        });
    }
    for(leti=0;i<=30;i++){
        this.data['mail.message'].records.push({
            channel_ids:[11],
        });
    }
    awaitthis.start();
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['insert',{
            id:11,
            model:'mail.channel',
        }]],
    });
    awaitthis.afterEvent({
        eventName:'o-thread-view-hint-processed',
        func:()=>this.createThreadViewComponent(threadViewer.threadView,{order:'asc'},{isFixedSize:true}),
        message:"shouldwaituntilthreadbecomesloadedwithmessages",
        predicate:({hint,threadViewer})=>{
            return(
                hint.type==='messages-loaded'&&
                threadViewer.thread.model==='mail.channel'&&
                threadViewer.thread.id===11
            );
        },
    });
    assert.containsNone(
        document.body,
        '.o_Message',
        "Nomessageshouldbeshownasall30firstmessagesareempty"
    );
    assert.containsOnce(
        document.body,
        '.o_MessageList_loadMore',
        "Loadmorebuttonshouldbeshownastherearemoremessagestoshow"
    );
});

QUnit.test('firstunseenmessageshouldbedirectlyprecededbythenewmessageseparatorifthereisatransientmessagejustbeforeitwhilecomposerisnotfocused[REQUIREFOCUS]',asyncfunction(assert){
    //Thegoalofremovingthefocusistoensurethethreadisnotmarkedasseenautomatically.
    //Indeedthatwouldtriggerchannel_seennomatterwhat,whichisalreadycoveredbyothertests.
    //Thegoalofthistestistocovertheconditionsspecifictotransientmessages,
    //andtheconditionsfromfocuswouldotherwiseshadowthem.
    assert.expect(3);

    this.data['mail.channel_command'].records.push({name:'who'});
    //Neededpartner&usertoallowsimulationofmessagereception
    this.data['res.partner'].records.push({
        id:11,
        name:"Foreignerpartner",
    });
    this.data['res.users'].records.push({
        id:42,
        name:"Foreigneruser",
        partner_id:11,
    });
    this.data['mail.channel'].records=[{
        channel_type:'channel',
        id:20,
        is_pinned:true,
        name:"General",
        uuid:'channel20uuid',
    }];
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:20,
        model:'mail.channel'
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});
    //sendacommandthatleadstoreceivingatransientmessage
    document.querySelector('.o_ComposerTextInput_textarea').focus();
    awaitafterNextRender(()=>document.execCommand('insertText',false,"/who"));
    awaitafterNextRender(()=>{
        document.querySelector('.o_Composer_buttonSend').click();
    });

    //composerisfocusedbydefault,weremovethatfocus
    document.querySelector('.o_ComposerTextInput_textarea').blur();
    //simulatereceivingamessage
    awaitafterNextRender(()=>this.env.services.rpc({
        route:'/mail/chat_post',
        params:{
            context:{
                mockedUserId:42,
            },
            message_content:"test",
            uuid:'channel20uuid',
        },
    }));
    assert.containsN(
        document.body,
        '.o_Message',
        2,
        "shoulddisplay2messages(thetransient&thereceivedmessage),afterpostingacommand"
    );
    assert.containsOnce(
        document.body,
        '.o_MessageList_separatorNewMessages',
        "separatorshouldbeshownasamessagehasbeenreceived"
    );
    assert.containsOnce(
        document.body,
        `.o_Message[data-message-local-id="${
            this.env.models['mail.message'].find(m=>m.isTransient).localId
        }"]+.o_MessageList_separatorNewMessages`,
        "separatorshouldbeshownjustaftertransientmessage"
    );
});

QUnit.test('composershouldbefocusedautomaticallyafterclickingonthesendbutton[REQUIREFOCUS]',asyncfunction(assert){
    assert.expect(1);

    this.data['mail.channel'].records.push({id:20,});
    awaitthis.start();
    constthread=this.env.models['mail.thread'].findFromIdentifyingData({
        id:20,
        model:'mail.channel'
    });
    constthreadViewer=this.env.models['mail.thread_viewer'].create({
        hasThreadView:true,
        thread:[['link',thread]],
    });
    awaitthis.createThreadViewComponent(threadViewer.threadView,{hasComposer:true});
    document.querySelector('.o_ComposerTextInput_textarea').focus();
    awaitafterNextRender(()=>document.execCommand('insertText',false,"DummyMessage"));
    awaitafterNextRender(()=>{
        document.querySelector('.o_Composer_buttonSend').click();
    });
    assert.hasClass(
        document.querySelector('.o_Composer'),
        'o-focused',
        "composershouldbefocusedautomaticallyafterclickingonthesendbutton"
    );
});

});
});
});

});

flectra.define('mail/static/src/components/attachment/attachment_tests.js',function(require){
'usestrict';

constcomponents={
    Attachment:require('mail/static/src/components/attachment/attachment.js'),
};
const{
    afterEach,
    afterNextRender,
    beforeEach,
    createRootComponent,
    start,
}=require('mail/static/src/utils/test_utils.js');

QUnit.module('mail',{},function(){
QUnit.module('components',{},function(){
QUnit.module('attachment',{},function(){
QUnit.module('attachment_tests.js',{
    beforeEach(){
        beforeEach(this);

        this.createAttachmentComponent=async(attachment,otherProps)=>{
            constprops=Object.assign({attachmentLocalId:attachment.localId},otherProps);
            awaitcreateRootComponent(this,components.Attachment,{
                props,
                target:this.widget.el,
            });
        };

        this.start=asyncparams=>{
            const{env,widget}=awaitstart(Object.assign({},params,{
                data:this.data,
            }));
            this.env=env;
            this.widget=widget;
        };
    },
    afterEach(){
        afterEach(this);
    },
});

QUnit.test('simplestlayout',asyncfunction(assert){
    assert.expect(8);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.txt",
        id:750,
        mimetype:'text/plain',
        name:"test.txt",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'none',
        isDownloadable:false,
        isEditable:false,
        showExtension:false,
        showFilename:false,
    });
    assert.strictEqual(
        document.querySelectorAll('.o_Attachment').length,
        1,
        "shouldhaveattachmentcomponentinDOM"
    );
    constattachmentEl=document.querySelector('.o_Attachment');
    assert.strictEqual(
        attachmentEl.dataset.attachmentLocalId,
        this.env.models['mail.attachment'].findFromIdentifyingData({id:750}).localId,
        "attachmentcomponentshouldbelinkedtoattachmentstoremodel"
    );
    assert.strictEqual(
        attachmentEl.title,
        "test.txt",
        "attachmentshouldhavefilenameastitleattribute"
    );
    assert.strictEqual(
        attachmentEl.querySelectorAll(`:scope.o_Attachment_image`).length,
        1,
        "attachmentshouldhaveanimagepart"
    );
    constattachmentImage=document.querySelector(`.o_Attachment_image`);
    assert.ok(
        attachmentImage.classList.contains('o_image'),
        "attachmentshouldhaveo_imageclassname(requiredformimetype.scssstyle)"
    );
    assert.strictEqual(
        attachmentImage.dataset.mimetype,
        'text/plain',
        "attachmentshouldhavedata-mimetypeset(requiredformimetype.scssstyle)"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_details`).length,
        0,
        "attachmentshouldnothaveadetailspart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_aside`).length,
        0,
        "attachmentshouldnothaveanasidepart"
    );
});

QUnit.test('simplestlayout+deletable',asyncfunction(assert){
    assert.expect(6);

    awaitthis.start({
        asyncmockRPC(route,args){
            if(route.includes('web/image/750')){
                assert.ok(
                    route.includes('/200x200'),
                    "shouldfetchimagewith200x200pixelsratio");
                assert.step('fetch_image');
            }
            returnthis._super(...arguments);
        },
    });
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.txt",
        id:750,
        mimetype:'text/plain',
        name:"test.txt",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'none',
        isDownloadable:false,
        isEditable:true,
        showExtension:false,
        showFilename:false
    });
    assert.strictEqual(
        document.querySelectorAll('.o_Attachment').length,
        1,
        "shouldhaveattachmentcomponentinDOM"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_image`).length,
        1,
        "attachmentshouldhaveanimagepart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_details`).length,
        0,
        "attachmentshouldnothaveadetailspart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_aside`).length,
        1,
        "attachmentshouldhaveanasidepart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_asideItem`).length,
        1,
        "attachmentshouldhaveonlyoneasideitem"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_asideItemUnlink`).length,
        1,
        "attachmentshouldhaveadeletebutton"
    );
});

QUnit.test('simplestlayout+downloadable',asyncfunction(assert){
    assert.expect(6);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.txt",
        id:750,
        mimetype:'text/plain',
        name:"test.txt",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'none',
        isDownloadable:true,
        isEditable:false,
        showExtension:false,
        showFilename:false
    });
    assert.strictEqual(
        document.querySelectorAll('.o_Attachment').length,
        1,
        "shouldhaveattachmentcomponentinDOM"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_image`).length,
        1,
        "attachmentshouldhaveanimagepart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_details`).length,
        0,
        "attachmentshouldnothaveadetailspart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_aside`).length,
        1,
        "attachmentshouldhaveanasidepart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_asideItem`).length,
        1,
        "attachmentshouldhaveonlyoneasideitem"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_asideItemDownload`).length,
        1,
        "attachmentshouldhaveadownloadbutton"
    );
});

QUnit.test('simplestlayout+deletable+downloadable',asyncfunction(assert){
    assert.expect(8);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.txt",
        id:750,
        mimetype:'text/plain',
        name:"test.txt",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'none',
        isDownloadable:true,
        isEditable:true,
        showExtension:false,
        showFilename:false
    });
    assert.strictEqual(
        document.querySelectorAll('.o_Attachment').length,
        1,
        "shouldhaveattachmentcomponentinDOM"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_image`).length,
        1,
        "attachmentshouldhaveanimagepart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_details`).length,
        0,
        "attachmentshouldnothaveadetailspart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_aside`).length,
        1,
        "attachmentshouldhaveanasidepart"
    );
    assert.ok(
        document.querySelector(`.o_Attachment_aside`).classList.contains('o-has-multiple-action'),
        "attachmentasideshouldcontainmultipleactions"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_asideItem`).length,
        2,
        "attachmentshouldhaveonlytwoasideitems"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_asideItemDownload`).length,
        1,
        "attachmentshouldhaveadownloadbutton"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_asideItemUnlink`).length,
        1,
        "attachmentshouldhaveadeletebutton"
    );
});

QUnit.test('layoutwithcarddetails',asyncfunction(assert){
    assert.expect(3);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.txt",
        id:750,
        mimetype:'text/plain',
        name:"test.txt",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'card',
        isDownloadable:false,
        isEditable:false,
        showExtension:false,
        showFilename:false
    });
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_image`).length,
        1,
        "attachmentshouldhaveanimagepart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_details`).length,
        0,
        "attachmentshouldnothaveadetailspart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_aside`).length,
        0,
        "attachmentshouldnothaveanasidepart"
    );
});

QUnit.test('layoutwithcarddetailsandfilename',asyncfunction(assert){
    assert.expect(3);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.txt",
        id:750,
        mimetype:'text/plain',
        name:"test.txt",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'card',
        isDownloadable:false,
        isEditable:false,
        showExtension:false,
        showFilename:true
    });
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_details`).length,
        1,
        "attachmentshouldhaveadetailspart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_filename`).length,
        1,
        "attachmentshouldnothaveitsfilenameshown"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_extension`).length,
        0,
        "attachmentshouldhaveitsextensionshown"
    );
});

QUnit.test('layoutwithcarddetailsandextension',asyncfunction(assert){
    assert.expect(3);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.txt",
        id:750,
        mimetype:'text/plain',
        name:"test.txt",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'card',
        isDownloadable:false,
        isEditable:false,
        showExtension:true,
        showFilename:false
    });
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_details`).length,
        1,
        "attachmentshouldhaveadetailspart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_filename`).length,
        0,
        "attachmentshouldnothaveitsfilenameshown"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_extension`).length,
        1,
        "attachmentshouldhaveitsextensionshown"
    );
});

QUnit.test('layoutwithcarddetailsandfilenameandextension',asyncfunction(assert){
    assert.expect(3);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.txt",
        id:750,
        mimetype:'text/plain',
        name:"test.txt",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'card',
        isDownloadable:false,
        isEditable:false,
        showExtension:true,
        showFilename:true
    });
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_details`).length,
        1,
        "attachmentshouldhaveadetailspart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_filename`).length,
        1,
        "attachmentshouldhaveitsfilenameshown"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_extension`).length,
        1,
        "attachmentshouldhaveitsextensionshown"
    );
});

QUnit.test('simplestlayoutwithhoverdetailsandfilenameandextension',asyncfunction(assert){
    assert.expect(8);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.txt",
        id:750,
        mimetype:'text/plain',
        name:"test.txt",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'hover',
        isDownloadable:true,
        isEditable:true,
        showExtension:true,
        showFilename:true
    });
    assert.strictEqual(
        document.querySelectorAll(`
            .o_Attachment_details:not(.o_Attachment_imageOverlayDetails)
        `).length,
        0,
        "attachmentshouldnothaveadetailspartdirectly"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_imageOverlayDetails`).length,
        1,
        "attachmentshouldhaveadetailspartintheoverlay"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_image`).length,
        1,
        "attachmentshouldhaveanimagepart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_imageOverlay`).length,
        1,
        "attachmentshouldhaveanimageoverlaypart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_filename`).length,
        1,
        "attachmentshouldhaveitsfilenameshown"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_extension`).length,
        1,
        "attachmentshouldhaveitsextensionshown"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_actions`).length,
        1,
        "attachmentshouldhaveanactionspart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_aside`).length,
        0,
        "attachmentshouldnothaveanasideelement"
    );
});

QUnit.test('autolayoutwithimage',asyncfunction(assert){
    assert.expect(7);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.png",
        id:750,
        mimetype:'image/png',
        name:"test.png",
    });

    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'auto',
        isDownloadable:false,
        isEditable:false,
        showExtension:true,
        showFilename:true
    });
    assert.strictEqual(
        document.querySelectorAll(`
            .o_Attachment_details:not(.o_Attachment_imageOverlayDetails)
        `).length,
        0,
        "attachmentshouldnothaveadetailspartdirectly"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_imageOverlayDetails`).length,
        1,
        "attachmentshouldhaveadetailspartintheoverlay"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_image`).length,
        1,
        "attachmentshouldhaveanimagepart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_imageOverlay`).length,
        1,
        "attachmentshouldhaveanimageoverlaypart"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_filename`).length,
        1,
        "attachmentshouldhaveitsfilenameshown"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_extension`).length,
        1,
        "attachmentshouldhaveitsextensionshown"
    );
    assert.strictEqual(
        document.querySelectorAll(`.o_Attachment_aside`).length,
        0,
        "attachmentshouldnothaveanasideelement"
    );
});

QUnit.test('viewattachment',asyncfunction(assert){
    assert.expect(3);

    awaitthis.start({
        hasDialog:true,
    });
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.png",
        id:750,
        mimetype:'image/png',
        name:"test.png",
    });

    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'hover',
        isDownloadable:false,
        isEditable:false,
    });
    assert.containsOnce(
        document.body,
        '.o_Attachment_image',
        "attachmentshouldhaveanimagepart"
    );
    awaitafterNextRender(()=>document.querySelector('.o_Attachment_image').click());
    assert.containsOnce(
        document.body,
        '.o_Dialog',
        'adialogshouldhavebeenopenedonceattachmentimageisclicked',
    );
    assert.containsOnce(
        document.body,
        '.o_AttachmentViewer',
        'anattachmentviewershouldhavebeenopenedonceattachmentimageisclicked',
    );
});

QUnit.test('closeattachmentviewer',asyncfunction(assert){
    assert.expect(3);

    awaitthis.start({hasDialog:true});
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.png",
        id:750,
        mimetype:'image/png',
        name:"test.png",
    });

    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'hover',
        isDownloadable:false,
        isEditable:false,
    });
    assert.containsOnce(
        document.body,
        '.o_Attachment_image',
        "attachmentshouldhaveanimagepart"
    );

    awaitafterNextRender(()=>document.querySelector('.o_Attachment_image').click());
    assert.containsOnce(
        document.body,
        '.o_AttachmentViewer',
        "anattachmentviewershouldhavebeenopenedonceattachmentimageisclicked",
    );

    awaitafterNextRender(()=>
        document.querySelector('.o_AttachmentViewer_headerItemButtonClose').click()
    );
    assert.containsNone(
        document.body,
        '.o_Dialog',
        "attachmentviewershouldbeclosedafterclickingonclosebutton"
    );
});

QUnit.test('clickingonthedeleteattachmentbuttonmultipletimesshoulddotherpconlyonce',asyncfunction(assert){
    assert.expect(2);
    awaitthis.start({
        asyncmockRPC(route,args){
            if(args.method==="unlink"&&args.model==="ir.attachment"){
                assert.step('attachment_unlink');
                return;
            }
            returnthis._super(...arguments);
        },
    });
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.txt",
        id:750,
        mimetype:'text/plain',
        name:"test.txt",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'hover',
    });
    awaitafterNextRender(()=>{
        document.querySelector('.o_Attachment_actionUnlink').click();
    });

    awaitafterNextRender(()=>{
        document.querySelector('.o_AttachmentDeleteConfirmDialog_confirmButton').click();
        document.querySelector('.o_AttachmentDeleteConfirmDialog_confirmButton').click();
        document.querySelector('.o_AttachmentDeleteConfirmDialog_confirmButton').click();
    });
    assert.verifySteps(
        ['attachment_unlink'],
        "Theunlinkmethodmustbecalledonce"
    );
});

QUnit.test('[technical]doesnotcrashwhentheviewerisclosedbeforeimageload',asyncfunction(assert){
    /**
     *Whenimagesaredisplayedusing`src`attributeforthe1sttime,itfetchestheresource.
     *Inthiscase,imagesareactuallydisplayed(fullyfetchedandrenderedonscreen)when
     *`<image>`intercepts`load`event.
     *
     *Currentcodeneedstobeawareofloadstateofimage,todisplayspinnerwhenloading
     *andactualimagewhenloaded.Thistestassertsnocrashfrommishandlingimagebecoming
     *loadedfrombeingviewedfor1sttime,butviewerbeingclosedwhileimageisloading.
     */
    assert.expect(1);

    awaitthis.start({hasDialog:true});
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.png",
        id:750,
        mimetype:'image/png',
        name:"test.png",
    });
    awaitthis.createAttachmentComponent(attachment);
    awaitafterNextRender(()=>document.querySelector('.o_Attachment_image').click());
    constimageEl=document.querySelector('.o_AttachmentViewer_viewImage');
    awaitafterNextRender(()=>
        document.querySelector('.o_AttachmentViewer_headerItemButtonClose').click()
    );
    //Simulateimagebecomingloaded.
    letsuccessfulLoad;
    try{
        imageEl.dispatchEvent(newEvent('load',{bubbles:true}));
        successfulLoad=true;
    }catch(err){
        successfulLoad=false;
    }finally{
        assert.ok(successfulLoad,'shouldnotcrashwhentheimageisloaded');
    }
});

QUnit.test('plaintextfileisviewable',asyncfunction(assert){
    assert.expect(1);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.txt",
        id:750,
        mimetype:'text/plain',
        name:"test.txt",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'card',
        isDownloadable:false,
        isEditable:false,
    });
    assert.hasClass(
        document.querySelector('.o_Attachment'),
        'o-viewable',
        "shouldbeviewable",
    );
});

QUnit.test('HTMLfileisviewable',asyncfunction(assert){
    assert.expect(1);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.html",
        id:750,
        mimetype:'text/html',
        name:"test.html",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'card',
        isDownloadable:false,
        isEditable:false,
    });
    assert.hasClass(
        document.querySelector('.o_Attachment'),
        'o-viewable',
        "shouldbeviewable",
    );
});

QUnit.test('ODTfileisnotviewable',asyncfunction(assert){
    assert.expect(1);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.odt",
        id:750,
        mimetype:'application/vnd.oasis.opendocument.text',
        name:"test.odt",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'card',
        isDownloadable:false,
        isEditable:false,
    });
    assert.doesNotHaveClass(
        document.querySelector('.o_Attachment'),
        'o-viewable',
        "shouldnotbeviewable",
    );
});

QUnit.test('DOCXfileisnotviewable',asyncfunction(assert){
    assert.expect(1);

    awaitthis.start();
    constattachment=this.env.models['mail.attachment'].create({
        filename:"test.docx",
        id:750,
        mimetype:'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        name:"test.docx",
    });
    awaitthis.createAttachmentComponent(attachment,{
        detailsMode:'card',
        isDownloadable:false,
        isEditable:false,
    });
    assert.doesNotHaveClass(
        document.querySelector('.o_Attachment'),
        'o-viewable',
        "shouldnotbeviewable",
    );
});

});
});
});

});

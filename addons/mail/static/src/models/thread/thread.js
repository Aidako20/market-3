flectra.define('mail/static/src/models/thread/thread.js',function(require){
'usestrict';

const{registerNewModel}=require('mail/static/src/model/model_core.js');
const{attr,many2many,many2one,one2many,one2one}=require('mail/static/src/model/model_field.js');
const{clear}=require('mail/static/src/model/model_field_command.js');
constthrottle=require('mail/static/src/utils/throttle/throttle.js');
constTimer=require('mail/static/src/utils/timer/timer.js');
const{cleanSearchTerm}=require('mail/static/src/utils/utils.js');
constmailUtils=require('mail.utils');

functionfactory(dependencies){

    classThreadextendsdependencies['mail.model']{

        /**
         *@override
         */
        _willCreate(){
            constres=super._willCreate(...arguments);
            /**
             *Timerofcurrentpartnerthatwascurrentlytypingsomething,but
             *thereisnochangeontheinputfor5seconds.Thisisused
             *inordertoautomaticallynotifyothermembersthatcurrent
             *partnerhasstoppedtypingsomething,duetomakingnochanges
             *onthecomposerforsometime.
             */
            this._currentPartnerInactiveTypingTimer=newTimer(
                this.env,
                ()=>this.async(()=>this._onCurrentPartnerInactiveTypingTimeout()),
                5*1000
            );
            /**
             *Last'is_typing'statusofcurrentpartnerthathasbeennotified
             *toothermembers.Usefultopreventspammingtypingnotifications
             *toothermembersifithasn'tchanged.Anexceptionisthe
             *currentpartnerlongtypingscenariowherecurrentpartnerhas
             *tore-sendthesametypingnotificationfromtimetotime,so
             *thatothermembersdonotassumehe/sheisnolongertyping
             *somethingfromnotreceivinganytypingnotificationsfora
             *verylongtime.
             *
             *Supportedvalues:true/false/undefined.
             *undefinedmakesonlysenseinitiallyandduringcurrentpartner
             *longtypingtimeoutflow.
             */
            this._currentPartnerLastNotifiedIsTyping=undefined;
            /**
             *Timerofcurrentpartnerthatistypingaverylongtext.When
             *theothermembersdonotreceiveanytypingnotificationfora
             *longtime,theymustassumethattherelatedpartnerisnolonger
             *typingsomething(e.g.theyhaveclosedthebrowsertab).
             *Thisisatimertoletothermembersknowthatcurrentpartner
             *isstilltypingsomething,sothattheyshouldnotassumehe/she
             *hasstoppedtypingsomething.
             */
            this._currentPartnerLongTypingTimer=newTimer(
                this.env,
                ()=>this.async(()=>this._onCurrentPartnerLongTypingTimeout()),
                50*1000
            );
            /**
             *Determineswhetherthenextrequesttonotifycurrentpartner
             *typingstatusshouldalwaysresulttomakingRPC,regardlessof
             *whetherlastnotifiedcurrentpartnertypingstatusisthesame.
             *Mostofthetimewedonotwanttonotifyifvaluehasn't
             *changed,exceptionbeingthelongtypingscenarioofcurrent
             *partner.
             */
            this._forceNotifyNextCurrentPartnerTypingStatus=false;
            /**
             *Registryoftimersofpartnerscurrentlytypinginthethread,
             *excludingcurrentpartner.Thisisusefulinorderto
             *automaticallyunregistertypingmemberswhennotreceiveany
             *typingnotificationafteralongtime.Timersareinternally
             *indexedbypartnerrecordsaskey.Thecurrentpartneris
             *ignoredinthisregistryoftimers.
             *
             *@seeregisterOtherMemberTypingMember
             *@seeunregisterOtherMemberTypingMember
             */
            this._otherMembersLongTypingTimers=newMap();

            /**
             *Clearableandcancellablethrottledversionofthe
             *`_notifyCurrentPartnerTypingStatus`method.
             *Thisisusefulwhenthecurrentpartnerpostsamessageand
             *typessomethingelseafterwards:itmustnotifyimmediatelythat
             *he/sheistypingsomething,insteadofwaitingforthethrottle
             *internaltimer.
             *
             *@see_notifyCurrentPartnerTypingStatus
             */
            this._throttleNotifyCurrentPartnerTypingStatus=throttle(
                this.env,
                ({isTyping})=>this.async(()=>this._notifyCurrentPartnerTypingStatus({isTyping})),
                2.5*1000
            );
            returnres;
        }

        /**
         *@override
         */
        _willDelete(){
            this._currentPartnerInactiveTypingTimer.clear();
            this._currentPartnerLongTypingTimer.clear();
            this._throttleNotifyCurrentPartnerTypingStatus.clear();
            for(consttimerofthis._otherMembersLongTypingTimers.values()){
                timer.clear();
            }
            if(this.isTemporary){
                for(constmessageofthis.messages){
                    message.delete();
                }
            }
            returnsuper._willDelete(...arguments);
        }

        //----------------------------------------------------------------------
        //Public
        //----------------------------------------------------------------------

        /**
         *@static
         *@param{mail.thread}[thread]theconcernedthread
         */
        staticcomputeLastCurrentPartnerMessageSeenByEveryone(thread=undefined){
            constthreads=thread?[thread]:this.env.models['mail.thread'].all();
            threads.map(localThread=>{
                localThread.update({
                    lastCurrentPartnerMessageSeenByEveryone:localThread._computeLastCurrentPartnerMessageSeenByEveryone(),
                });
            });
        }

        /**
         *@static
         *@param{Object}data
         *@return{Object}
         */
        staticconvertData(data){
            constdata2={
                messagesAsServerChannel:[],
            };
            if('model'indata){
                data2.model=data.model;
            }
            if('channel_type'indata){
                data2.channel_type=data.channel_type;
                data2.model='mail.channel';
            }
            if('create_uid'indata){
                data2.creator=[['insert',{id:data.create_uid}]];
            }
            if('custom_channel_name'indata){
                data2.custom_channel_name=data.custom_channel_name;
            }
            if('group_based_subscription'indata){
                data2.group_based_subscription=data.group_based_subscription;
            }
            if('id'indata){
                data2.id=data.id;
            }
            if('is_minimized'indata&&'state'indata){
                data2.serverFoldState=data.is_minimized?data.state:'closed';
            }
            if('is_moderator'indata){
                data2.is_moderator=data.is_moderator;
            }
            if('is_pinned'indata){
                data2.isServerPinned=data.is_pinned;
            }
            if('last_message'indata&&data.last_message){
                data2.messagesAsServerChannel.push(['insert',{id:data.last_message.id}]);
                data2.serverLastMessageId=data.last_message.id;
            }
            if('last_message_id'indata&&data.last_message_id){
                data2.messagesAsServerChannel.push(['insert',{id:data.last_message_id}]);
                data2.serverLastMessageId=data.last_message_id;
            }
            if('mass_mailing'indata){
                data2.mass_mailing=data.mass_mailing;
            }
            if('moderation'indata){
                data2.moderation=data.moderation;
            }
            if('message_needaction_counter'indata){
                data2.message_needaction_counter=data.message_needaction_counter;
            }
            if('message_unread_counter'indata){
                data2.serverMessageUnreadCounter=data.message_unread_counter;
            }
            if('name'indata){
                data2.name=data.name;
            }
            if('public'indata){
                data2.public=data.public;
            }
            if('seen_message_id'indata){
                data2.lastSeenByCurrentPartnerMessageId=data.seen_message_id||0;
            }
            if('uuid'indata){
                data2.uuid=data.uuid;
            }

            //relations
            if('members'indata){
                if(!data.members){
                    data2.members=[['unlink-all']];
                }else{
                    data2.members=[
                        ['insert-and-replace',data.members.map(memberData=>
                            this.env.models['mail.partner'].convertData(memberData)
                        )],
                    ];
                }
            }
            if('seen_partners_info'indata){
                if(!data.seen_partners_info){
                    data2.partnerSeenInfos=[['unlink-all']];
                }else{
                    /*
                     *FIXME:notoptimaltowriteonrelationgiventhefactthattherelation
                     *willbe(re)computedbasedongivenfields.
                     *(herechannelIdwillcomputepartnerSeenInfo.thread))
                     *task-2336946
                     */
                    data2.partnerSeenInfos=[
                        ['insert-and-replace',
                            data.seen_partners_info.map(
                                ({fetched_message_id,partner_id,seen_message_id})=>{
                                    return{
                                        channelId:data2.id,
                                        lastFetchedMessage:[fetched_message_id?['insert',{id:fetched_message_id}]:['unlink-all']],
                                        lastSeenMessage:[seen_message_id?['insert',{id:seen_message_id}]:['unlink-all']],
                                        partnerId:partner_id,
                                    };
                                })
                        ]
                    ];
                    if(data.id||this.id){
                        constmessageIds=data.seen_partners_info.reduce((currentSet,{fetched_message_id,seen_message_id})=>{
                            if(fetched_message_id){
                                currentSet.add(fetched_message_id);
                            }
                            if(seen_message_id){
                                currentSet.add(seen_message_id);
                            }
                            returncurrentSet;
                        },newSet());
                        if(messageIds.size>0){
                            /*
                             *FIXME:notoptimaltowriteonrelationgiventhefactthattherelation
                             *willbe(re)computedbasedongivenfields.
                             *(herechannelIdwillcomputemessageSeenIndicator.thread))
                             *task-2336946
                             */
                            data2.messageSeenIndicators=[
                                ['insert',
                                    [...messageIds].map(messageId=>{
                                       return{
                                           channelId:data.id||this.id,
                                           messageId,
                                       };
                                    })
                                ]
                            ];
                        }
                    }
                }
            }

            returndata2;
        }

        /**
         *Fetchesthreadsmatchingthegivencomposersearchstatetoextend
         *theJSknowledgeandtoupdatethesuggestionlistaccordingly.
         *Morespecificallyonlythreadofmodel'mail.channel'arefetched.
         *
         *@static
         *@param{string}searchTerm
         *@param{Object}[options={}]
         *@param{mail.thread}[options.thread]prioritizeand/orrestrict
         * resultinthecontextofgiventhread
         */
        staticasyncfetchSuggestions(searchTerm,{thread}={}){
            constchannelsData=awaitthis.env.services.rpc(
                {
                    model:'mail.channel',
                    method:'get_mention_suggestions',
                    kwargs:{search:searchTerm},
                },
                {shadow:true},
            );
            this.env.models['mail.thread'].insert(channelsData.map(channelData=>
                Object.assign(
                    {model:'mail.channel'},
                    this.env.models['mail.thread'].convertData(channelData),
                )
            ));
        }

        /**
         *Returnsasortfunctiontodeterminetheorderofdisplayofthreads
         *inthesuggestionlist.
         *
         *@static
         *@param{string}searchTerm
         *@param{Object}[options={}]
         *@param{mail.thread}[options.thread]prioritizeresultinthe
         * contextofgiventhread
         *@returns{function}
         */
        staticgetSuggestionSortFunction(searchTerm,{thread}={}){
            constcleanedSearchTerm=cleanSearchTerm(searchTerm);
            return(a,b)=>{
                constisAPublic=a.model==='mail.channel'&&a.public==='public';
                constisBPublic=b.model==='mail.channel'&&b.public==='public';
                if(isAPublic&&!isBPublic){
                    return-1;
                }
                if(!isAPublic&&isBPublic){
                    return1;
                }
                constisMemberOfA=a.model==='mail.channel'&&a.members.includes(this.env.messaging.currentPartner);
                constisMemberOfB=b.model==='mail.channel'&&b.members.includes(this.env.messaging.currentPartner);
                if(isMemberOfA&&!isMemberOfB){
                    return-1;
                }
                if(!isMemberOfA&&isMemberOfB){
                    return1;
                }
                constcleanedAName=cleanSearchTerm(a.name||'');
                constcleanedBName=cleanSearchTerm(b.name||'');
                if(cleanedAName.startsWith(cleanedSearchTerm)&&!cleanedBName.startsWith(cleanedSearchTerm)){
                    return-1;
                }
                if(!cleanedAName.startsWith(cleanedSearchTerm)&&cleanedBName.startsWith(cleanedSearchTerm)){
                    return1;
                }
                if(cleanedAName<cleanedBName){
                    return-1;
                }
                if(cleanedAName>cleanedBName){
                    return1;
                }
                returna.id-b.id;
            };
        }

        /**
         *Loadthepreviewsofthespecifiedthreads.Basically,itfetchesthe
         *lastmessages,sincetheyareusedtodisplayinlinecontentofthem.
         *
         *@static
         *@param{mail.thread[]}threads
         */
        staticasyncloadPreviews(threads){
            constchannelIds=threads.reduce((list,thread)=>{
                if(thread.model==='mail.channel'){
                    returnlist.concat(thread.id);
                }
                returnlist;
            },[]);
            if(channelIds.length===0){
                return;
            }
            constchannelPreviews=awaitthis.env.services.rpc({
                model:'mail.channel',
                method:'channel_fetch_preview',
                args:[channelIds],
            },{shadow:true});
            this.env.models['mail.message'].insert(channelPreviews.filter(p=>p.last_message).map(
                channelPreview=>this.env.models['mail.message'].convertData(channelPreview.last_message)
            ));
        }


        /**
         *Performsthe`channel_fold`RPCon`mail.channel`.
         *
         *@static
         *@param{string}uuid
         *@param{string}state
         */
        staticasyncperformRpcChannelFold(uuid,state){
            returnthis.env.services.rpc({
                model:'mail.channel',
                method:'channel_fold',
                kwargs:{
                    state,
                    uuid,
                }
            },{shadow:true});
        }

        /**
         *Performsthe`channel_info`RPCon`mail.channel`.
         *
         *@static
         *@param{Object}param0
         *@param{integer[]}param0.idslistofidofchannels
         *@returns{mail.thread[]}
         */
        staticasyncperformRpcChannelInfo({ids}){
            constchannelInfos=awaitthis.env.services.rpc({
                model:'mail.channel',
                method:'channel_info',
                args:[ids],
            },{shadow:true});
            constchannels=this.env.models['mail.thread'].insert(
                channelInfos.map(channelInfo=>this.env.models['mail.thread'].convertData(channelInfo))
            );
            //manuallyforcerecomputeofcounter
            this.env.messaging.messagingMenu.update();
            returnchannels;
        }

        /**
         *Performsthe`channel_seen`RPCon`mail.channel`.
         *
         *@static
         *@param{Object}param0
         *@param{integer[]}param0.idslistofidofchannels
         *@param{integer[]}param0.lastMessageId
         */
        staticasyncperformRpcChannelSeen({ids,lastMessageId}){
            returnthis.env.services.rpc({
                model:'mail.channel',
                method:'channel_seen',
                args:[ids],
                kwargs:{
                    last_message_id:lastMessageId,
                },
            },{shadow:true});
        }

        /**
         *Performsthe`channel_pin`RPCon`mail.channel`.
         *
         *@static
         *@param{Object}param0
         *@param{boolean}[param0.pinned=false]
         *@param{string}param0.uuid
         */
        staticasyncperformRpcChannelPin({pinned=false,uuid}){
            returnthis.env.services.rpc({
                model:'mail.channel',
                method:'channel_pin',
                kwargs:{
                    uuid,
                    pinned,
                },
            },{shadow:true});
        }

        /**
         *Performsthe`channel_create`RPCon`mail.channel`.
         *
         *@static
         *@param{Object}param0
         *@param{string}param0.name
         *@param{string}[param0.privacy]
         *@returns{mail.thread}thecreatedchannel
         */
        staticasyncperformRpcCreateChannel({name,privacy}){
            constdevice=this.env.messaging.device;
            constdata=awaitthis.env.services.rpc({
                model:'mail.channel',
                method:'channel_create',
                args:[name,privacy],
                kwargs:{
                    context:Object.assign({},this.env.session.user_content,{
                        //optimizethereturnvaluebyavoidinguselessqueries
                        //innon-mobiledevices
                        isMobile:device.isMobile,
                    }),
                },
            });
            returnthis.env.models['mail.thread'].insert(
                this.env.models['mail.thread'].convertData(data)
            );
        }

        /**
         *Performsthe`channel_get`RPCon`mail.channel`.
         *
         *`openChat`ispreferableinbusinesscodebecauseitwillavoidthe
         *RPCifthechatalreadyexists.
         *
         *@static
         *@param{Object}param0
         *@param{integer[]}param0.partnerIds
         *@param{boolean}[param0.pinForCurrentPartner]
         *@returns{mail.thread|undefined}thecreatedorexistingchat
         */
        staticasyncperformRpcCreateChat({partnerIds,pinForCurrentPartner}){
            constdevice=this.env.messaging.device;
            //TODOFIX:potentialduplicatechattask-2276490
            constdata=awaitthis.env.services.rpc({
                model:'mail.channel',
                method:'channel_get',
                kwargs:{
                    context:Object.assign({},this.env.session.user_content,{
                        //optimizethereturnvaluebyavoidinguselessqueries
                        //innon-mobiledevices
                        isMobile:device.isMobile,
                    }),
                    partners_to:partnerIds,
                    pin:pinForCurrentPartner,
                },
            });
            if(!data){
                return;
            }
            returnthis.env.models['mail.thread'].insert(
                this.env.models['mail.thread'].convertData(data)
            );
        }

        /**
         *Performsthe`channel_join_and_get_info`RPCon`mail.channel`.
         *
         *@static
         *@param{Object}param0
         *@param{integer}param0.channelId
         *@returns{mail.thread}thechannelthatwasjoined
         */
        staticasyncperformRpcJoinChannel({channelId}){
            constdevice=this.env.messaging.device;
            constdata=awaitthis.env.services.rpc({
                model:'mail.channel',
                method:'channel_join_and_get_info',
                args:[[channelId]],
                kwargs:{
                    context:Object.assign({},this.env.session.user_content,{
                        //optimizethereturnvaluebyavoidinguselessqueries
                        //innon-mobiledevices
                        isMobile:device.isMobile,
                    }),
                },
            });
            returnthis.env.models['mail.thread'].insert(
                this.env.models['mail.thread'].convertData(data)
            );
        }

        /**
         *Performsthe`execute_command`RPCon`mail.channel`.
         *
         *@static
         *@param{Object}param0
         *@param{integer}param0.channelId
         *@param{string}param0.command
         *@param{Object}[param0.postData={}]
         */
        staticasyncperformRpcExecuteCommand({channelId,command,postData={}}){
            returnthis.env.services.rpc({
                model:'mail.channel',
                method:'execute_command',
                args:[[channelId]],
                kwargs:Object.assign({command},postData),
            });
        }

        /**
         *Performsthe`message_post`RPCongiventhreadModel.
         *
         *@static
         *@param{Object}param0
         *@param{Object}param0.postData
         *@param{integer}param0.threadId
         *@param{string}param0.threadModel
         *@return{integer}thepostedmessageid
         */
        staticasyncperformRpcMessagePost({postData,threadId,threadModel}){
            returnthis.env.services.rpc({
                model:threadModel,
                method:'message_post',
                args:[threadId],
                kwargs:postData,
            });
        }

        /**
         *PerformsRPContheroute`/mail/get_suggested_recipients`.
         *
         *@static
         *@param{Object}param0
         *@param{string}param0.model
         *@param{integer[]}param0.res_id
         */
        staticasyncperformRpcMailGetSuggestedRecipients({model,res_ids}){
            constdata=awaitthis.env.services.rpc({
                route:'/mail/get_suggested_recipients',
                params:{
                    model,
                    res_ids,
                },
            },{shadow:true});
            for(constidindata){
                constrecipientInfoList=data[id].map(recipientInfoData=>{
                    const[partner_id,emailInfo,reason]=recipientInfoData;
                    const[name,email]=emailInfo&&mailUtils.parseEmail(emailInfo);
                    return{
                        email,
                        name,
                        partner:[partner_id?['insert',{id:partner_id}]:['unlink']],
                        reason,
                    };
                });
                this.insert({
                    id:parseInt(id),
                    model,
                    suggestedRecipientInfoList:[['insert-and-replace',recipientInfoList]],
                });
            }
        }

        /*
         *Returnsthreadsthatmatchthegivensearchterm.Morespeciallyonly
         *threadsofmodel'mail.channel'aresuggested,andifthecontext
         *threadisaprivatechannel,onlyitselfisreturnedifitmatches
         *thesearchterm.
         *
         *@static
         *@param{string}searchTerm
         *@param{Object}[options={}]
         *@param{mail.thread}[options.thread]prioritizeand/orrestrict
         * resultinthecontextofgiventhread
         *@returns{[mail.threads[],mail.threads[]]}
         */
        staticsearchSuggestions(searchTerm,{thread}={}){
            letthreads;
            if(thread&&thread.model==='mail.channel'&&thread.public!=='public'){
                //Onlyreturnthecurrentchannelwheninthecontextofa
                //non-publicchannel.Indeed,themessagewiththemention
                //wouldappearinthetargetchannel,sothispreventsfrom
                //inadvertentlyleakingtheprivatemessageintothementioned
                //channel.
                threads=[thread];
            }else{
                threads=this.env.models['mail.thread'].all();
            }
            constcleanedSearchTerm=cleanSearchTerm(searchTerm);
            return[threads.filter(thread=>
                !thread.isTemporary&&
                thread.model==='mail.channel'&&
                thread.channel_type==='channel'&&
                thread.name&&
                cleanSearchTerm(thread.name).includes(cleanedSearchTerm)
            )];
        }

        /**
         *@param{string}[stringifiedDomain='[]']
         *@returns{mail.thread_cache}
         */
        cache(stringifiedDomain='[]'){
            returnthis.env.models['mail.thread_cache'].insert({
                stringifiedDomain,
                thread:[['link',this]],
            });
        }

        /**
         *Fetchattachmentslinkedtoarecord.Usefulforpopulatingthestore
         *withtheseattachments,whichareusedbyattachmentboxinthechatter.
         */
        asyncfetchAttachments(){
            returnthis.fetchData(['attachments']);
        }

        /**
         *Requeststhegiven`requestList`datafromtheserver.
         *
         *@param{string[]}requestList
         */
        asyncfetchData(requestList){
            if(this.isTemporary){
                return;
            }
            constrequestSet=newSet(requestList);
            if(requestSet.has('attachments')){
                this.update({isLoadingAttachments:true});
            }
            const{
                attachments:attachmentsData,
            }=awaitthis.env.services.rpc({
                route:'/mail/thread/data',
                params:{
                    request_list:[...requestSet],
                    thread_id:this.id,
                    thread_model:this.model,
                },
            },{shadow:true});
            if(!this.exists()){
                return;
            }
            constvalues={};
            if(attachmentsData){
                Object.assign(values,{
                    areAttachmentsLoaded:true,
                    isLoadingAttachments:false,
                    originThreadAttachments:[['insert-and-replace',attachmentsData]],
                });
            }
            this.update(values);
        }

        /**
         *Fetchessuggestedrecipients.
         */
        asyncfetchAndUpdateSuggestedRecipients(){
            if(this.isTemporary){
                return;
            }
            returnthis.env.models['mail.thread'].performRpcMailGetSuggestedRecipients({
                model:this.model,
                res_ids:[this.id],
            });
        }

        /**
         *Addcurrentusertoprovidedthread'sfollowers.
         */
        asyncfollow(){
            awaitthis.async(()=>this.env.services.rpc({
                model:this.model,
                method:'message_subscribe',
                args:[[this.id]],
                kwargs:{
                    partner_ids:[this.env.messaging.currentPartner.id],
                    context:{},//FIXMEemptycontexttobeoverriddeninsession.jswith'allowed_company_ids'task-2243187
                },
            }));
            this.refreshFollowers();
            this.fetchAndUpdateSuggestedRecipients();
        }

        /**
         *Returnsthenameofthegivenpartnerinthecontextofthisthread.
         *
         *@param{mail.partner}partner
         *@returns{string}
         */
        getMemberName(partner){
            returnpartner.nameOrDisplayName;
        }

        /**
         *Returnsthetextthatidentifiesthisthreadinamention.
         *
         *@returns{string}
         */
        getMentionText(){
            returnthis.name;
        }

        /**
         *Loadnewmessagesonthemaincacheofthisthread.
         */
        loadNewMessages(){
            this.mainCache.loadNewMessages();
        }

        /**
         *Markthespecifiedconversationasfetched.
         */
        asyncmarkAsFetched(){
            awaitthis.async(()=>this.env.services.rpc({
                model:'mail.channel',
                method:'channel_fetched',
                args:[[this.id]],
            },{shadow:true}));
        }

        /**
         *Markthespecifiedconversationasread/seen.
         *
         *@param{mail.message}messagethemessagetobeconsideredaslastseen.
         */
        asyncmarkAsSeen(message){
            if(this.model!=='mail.channel'){
                return;
            }
            if(this.pendingSeenMessageId&&message.id<=this.pendingSeenMessageId){
                return;
            }
            if(
                this.lastSeenByCurrentPartnerMessageId&&
                message.id<=this.lastSeenByCurrentPartnerMessageId
            ){
                return;
            }
            this.update({pendingSeenMessageId:message.id});
            returnthis.env.models['mail.thread'].performRpcChannelSeen({
                ids:[this.id],
                lastMessageId:message.id,
            });
        }

        /**
         *Marksasreadallneedactionmessageswiththisthreadasorigin.
         */
        asyncmarkNeedactionMessagesAsOriginThreadAsRead(){
            awaitthis.async(()=>
                this.env.models['mail.message'].markAsRead(this.needactionMessagesAsOriginThread)
            );
        }

        /**
         *Markasreadallneedactionmessagesofthisthread.
         */
        asyncmarkNeedactionMessagesAsRead(){
            awaitthis.async(()=>
                this.env.models['mail.message'].markAsRead(this.needactionMessages)
            );
        }

        /**
         *Notifiestheserverofnewfoldstate.Usefulforinitial,
         *cross-tab,andcross-devicechatwindowstatesynchronization.
         *
         *@param{string}state
         */
        asyncnotifyFoldStateToServer(state){
            if(this.model!=='mail.channel'){
                //Serversyncoffoldstateisonlysupportedforchannels.
                return;
            }
            if(!this.uuid){
                return;
            }
            returnthis.env.models['mail.thread'].performRpcChannelFold(this.uuid,state);
        }

        /**
         *Notifyservertoleavethecurrentchannel.Usefulforcross-tab
         *andcross-devicechatwindowstatesynchronization.
         *
         *OnlymakessenseifisPendingPinnedissettothedesiredvalue.
         */
        asyncnotifyPinStateToServer(){
            if(this.isPendingPinned){
                awaitthis.env.models['mail.thread'].performRpcChannelPin({
                    pinned:true,
                    uuid:this.uuid,
                });
            }else{
                this.env.models['mail.thread'].performRpcExecuteCommand({
                    channelId:this.id,
                    command:'leave',
                });
            }
        }

        /**
         *Opensthisthreadeitherasformview,indiscussapp,orasachat
         *window.Thethreadwillbeopenedinan"active"matter,whichwill
         *interruptcurrentuserflow.
         *
         *@param{Object}[param0]
         *@param{boolean}[param0.expanded=false]
         */
        asyncopen({expanded=false}={}){
            constdiscuss=this.env.messaging.discuss;
            //checkifthreadmustbeopenedinformview
            if(!['mail.box','mail.channel'].includes(this.model)){
                if(expanded||discuss.isOpen){
                    //Closechatwindowbecausehavingthesamethreadopened
                    //bothinchatwindowandasmaindocumentdoesnotlook
                    //good.
                    this.env.messaging.chatWindowManager.closeThread(this);
                    returnthis.env.messaging.openDocument({
                        id:this.id,
                        model:this.model,
                    });
                }
            }
            //checkifthreadmustbeopenedindiscuss
            constdevice=this.env.messaging.device;
            if(
                (!device.isMobile&&(discuss.isOpen||expanded))||
                this.model==='mail.box'
            ){
                returndiscuss.openThread(this);
            }
            //threadmustbeopenedinchatwindow
            returnthis.env.messaging.chatWindowManager.openThread(this,{
                makeActive:true,
            });
        }

        /**
         *Opensthemostappropriateviewthatisaprofileforthisthread.
         */
        asyncopenProfile(){
            returnthis.env.messaging.openDocument({
                id:this.id,
                model:this.model,
            });
        }

        /**
         *Pinthisthreadandnotifyserverofthechange.
         */
        asyncpin(){
            this.update({isPendingPinned:true});
            awaitthis.notifyPinStateToServer();
        }

        /**
         *Openadialogtoaddchannelsasfollowers.
         */
        promptAddChannelFollower(){
            this._promptAddFollower({mail_invite_follower_channel_only:true});
        }

        /**
         *Openadialogtoaddpartnersasfollowers.
         */
        promptAddPartnerFollower(){
            this._promptAddFollower({mail_invite_follower_channel_only:false});
        }

        asyncrefresh(){
            if(this.isTemporary){
                return;
            }
            this.loadNewMessages();
            awaitthis.async(()=>this.fetchAttachments());
        }

        asyncrefreshActivities(){
            if(!this.hasActivities){
                return;
            }
            if(this.isTemporary){
                return;
            }
            //Abit"extreme",maybeimproved
            const[{activity_ids:newActivityIds}]=awaitthis.async(()=>this.env.services.rpc({
                model:this.model,
                method:'read',
                args:[this.id,['activity_ids']]
            },{shadow:true}));
            constactivitiesData=awaitthis.async(()=>this.env.services.rpc({
                model:'mail.activity',
                method:'activity_format',
                args:[newActivityIds]
            },{shadow:true}));
            constactivities=this.env.models['mail.activity'].insert(activitiesData.map(
                activityData=>this.env.models['mail.activity'].convertData(activityData)
            ));
            this.update({activities:[['replace',activities]]});
        }

        /**
         *Refreshfollowersinformationfromserver.
         */
        asyncrefreshFollowers(){
            if(this.isTemporary){
                this.update({followers:[['unlink-all']]});
                return;
            }
            const{followers}=awaitthis.async(()=>this.env.services.rpc({
                route:'/mail/read_followers',
                params:{
                    res_id:this.id,
                    res_model:this.model,
                },
            },{shadow:true}));
            this.update({areFollowersLoaded:true});
            if(followers.length>0){
                this.update({
                    followers:[['insert-and-replace',followers.map(data=>
                        this.env.models['mail.follower'].convertData(data))
                    ]],
                });
            }else{
                this.update({
                    followers:[['unlink-all']],
                });
            }
        }

        /**
         *Refreshthetypingstatusofthecurrentpartner.
         */
        refreshCurrentPartnerIsTyping(){
            this._currentPartnerInactiveTypingTimer.reset();
        }

        /**
         *Calledtorefresharegisteredothermemberpartnerthatistyping
         *something.
         *
         *@param{mail.partner}partner
         */
        refreshOtherMemberTypingMember(partner){
            this._otherMembersLongTypingTimers.get(partner).reset();
        }

        /**
         *Calledwhencurrentpartnerisinsertingsomeinputincomposer.
         *Usefultonotifycurrentpartneriscurrentlytypingsomethinginthe
         *composerofthisthreadtoallothermembers.
         */
        asyncregisterCurrentPartnerIsTyping(){
            //Handlingoftypingtimers.
            this._currentPartnerInactiveTypingTimer.start();
            this._currentPartnerLongTypingTimer.start();
            //Managetypingmemberrelation.
            constcurrentPartner=this.env.messaging.currentPartner;
            constnewOrderedTypingMemberLocalIds=this.orderedTypingMemberLocalIds
                .filter(localId=>localId!==currentPartner.localId);
            newOrderedTypingMemberLocalIds.push(currentPartner.localId);
            this.update({
                orderedTypingMemberLocalIds:newOrderedTypingMemberLocalIds,
                typingMembers:[['link',currentPartner]],
            });
            //Notifytypingstatustoothermembers.
            awaitthis._throttleNotifyCurrentPartnerTypingStatus({isTyping:true});
        }

        /**
         *Calledtoregisteranewothermemberpartnerthatistyping
         *something.
         *
         *@param{mail.partner}partner
         */
        registerOtherMemberTypingMember(partner){
            consttimer=newTimer(
                this.env,
                ()=>this.async(()=>this._onOtherMemberLongTypingTimeout(partner)),
                60*1000
            );
            this._otherMembersLongTypingTimers.set(partner,timer);
            timer.start();
            constnewOrderedTypingMemberLocalIds=this.orderedTypingMemberLocalIds
                .filter(localId=>localId!==partner.localId);
            newOrderedTypingMemberLocalIds.push(partner.localId);
            this.update({
                orderedTypingMemberLocalIds:newOrderedTypingMemberLocalIds,
                typingMembers:[['link',partner]],
            });
        }

        /**
         *Renamethegiventhreadwithprovidednewname.
         *
         *@param{string}newName
         */
        asyncrename(newName){
            if(this.channel_type==='chat'){
                awaitthis.async(()=>this.env.services.rpc({
                    model:'mail.channel',
                    method:'channel_set_custom_name',
                    args:[this.id],
                    kwargs:{
                        name:newName,
                    },
                }));
            }
            this.update({custom_channel_name:newName});
        }

        /**
         *Unfollowcurrentpartnerfromthisthread.
         */
        asyncunfollow(){
            constcurrentPartnerFollower=this.followers.find(
                follower=>follower.partner===this.env.messaging.currentPartner
            );
            awaitthis.async(()=>currentPartnerFollower.remove());
        }

        /**
         *Unpinthisthreadandnotifyserverofthechange.
         */
        asyncunpin(){
            this.update({isPendingPinned:false});
            awaitthis.notifyPinStateToServer();
        }

        /**
         *Calledwhencurrentpartnerhasexplicitlystoppedinsertingsome
         *inputincomposer.Usefultonotifycurrentpartnerhascurrently
         *stoppedtypingsomethinginthecomposerofthisthreadtoallother
         *members.
         *
         *@param{Object}[param0={}]
         *@param{boolean}[param0.immediateNotify=false]ifset,istyping
         *  statusofcurrentpartnerisimmediatelynotifiedanddoesn't
         *  consumethrottlingatall.
         */
        asyncunregisterCurrentPartnerIsTyping({immediateNotify=false}={}){
            //Handlingoftypingtimers.
            this._currentPartnerInactiveTypingTimer.clear();
            this._currentPartnerLongTypingTimer.clear();
            //Managetypingmemberrelation.
            constcurrentPartner=this.env.messaging.currentPartner;
            constnewOrderedTypingMemberLocalIds=this.orderedTypingMemberLocalIds
                .filter(localId=>localId!==currentPartner.localId);
            this.update({
                orderedTypingMemberLocalIds:newOrderedTypingMemberLocalIds,
                typingMembers:[['unlink',currentPartner]],
            });
            //Notifytypingstatustoothermembers.
            if(immediateNotify){
                this._throttleNotifyCurrentPartnerTypingStatus.clear();
            }
            awaitthis.async(
                ()=>this._throttleNotifyCurrentPartnerTypingStatus({isTyping:false})
            );
        }

        /**
         *Calledtounregisteranothermemberpartnerthatisnolongertyping
         *something.
         *
         *@param{mail.partner}partner
         */
        unregisterOtherMemberTypingMember(partner){
            this._otherMembersLongTypingTimers.get(partner).clear();
            this._otherMembersLongTypingTimers.delete(partner);
            constnewOrderedTypingMemberLocalIds=this.orderedTypingMemberLocalIds
                .filter(localId=>localId!==partner.localId);
            this.update({
                orderedTypingMemberLocalIds:newOrderedTypingMemberLocalIds,
                typingMembers:[['unlink',partner]],
            });
        }

        /**
         *Unsubscribecurrentuserfromprovidedchannel.
         */
        unsubscribe(){
            this.env.messaging.chatWindowManager.closeThread(this);
            this.unpin();
        }

        //----------------------------------------------------------------------
        //Private
        //----------------------------------------------------------------------

        /**
         *@override
         */
        static_createRecordLocalId(data){
            const{channel_type,id,model}=data;
            letthreadModel=model;
            if(!threadModel&&channel_type){
                threadModel='mail.channel';
            }
            return`${this.modelName}_${threadModel}_${id}`;
        }

        /**
         *@private
         *@returns{mail.attachment[]}
         */
        _computeAllAttachments(){
            constallAttachments=[...newSet(this.originThreadAttachments.concat(this.attachments))]
                .sort((a1,a2)=>{
                    //"uploading"before"uploaded"attachments.
                    if(!a1.isTemporary&&a2.isTemporary){
                        return1;
                    }
                    if(a1.isTemporary&&!a2.isTemporary){
                        return-1;
                    }
                    //"most-recent"before"oldest"attachments.
                    returnMath.abs(a2.id)-Math.abs(a1.id);
                });
            return[['replace',allAttachments]];
        }

        /**
         *@private
         *@returns{mail.partner}
         */
        _computeCorrespondent(){
            if(this.channel_type==='channel'){
                return[['unlink']];
            }
            constcorrespondents=this.members.filter(partner=>
                partner!==this.env.messaging.currentPartner
            );
            if(correspondents.length===1){
                //2memberschat
                return[['link',correspondents[0]]];
            }
            if(this.members.length===1){
                //chatwithoneself
                return[['link',this.members[0]]];
            }
            return[['unlink']];
        }

        /**
         *@private
         *@returns{integer}
         */
        _computeDisplayCounter(){
            if(this.mass_mailing&&this.env.session.notification_type==='email'){
                return0;
            }
            returnthis.localMessageUnreadCounter;
        }

        /**
         *@private
         *@returns{string}
         */
        _computeDisplayName(){
            if(this.channel_type==='chat'&&this.correspondent){
                returnthis.custom_channel_name||this.correspondent.nameOrDisplayName;
            }
            returnthis.name;
        }

        /**
         *@private
         *@returns{mail.activity[]}
         */
        _computeFutureActivities(){
            return[['replace',this.activities.filter(activity=>activity.state==='planned')]];
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeHasSeenIndicators(){
            if(this.model!=='mail.channel'){
                returnfalse;
            }
            if(this.mass_mailing){
                returnfalse;
            }
            return['chat','livechat'].includes(this.channel_type);
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeIsChatChannel(){
            returnthis.channel_type==='chat';
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeIsCurrentPartnerFollowing(){
            returnthis.followers.some(follower=>
                follower.partner&&follower.partner===this.env.messaging.currentPartner
            );
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeIsModeratedByCurrentPartner(){
            if(!this.messaging){
                returnfalse;
            }
            if(!this.messaging.currentPartner){
                returnfalse;
            }
            returnthis.moderators.includes(this.env.messaging.currentPartner);
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeIsPinned(){
            returnthis.isPendingPinned!==undefined?this.isPendingPinned:this.isServerPinned;
        }

        /**
         *@private
         *@returns{mail.message}
         */
        _computeLastCurrentPartnerMessageSeenByEveryone(){
            constotherPartnerSeenInfos=
                this.partnerSeenInfos.filter(partnerSeenInfo=>
                    partnerSeenInfo.partner!==this.messagingCurrentPartner);
            if(otherPartnerSeenInfos.length===0){
                return[['unlink-all']];
            }

            constotherPartnersLastSeenMessageIds=
                otherPartnerSeenInfos.map(partnerSeenInfo=>
                    partnerSeenInfo.lastSeenMessage?partnerSeenInfo.lastSeenMessage.id:0
                );
            if(otherPartnersLastSeenMessageIds.length===0){
                return[['unlink-all']];
            }
            constlastMessageSeenByAllId=Math.min(
                ...otherPartnersLastSeenMessageIds
            );
            constcurrentPartnerOrderedSeenMessages=
                this.orderedNonTransientMessages.filter(message=>
                    message.author===this.messagingCurrentPartner&&
                    message.id<=lastMessageSeenByAllId);

            if(
                !currentPartnerOrderedSeenMessages||
                currentPartnerOrderedSeenMessages.length===0
            ){
                return[['unlink-all']];
            }
            return[['link',currentPartnerOrderedSeenMessages.slice().pop()]];
        }

        /**
         *@private
         *@returns{mail.message|undefined}
         */
        _computeLastMessage(){
            const{
                length:l,
                [l-1]:lastMessage,
            }=this.orderedMessages;
            if(lastMessage){
                return[['link',lastMessage]];
            }
            return[['unlink']];
        }

        /**
         *@private
         *@returns{mail.message|undefined}
         */
        _computeLastNonTransientMessage(){
            const{
                length:l,
                [l-1]:lastMessage,
            }=this.orderedNonTransientMessages;
            if(lastMessage){
                return[['link',lastMessage]];
            }
            return[['unlink']];
        }

        /**
         *Adjuststhelastseenmessagereceivedfromtheservertoconsider
         *thefollowingmessagesalsoasreadiftheyareeithertransient
         *messagesormessagesfromthecurrentpartner.
         *
         *@private
         *@returns{integer}
         */
        _computeLastSeenByCurrentPartnerMessageId(){
            constfirstMessage=this.orderedMessages[0];
            if(
                firstMessage&&
                this.lastSeenByCurrentPartnerMessageId&&
                this.lastSeenByCurrentPartnerMessageId<firstMessage.id
            ){
                //nodeductioncanbemadeifthereisagap
                returnthis.lastSeenByCurrentPartnerMessageId;
            }
            letlastSeenByCurrentPartnerMessageId=this.lastSeenByCurrentPartnerMessageId;
            for(constmessageofthis.orderedMessages){
                if(message.id<=this.lastSeenByCurrentPartnerMessageId){
                    continue;
                }
                if(
                    message.author===this.env.messaging.currentPartner||
                    message.isTransient
                ){
                    lastSeenByCurrentPartnerMessageId=message.id;
                    continue;
                }
                returnlastSeenByCurrentPartnerMessageId;
            }
            returnlastSeenByCurrentPartnerMessageId;
        }

        /**
         *@private
         *@returns{mail.message|undefined}
         */
        _computeLastNeedactionMessage(){
            constorderedNeedactionMessages=this.needactionMessages.sort(
                (m1,m2)=>m1.id<m2.id?-1:1
            );
            const{
                length:l,
                [l-1]:lastNeedactionMessage,
            }=orderedNeedactionMessages;
            if(lastNeedactionMessage){
                return[['link',lastNeedactionMessage]];
            }
            return[['unlink']];
        }

        /**
         *@private
         *@returns{mail.message|undefined}
         */
        _computeLastNeedactionMessageAsOriginThread(){
            constorderedNeedactionMessagesAsOriginThread=this.needactionMessagesAsOriginThread.sort(
                (m1,m2)=>m1.id<m2.id?-1:1
            );
            const{
                length:l,
                [l-1]:lastNeedactionMessageAsOriginThread,
            }=orderedNeedactionMessagesAsOriginThread;
            if(lastNeedactionMessageAsOriginThread){
                return[['link',lastNeedactionMessageAsOriginThread]];
            }
            return[['unlink']];
        }

        /**
         *@private
         *@returns{mail.thread_cache}
         */
        _computeMainCache(){
            return[['link',this.cache()]];
        }

        /**
         *@private
         *@returns{integer}
         */
        _computeLocalMessageUnreadCounter(){
            if(this.model!=='mail.channel'){
                //unreadcounteronlymakessenseonchannels
                returnclear();
            }
            //Bydefaulttrusttheserveruptothelastmessageitused
            //becauseit'snotpossibletodobetter.
            letbaseCounter=this.serverMessageUnreadCounter;
            letcountFromId=this.serverLastMessageId;
            //Butiftheclientknowsthelastseenmessagethattheserver
            //returned(andbyassumptionallthemessagesthatcomeafter),
            //thecountercanbecomputedfullylocally,ignoringpotentially
            //obsoletevaluesfromtheserver.
            constfirstMessage=this.orderedMessages[0];
            if(
                firstMessage&&
                this.lastSeenByCurrentPartnerMessageId&&
                this.lastSeenByCurrentPartnerMessageId>=firstMessage.id
            ){
                baseCounter=0;
                countFromId=this.lastSeenByCurrentPartnerMessageId;
            }
            //Includeallthemessagesthatareknownlocallybuttheserver
            //didn'ttakeintoaccount.
            returnthis.orderedMessages.reduce((total,message)=>{
                if(message.id<=countFromId){
                    returntotal;
                }
                returntotal+1;
            },baseCounter);
        }

        /**
         *@private
         *@returns{mail.messaging}
         */
        _computeMessaging(){
            return[['link',this.env.messaging]];
        }

        /**
         *@private
         *@returns{mail.message[]}
         */
        _computeNeedactionMessages(){
            return[['replace',this.messages.filter(message=>message.isNeedaction)]];
        }

        /**
         *@private
         *@returns{mail.message[]}
         */
        _computeNeedactionMessagesAsOriginThread(){
            return[['replace',this.messagesAsOriginThread.filter(message=>message.isNeedaction)]];
        }

        /**
         *@private
         *@returns{mail.message|undefined}
         */
        _computeMessageAfterNewMessageSeparator(){
            if(this.model!=='mail.channel'){
                return[['unlink']];
            }
            if(this.localMessageUnreadCounter===0){
                return[['unlink']];
            }
            constindex=this.orderedMessages.findIndex(message=>
                message.id===this.lastSeenByCurrentPartnerMessageId
            );
            if(index===-1){
                return[['unlink']];
            }
            constmessage=this.orderedMessages[index+1];
            if(!message){
                return[['unlink']];
            }
            return[['link',message]];
        }

        /**
         *@private
         *@returns{mail.message[]}
         */
        _computeOrderedMessages(){
            return[['replace',this.messages.sort((m1,m2)=>m1.id<m2.id?-1:1)]];
        }

        /**
         *@private
         *@returns{mail.message[]}
         */
        _computeOrderedNonTransientMessages(){
            return[['replace',this.orderedMessages.filter(m=>!m.isTransient)]];
        }

        /**
         *@private
         *@returns{mail.partner[]}
         */
        _computeOrderedOtherTypingMembers(){
            return[[
                'replace',
                this.orderedTypingMembers.filter(
                    member=>member!==this.env.messaging.currentPartner
                ),
            ]];
        }

        /**
         *@private
         *@returns{mail.partner[]}
         */
        _computeOrderedTypingMembers(){
            return[[
                'replace',
                this.orderedTypingMemberLocalIds
                    .map(localId=>this.env.models['mail.partner'].get(localId))
                    .filter(member=>!!member),
            ]];
        }

        /**
         *@private
         *@returns{mail.activity[]}
         */
        _computeOverdueActivities(){
            return[['replace',this.activities.filter(activity=>activity.state==='overdue')]];
        }

        /**
         *@private
         *@returns{mail.activity[]}
         */
        _computeTodayActivities(){
            return[['replace',this.activities.filter(activity=>activity.state==='today')]];
        }

        /**
         *@private
         *@returns{string}
         */
        _computeTypingStatusText(){
            if(this.orderedOtherTypingMembers.length===0){
                returnthis.constructor.fields.typingStatusText.default;
            }
            if(this.orderedOtherTypingMembers.length===1){
                return_.str.sprintf(
                    this.env._t("%sistyping..."),
                    this.getMemberName(this.orderedOtherTypingMembers[0])
                );
            }
            if(this.orderedOtherTypingMembers.length===2){
                return_.str.sprintf(
                    this.env._t("%sand%saretyping..."),
                    this.getMemberName(this.orderedOtherTypingMembers[0]),
                    this.getMemberName(this.orderedOtherTypingMembers[1])
                );
            }
            return_.str.sprintf(
                this.env._t("%s,%sandmorearetyping..."),
                this.getMemberName(this.orderedOtherTypingMembers[0]),
                this.getMemberName(this.orderedOtherTypingMembers[1])
            );
        }

        /**
         *Computeanurlstringthatcanbeusedinsideahrefattribute
         *
         *@private
         *@returns{string}
         */
        _computeUrl(){
            constbaseHref=this.env.session.url('/web');
            if(this.model==='mail.channel'){
                return`${baseHref}#action=mail.action_discuss&active_id=${this.model}_${this.id}`;
            }
            return`${baseHref}#model=${this.model}&id=${this.id}`;
        }

        /**
         *@private
         *@param{Object}param0
         *@param{boolean}param0.isTyping
         */
        async_notifyCurrentPartnerTypingStatus({isTyping}){
            if(
                this._forceNotifyNextCurrentPartnerTypingStatus||
                isTyping!==this._currentPartnerLastNotifiedIsTyping
            ){
                if(this.model==='mail.channel'){
                    awaitthis.async(()=>this.env.services.rpc({
                        model:'mail.channel',
                        method:'notify_typing',
                        args:[this.id],
                        kwargs:{is_typing:isTyping},
                    },{shadow:true}));
                }
                if(isTyping&&this._currentPartnerLongTypingTimer.isRunning){
                    this._currentPartnerLongTypingTimer.reset();
                }
            }
            this._forceNotifyNextCurrentPartnerTypingStatus=false;
            this._currentPartnerLastNotifiedIsTyping=isTyping;
        }

        /**
         *Cleansfollowersofcurrentthread.Inparticular,chatsaresupposed
         *toworkwith"members",notwith"followers".Thiscleanupisonly
         *necessarytoremoveillegitimatefollowersinstableversion,itcan
         *beremovedinmasterafterpropermigrationtocleanthedatabase.
         *
         *@private
         */
        _onChangeFollowersPartner(){
            if(this.channel_type!=='chat'){
                return;
            }
            for(constfollowerofthis.followers){
                if(follower.partner){
                    follower.remove();
                }
            }
        }

        /**
         *@private
         */
        _onChangeLastSeenByCurrentPartnerMessageId(){
            this.env.messagingBus.trigger('o-thread-last-seen-by-current-partner-message-id-changed',{
                thread:this,
            });
        }

        /**
         *@private
         */
        _onChangeThreadViews(){
            if(this.threadViews.length===0){
                return;
            }
            /**
             *Fetchesfollowersofchatswhentheyaredisplayedforthefirst
             *time.Thisisnecessarytocleanthefollowers.
             *@see`_onChangeFollowersPartner`formoreinformation.
             */
            if(this.channel_type==='chat'&&!this.areFollowersLoaded){
                this.refreshFollowers();
            }
        }

        /**
         *Handleschangeofpinnedstatecomingfromtheserver.Usefulto
         *clearpendingstateonceserveracknowledgedthechange.
         *
         *@private
         *@seeisPendingPinned
         */
        _onIsServerPinnedChanged(){
            if(this.isServerPinned===this.isPendingPinned){
                this.update({isPendingPinned:clear()});
            }
        }

        /**
         *Handleschangeoffoldstatecomingfromtheserver.Usefulto
         *synchronizecorrespondingchatwindow.
         *
         *@private
         */
        _onServerFoldStateChanged(){
            if(!this.env.messaging.chatWindowManager){
                //avoidcrashduringdestroy
                return;
            }
            if(this.env.messaging.device.isMobile){
                return;
            }
            if(this.serverFoldState==='closed'){
                this.env.messaging.chatWindowManager.closeThread(this,{
                    notifyServer:false,
                });
            }else{
                this.env.messaging.chatWindowManager.openThread(this,{
                    isFolded:this.serverFoldState==='folded',
                    notifyServer:false,
                });
            }
        }

        /**
         *@private
         *@param{Object}[param0={}]
         *@param{boolean}[param0.mail_invite_follower_channel_only=false]
         */
        _promptAddFollower({mail_invite_follower_channel_only=false}={}){
            constself=this;
            constaction={
                type:'ir.actions.act_window',
                res_model:'mail.wizard.invite',
                view_mode:'form',
                views:[[false,'form']],
                name:this.env._t("InviteFollower"),
                target:'new',
                context:{
                    default_res_model:this.model,
                    default_res_id:this.id,
                    mail_invite_follower_channel_only,
                },
            };
            this.env.bus.trigger('do-action',{
                action,
                options:{
                    on_close:async()=>{
                       awaitthis.async(()=>this.refreshFollowers());
                       this.env.bus.trigger('mail.thread:promptAddFollower-closed');
                    },
                },
            });
        }

        //----------------------------------------------------------------------
        //Handlers
        //----------------------------------------------------------------------

        /**
         *@private
         */
        async_onCurrentPartnerInactiveTypingTimeout(){
            awaitthis.async(()=>this.unregisterCurrentPartnerIsTyping());
        }

        /**
         *Calledwhencurrentpartnerhasbeentypingforaverylongtime.
         *Immediatelynotifyothermembersthathe/sheisstilltyping.
         *
         *@private
         */
        async_onCurrentPartnerLongTypingTimeout(){
            this._forceNotifyNextCurrentPartnerTypingStatus=true;
            this._throttleNotifyCurrentPartnerTypingStatus.clear();
            awaitthis.async(
                ()=>this._throttleNotifyCurrentPartnerTypingStatus({isTyping:true})
            );
        }

        /**
         *@private
         *@param{mail.partner}partner
         */
        async_onOtherMemberLongTypingTimeout(partner){
            if(!this.typingMembers.includes(partner)){
                this._otherMembersLongTypingTimers.delete(partner);
                return;
            }
            this.unregisterOtherMemberTypingMember(partner);
        }

    }

    Thread.fields={
        /**
         *Determinesthe`mail.activity`thatbelongto`this`,assuming`this`
         *hasactivities(@seehasActivities).
         */
        activities:one2many('mail.activity',{
            inverse:'thread',
        }),
        /**
         *Servesascomputedependency.
         */
        activitiesState:attr({
            related:'activities.state',
        }),
        allAttachments:many2many('mail.attachment',{
            compute:'_computeAllAttachments',
            dependencies:[
                'attachments',
                'originThreadAttachments',
            ],
        }),
        areAttachmentsLoaded:attr({
            default:false,
        }),
        /**
         *Stateswhetherfollowershavebeenloadedatleastonceforthis
         *thread.
         */
        areFollowersLoaded:attr({
            default:false,
        }),
        attachments:many2many('mail.attachment',{
            inverse:'threads',
        }),
        caches:one2many('mail.thread_cache',{
            inverse:'thread',
            isCausal:true,
        }),
        channel_type:attr(),
        /**
         *Statesthe`mail.chat_window`relatedto`this`.Servesascompute
         *dependency.Itiscomputedfromtheinverserelationanditshould
         *otherwisebeconsideredread-only.
         */
        chatWindow:one2one('mail.chat_window',{
            inverse:'thread',
        }),
        /**
         *Servesascomputedependency.
         */
        chatWindowIsFolded:attr({
            related:'chatWindow.isFolded',
        }),
        composer:one2one('mail.composer',{
            default:[['create']],
            inverse:'thread',
            isCausal:true,
        }),
        correspondent:many2one('mail.partner',{
            compute:'_computeCorrespondent',
            dependencies:[
                'channel_type',
                'members',
                'messagingCurrentPartner',
            ],
            inverse:'correspondentThreads',
        }),
        correspondentNameOrDisplayName:attr({
            related:'correspondent.nameOrDisplayName',
        }),
        counter:attr({
            default:0,
        }),
        creator:many2one('mail.user'),
        custom_channel_name:attr(),
        /**
         *Determineswhethercountershouldbedisplayedornot.
         */
        displayCounter:attr({
            compute:'_computeDisplayCounter',
            dependencies:[
                'localMessageUnreadCounter',
                'mass_mailing',
            ],
        }),
        displayName:attr({
            compute:'_computeDisplayName',
            dependencies:[
                'channel_type',
                'correspondent',
                'correspondentNameOrDisplayName',
                'custom_channel_name',
                'name',
            ],
        }),
        followersPartner:many2many('mail.partner',{
            related:'followers.partner',
        }),
        followers:one2many('mail.follower',{
            inverse:'followedThread',
        }),
        /**
         *Statesthe`mail.activity`thatbelongsto`this`andthatare
         *plannedinthefuture(duelaterthantoday).
         */
        futureActivities:one2many('mail.activity',{
            compute:'_computeFutureActivities',
            dependencies:['activitiesState'],
        }),
        group_based_subscription:attr({
            default:false,
        }),
        /**
         *Stateswhether`this`hasactivities(`mail.activity.mixin`serverside).
         */
        hasActivities:attr({
            default:false,
        }),
        /**
         *Determinewhetherthisthreadhastheseenindicators(VandVV)
         *enabledornot.
         */
        hasSeenIndicators:attr({
            compute:'_computeHasSeenIndicators',
            default:false,
            dependencies:[
                'channel_type',
                'mass_mailing',
                'model',
            ],
        }),
        id:attr(),
        /**
         *Stateswhetherthisthreadisa`mail.channel`qualifiedaschat.
         *
         *Usefultolistchatchannels,likeinmessagingmenuwiththefilter
         *'chat'.
         */
        isChatChannel:attr({
            compute:'_computeIsChatChannel',
            dependencies:[
                'channel_type',
            ],
            default:false,
        }),
        isCurrentPartnerFollowing:attr({
            compute:'_computeIsCurrentPartnerFollowing',
            default:false,
            dependencies:[
                'followersPartner',
                'messagingCurrentPartner',
            ],
        }),
        /**
         *Stateswhether`this`iscurrentlyloadingattachments.
         */
        isLoadingAttachments:attr({
            default:false,
        }),
        isModeratedByCurrentPartner:attr({
            compute:'_computeIsModeratedByCurrentPartner',
            dependencies:[
                'messagingCurrentPartner',
                'moderators',
            ],
        }),
        /**
         *Determineifthereisapendingpinstatechange,whichisachange
         *ofpinstaterequestedbytheclientbutnotyetconfirmedbythe
         *server.
         *
         *Thisfieldcanbeupdatedtoimmediatelychangethepinstateonthe
         *interfaceandtonotifytheserverofthenewstate.
         */
        isPendingPinned:attr(),
        /**
         *Booleanthatdetermineswhetherthisthreadispinned
         *indiscussandpresentinthemessagingmenu.
         */
        isPinned:attr({
            compute:'_computeIsPinned',
            dependencies:[
                'isPendingPinned',
                'isServerPinned',
            ],
        }),
        /**
         *Determinethelastpinstateknownbytheserver,whichisthepin
         *statedisplayedafterinitializationorwhenthelastpending
         *pinstatechangewasconfirmedbytheserver.
         *
         *Thisfieldshouldbeconsideredreadonlyinmostsituations.Only
         *thecodehandlingpinstatechangefromtheservershouldtypically
         *updateit.
         */
        isServerPinned:attr({
            default:false,
        }),
        isTemporary:attr({
            default:false,
        }),
        is_moderator:attr({
            default:false,
        }),
        lastCurrentPartnerMessageSeenByEveryone:many2one('mail.message',{
            compute:'_computeLastCurrentPartnerMessageSeenByEveryone',
            dependencies:[
                'messagingCurrentPartner',
                'orderedNonTransientMessages',
                'partnerSeenInfos',
            ],
        }),
        /**
         *Lastmessageofthethread,couldbeatransientone.
         */
        lastMessage:many2one('mail.message',{
            compute:'_computeLastMessage',
            dependencies:['orderedMessages'],
        }),
        lastNeedactionMessage:many2one('mail.message',{
            compute:'_computeLastNeedactionMessage',
            dependencies:['needactionMessages'],
        }),
        /**
         *Statesthelastknownneedactionmessagehavingthisthreadasorigin.
         */
        lastNeedactionMessageAsOriginThread:many2one('mail.message',{
            compute:'_computeLastNeedactionMessageAsOriginThread',
            dependencies:[
                'needactionMessagesAsOriginThread',
            ],
        }),
        /**
         *Lastnon-transientmessage.
         */
        lastNonTransientMessage:many2one('mail.message',{
            compute:'_computeLastNonTransientMessage',
            dependencies:['orderedNonTransientMessages'],
        }),
        /**
         *Lastseenmessageidofthechannelbycurrentpartner.
         *
         *Also,itneedstobekeptasanidbecauseit'sconsideredlikea"date"andcouldstay
         *evenifcorrespondingmessageisdeleted.Itisbasicallyusedtoknowwhich
         *messagesarebeforeorafterit.
         */
        lastSeenByCurrentPartnerMessageId:attr({
            compute:'_computeLastSeenByCurrentPartnerMessageId',
            default:0,
            dependencies:[
                'lastSeenByCurrentPartnerMessageId',
                'messagingCurrentPartner',
                'orderedMessages',
                'orderedMessagesIsTransient',
                //FIXMEmissingdependency'orderedMessages.author',(task-2261221)
            ],
        }),
        /**
         *Localvalueofmessageunreadcounter,thatmeansitisbasedoninitialservervalueand
         *updatedwithinterfaceupdates.
         */
        localMessageUnreadCounter:attr({
            compute:'_computeLocalMessageUnreadCounter',
            dependencies:[
                'lastSeenByCurrentPartnerMessageId',
                'messagingCurrentPartner',
                'orderedMessages',
                'serverLastMessageId',
                'serverMessageUnreadCounter',
            ],
        }),
        mainCache:one2one('mail.thread_cache',{
            compute:'_computeMainCache',
        }),
        mass_mailing:attr({
            default:false,
        }),
        members:many2many('mail.partner',{
            inverse:'memberThreads',
        }),
        /**
         *Determinesthemessagebeforewhichthe"newmessage"separatormust
         *bepositioned,ifany.
         */
        messageAfterNewMessageSeparator:many2one('mail.message',{
            compute:'_computeMessageAfterNewMessageSeparator',
            dependencies:[
                'lastSeenByCurrentPartnerMessageId',
                'localMessageUnreadCounter',
                'model',
                'orderedMessages',
            ],
        }),
        message_needaction_counter:attr({
            default:0,
        }),
        /**
         *Allmessagesthatthisthreadislinkedto.
         *Notethatthisfieldisautomaticallycomputedbyinverse
         *computedfield.Thisfieldisreadonly.
         */
        messages:many2many('mail.message',{
            inverse:'threads',
        }),
        /**
         *Allmessagesthathavebeenoriginallypostedinthisthread.
         */
        messagesAsOriginThread:one2many('mail.message',{
            inverse:'originThread',
        }),
        /**
         *Servesascomputedependency.
         */
        messagesAsOriginThreadIsNeedaction:attr({
            related:'messagesAsOriginThread.isNeedaction',
        }),
        /**
         *Allmessagesthatarecontainedonthischannelontheserver.
         *Equivalenttotheinverseofpythonfield`channel_ids`.
         */
        messagesAsServerChannel:many2many('mail.message',{
            inverse:'serverChannels',
        }),
        /**
         *Servesascomputedependency.
         */
        messagesIsNeedaction:attr({
            related:'messages.isNeedaction',
        }),
        messageSeenIndicators:one2many('mail.message_seen_indicator',{
            inverse:'thread',
            isCausal:true,
        }),
        messaging:many2one('mail.messaging',{
            compute:'_computeMessaging',
        }),
        messagingCurrentPartner:many2one('mail.partner',{
            related:'messaging.currentPartner',
        }),
        model:attr(),
        model_name:attr(),
        moderation:attr({
            default:false,
        }),
        /**
         *Partnersthataremoderatingthisthread(onlyappliestochannels).
         */
        moderators:many2many('mail.partner',{
            inverse:'moderatedChannels',
        }),
        moduleIcon:attr(),
        name:attr(),
        needactionMessages:many2many('mail.message',{
            compute:'_computeNeedactionMessages',
            dependencies:[
                'messages',
                'messagesIsNeedaction',
            ],
        }),
        /**
         *Statesallknownneedactionmessageshavingthisthreadasorigin.
         */
        needactionMessagesAsOriginThread:many2many('mail.message',{
            compute:'_computeNeedactionMessagesAsOriginThread',
            dependencies:[
                'messagesAsOriginThread',
                'messagesAsOriginThreadIsNeedaction',
            ],
        }),
        /**
         *Notarealfield,usedtotrigger`_onChangeFollowersPartner`whenoneof
         *thedependencieschanges.
         */
        onChangeFollowersPartner:attr({
            compute:'_onChangeFollowersPartner',
            dependencies:[
                'followersPartner',
            ],
        }),
        /**
         *Notarealfield,usedtotrigger`_onChangeLastSeenByCurrentPartnerMessageId`whenoneof
         *thedependencieschanges.
         */
        onChangeLastSeenByCurrentPartnerMessageId:attr({
            compute:'_onChangeLastSeenByCurrentPartnerMessageId',
            dependencies:[
                'lastSeenByCurrentPartnerMessageId',
            ],
        }),
        /**
         *Notarealfield,usedtotrigger`_onChangeThreadViews`whenoneof
         *thedependencieschanges.
         */
        onChangeThreadView:attr({
            compute:'_onChangeThreadViews',
            dependencies:[
                'threadViews',
            ],
        }),
        /**
         *Notarealfield,usedtotrigger`_onIsServerPinnedChanged`whenoneof
         *thedependencieschanges.
         */
        onIsServerPinnedChanged:attr({
            compute:'_onIsServerPinnedChanged',
            dependencies:[
                'isServerPinned',
            ],
        }),
        /**
         *Notarealfield,usedtotrigger`_onServerFoldStateChanged`whenoneof
         *thedependencieschanges.
         */
        onServerFoldStateChanged:attr({
            compute:'_onServerFoldStateChanged',
            dependencies:[
                'serverFoldState',
            ],
        }),
        /**
         *Allmessagesorderedliketheyaredisplayed.
         */
        orderedMessages:many2many('mail.message',{
            compute:'_computeOrderedMessages',
            dependencies:['messages'],
        }),
        /**
         *Servesascomputedependency.(task-2261221)
         */
        orderedMessagesIsTransient:attr({
            related:'orderedMessages.isTransient',
        }),
        /**
         *Allmessagesorderedliketheyaredisplayed.Thisfielddoesnot
         *containtransientmessageswhicharenot"real"records.
         */
        orderedNonTransientMessages:many2many('mail.message',{
            compute:'_computeOrderedNonTransientMessages',
            dependencies:[
                'orderedMessages',
                'orderedMessagesIsTransient',
            ],
        }),
        /**
         *Orderedtypingmembersonthisthread,excludingthecurrentpartner.
         */
        orderedOtherTypingMembers:many2many('mail.partner',{
            compute:'_computeOrderedOtherTypingMembers',
            dependencies:['orderedTypingMembers'],
        }),
        /**
         *Orderedtypingmembersonthisthread.Lowerindexmeansthismember
         *iscurrentlytypingforthelongesttime.Thislistincludescurrent
         *partnerastyper.
         */
        orderedTypingMembers:many2many('mail.partner',{
            compute:'_computeOrderedTypingMembers',
            dependencies:[
                'orderedTypingMemberLocalIds',
                'typingMembers',
            ],
        }),
        /**
         *Technicalattributetomanageorderedlistoftypingmembers.
         */
        orderedTypingMemberLocalIds:attr({
            default:[],
        }),
        originThreadAttachments:one2many('mail.attachment',{
            inverse:'originThread',
        }),
        /**
         *Statesthe`mail.activity`thatbelongsto`this`andthatare
         *overdue(dueearlierthantoday).
         */
        overdueActivities:one2many('mail.activity',{
            compute:'_computeOverdueActivities',
            dependencies:['activitiesState'],
        }),
        partnerSeenInfos:one2many('mail.thread_partner_seen_info',{
            inverse:'thread',
            isCausal:true,
        }),
        /**
         *Determineifthereisapendingseenmessagechange,whichisachange
         *ofseenmessagerequestedbytheclientbutnotyetconfirmedbythe
         *server.
         */
        pendingSeenMessageId:attr(),
        public:attr(),
        /**
         *Determinethelastfoldstateknownbytheserver,whichisthefold
         *statedisplayedafterinitializationorwhenthelastpending
         *foldstatechangewasconfirmedbytheserver.
         *
         *Thisfieldshouldbeconsideredreadonlyinmostsituations.Only
         *thecodehandlingfoldstatechangefromtheservershouldtypically
         *updateit.
         */
        serverFoldState:attr({
            default:'closed',
        }),
        /**
         *Lastmessageidconsideredbytheserver.
         *
         *UsefultocomputelocalMessageUnreadCounterfield.
         *
         *@seelocalMessageUnreadCounter
         */
        serverLastMessageId:attr({
            default:0,
        }),
        /**
         *Messageunreadcountercomingfromserver.
         *
         *Valueofthisfieldisunreliable,duetodynamicnatureof
         *messaging.Solikelyoutdated/unsyncwithserver.Shoulduse
         *localMessageUnreadCounterinstead,whichsmartlyguesstheactual
         *messageunreadcounteratalltime.
         *
         *@seelocalMessageUnreadCounter
         */
        serverMessageUnreadCounter:attr({
            default:0,
        }),
        /**
         *Determinesthe`mail.suggested_recipient_info`concerning`this`.
         */
        suggestedRecipientInfoList:one2many('mail.suggested_recipient_info',{
            inverse:'thread',
        }),
        threadViews:one2many('mail.thread_view',{
            inverse:'thread',
        }),
        /**
         *Statesthe`mail.activity`thatbelongsto`this`andthataredue
         *specificallytoday.
         */
        todayActivities:one2many('mail.activity',{
            compute:'_computeTodayActivities',
            dependencies:['activitiesState'],
        }),
        /**
         *Membersthatarecurrentlytypingsomethinginthecomposerofthis
         *thread,includingcurrentpartner.
         */
        typingMembers:many2many('mail.partner'),
        /**
         *Textthatrepresentsthestatusonthisthreadabouttypingmembers.
         */
        typingStatusText:attr({
            compute:'_computeTypingStatusText',
            default:'',
            dependencies:['orderedOtherTypingMembers'],
        }),
        /**
         *URLtoaccesstotheconversation.
         */
        url:attr({
            compute:'_computeUrl',
            default:'',
            dependencies:[
                'id',
                'model',
            ]
        }),
        uuid:attr(),
    };

    Thread.modelName='mail.thread';

    returnThread;
}

registerNewModel('mail.thread',factory);

});

flectra.define('mail/static/src/models/messaging_initializer/messaging_initializer.js',function(require){
'usestrict';

const{registerNewModel}=require('mail/static/src/model/model_core.js');
const{one2one}=require('mail/static/src/model/model_field.js');
const{executeGracefully}=require('mail/static/src/utils/utils.js');

functionfactory(dependencies){

    classMessagingInitializerextendsdependencies['mail.model']{

        //----------------------------------------------------------------------
        //Public
        //----------------------------------------------------------------------

        /**
         *Fetchmessagingdatainitiallytopopulatethestorespecificallyfor
         *thecurrentuser.Thisincludespinnedchannelsforinstance.
         */
        asyncstart(){
            this.messaging.update({
                history:[['create',{
                    id:'history',
                    isServerPinned:true,
                    model:'mail.box',
                    name:this.env._t("History"),
                }]],
                inbox:[['create',{
                    id:'inbox',
                    isServerPinned:true,
                    model:'mail.box',
                    name:this.env._t("Inbox"),
                }]],
                moderation:[['create',{
                    id:'moderation',
                    model:'mail.box',
                    name:this.env._t("Moderation"),
                }]],
                starred:[['create',{
                    id:'starred',
                    isServerPinned:true,
                    model:'mail.box',
                    name:this.env._t("Starred"),
                }]],
            });
            constdevice=this.messaging.device;
            device.start();
            constcontext=Object.assign({
                isMobile:device.isMobile,
            },this.env.session.user_context);
            constdiscuss=this.messaging.discuss;
            constdata=awaitthis.async(()=>this.env.services.rpc({
                route:'/mail/init_messaging',
                params:{context:context}
            },{shadow:true}));
            awaitthis.async(()=>this._init(data));
            if(discuss.isOpen){
                discuss.openInitThread();
            }
            if(this.env.autofetchPartnerImStatus){
                this.env.models['mail.partner'].startLoopFetchImStatus();
            }
        }

        //----------------------------------------------------------------------
        //Private
        //----------------------------------------------------------------------

        /**
         *@private
         *@param{Object}param0
         *@param{Object}param0.channel_slots
         *@param{Array}[param0.commands=[]]
         *@param{Object}param0.current_partner
         *@param{integer}param0.current_user_id
         *@param{Object}[param0.mail_failures={}]
         *@param{Object[]}[param0.mention_partner_suggestions=[]]
         *@param{Object[]}[param0.moderation_channel_ids=[]]
         *@param{integer}[param0.moderation_counter=0]
         *@param{integer}[param0.needaction_inbox_counter=0]
         *@param{Object}param0.partner_root
         *@param{Object}param0.public_partner
         *@param{Object[]}param0.public_partners
         *@param{Object[]}[param0.shortcodes=[]]
         *@param{integer}[param0.starred_counter=0]
         */
        async_init({
            channel_slots,
            commands=[],
            current_partner,
            current_user_id,
            mail_failures={},
            mention_partner_suggestions=[],
            menu_id,
            moderation_channel_ids=[],
            moderation_counter=0,
            needaction_inbox_counter=0,
            partner_root,
            public_partner,
            public_partners,
            shortcodes=[],
            starred_counter=0
        }){
            constdiscuss=this.messaging.discuss;
            //partnersfirstbecausetherestofthecodereliesonthem
            this._initPartners({
                current_partner,
                current_user_id,
                moderation_channel_ids,
                partner_root,
                public_partner,
                public_partners,
            });
            //mailboxesafterpartnersandbeforeotherinitializersthatmight
            //manipulatethreadsormessages
            this._initMailboxes({
                moderation_channel_ids,
                moderation_counter,
                needaction_inbox_counter,
                starred_counter,
            });
            //varioussuggestionsinnoparticularorder
            this._initCannedResponses(shortcodes);
            this._initCommands(commands);
            this._initMentionPartnerSuggestions(mention_partner_suggestions);
            //channelswhentherestofmessagingisready
            awaitthis.async(()=>this._initChannels(channel_slots));
            //failuresafterchannels
            this._initMailFailures(mail_failures);
            discuss.update({menu_id});
        }

        /**
         *@private
         *@param{Object[]}cannedResponsesData
         */
        _initCannedResponses(cannedResponsesData){
            this.messaging.update({
                cannedResponses:[['insert',cannedResponsesData]],
            });
        }

        /**
         *@private
         *@param{Object}[param0={}]
         *@param{Object[]}[param0.channel_channel=[]]
         *@param{Object[]}[param0.channel_direct_message=[]]
         *@param{Object[]}[param0.channel_private_group=[]]
         */
        async_initChannels({
            channel_channel=[],
            channel_direct_message=[],
            channel_private_group=[],
        }={}){
            constchannelsData=channel_channel.concat(channel_direct_message,channel_private_group);
            returnexecuteGracefully(channelsData.map(channelData=>()=>{
                constconvertedData=this.env.models['mail.thread'].convertData(channelData);
                if(!convertedData.members){
                    //channel_infodoesnotreturnallmembersofchannelfor
                    //performancereasons,butcodeisexpectingtoknowat
                    //leastifthecurrentpartnerismemberofit.
                    //(e.g.toknowwhentodisplay"invited"notification)
                    //Currentpartnercanalwaysbeassumedtobeamemberof
                    //channelsreceivedatinit.
                    convertedData.members=[['link',this.env.messaging.currentPartner]];
                }
                constchannel=this.env.models['mail.thread'].insert(
                    Object.assign({model:'mail.channel'},convertedData)
                );
                //fluxspecific:channelsreceivedatinithavetobe
                //consideredpinned.task-2284357
                if(!channel.isPinned){
                    channel.pin();
                }
            }));
        }

        /**
         *@private
         *@param{Object[]}commandsData
         */
        _initCommands(commandsData){
            this.messaging.update({
                commands:[['insert',commandsData]],
            });
        }

        /**
         *@private
         *@param{Object}param0
         *@param{Object[]}[param0.moderation_channel_ids=[]]
         *@param{integer}param0.moderation_counter
         *@param{integer}param0.needaction_inbox_counter
         *@param{integer}param0.starred_counter
         */
        _initMailboxes({
            moderation_channel_ids,
            moderation_counter,
            needaction_inbox_counter,
            starred_counter,
        }){
            this.env.messaging.inbox.update({counter:needaction_inbox_counter});
            this.env.messaging.starred.update({counter:starred_counter});
            if(moderation_channel_ids.length>0){
                this.messaging.moderation.update({
                    counter:moderation_counter,
                    isServerPinned:true,
                });
            }
        }

        /**
         *@private
         *@param{Object}mailFailuresData
         */
        async_initMailFailures(mailFailuresData){
            awaitexecuteGracefully(mailFailuresData.map(messageData=>()=>{
                constmessage=this.env.models['mail.message'].insert(
                    this.env.models['mail.message'].convertData(messageData)
                );
                //implicit:failuresaresentbytheserveratinitialization
                //onlyifthecurrentpartnerisauthorofthemessage
                if(!message.author&&this.messaging.currentPartner){
                    message.update({author:[['link',this.messaging.currentPartner]]});
                }
            }));
            this.messaging.notificationGroupManager.computeGroups();
            //manuallyforcerecomputeofcounter(aftercomputingthegroups)
            this.messaging.messagingMenu.update();
        }

        /**
         *@private
         *@param{Object[]}mentionPartnerSuggestionsData
         */
        async_initMentionPartnerSuggestions(mentionPartnerSuggestionsData){
            returnexecuteGracefully(mentionPartnerSuggestionsData.map(suggestions=>()=>{
                returnexecuteGracefully(suggestions.map(suggestion=>()=>{
                    this.env.models['mail.partner'].insert(this.env.models['mail.partner'].convertData(suggestion));
                }));
            }));
        }

        /**
         *@private
         *@param{Object}current_partner
         *@param{integer}current_user_id
         *@param{integer[]}moderation_channel_ids
         *@param{Object}partner_root
         *@param{Object}public_partner
         *@param{Object[]}[public_partners=[]]
         */
        _initPartners({
            current_partner,
            current_user_id:currentUserId,
            moderation_channel_ids=[],
            partner_root,
            public_partner,
            public_partners=[],
        }){
            constpublicPartner=this.env.models['mail.partner'].convertData(public_partner);
            this.messaging.update({
                currentPartner:[['insert',Object.assign(
                    this.env.models['mail.partner'].convertData(current_partner),
                    {
                        moderatedChannels:[
                            ['insert',moderation_channel_ids.map(id=>{
                                return{
                                    id,
                                    model:'mail.channel',
                                };
                            })],
                        ],
                        user:[['insert',{id:currentUserId}]],
                    }
                )]],
                currentUser:[['insert',{id:currentUserId}]],
                partnerRoot:[['insert',this.env.models['mail.partner'].convertData(partner_root)]],
                publicPartner:[['insert',publicPartner]],
                publicPartners:[
                    ['insert',publicPartner],
                    ['insert',public_partners.map(
                        publicPartner=>this.env.models['mail.partner'].convertData(publicPartner))
                    ],
                ],
            });
        }

    }

    MessagingInitializer.fields={
        messaging:one2one('mail.messaging',{
            inverse:'initializer',
        }),
    };

    MessagingInitializer.modelName='mail.messaging_initializer';

    returnMessagingInitializer;
}

registerNewModel('mail.messaging_initializer',factory);

});

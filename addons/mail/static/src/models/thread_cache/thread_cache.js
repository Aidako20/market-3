flectra.define('mail/static/src/models/thread_cache/thread_cache.js',function(require){
'usestrict';

const{registerNewModel}=require('mail/static/src/model/model_core.js');
const{attr,many2many,many2one,one2many}=require('mail/static/src/model/model_field.js');

functionfactory(dependencies){

    classThreadCacheextendsdependencies['mail.model']{

        //----------------------------------------------------------------------
        //Public
        //----------------------------------------------------------------------

        /**
         *@returns{mail.message[]|undefined}
         */
        asyncloadMoreMessages(){
            if(this.isAllHistoryLoaded||this.isLoading){
                return;
            }
            if(!this.isLoaded){
                this.update({isCacheRefreshRequested:true});
                return;
            }
            this.update({isLoadingMore:true});
            constmessageIds=this.fetchedMessages.map(message=>message.id);
            constlimit=30;
            constfetchedMessages=awaitthis.async(()=>this._loadMessages({
                extraDomain:[['id','<',Math.min(...messageIds)]],
                limit,
            }));
            this.update({isLoadingMore:false});
            if(fetchedMessages.length<limit){
                this.update({isAllHistoryLoaded:true});
            }
            for(constthreadViewofthis.threadViews){
                threadView.addComponentHint('more-messages-loaded',{fetchedMessages});
            }
            returnfetchedMessages;
        }

        /**
         *@returns{mail.message[]|undefined}
         */
        asyncloadNewMessages(){
            if(this.isLoading){
                return;
            }
            if(!this.isLoaded){
                this.update({isCacheRefreshRequested:true});
                return;
            }
            constmessageIds=this.fetchedMessages.map(message=>message.id);
            constfetchedMessages=this._loadMessages({
                extraDomain:[['id','>',Math.max(...messageIds,0)]],
                limit:false,
            });
            for(constthreadViewofthis.threadViews){
                threadView.addComponentHint('new-messages-loaded',{fetchedMessages});
            }
            returnfetchedMessages;
        }

        //----------------------------------------------------------------------
        //Private
        //----------------------------------------------------------------------

        /**
         *@override
         */
        static_createRecordLocalId(data){
            const{
                stringifiedDomain='[]',
                thread:[[commandInsert,thread]],
            }=data;
            return`${this.modelName}_[${thread.localId}]_<${stringifiedDomain}>`;
        }

        /**
         *@private
         */
        _computeCheckedMessages(){
            constmessagesWithoutCheckbox=this.checkedMessages.filter(
                message=>!message.hasCheckbox
            );
            return[['unlink',messagesWithoutCheckbox]];
        }

        /**
         *@private
         *@returns{mail.message[]}
         */
        _computeFetchedMessages(){
            if(!this.thread){
                return[['unlink-all']];
            }
            consttoUnlinkMessages=[];
            for(constmessageofthis.fetchedMessages){
                if(!this.thread.messages.includes(message)){
                    toUnlinkMessages.push(message);
                }
            }
            return[['unlink',toUnlinkMessages]];
        }

        /**
         *@private
         *@returns{mail.message|undefined}
         */
        _computeLastFetchedMessage(){
            const{
                length:l,
                [l-1]:lastFetchedMessage,
            }=this.orderedFetchedMessages;
            if(!lastFetchedMessage){
                return[['unlink']];
            }
            return[['link',lastFetchedMessage]];
        }

        /**
         *@private
         *@returns{mail.message|undefined}
         */
        _computeLastMessage(){
            const{
                length:l,
                [l-1]:lastMessage,
            }=this.orderedMessages;
            if(!lastMessage){
                return[['unlink']];
            }
            return[['link',lastMessage]];
        }

        /**
         *@private
         *@returns{mail.message[]}
         */
        _computeMessages(){
            if(!this.thread){
                return[['unlink-all']];
            }
            letmessages=this.fetchedMessages;
            if(this.stringifiedDomain!=='[]'){
                return[['replace',messages]];
            }
            //maincache:adjustwithnewermessages
            letnewerMessages;
            if(!this.lastFetchedMessage){
                newerMessages=this.thread.messages;
            }else{
                newerMessages=this.thread.messages.filter(message=>
                    message.id>this.lastFetchedMessage.id
                );
            }
            messages=messages.concat(newerMessages);
            return[['replace',messages]];
        }

        /**
         *
         *@private
         *@returns{mail.message[]}
         */
        _computeNonEmptyMessages(){
            return[['replace',this.messages.filter(message=>!message.isEmpty)]];
        }

        /**
         *@private
         *@returns{mail.message[]}
         */
        _computeOrderedFetchedMessages(){
            return[['replace',this.fetchedMessages.sort((m1,m2)=>m1.id<m2.id?-1:1)]];
        }

        /**
         *@private
         *@returns{mail.message[]}
         */
        _computeOrderedMessages(){
            return[['replace',this.messages.sort((m1,m2)=>m1.id<m2.id?-1:1)]];
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeHasToLoadMessages(){
            if(!this.thread){
                //happensduringdestroyorcomputeexecutedinwrongorder
                returnfalse;
            }
            constwasCacheRefreshRequested=this.isCacheRefreshRequested;
            //markhintasprocessed
            if(this.isCacheRefreshRequested){
                this.update({isCacheRefreshRequested:false});
            }
            if(this.thread.isTemporary){
                //temporarythreadsdon'texistontheserver
                returnfalse;
            }
            if(!wasCacheRefreshRequested&&this.threadViews.length===0){
                //don'tloadmessagethatwon'tbeused
                returnfalse;
            }
            if(this.isLoading){
                //avoidduplicateRPC
                returnfalse;
            }
            if(!wasCacheRefreshRequested&&this.isLoaded){
                //avoidduplicateRPC
                returnfalse;
            }
            constisMainCache=this.thread.mainCache===this;
            if(isMainCache&&this.isLoaded){
                //Ignorerequestonthemaincacheifitisalreadyloadedor
                //loading.Indeedthemaincacheisautomaticallysyncwith
                //serverupdatesalready,sothereisneveraneedtorefresh
                //itpastthefirsttime.
                returnfalse;
            }
            returntrue;
        }

        /**
         *@private
         *@returns{mail.message[]}
         */
        _computeUncheckedMessages(){
            return[['replace',this.messages.filter(
                message=>message.hasCheckbox&&!this.checkedMessages.includes(message)
            )]];
        }

        /**
         *@private
         *@param{Array}domain
         *@returns{Array}
         */
        _extendMessageDomain(domain){
            constthread=this.thread;
            if(thread.model==='mail.channel'){
                returndomain.concat([['channel_ids','in',[thread.id]]]);
            }elseif(thread===this.env.messaging.inbox){
                returndomain.concat([['needaction','=',true]]);
            }elseif(thread===this.env.messaging.starred){
                returndomain.concat([
                    ['starred_partner_ids','in',[this.env.messaging.currentPartner.id]],
                ]);
            }elseif(thread===this.env.messaging.history){
                returndomain.concat([['needaction','=',false]]);
            }elseif(thread===this.env.messaging.moderation){
                returndomain.concat([['moderation_status','=','pending_moderation']]);
            }else{
                //Avoidtoloaduser_notificationasthesemessagesarenot
                //meanttobeshownonchatters.
                returndomain.concat([
                    ['message_type','!=','user_notification'],
                    ['model','=',thread.model],
                    ['res_id','=',thread.id],
                ]);
            }
        }

        /**
         *@private
         *@param{Object}[param0={}]
         *@param{Array[]}[param0.extraDomain]
         *@param{integer}[param0.limit=30]
         *@returns{mail.message[]}
         */
        async_loadMessages({extraDomain,limit=30}={}){
            this.update({isLoading:true});
            constsearchDomain=JSON.parse(this.stringifiedDomain);
            letdomain=searchDomain.length?searchDomain:[];
            domain=this._extendMessageDomain(domain);
            if(extraDomain){
                domain=extraDomain.concat(domain);
            }
            constcontext=this.env.session.user_context;
            constmoderated_channel_ids=this.thread.moderation
                ?[this.thread.id]
                :undefined;
            constmessages=awaitthis.async(()=>
                this.env.models['mail.message'].performRpcMessageFetch(
                    domain,
                    limit,
                    moderated_channel_ids,
                    context,
                )
            );
            this.update({
                fetchedMessages:[['link',messages]],
                isLoaded:true,
                isLoading:false,
            });
            if(!extraDomain&&messages.length<limit){
                this.update({isAllHistoryLoaded:true});
            }
            this.env.messagingBus.trigger('o-thread-cache-loaded-messages',{
                fetchedMessages:messages,
                threadCache:this,
            });
            returnmessages;
        }

        /**
         *Calls"markallasread"whenthisthreadbecomesdisplayedina
         *view(whichisnotifiedby`isMarkAllAsReadRequested`being`true`),
         *butdelaysthecalluntilsomeotherconditionsaremet,suchasthe
         *messagesbeingloaded.
         *Thereasontowaituntilmessagesareloadedistoavoidarace
         *conditionbecause"markallasread"willchangethestateofthe
         *messagesinparalleltofetchreadingthem.
         *
         *@private
         */
        _onChangeMarkAllAsRead(){
            if(
                !this.isMarkAllAsReadRequested||
                !this.thread||
                !this.thread.mainCache||
                !this.isLoaded||
                this.isLoading
            ){
                //waitforchangeofstatebeforedecidingwhattodo
                return;
            }
            this.update({isMarkAllAsReadRequested:false});
            if(
                this.thread.isTemporary||
                this.thread.model==='mail.box'||
                this.thread.mainCache!==this||
                this.threadViews.length===0
            ){
                //ignoretherequest
                return;
            }
            this.env.models['mail.message'].markAllAsRead([
                ['model','=',this.thread.model],
                ['res_id','=',this.thread.id],
            ]);
        }

        /**
         *Loadsthisthreadcache,byfetchingthemostrecentmessagesinthis
         *conversation.
         *
         *@private
         */
        _onHasToLoadMessagesChanged(){
            if(!this.hasToLoadMessages){
                return;
            }
            this._loadMessages().then(fetchedMessages=>{
                for(constthreadViewofthis.threadViews){
                    threadView.addComponentHint('messages-loaded',{fetchedMessages});
                }
            });
        }

        /**
         *Handleschangeofmessagesonthisthreadcache.Thisisusefulto
         *refreshnon-maincachesthatarecurrentlydisplayedwhenthemain
         *cachereceivesupdates.Thisisnecessarybecauseonlythemaincache
         *isawareofchangesinrealtime.
         */
        _onMessagesChanged(){
            if(!this.thread){
                return;
            }
            if(this.thread.mainCache!==this){
                return;
            }
            for(constthreadViewofthis.thread.threadViews){
                if(threadView.threadCache){
                    threadView.threadCache.update({isCacheRefreshRequested:true});
                }
            }
        }

    }

    ThreadCache.fields={
        checkedMessages:many2many('mail.message',{
            compute:'_computeCheckedMessages',
            dependencies:[
                'checkedMessages',
                'messagesCheckboxes',
            ],
            inverse:'checkedThreadCaches',
        }),
        /**
         *Listofmessagesthathavebeenfetchedbythiscache.
         *
         *ThisDOESNOTnecessarilyincludesallmessageslinkedtothisthread
         *cache(@seemessagesfieldforthat):itjustcontainslist
         *ofsuccessivemessagesthathavebeenexplicitlyfetchedbythis
         *cache.Forallnon-maincaches,thiscorrespondstoallmessages.
         *Forthemaincache,however,messagesreceivedfromlongpolling
         *shouldbedisplayedonmaincachebuttheyhavenotbeenexplicitly
         *fetchedbycache,sotheyARENOTinthislist(atleast,notuntila
         *fetchonthisthreadcachecontainsthismessage).
         *
         *Thedistinctionbetweenmessagesandfetchedmessagesisimportant
         *tomanage"holes"inmessagelist,whilestillallowingtodisplay
         *newmessagesonmaincacheofthreadinreal-time.
         */
        fetchedMessages:many2many('mail.message',{
            //adjustwithmessagesunlinkedfromthread
            compute:'_computeFetchedMessages',
            dependencies:['threadMessages'],
        }),
        /**
         *Determineswhether`this`shouldloadinitialmessages.Thisfieldis
         *computedandshouldbeconsideredread-only.
         *@see`isCacheRefreshRequested`torequestmanualrefreshofmessages.
         */
        hasToLoadMessages:attr({
            compute:'_computeHasToLoadMessages',
            dependencies:[
                'isCacheRefreshRequested',
                'isLoaded',
                'isLoading',
                'thread',
                'threadIsTemporary',
                'threadMainCache',
                'threadViews',
            ],
        }),
        isAllHistoryLoaded:attr({
            default:false,
        }),
        isLoaded:attr({
            default:false,
        }),
        isLoading:attr({
            default:false,
        }),
        isLoadingMore:attr({
            default:false,
        }),
        /**
         *Determineswhether`this`shouldconsiderrefreshingitsmessages.
         *Thisfieldisahintthatmayormaynotleadtoanactualrefresh.
         *@see`hasToLoadMessages`
         */
        isCacheRefreshRequested:attr({
            default:false,
        }),
        /**
         *Determineswhetherthiscacheshouldconsidercalling"markallas
         *read"onthisthread.
         *
         *Thisfieldisahintthatmayormaynotleadtoanactualcall.
         *@see`_onChangeMarkAllAsRead`
         */
        isMarkAllAsReadRequested:attr({
            default:false,
        }),
        /**
         *Lastmessagethathasbeenfetchedbythisthreadcache.
         *
         *ThisDOESNOTnecessarilymeanthelastmessagelinkedtothisthread
         *cache(@seelastMessagefieldforthat).@seefetchedMessagesfield
         *foradeeperexplanationabout"fetched"messages.
         */
        lastFetchedMessage:many2one('mail.message',{
            compute:'_computeLastFetchedMessage',
            dependencies:['orderedFetchedMessages'],
        }),
        lastMessage:many2one('mail.message',{
            compute:'_computeLastMessage',
            dependencies:['orderedMessages'],
        }),
        messagesCheckboxes:attr({
            related:'messages.hasCheckbox',
        }),
        /**
         *Listofmessageslinkedtothiscache.
         */
        messages:many2many('mail.message',{
            compute:'_computeMessages',
            dependencies:[
                'fetchedMessages',
                'threadMessages',
            ],
        }),
        /**
         *IsEmptytraitofallmessages.
         *Servesascomputedependency.
         */
        messagesAreEmpty:attr({
            related:'messages.isEmpty'
        }),
        /**
         *Listofnonemptymessageslinkedtothiscache.
         */
        nonEmptyMessages:many2many('mail.message',{
            compute:'_computeNonEmptyMessages',
            dependencies:[
                'messages',
                'messagesAreEmpty',
            ],
        }),
        /**
         *Notarealfield,usedtotriggeritscomputemethodwhenoneofthe
         *dependencieschanges.
         */
        onChangeMarkAllAsRead:attr({
            compute:'_onChangeMarkAllAsRead',
            dependencies:[
                'isLoaded',
                'isLoading',
                'isMarkAllAsReadRequested',
                'thread',
                'threadIsTemporary',
                'threadMainCache',
                'threadModel',
                'threadViews',
            ],
        }),
        /**
         *Loadsinitialmessagesfrom`this`.
         *Thisisnota"real"field,itscomputefunctionisusedtotrigger
         *theloadofmessagesattherighttime.
         */
        onHasToLoadMessagesChanged:attr({
            compute:'_onHasToLoadMessagesChanged',
            dependencies:[
                'hasToLoadMessages',
            ],
        }),
        /**
         *Notarealfield,usedtotrigger`_onMessagesChanged`whenoneof
         *thedependencieschanges.
         */
        onMessagesChanged:attr({
            compute:'_onMessagesChanged',
            dependencies:[
                'messages',
                'thread',
                'threadMainCache',
            ],
        }),
        /**
         *Orderedlistofmessagesthathavebeenfetchedbythiscache.
         *
         *ThisDOESNOTnecessarilyincludesallmessageslinkedtothisthread
         *cache(@seeorderedMessagesfieldforthat).@seefetchedMessages
         *fieldfordeeperexplanationabout"fetched"messages.
         */
        orderedFetchedMessages:many2many('mail.message',{
            compute:'_computeOrderedFetchedMessages',
            dependencies:['fetchedMessages'],
        }),
        /**
         *Orderedlistofmessageslinkedtothiscache.
         */
        orderedMessages:many2many('mail.message',{
            compute:'_computeOrderedMessages',
            dependencies:['messages'],
        }),
        stringifiedDomain:attr({
            default:'[]',
        }),
        thread:many2one('mail.thread',{
            inverse:'caches',
        }),
        /**
         *Servesascomputedependency.
         */
        threadIsTemporary:attr({
            related:'thread.isTemporary',
        }),
        /**
         *Servesascomputedependency.
         */
        threadMainCache:many2one('mail.thread_cache',{
            related:'thread.mainCache',
        }),
        threadMessages:many2many('mail.message',{
            related:'thread.messages',
        }),
        /**
         *Servesascomputedependency.
         */
        threadModel:attr({
            related:'thread.model',
        }),
        /**
         *Statesthe'mail.thread_view'thatarecurrentlydisplaying`this`.
         */
        threadViews:one2many('mail.thread_view',{
            inverse:'threadCache',
        }),
        uncheckedMessages:many2many('mail.message',{
            compute:'_computeUncheckedMessages',
            dependencies:[
                'checkedMessages',
                'messagesCheckboxes',
                'messages',
            ],
        }),
    };

    ThreadCache.modelName='mail.thread_cache';

    returnThreadCache;
}

registerNewModel('mail.thread_cache',factory);

});

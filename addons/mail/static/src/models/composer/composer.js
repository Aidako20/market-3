flectra.define('mail/static/src/models/composer/composer.js',function(require){
'usestrict';

constemojis=require('mail.emojis');
const{registerNewModel}=require('mail/static/src/model/model_core.js');
const{attr,many2many,many2one,one2one}=require('mail/static/src/model/model_field.js');
const{clear}=require('mail/static/src/model/model_field_command.js');
constmailUtils=require('mail.utils');

const{
    addLink,
    escapeAndCompactTextContent,
    parseAndTransform,
}=require('mail.utils');

functionfactory(dependencies){

    classComposerextendsdependencies['mail.model']{

        /**
         *@override
         */
        _willCreate(){
            constres=super._willCreate(...arguments);
            /**
             *DetermineswhetherthereisamentionRPCcurrentlyinprogress.
             *Usefultoqueueanewcallifthereisalreadyonepending.
             */
            this._hasMentionRpcInProgress=false;
            /**
             *Determinesthenextfunctiontoexecuteafterthecurrentmention
             *RPCisdone,ifany.
             */
            this._nextMentionRpcFunction=undefined;
            returnres;
        }

        /**
         *@override
         */
        _willDelete(){
            //Clearsthementionqueueondeletingtherecordtoprevent
            //unnecessaryRPC.
            this._nextMentionRpcFunction=undefined;
            returnsuper._willDelete(...arguments);
        }

        //----------------------------------------------------------------------
        //Public
        //----------------------------------------------------------------------

        /**
         *Closesthesuggestionlist.
         */
        closeSuggestions(){
            this.update({suggestionDelimiterPosition:clear()});
        }

        /**
         *@deprecatedwhatthismethodusedtodoisnowautomaticallycomputed
         * basedoncomposerstate
         */
        asyncdetectSuggestionDelimiter(){}

        /**
         *Hidesthecomposer,whichonlymakessenseifthecomposeris
         *currentlyusedasaDiscussInboxreplycomposer.
         */
        discard(){
            if(this.discussAsReplying){
                this.discussAsReplying.clearReplyingToMessage();
            }
        }

        /**
         *Focusthiscomposerandremovefocusfromallothers.
         *Focusisaglobalconcern,itmakesnosensetohavemultiplecomposersfocusedatthe
         *sametime.
         */
        focus(){
            constallComposers=this.env.models['mail.composer'].all();
            for(constotherComposerofallComposers){
                if(otherComposer!==this&&otherComposer.hasFocus){
                    otherComposer.update({hasFocus:false});
                }
            }
            this.update({hasFocus:true});
        }

        /**
         *Insertstextcontentintextinputbasedonselection.
         *
         *@param{string}content
         */
        insertIntoTextInput(content){
            constpartA=this.textInputContent.slice(0,this.textInputCursorStart);
            constpartB=this.textInputContent.slice(
                this.textInputCursorEnd,
                this.textInputContent.length
            );
            letsuggestionDelimiterPosition=this.suggestionDelimiterPosition;
            if(
                suggestionDelimiterPosition!==undefined&&
                suggestionDelimiterPosition>=this.textInputCursorStart
            ){
                suggestionDelimiterPosition=suggestionDelimiterPosition+content.length;
            }
            this.update({
                isLastStateChangeProgrammatic:true,
                suggestionDelimiterPosition,
                textInputContent:partA+content+partB,
                textInputCursorEnd:this.textInputCursorStart+content.length,
                textInputCursorStart:this.textInputCursorStart+content.length,
            });
        }

        insertSuggestion(){
            constcursorPosition=this.textInputCursorStart;
            lettextLeft=this.textInputContent.substring(
                0,
                this.suggestionDelimiterPosition+1
            );
            lettextRight=this.textInputContent.substring(
                cursorPosition,
                this.textInputContent.length
            );
            if(this.suggestionDelimiter===':'){
                textLeft=this.textInputContent.substring(
                    0,
                    this.suggestionDelimiterPosition
                );
                textRight=this.textInputContent.substring(
                    cursorPosition,
                    this.textInputContent.length
                );
            }
            constrecordReplacement=this.activeSuggestedRecord.getMentionText();
            constupdateData={
                isLastStateChangeProgrammatic:true,
                textInputContent:textLeft+recordReplacement+''+textRight,
                textInputCursorEnd:textLeft.length+recordReplacement.length+1,
                textInputCursorStart:textLeft.length+recordReplacement.length+1,
            };
            //Specificcasesforchannelandpartnermentions:themessagewith
            //thementionwillappearinthetargetchannel,orbenotifiedto
            //thetargetpartner.
            switch(this.activeSuggestedRecord.constructor.modelName){
                case'mail.thread':
                    Object.assign(updateData,{mentionedChannels:[['link',this.activeSuggestedRecord]]});
                    break;
                case'mail.partner':
                    Object.assign(updateData,{mentionedPartners:[['link',this.activeSuggestedRecord]]});
                    break;
            }
            this.update(updateData);
        }

        /**
         *@private
         *@returns{mail.partner[]}
         */
        _computeRecipients(){
            constrecipients=[...this.mentionedPartners];
            if(this.thread&&!this.isLog){
                for(constrecipientofthis.thread.suggestedRecipientInfoList){
                    if(recipient.partner&&recipient.isSelected){
                        recipients.push(recipient.partner);
                    }
                }
            }
            return[['replace',recipients]];
        }

        /**
         *Openthefullcomposermodal.
         */
        asyncopenFullComposer(){
            constattachmentIds=this.attachments.map(attachment=>attachment.id);

            constcontext={
                default_attachment_ids:attachmentIds,
                default_body:mailUtils.escapeAndCompactTextContent(this.textInputContent),
                default_is_log:this.isLog,
                default_model:this.thread.model,
                default_partner_ids:this.recipients.map(partner=>partner.id),
                default_res_id:this.thread.id,
                mail_post_autofollow:true,
            };

            constaction={
                type:'ir.actions.act_window',
                res_model:'mail.compose.message',
                view_mode:'form',
                views:[[false,'form']],
                target:'new',
                context:context,
            };
            constoptions={
                on_close:()=>{
                    if(!this.exists()){
                        return;
                    }
                    this._reset();
                    this.thread.loadNewMessages();
                },
            };
            awaitthis.env.bus.trigger('do-action',{action,options});
        }

        /**
         *Postamessageinprovidedcomposer'sthreadbasedoncurrentcomposerfieldsvalues.
         */
        asyncpostMessage(){
            constthread=this.thread;
            this.thread.unregisterCurrentPartnerIsTyping({immediateNotify:true});
            constescapedAndCompactContent=escapeAndCompactTextContent(this.textInputContent);
            letbody=escapedAndCompactContent.replace(/&nbsp;/g,'').trim();
            //Thismessagewillbereceivedfromthemailcomposerashtmlcontent
            //subtypebuttheurlswillnotbelinkified.Ifthemailcomposer
            //takestheresponsibilitytolinkifytheurlsweendupwithdouble
            //linkificationabiteverywhere.Ideallywewanttokeepthecontent
            //astextinternallyandonlymakehtmlenrichmentatdisplaytimebut
            //thecurrentdesignmakesthisquitehardtodo.
            body=this._generateMentionsLinks(body);
            body=parseAndTransform(body,addLink);
            body=this._generateEmojisOnHtml(body);
            letpostData={
                attachment_ids:this.attachments.map(attachment=>attachment.id),
                body,
                channel_ids:this.mentionedChannels.map(channel=>channel.id),
                message_type:'comment',
                partner_ids:this.recipients.map(partner=>partner.id),
            };
            if(this.subjectContent){
                postData.subject=this.subjectContent;
            }
            try{
                letmessageId;
                this.update({isPostingMessage:true});
                if(thread.model==='mail.channel'){
                    constcommand=this._getCommandFromText(body);
                    Object.assign(postData,{
                        subtype_xmlid:'mail.mt_comment',
                    });
                    if(command){
                        messageId=awaitthis.async(()=>this.env.models['mail.thread'].performRpcExecuteCommand({
                            channelId:thread.id,
                            command:command.name,
                            postData,
                        }));
                    }else{
                        messageId=awaitthis.async(()=>
                            this.env.models['mail.thread'].performRpcMessagePost({
                                postData,
                                threadId:thread.id,
                                threadModel:thread.model,
                            })
                        );
                    }
                }else{
                    Object.assign(postData,{
                        subtype_xmlid:this.isLog?'mail.mt_note':'mail.mt_comment',
                    });
                    if(!this.isLog){
                        postData.context={
                            mail_post_autofollow:true,
                        };
                    }
                    messageId=awaitthis.async(()=>
                        this.env.models['mail.thread'].performRpcMessagePost({
                            postData,
                            threadId:thread.id,
                            threadModel:thread.model,
                        })
                    );
                    const[messageData]=awaitthis.async(()=>this.env.services.rpc({
                        model:'mail.message',
                        method:'message_format',
                        args:[[messageId]],
                    },{shadow:true}));
                    this.env.models['mail.message'].insert(Object.assign(
                        {},
                        this.env.models['mail.message'].convertData(messageData),
                        {
                            originThread:[['insert',{
                                id:thread.id,
                                model:thread.model,
                            }]],
                        })
                    );
                    thread.loadNewMessages();
                }
                for(constthreadViewofthis.thread.threadViews){
                    //Resetautoscrolltobeabletoseethenewlypostedmessage.
                    threadView.update({hasAutoScrollOnMessageReceived:true});
                }
                thread.refreshFollowers();
                thread.fetchAndUpdateSuggestedRecipients();
                this._reset();
            }finally{
                this.update({isPostingMessage:false});
            }
        }

        /**
         *Calledwhencurrentpartnerisinsertingsomeinputincomposer.
         *Usefultonotifycurrentpartneriscurrentlytypingsomethinginthe
         *composerofthisthreadtoallothermembers.
         */
        handleCurrentPartnerIsTyping(){
            if(!this.thread){
                return;
            }
            if(
                this.suggestionModelName==='mail.channel_command'||
                this._getCommandFromText(this.textInputContent)
            ){
                return;
            }
            if(this.thread.typingMembers.includes(this.env.messaging.currentPartner)){
                this.thread.refreshCurrentPartnerIsTyping();
            }else{
                this.thread.registerCurrentPartnerIsTyping();
            }
        }

        /**
         *Setsthefirstsuggestionasactive.Mainandextrarecordsare
         *consideredtogether.
         */
        setFirstSuggestionActive(){
            constsuggestedRecords=this.mainSuggestedRecords.concat(this.extraSuggestedRecords);
            constfirstRecord=suggestedRecords[0];
            this.update({activeSuggestedRecord:[['link',firstRecord]]});
        }

        /**
         *Setsthelastsuggestionasactive.Mainandextrarecordsare
         *consideredtogether.
         */
        setLastSuggestionActive(){
            constsuggestedRecords=this.mainSuggestedRecords.concat(this.extraSuggestedRecords);
            const{length,[length-1]:lastRecord}=suggestedRecords;
            this.update({activeSuggestedRecord:[['link',lastRecord]]});
        }

        /**
         *Setsthenextsuggestionasactive.Mainandextrarecordsare
         *consideredtogether.
         */
        setNextSuggestionActive(){
            constsuggestedRecords=this.mainSuggestedRecords.concat(this.extraSuggestedRecords);
            constactiveElementIndex=suggestedRecords.findIndex(
                suggestion=>suggestion===this.activeSuggestedRecord
            );
            if(activeElementIndex===suggestedRecords.length-1){
                //loopwhenreachingtheendofthelist
                this.setFirstSuggestionActive();
                return;
            }
            constnextRecord=suggestedRecords[activeElementIndex+1];
            this.update({activeSuggestedRecord:[['link',nextRecord]]});
        }

        /**
         *Setstheprevioussuggestionasactive.Mainandextrarecordsare
         *consideredtogether.
         */
        setPreviousSuggestionActive(){
            constsuggestedRecords=this.mainSuggestedRecords.concat(this.extraSuggestedRecords);
            constactiveElementIndex=suggestedRecords.findIndex(
                suggestion=>suggestion===this.activeSuggestedRecord
            );
            if(activeElementIndex===0){
                //loopwhenreachingthestartofthelist
                this.setLastSuggestionActive();
                return;
            }
            constpreviousRecord=suggestedRecords[activeElementIndex-1];
            this.update({activeSuggestedRecord:[['link',previousRecord]]});
        }

        //----------------------------------------------------------------------
        //Private
        //----------------------------------------------------------------------

        /**
         *@deprecated
         *@private
         *@returns{mail.canned_response}
         */
        _computeActiveSuggestedCannedResponse(){
            if(this.suggestionDelimiter===':'&&this.activeSuggestedRecord){
                return[['link',this.activeSuggestedRecord]];
            }
            return[['unlink']];
        }

        /**
         *@deprecated
         *@private
         *@returns{mail.thread}
         */
        _computeActiveSuggestedChannel(){
            if(this.suggestionDelimiter==='#'&&this.activeSuggestedRecord){
                return[['link',this.activeSuggestedRecord]];
            }
            return[['unlink']];
        }

        /**
         *@deprecated
         *@private
         *@returns{mail.channel_command}
         */
        _computeActiveSuggestedChannelCommand(){
            if(this.suggestionDelimiter==='/'&&this.activeSuggestedRecord){
                return[['link',this.activeSuggestedRecord]];
            }
            return[['unlink']];
        }

        /**
         *@deprecated
         *@private
         *@returns{mail.partner}
         */
        _computeActiveSuggestedPartner(){
            if(this.suggestionDelimiter==='@'&&this.activeSuggestedRecord){
                return[['link',this.activeSuggestedRecord]];
            }
            return[['unlink']];
        }

        /**
         *Clearstheactivesuggestedrecordonclosingmentionsoradaptitif
         *theactivecurrentrecordisnolongerpartofthesuggestions.
         *
         *@private
         *@returns{mail.model}
         */
        _computeActiveSuggestedRecord(){
            if(
                this.mainSuggestedRecords.length===0&&
                this.extraSuggestedRecords.length===0
            ){
                return[['unlink']];
            }
            if(
                this.mainSuggestedRecords.includes(this.activeSuggestedRecord)||
                this.extraSuggestedRecords.includes(this.activeSuggestedRecord)
            ){
                return;
            }
            constsuggestedRecords=this.mainSuggestedRecords.concat(this.extraSuggestedRecords);
            constfirstRecord=suggestedRecords[0];
            return[['link',firstRecord]];
        }

        /**
         *@deprecated
         *@private
         *@returns{string}
         */
        _computeActiveSuggestedRecordName(){
            switch(this.suggestionDelimiter){
                case'@':
                    return"activeSuggestedPartner";
                case':':
                    return"activeSuggestedCannedResponse";
                case'/':
                    return"activeSuggestedChannelCommand";
                case'#':
                    return"activeSuggestedChannel";
                default:
                    returnclear();
            }
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeCanPostMessage(){
            if(!this.textInputContent&&this.attachments.length===0){
                returnfalse;
            }
            return!this.hasUploadingAttachment&&!this.isPostingMessage;
        }

        /**
         *@deprecated
         *@private
         *@returns{mail.partner[]}
         */
        _computeExtraSuggestedPartners(){
            if(this.suggestionDelimiter==='@'){
                return[['replace',this.extraSuggestedRecords]];
            }
            return[['unlink-all']];
        }

        /**
         *Clearstheextrasuggestedrecordonclosingmentions,andensures
         *theextralistdoesnotcontainanyelementalreadypresentinthe
         *mainlist,whichisarequirementforthenavigationprocess.
         *
         *@private
         *@returns{mail.model[]}
         */
        _computeExtraSuggestedRecords(){
            if(this.suggestionDelimiterPosition===undefined){
                return[['unlink-all']];
            }
            return[['unlink',this.mainSuggestedRecords]];
        }

        /**
         *@deprecated
         *@private
         *@returns{mail.model[]}
         */
        _computeExtraSuggestedRecordsList(){
            returnthis.extraSuggestedRecords;
        }

        /**
         *@deprecated
         *@private
         *@returns{string}
         */
        _computeExtraSuggestedRecordsListName(){
            if(this.suggestionDelimiter==='@'){
                return"extraSuggestedPartners";
            }
            returnclear();
        }

        /**
         *@private
         *@return{boolean}
         */
        _computeHasDropZone(){
            returntrue;
        }

        /**
         *@private
         *@return{boolean}
         */
        _computeHasSuggestions(){
            returnthis.mainSuggestedRecords.length>0||this.extraSuggestedRecords.length>0;
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeHasUploadingAttachment(){
            returnthis.attachments.some(attachment=>attachment.isTemporary);
        }

        /**
         *@deprecated
         *@private
         *@returns{mail.model[]}
         */
        _computeMainSuggestedPartners(){
            if(this.suggestionDelimiter==='@'){
                return[['replace',this.mainSuggestedRecords]];
            }
            return[['unlink-all']];
        }

        /**
         *Clearsthemainsuggestedrecordonclosingmentions.
         *
         *@private
         *@returns{mail.model[]}
         */
        _computeMainSuggestedRecords(){
            if(this.suggestionDelimiterPosition===undefined){
                return[['unlink-all']];
            }
        }

        /**
         *@deprecated
         *@private
         *@returns{mail.model[]}
         */
        _computeMainSuggestedRecordsList(){
            returnthis.mainSuggestedRecords;
        }

        /**
         *@deprecated
         *@private
         *@returns{string}
         */
        _computeMainSuggestedRecordsListName(){
            switch(this.suggestionDelimiter){
                case'@':
                    return"mainSuggestedPartners";
                case':':
                    return"suggestedCannedResponses";
                case'/':
                    return"suggestedChannelCommands";
                case'#':
                    return"suggestedChannels";
                default:
                    returnclear();
            }
        }

        /**
         *Detectsifmentionedpartnersarestillinthecomposertextinputcontent
         *andremovesthemifnot.
         *
         *@private
         *@returns{mail.partner[]}
         */
        _computeMentionedPartners(){
            constunmentionedPartners=[];
            //ensurethesamementionisnotusedmultipletimesifmultiple
            //partnershavethesamename
            constnamesIndex={};
            for(constpartnerofthis.mentionedPartners){
                constfromIndex=namesIndex[partner.name]!==undefined
                    ?namesIndex[partner.name]+1:
                    0;
                constindex=this.textInputContent.indexOf(`@${partner.name}`,fromIndex);
                if(index!==-1){
                    namesIndex[partner.name]=index;
                }else{
                    unmentionedPartners.push(partner);
                }
            }
            return[['unlink',unmentionedPartners]];
        }

        /**
         *Detectsifmentionedchannelsarestillinthecomposertextinputcontent
         *andremovesthemifnot.
         *
         *@private
         *@returns{mail.partner[]}
         */
        _computeMentionedChannels(){
            constunmentionedChannels=[];
            //ensurethesamementionisnotusedmultipletimesifmultiple
            //channelshavethesamename
            constnamesIndex={};
            for(constchannelofthis.mentionedChannels){
                constfromIndex=namesIndex[channel.name]!==undefined
                    ?namesIndex[channel.name]+1:
                    0;
                constindex=this.textInputContent.indexOf(`#${channel.name}`,fromIndex);
                if(index!==-1){
                    namesIndex[channel.name]=index;
                }else{
                    unmentionedChannels.push(channel);
                }
            }
            return[['unlink',unmentionedChannels]];
        }

        /**
         *@deprecated
         *@private
         *@returns{mail.canned_response[]}
         */
        _computeSuggestedCannedResponses(){
            if(this.suggestionDelimiter===':'){
                return[['replace',this.mainSuggestedRecords]];
            }
            return[['unlink-all']];
        }

        /**
         *@deprecated
         *@private
         *@returns{mail.thread[]}
         */
        _computeSuggestedChannels(){
            if(this.suggestionDelimiter==='#'){
                return[['replace',this.mainSuggestedRecords]];
            }
            return[['unlink-all']];
        }

        /**
         *@private
         *@returns{string}
         */
        _computeSuggestionDelimiter(){
            if(
                this.suggestionDelimiterPosition===undefined||
                this.suggestionDelimiterPosition>=this.textInputContent.length
            ){
                returnclear();
            }
            returnthis.textInputContent[this.suggestionDelimiterPosition];
        }

        /**
         *@private
         *@returns{integer}
         */
        _computeSuggestionDelimiterPosition(){
            if(this.textInputCursorStart!==this.textInputCursorEnd){
                //avoidinterferingwithmulti-charselection
                returnclear();
            }
            constcandidatePositions=[];
            //keepthecurrentdelimiterifitisstillvalid
            if(
                this.suggestionDelimiterPosition!==undefined&&
                this.suggestionDelimiterPosition<this.textInputCursorStart
            ){
                candidatePositions.push(this.suggestionDelimiterPosition);
            }
            //considerthecharbeforethecurrentcursorpositionifthe
            //currentdelimiterisnolongervalid(orifthereisnone)
            if(this.textInputCursorStart>0){
                candidatePositions.push(this.textInputCursorStart-1);
            }
            constsuggestionDelimiters=['@',':','#','/'];
            for(constcandidatePositionofcandidatePositions){
                if(
                    candidatePosition<0||
                    candidatePosition>=this.textInputContent.length
                ){
                    continue;
                }
                constcandidateChar=this.textInputContent[candidatePosition];
                if(candidateChar==='/'&&candidatePosition!==0){
                    continue;
                }
                if(!suggestionDelimiters.includes(candidateChar)){
                    continue;
                }
                constcharBeforeCandidate=this.textInputContent[candidatePosition-1];
                if(charBeforeCandidate&&!/\s/.test(charBeforeCandidate)){
                    continue;
                }
                returncandidatePosition;
            }
            returnclear();
        }

        /**
         *@deprecated
         *@private
         *@returns{mail.channel_command[]}
         */
        _computeSuggestedChannelCommands(){
            if(this.suggestionDelimiter==='/'){
                return[['replace',this.mainSuggestedRecords]];
            }
            return[['unlink-all']];
        }

        /**
         *@private
         *@returns{string}
         */
        _computeSuggestionModelName(){
            switch(this.suggestionDelimiter){
                case'@':
                    return'mail.partner';
                case':':
                    return'mail.canned_response';
                case'/':
                    return'mail.channel_command';
                case'#':
                    return'mail.thread';
                default:
                    returnclear();
            }
        }

        /**
         *@private
         *@returns{string}
         */
        _computeSuggestionSearchTerm(){
            if(
                this.suggestionDelimiterPosition===undefined||
                this.suggestionDelimiterPosition>=this.textInputCursorStart
            ){
                returnclear();
            }
            returnthis.textInputContent.substring(this.suggestionDelimiterPosition+1,this.textInputCursorStart);
        }

        /**
         *Executesthegivenasyncfunction,onlywhenthelastfunction
         *executedbythismethodterminates.Ifthereisalreadyapending
         *functionitisreplacedbythenewone.Thisensurestheresultof
         *thesefunctioncomeinthesameorderasthecallorder,anditalso
         *allowstoskipobsoleteintermediatecalls.
         *
         *@private
         *@param{function}func
         */
        async_executeOrQueueFunction(func){
            if(this._hasMentionRpcInProgress){
                this._nextMentionRpcFunction=func;
                return;
            }
            this._hasMentionRpcInProgress=true;
            this._nextMentionRpcFunction=undefined;
            try{
                awaitthis.async(func);
            }finally{
                this._hasMentionRpcInProgress=false;
                if(this._nextMentionRpcFunction){
                    this._executeOrQueueFunction(this._nextMentionRpcFunction);
                }
            }
        }

        /**
         *@private
         *@param{string}htmlString
         *@returns{string}
         */
        _generateEmojisOnHtml(htmlString){
            for(constemojiofemojis){
                for(constsourceofemoji.sources){
                    constescapedSource=String(source).replace(
                        /([.*+?=^!:${}()|[\]/\\])/g,
                        '\\$1');
                    constregexp=newRegExp(
                        '(\\s|^)('+escapedSource+')(?=\\s|$)',
                        'g');
                    htmlString=htmlString.replace(regexp,'$1'+emoji.unicode);
                }
            }
            returnhtmlString;
        }

        /**
         *
         *Generatesthehtmllinkrelatedtothementionedpartner
         *
         *@private
         *@param{string}body
         *@returns{string}
         */
        _generateMentionsLinks(body){
            //Listofmentiondatatoinsertinthebody.
            //Usefultodothefinalreplaceafterparsingtoavoidusingthe
            //sametagtwiceiftwodifferentmentionshavethesamename.
            constmentions=[];
            for(constpartnerofthis.mentionedPartners){
                constplaceholder=`@-mention-partner-${partner.id}`;
                consttext=`@${owl.utils.escape(partner.name)}`;
                mentions.push({
                    class:'o_mail_redirect',
                    id:partner.id,
                    model:'res.partner',
                    placeholder,
                    text,
                });
                body=body.replace(text,placeholder);
            }
            for(constchannelofthis.mentionedChannels){
                constplaceholder=`#-mention-channel-${channel.id}`;
                consttext=`#${owl.utils.escape(channel.name)}`;
                mentions.push({
                    class:'o_channel_redirect',
                    id:channel.id,
                    model:'mail.channel',
                    placeholder,
                    text,
                });
                body=body.replace(text,placeholder);
            }
            constbaseHREF=this.env.session.url('/web');
            for(constmentionofmentions){
                consthref=`href='${baseHREF}#model=${mention.model}&id=${mention.id}'`;
                constattClass=`class='${mention.class}'`;
                constdataOeId=`data-oe-id='${mention.id}'`;
                constdataOeModel=`data-oe-model='${mention.model}'`;
                consttarget=`target='_blank'`;
                constlink=`<a${href}${attClass}${dataOeId}${dataOeModel}${target}>${mention.text}</a>`;
                body=body.replace(mention.placeholder,link);
            }
            returnbody;
        }

        /**
         *@private
         *@param{string}contenthtmlcontent
         *@returns{mail.channel_command|undefined}command,ifanyinthecontent
         */
        _getCommandFromText(content){
            if(content.startsWith('/')){
                constfirstWord=content.substring(1).split(/\s/)[0];
                returnthis.env.messaging.commands.find(command=>{
                    if(command.name!==firstWord){
                        returnfalse;
                    }
                    if(command.channel_types){
                        returncommand.channel_types.includes(this.thread.channel_type);
                    }
                    returntrue;
                });
            }
            returnundefined;
        }

        /**
         *Updatesthesuggestionstatebasedonthecurrentlysavedcomposer
         *state(inparticularcontentandcursorposition).
         *
         *@private
         */
        _onChangeUpdateSuggestionList(){
            //UpdatethesuggestionlistimmediatelyforareactiveUX...
            this._updateSuggestionList();
            //...andthenupdateitagainaftertheserverreturneddata.
            this._executeOrQueueFunction(async()=>{
                if(
                    this.suggestionDelimiterPosition===undefined||
                    this.suggestionSearchTerm===undefined||
                    !this.suggestionModelName
                ){
                    //ignoreobsoletecall
                    return;
                }
                constModel=this.env.models[this.suggestionModelName];
                constsearchTerm=this.suggestionSearchTerm;
                awaitthis.async(()=>Model.fetchSuggestions(searchTerm,{thread:this.thread}));
                this._updateSuggestionList();
                if(
                    this.suggestionSearchTerm&&
                    this.suggestionSearchTerm===searchTerm&&
                    this.suggestionModelName&&
                    this.env.models[this.suggestionModelName]===Model&&
                    !this.hasSuggestions
                ){
                    this.closeSuggestions();
                }
            });
        }

        /**
         *@private
         */
        _reset(){
            this.update({
                attachments:[['unlink-all']],
                isLastStateChangeProgrammatic:true,
                mentionedChannels:[['unlink-all']],
                mentionedPartners:[['unlink-all']],
                subjectContent:"",
                textInputContent:'',
                textInputCursorEnd:0,
                textInputCursorStart:0,
            });
        }

        /**
         *Updatesthecurrentsuggestionlist.Thismethodshouldbecalled
         *whenevertheUIhastoberefreshedfollowingchangeinstate.
         *
         *Thismethodshouldideallybeacompute,butitsdependenciesare
         *currentlytoocomplextoexpressduetoaccessingplentyoffields
         *fromallrecordsofdynamicmodels.
         *
         *@private
         */
        _updateSuggestionList(){
            if(
                this.suggestionDelimiterPosition===undefined||
                this.suggestionSearchTerm===undefined||
                !this.suggestionModelName
            ){
                return;
            }
            constModel=this.env.models[this.suggestionModelName];
            const[
                mainSuggestedRecords,
                extraSuggestedRecords=[],
            ]=Model.searchSuggestions(this.suggestionSearchTerm,{thread:this.thread});
            constsortFunction=Model.getSuggestionSortFunction(this.suggestionSearchTerm,{thread:this.thread});
            mainSuggestedRecords.sort(sortFunction);
            extraSuggestedRecords.sort(sortFunction);
            //arbitrarylimittoavoiddisplayingtoomanyelementsatonce
            //ideallyaloadmoremechanismshouldbeintroduced
            constlimit=8;
            mainSuggestedRecords.length=Math.min(mainSuggestedRecords.length,limit);
            extraSuggestedRecords.length=Math.min(extraSuggestedRecords.length,limit-mainSuggestedRecords.length);
            this.update({
                extraSuggestedRecords:[['replace',extraSuggestedRecords]],
                hasToScrollToActiveSuggestion:true,
                mainSuggestedRecords:[['replace',mainSuggestedRecords]],
            });
        }

        /**
         *Validatesuser'scurrenttypingasacorrectmentionkeywordinorder
         *totriggermentionssuggestionsdisplay.
         *Returnsthementionkeywordwithoutthesuggestiondelimiterifit
         *hasbeenvalidatedandfalseifnot.
         *
         *@deprecated
         *@private
         *@param{boolean}beginningOnly
         *@returns{string|boolean}
         */
        _validateMentionKeyword(beginningOnly){
            //usepositionbeforesuggestiondelimiterbecausethereshouldbewhitespaces
            //orlinefeed/carriagereturnbeforethesuggestiondelimiter
            constbeforeSuggestionDelimiterPosition=this.suggestionDelimiterPosition-1;
            if(beginningOnly&&beforeSuggestionDelimiterPosition>0){
                returnfalse;
            }
            letsearchStr=this.textInputContent.substring(
                beforeSuggestionDelimiterPosition,
                this.textInputCursorStart
            );
            //regexstringstartwithsuggestiondelimiterorwhitespacethensuggestiondelimiter
            constpattern="^"+this.suggestionDelimiter+"|^\\s"+this.suggestionDelimiter;
            constregexStart=newRegExp(pattern,'g');
            //trimanyleftwhitespacesortheleftlinefeed/carriagereturn
            //atthebeginningofthestring
            searchStr=searchStr.replace(/^\s\s*|^[\n\r]/g,'');
            if(regexStart.test(searchStr)&&searchStr.length){
                searchStr=searchStr.replace(pattern,'');
                return!searchStr.includes('')&&!/[\r\n]/.test(searchStr)
                    ?searchStr.replace(this.suggestionDelimiter,'')
                    :false;
            }
            returnfalse;
        }
    }

    Composer.fields={
        /**
         *Deprecated.Use`activeSuggestedRecord`instead.
         */
        activeSuggestedCannedResponse:many2one('mail.canned_response',{
            compute:'_computeActiveSuggestedCannedResponse',
            dependencies:[
                'activeSuggestedRecord',
                'suggestionDelimiter',
            ],
        }),
        /**
         *Deprecated.Use`activeSuggestedRecord`instead.
         */
        activeSuggestedChannel:many2one('mail.thread',{
            compute:'_computeActiveSuggestedChannel',
            dependencies:[
                'activeSuggestedRecord',
                'suggestionDelimiter',
            ],
        }),
        /**
         *Deprecated.Use`activeSuggestedRecord`instead.
         */
        activeSuggestedChannelCommand:many2one('mail.channel_command',{
            compute:'_computeActiveSuggestedChannelCommand',
            dependencies:[
                'activeSuggestedRecord',
                'suggestionDelimiter',
            ],
        }),
        /**
         *Deprecated.Use`activeSuggestedRecord`instead.
         */
        activeSuggestedPartner:many2one('mail.partner',{
            compute:'_computeActiveSuggestedPartner',
            dependencies:[
                'activeSuggestedRecord',
                'suggestionDelimiter',
            ],
        }),
        /**
         *Determinesthesuggestedrecordthatiscurrentlyactive.Thisrecord
         *ishighlightedintheUIanditwillbetheselectedrecordifthe
         *suggestionisconfirmedbytheuser.
         */
        activeSuggestedRecord:many2one('mail.model',{
            compute:'_computeActiveSuggestedRecord',
            dependencies:[
                'activeSuggestedRecord',
                'extraSuggestedRecords',
                'mainSuggestedRecords',
            ],
        }),
        /**
         *Deprecated,suggestionsshouldbeusedinamannerthatdoesnot
         *dependontheirtype.Use`activeSuggestedRecord`directlyinstead.
         */
        activeSuggestedRecordName:attr({
            compute:'_computeActiveSuggestedRecordName',
            dependencies:[
                'suggestionDelimiter',
            ],
        }),
        attachments:many2many('mail.attachment',{
            inverse:'composers',
        }),
        /**
         *Thisfieldwatchestheuploading(=temporary)statusofattachments
         *linkedtothiscomposer.
         *
         *Usefultodeterminewhethertherearesomeattachmentsthatarebeing
         *uploaded.
         */
        attachmentsAreTemporary:attr({
            related:'attachments.isTemporary',
        }),
        canPostMessage:attr({
            compute:'_computeCanPostMessage',
            dependencies:[
                'attachments',
                'hasUploadingAttachment',
                'isPostingMessage',
                'textInputContent',
            ],
            default:false,
        }),
        /**
         *Instanceofdiscussifthiscomposerisusedasthereplycomposer
         *fromInbox.Thisfieldiscomputedfromtheinverserelationand
         *shouldbeconsideredread-only.
         */
        discussAsReplying:one2one('mail.discuss',{
            inverse:'replyingToMessageOriginThreadComposer',
        }),
        /**
         *Deprecated.Use`extraSuggestedRecords`instead.
         */
        extraSuggestedPartners:many2many('mail.partner',{
            compute:'_computeExtraSuggestedPartners',
            dependencies:[
                'extraSuggestedRecords',
                'suggestionDelimiter',
            ],
        }),
        /**
         *Determinestheextrarecordsthatarecurrentlysuggested.
         *Allowstohavedifferentmodeltypesofmentionsthroughadynamic
         *process.2arbitrarylistscanbeprovidedandthesecondisdefined
         *as"extra".
         */
        extraSuggestedRecords:many2many('mail.model',{
            compute:'_computeExtraSuggestedRecords',
            dependencies:[
                'extraSuggestedRecords',
                'mainSuggestedRecords',
                'suggestionDelimiterPosition',
            ],
        }),
        /**
         *Deprecated.Use`extraSuggestedRecords`instead.
         */
        extraSuggestedRecordsList:attr({
            compute:'_computeExtraSuggestedRecordsList',
            dependencies:[
                'extraSuggestedRecords',
            ],
        }),
        /**
         *Deprecated,suggestionsshouldbeusedinamannerthatdoesnot
         *dependontheirtype.Use`extraSuggestedRecords`directlyinstead.
         */
        extraSuggestedRecordsListName:attr({
            compute:'_computeExtraSuggestedRecordsListName',
            dependencies:[
                'suggestionDelimiter',
            ],
        }),
        hasDropZone:attr({
            compute:'_computeHasDropZone',
            dependencies:[
                'thread',
                'threadChannelType',
            ],
        }),
        /**
         *Thisfielddetermineswhethersomeattachmentslinkedtothis
         *composerarebeinguploaded.
         */
        hasUploadingAttachment:attr({
            compute:'_computeHasUploadingAttachment',
            dependencies:[
                'attachments',
                'attachmentsAreTemporary',
            ],
        }),
        hasFocus:attr({
            default:false,
        }),
        /**
         *Stateswhetherthereisanyresultcurrentlyfoundforthecurrent
         *suggestiondelimiterandsearchterm,ifapplicable.
         */
        hasSuggestions:attr({
            compute:'_computeHasSuggestions',
            dependencies:[
                'extraSuggestedRecords',
                'mainSuggestedRecords',
            ],
            default:false,
        }),
        /**
         *Determineswhetherthecurrentlyactivesuggestionshouldbescrolled
         *intoview.
         */
        hasToScrollToActiveSuggestion:attr({
            default:false,
        }),
        /**
         *Determineswhetherthelastchange(sincethelastrender)was
         *programmatic.Usefultoavoidrestoringthestatewhenitschangewas
         *fromauseraction,inparticulartopreventthecursorfromjumping
         *toitspreviouspositionaftertheuserclickedonthetextareawhile
         *itdidn'thavethefocusanymore.
         */
        isLastStateChangeProgrammatic:attr({
            default:false,
        }),
        /**
         *Iftruecomposerwillloganote,elseacommentwillbeposted.
         */
        isLog:attr({
            default:true,
        }),
        /**
         *Determineswhetherapost_messagerequestiscurrentlypending.
         */
        isPostingMessage:attr(),
        /**
         *Deprecated.Use`mainSuggestedRecords`instead.
         */
        mainSuggestedPartners:many2many('mail.partner',{
            compute:'_computeMainSuggestedPartners',
            dependencies:[
                'mainSuggestedRecords',
                'suggestionDelimiter',
            ],
        }),
        /**
         *Determinesthemainrecordsthatarecurrentlysuggested.
         *Allowstohavedifferentmodeltypesofmentionsthroughadynamic
         *process.2arbitrarylistscanbeprovidedandthefirstisdefined
         *as"main".
         */
        mainSuggestedRecords:many2many('mail.model',{
            compute:'_computeMainSuggestedRecords',
            dependencies:[
                'mainSuggestedRecords',
                'suggestionDelimiterPosition',
            ],
        }),
        /**
         *Deprecated.Use`mainSuggestedRecords`instead.
         */
        mainSuggestedRecordsList:attr({
            compute:'_computeMainSuggestedRecordsList',
            dependencies:[
                'mainSuggestedRecords',
            ],
        }),
        /**
         *Deprecated,suggestionsshouldbeusedinamannerthatdoesnot
         *dependontheirtype.Use`mainSuggestedRecords`directlyinstead.
         */
        mainSuggestedRecordsListName:attr({
            compute:'_computeMainSuggestedRecordsListName',
            dependencies:[
                'suggestionDelimiter',
            ],
        }),
        mentionedChannels:many2many('mail.thread',{
            compute:'_computeMentionedChannels',
            dependencies:['textInputContent'],
        }),
        mentionedPartners:many2many('mail.partner',{
            compute:'_computeMentionedPartners',
            dependencies:[
                'mentionedPartners',
                'mentionedPartnersName',
                'textInputContent',
            ],
        }),
        /**
         *Servesascomputedependency.
         */
        mentionedPartnersName:attr({
            related:'mentionedPartners.name',
        }),
        /**
         *Notarealfield,usedtotrigger`_onChangeUpdateSuggestionList`
         *whenoneofthedependencieschanges.
         */
        onChangeUpdateSuggestionList:attr({
            compute:'_onChangeUpdateSuggestionList',
            dependencies:[
                'suggestionDelimiterPosition',
                'suggestionModelName',
                'suggestionSearchTerm',
                'thread',
            ],
        }),
        /**
         *Determinestheextra`mail.partner`(ontopofexistingfollowers)
         *thatwillreceivethemessagebeingcomposedby`this`,andthatwill
         *alsobeaddedasfollowerof`this.thread`.
         */
        recipients:many2many('mail.partner',{
            compute:'_computeRecipients',
            dependencies:[
                'isLog',
                'mentionedPartners',
                'threadSuggestedRecipientInfoListIsSelected',
                //FIXMEthread.suggestedRecipientInfoList.partnershouldbea
                //dependency,butitiscurrentlyimpossibletohavearelated
                //m2othrougham2m.task-2261221
            ]
        }),
        /**
         *Servesascomputedependency.
         */
        threadSuggestedRecipientInfoList:many2many('mail.suggested_recipient_info',{
            related:'thread.suggestedRecipientInfoList',
        }),
        /**
         *Servesascomputedependency.
         */
        threadSuggestedRecipientInfoListIsSelected:attr({
            related:'threadSuggestedRecipientInfoList.isSelected',
        }),
        /**
         *Composersubjectinputcontent.
         */
        subjectContent:attr({
            default:"",
        }),
        /**
         *Deprecated.Use`mainSuggestedRecords`instead.
         */
        suggestedCannedResponses:many2many('mail.canned_response',{
            compute:'_computeSuggestedCannedResponses',
            dependencies:[
                'mainSuggestedRecords',
                'suggestionDelimiter',
            ],
        }),
        /**
         *Deprecated.Use`mainSuggestedRecords`instead.
         */
        suggestedChannelCommands:many2many('mail.channel_command',{
            compute:'_computeSuggestedChannelCommands',
            dependencies:[
                'mainSuggestedRecords',
                'suggestionDelimiter',
            ],
        }),
        /**
         *Deprecated.Use`mainSuggestedRecords`instead.
         */
        suggestedChannels:many2many('mail.thread',{
            compute:'_computeSuggestedChannels',
            dependencies:[
                'mainSuggestedRecords',
                'suggestionDelimiter',
            ],
        }),
        /**
         *Stateswhichtypeofsuggestioniscurrentlyinprogress,ifany.
         *Thevalueofthisfieldcontainsthemagiccharthatcorrespondsto
         *thesuggestioncurrentlyinprogress,anditmustbeoneofthese:
         *cannedresponses(:),channels(#),commands(/)andpartners(@)
         */
        suggestionDelimiter:attr({
            compute:'_computeSuggestionDelimiter',
            dependencies:[
                'suggestionDelimiterPosition',
                'textInputContent',
            ],
        }),
        /**
         *StatesthepositioninsidetextInputContentofthesuggestion
         *delimitercurrentlyinconsideration.Usefulifthedelimiterchar
         *appearsmultipletimesinthecontent.
         *Note:thepositionis0basedsoit'simportanttocompareto
         *`undefined`whencheckingfortheabsenceofavalue.
         */
        suggestionDelimiterPosition:attr({
            compute:'_computeSuggestionDelimiterPosition',
            dependencies:[
                'textInputContent',
                'textInputCursorEnd',
                'textInputCursorStart',
            ],
        }),
        /**
         *Statesthetargetmodelnameofthesuggestioncurrentlyinprogress,
         *ifany.
         */
        suggestionModelName:attr({
            compute:'_computeSuggestionModelName',
            dependencies:[
                'suggestionDelimiter',
            ],
        }),
        /**
         *Statesthesearchtermtouseforsuggestions(ifany).
         */
        suggestionSearchTerm:attr({
            compute:'_computeSuggestionSearchTerm',
            dependencies:[
                'suggestionDelimiterPosition',
                'textInputContent',
                'textInputCursorStart',
            ],
        }),
        textInputContent:attr({
            default:"",
        }),
        textInputCursorEnd:attr({
            default:0,
        }),
        textInputCursorStart:attr({
            default:0,
        }),
        textInputSelectionDirection:attr({
            default:"none",
        }),
        thread:one2one('mail.thread',{
            inverse:'composer',
        }),
        threadChannelType:attr({
            related:'thread.channel_type',
        }),
    };

    Composer.modelName='mail.composer';

    returnComposer;
}

registerNewModel('mail.composer',factory);

});

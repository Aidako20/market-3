flectra.define('mail/static/src/models/chatter/chatter.js',function(require){
'usestrict';

const{registerNewModel}=require('mail/static/src/model/model_core.js');
const{attr,many2one,one2one}=require('mail/static/src/model/model_field.js');

functionfactory(dependencies){

    constgetThreadNextTemporaryId=(function(){
        lettmpId=0;
        return()=>{
            tmpId-=1;
            returntmpId;
        };
    })();

    constgetMessageNextTemporaryId=(function(){
        lettmpId=0;
        return()=>{
            tmpId-=1;
            returntmpId;
        };
    })();

    classChatterextendsdependencies['mail.model']{

        /**
         *@override
         */
        _willDelete(){
            this._stopAttachmentsLoading();
            returnsuper._willDelete(...arguments);
        }

        //----------------------------------------------------------------------
        //Public
        //----------------------------------------------------------------------

        focus(){
            this.update({isDoFocus:true});
        }

        asyncrefresh(){
            if(this.hasActivities){
                this.thread.refreshActivities();
            }
            if(this.hasFollowers){
                this.thread.refreshFollowers();
                this.thread.fetchAndUpdateSuggestedRecipients();
            }
            if(this.hasMessageList){
                this.thread.refresh();
            }
        }

        showLogNote(){
            this.update({isComposerVisible:true});
            this.thread.composer.update({isLog:true});
            this.focus();
        }

        showSendMessage(){
            this.update({isComposerVisible:true});
            this.thread.composer.update({isLog:false});
            this.focus();
        }

        toggleActivityBoxVisibility(){
            this.update({isActivityBoxVisible:!this.isActivityBoxVisible});
        }

        //----------------------------------------------------------------------
        //Private
        //----------------------------------------------------------------------

        /**
         *@private
         *@returns{boolean}
         */
        _computeHasThreadView(){
            returnthis.thread&&this.hasMessageList;
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeIsDisabled(){
            return!this.thread||this.thread.isTemporary;
        }

        /**
         *@private
         */
        _onThreadIdOrThreadModelChanged(){
            if(this.threadId){
                if(this.thread&&this.thread.isTemporary){
                    this.thread.delete();
                }
                this.update({
                    isAttachmentBoxVisible:this.isAttachmentBoxVisibleInitially,
                    thread:[['insert',{
                        //Ifthethreadwasconsideredtohavetheactivity
                        //mixinonce,itwillhaveitforever.
                        hasActivities:this.hasActivities?true:undefined,
                        id:this.threadId,
                        model:this.threadModel,
                    }]],
                });
                if(this.hasActivities){
                    this.thread.refreshActivities();
                }
                if(this.hasFollowers){
                    this.thread.refreshFollowers();
                    this.thread.fetchAndUpdateSuggestedRecipients();
                }
                if(this.hasMessageList){
                    this.thread.refresh();
                }
            }elseif(!this.thread||!this.thread.isTemporary){
                constcurrentPartner=this.env.messaging.currentPartner;
                constmessage=this.env.models['mail.message'].create({
                    author:[['link',currentPartner]],
                    body:this.env._t("Creatinganewrecord..."),
                    id:getMessageNextTemporaryId(),
                    isTemporary:true,
                });
                constnextId=getThreadNextTemporaryId();
                this.update({
                    isAttachmentBoxVisible:false,
                    thread:[['insert',{
                        areAttachmentsLoaded:true,
                        id:nextId,
                        isTemporary:true,
                        model:this.threadModel,
                    }]],
                });
                for(constcacheofthis.thread.caches){
                    cache.update({messages:[['link',message]]});
                }
            }
        }

        /**
         *@private
         */
        _onThreadIsLoadingAttachmentsChanged(){
            if(!this.thread||!this.thread.isLoadingAttachments){
                this._stopAttachmentsLoading();
                return;
            }
            if(this._isPreparingAttachmentsLoading||this.isShowingAttachmentsLoading){
                return;
            }
            this._prepareAttachmentsLoading();
        }

        /**
         *@private
         */
        _prepareAttachmentsLoading(){
            this._isPreparingAttachmentsLoading=true;
            this._attachmentsLoaderTimeout=this.env.browser.setTimeout(()=>{
                this.update({isShowingAttachmentsLoading:true});
                this._isPreparingAttachmentsLoading=false;
            },this.env.loadingBaseDelayDuration);
        }

        /**
         *@private
         */
        _stopAttachmentsLoading(){
            this.env.browser.clearTimeout(this._attachmentsLoaderTimeout);
            this._attachmentsLoaderTimeout=null;
            this.update({isShowingAttachmentsLoading:false});
            this._isPreparingAttachmentsLoading=false;
        }

    }

    Chatter.fields={
        composer:many2one('mail.composer',{
            related:'thread.composer',
        }),
        context:attr({
            default:{},
        }),
        /**
         *Determineswhether`this`shoulddisplayanactivitybox.
         */
        hasActivities:attr({
            default:true,
        }),
        hasExternalBorder:attr({
            default:true,
        }),
        /**
         *Determineswhether`this`shoulddisplayfollowersmenu.
         */
        hasFollowers:attr({
            default:true,
        }),
        /**
         *Determineswhether`this`shoulddisplayamessagelist.
         */
        hasMessageList:attr({
            default:true,
        }),
        /**
         *Whetherthemessagelistshouldmanageitsscroll.
         *Inparticular,whenthechatterisontheformview'sside,
         *thenthescrollismanagedbythemessagelist.
         *Also,themessagelistshoudnotmanagethescrollifitsharesit
         *withtherestofthepage.
         */
        hasMessageListScrollAdjust:attr({
            default:false,
        }),
        /**
         *Determineswhether`this.thread`shouldbedisplayed.
         */
        hasThreadView:attr({
            compute:'_computeHasThreadView',
            dependencies:[
                'hasMessageList',
                'thread',
            ],
        }),
        hasTopbarCloseButton:attr({
            default:false,
        }),
        isActivityBoxVisible:attr({
            default:true,
        }),
        /**
         *Determinerswhethertheattachmentboxiscurrentlyvisible.
         */
        isAttachmentBoxVisible:attr({
            default:false,
        }),
        /**
         *Determinerswhethertheattachmentboxisvisibleinitially.
         */
        isAttachmentBoxVisibleInitially:attr({
            default:false,
        }),
        isComposerVisible:attr({
            default:false,
        }),
        isDisabled:attr({
            compute:'_computeIsDisabled',
            default:false,
            dependencies:[
                'threadIsTemporary',
            ],
        }),
        /**
         *Determinewhetherthischattershouldbefocusedatnextrender.
         */
        isDoFocus:attr({
            default:false,
        }),
        isShowingAttachmentsLoading:attr({
            default:false,
        }),
        /**
         *Notarealfield,usedtotriggeritscomputemethodwhenoneofthe
         *dependencieschanges.
         */
        onThreadIdOrThreadModelChanged:attr({
            compute:'_onThreadIdOrThreadModelChanged',
            dependencies:[
                'threadId',
                'threadModel',
            ],
        }),
        /**
         *Notarealfield,usedtotriggeritscomputemethodwhenoneofthe
         *dependencieschanges.
         */
        onThreadIsLoadingAttachmentsChanged:attr({
            compute:'_onThreadIsLoadingAttachmentsChanged',
            dependencies:[
                'threadIsLoadingAttachments',
            ],
        }),
        /**
         *Determinesthe`mail.thread`thatshouldbedisplayedby`this`.
         */
        thread:many2one('mail.thread'),
        /**
         *Determinestheidofthethreadthatwillbedisplayedby`this`.
         */
        threadId:attr(),
        /**
         *Servesascomputedependency.
         */
        threadIsLoadingAttachments:attr({
            related:'thread.isLoadingAttachments',
        }),
        /**
         *Servesascomputedependency.
         */
        threadIsTemporary:attr({
            related:'thread.isTemporary',
        }),
        /**
         *Determinesthemodelofthethreadthatwillbedisplayedby`this`.
         */
        threadModel:attr(),
        /**
         *Statesthe`mail.thread_view`displaying`this.thread`.
         */
        threadView:one2one('mail.thread_view',{
            related:'threadViewer.threadView',
        }),
        /**
         *Determinesthe`mail.thread_viewer`managingthedisplayof`this.thread`.
         */
        threadViewer:one2one('mail.thread_viewer',{
            default:[['create']],
            inverse:'chatter',
            isCausal:true,
        }),
    };

    Chatter.modelName='mail.chatter';

    returnChatter;
}

registerNewModel('mail.chatter',factory);

});

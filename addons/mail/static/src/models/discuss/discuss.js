flectra.define('mail/static/src/models/discuss.discuss.js',function(require){
'usestrict';

const{registerNewModel}=require('mail/static/src/model/model_core.js');
const{attr,many2one,one2many,one2one}=require('mail/static/src/model/model_field.js');
const{clear}=require('mail/static/src/model/model_field_command.js');

functionfactory(dependencies){

    classDiscussextendsdependencies['mail.model']{

        //----------------------------------------------------------------------
        //Public
        //----------------------------------------------------------------------

        /**
         *@param{mail.thread}thread
         */
        cancelThreadRenaming(thread){
            this.update({renamingThreads:[['unlink',thread]]});
        }

        clearIsAddingItem(){
            this.update({
                addingChannelValue:"",
                isAddingChannel:false,
                isAddingChat:false,
            });
        }

        clearReplyingToMessage(){
            this.update({replyingToMessage:[['unlink-all']]});
        }

        /**
         *Closethediscussapp.Shouldresetitsinternalstate.
         */
        close(){
            this.update({isOpen:false});
        }

        focus(){
            this.update({isDoFocus:true});
        }

        /**
         *@param{Event}ev
         *@param{Object}ui
         *@param{Object}ui.item
         *@param{integer}ui.item.id
         */
        asynchandleAddChannelAutocompleteSelect(ev,ui){
            //NecessaryinordertopreventAutocompleteSelectevent'sdefault
            //behaviourashtmltagsvisibleforasplitsecondintextarea
            ev.preventDefault();
            constname=this.addingChannelValue;
            this.clearIsAddingItem();
            if(ui.item.special){
                constchannel=awaitthis.async(()=>
                    this.env.models['mail.thread'].performRpcCreateChannel({
                        name,
                        privacy:ui.item.special==='private'?'private':'groups',
                    })
                );
                channel.open();
            }else{
                constchannel=awaitthis.async(()=>
                    this.env.models['mail.thread'].performRpcJoinChannel({
                        channelId:ui.item.id,
                    })
                );
                channel.open();
            }
        }

        /**
         *@param{Object}req
         *@param{string}req.term
         *@param{function}res
         */
        asynchandleAddChannelAutocompleteSource(req,res){
            constvalue=req.term;
            constescapedValue=owl.utils.escape(value);
            this.update({addingChannelValue:value});
            constdomain=[
                ['channel_type','=','channel'],
                ['name','ilike',value],
            ];
            constfields=['channel_type','name','public','uuid'];
            constresult=awaitthis.async(()=>this.env.services.rpc({
                model:"mail.channel",
                method:"search_read",
                kwargs:{
                    domain,
                    fields,
                },
            }));
            constitems=result.map(data=>{
                letescapedName=owl.utils.escape(data.name);
                returnObject.assign(data,{
                    label:escapedName,
                    value:escapedName
                });
            });
            //XDUFIXMEcoulduseacomponentbutbecarefulwithowl's
            //renderToStringhttps://github.com/flectra/owl/issues/708
            items.push({
                label:_.str.sprintf(
                    `<strong>${this.env._t('Create%s')}</strong>`,
                    `<em><spanclass="fafa-hashtag"/>${escapedValue}</em>`,
                ),
                escapedValue,
                special:'public'
            },{
                label:_.str.sprintf(
                    `<strong>${this.env._t('Create%s')}</strong>`,
                    `<em><spanclass="fafa-lock"/>${escapedValue}</em>`,
                ),
                escapedValue,
                special:'private'
            });
            res(items);
        }

        /**
         *@param{Event}ev
         *@param{Object}ui
         *@param{Object}ui.item
         *@param{integer}ui.item.id
         */
        handleAddChatAutocompleteSelect(ev,ui){
            this.env.messaging.openChat({partnerId:ui.item.id});
            this.clearIsAddingItem();
        }

        /**
         *@param{Object}req
         *@param{string}req.term
         *@param{function}res
         */
        handleAddChatAutocompleteSource(req,res){
            constvalue=owl.utils.escape(req.term);
            this.env.models['mail.partner'].imSearch({
                callback:partners=>{
                    constsuggestions=partners.map(partner=>{
                        return{
                            id:partner.id,
                            value:partner.nameOrDisplayName,
                            label:partner.nameOrDisplayName,
                        };
                    });
                    res(_.sortBy(suggestions,'label'));
                },
                keyword:value,
                limit:10,
            });
        }

        /**
         *Openthreadfrominitactiveid.`initActiveId`isusedtoreferto
         *athreadthatwemaynothavefulldatayet,suchaswhenmessaging
         *isnotyetinitialized.
         */
        openInitThread(){
            const[model,id]=typeofthis.initActiveId==='number'
                ?['mail.channel',this.initActiveId]
                :this.initActiveId.split('_');
            constthread=this.env.models['mail.thread'].findFromIdentifyingData({
                id:model!=='mail.box'?Number(id):id,
                model,
            });
            if(!thread){
                return;
            }
            thread.open();
            if(this.env.messaging.device.isMobile&&thread.channel_type){
                this.update({activeMobileNavbarTabId:thread.channel_type});
            }
        }


        /**
         *OpensthegiventhreadinDiscuss,andopensDiscussifnecessary.
         *
         *@param{mail.thread}thread
         */
        asyncopenThread(thread){
            this.update({
                thread:[['link',thread]],
            });
            this.focus();
            if(!this.isOpen){
                this.env.bus.trigger('do-action',{
                    action:'mail.action_discuss',
                    options:{
                        name:this.env._t("Discuss"),
                        active_id:this.threadToActiveId(this),
                        clear_breadcrumbs:false,
                        on_reverse_breadcrumb:()=>this.close(),
                    },
                });
            }
        }

        /**
         *@param{mail.thread}thread
         *@param{string}newName
         */
        asyncrenameThread(thread,newName){
            awaitthis.async(()=>thread.rename(newName));
            this.update({renamingThreads:[['unlink',thread]]});
        }

        /**
         *ActiontoinitiatereplytogivenmessageinInbox.Assumesthat
         *DiscussandInboxarealreadyopened.
         *
         *@param{mail.message}message
         */
        replyToMessage(message){
            this.update({replyingToMessage:[['link',message]]});
            //avoidtoreplytoanotebyamessageandvice-versa.
            //subjecttochangelaterbyallowingsubtypechoice.
            this.replyingToMessageOriginThreadComposer.update({
                isLog:!message.is_discussion&&!message.is_notification
            });
            this.focus();
        }

        /**
         *@param{mail.thread}thread
         */
        setThreadRenaming(thread){
            this.update({renamingThreads:[['link',thread]]});
        }

        /**
         *@param{mail.thread}thread
         *@returns{string}
         */
        threadToActiveId(thread){
            return`${thread.model}_${thread.id}`;
        }

        //----------------------------------------------------------------------
        //Private
        //----------------------------------------------------------------------

        /**
         *@private
         *@returns{string|undefined}
         */
        _computeActiveId(){
            if(!this.thread){
                returnclear();
            }
            returnthis.threadToActiveId(this.thread);
        }

        /**
         *@private
         *@returns{string}
         */
        _computeAddingChannelValue(){
            if(!this.isOpen){
                return"";
            }
            returnthis.addingChannelValue;
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeHasThreadView(){
            if(!this.thread||!this.isOpen){
                returnfalse;
            }
            if(
                this.env.messaging.device.isMobile&&
                (
                    this.activeMobileNavbarTabId!=='mailbox'||
                    this.thread.model!=='mail.box'
                )
            ){
                returnfalse;
            }
            returntrue;
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeIsAddingChannel(){
            if(!this.isOpen){
                returnfalse;
            }
            returnthis.isAddingChannel;
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeIsAddingChat(){
            if(!this.isOpen){
                returnfalse;
            }
            returnthis.isAddingChat;
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeIsReplyingToMessage(){
            return!!this.replyingToMessage;
        }

        /**
         *Ensuresthereplyfeatureisdisabledifdiscussisnotopen.
         *
         *@private
         *@returns{mail.message|undefined}
         */
        _computeReplyingToMessage(){
            if(!this.isOpen){
                return[['unlink-all']];
            }
            return[];
        }


        /**
         *Onlypinnedthreadsareallowedindiscuss.
         *
         *@private
         *@returns{mail.thread|undefined}
         */
        _computeThread(){
            letthread=this.thread;
            if(this.env.messaging&&
                this.env.messaging.inbox&&
                this.env.messaging.device.isMobile&&
                this.activeMobileNavbarTabId==='mailbox'&&
                this.initActiveId!=='mail.box_inbox'&&
                !thread
            ){
                //AfterloadingDiscussfromanarbitrarytabotherthen'mailbox',
                //switchingto'mailbox'requirestoalsosetitsinner-tab;
                //bydefaultthe'inbox'.
                return[['replace',this.env.messaging.inbox]];
            }
            if(!thread||!thread.isPinned){
                return[['unlink']];
            }
            return[];
        }

    }

    Discuss.fields={
        activeId:attr({
            compute:'_computeActiveId',
            dependencies:[
                'thread',
                'threadId',
                'threadModel',
            ],
        }),
        /**
         *Activemobilenavbartab,either'mailbox','chat',or'channel'.
         */
        activeMobileNavbarTabId:attr({
            default:'mailbox',
        }),
        /**
         *Valuethatisusedtocreateachannelfromthesidebar.
         */
        addingChannelValue:attr({
            compute:'_computeAddingChannelValue',
            default:"",
            dependencies:['isOpen'],
        }),
        /**
         *Servesascomputedependency.
         */
        device:one2one('mail.device',{
            related:'messaging.device',
        }),
        /**
         *Servesascomputedependency.
         */
        deviceIsMobile:attr({
            related:'device.isMobile',
        }),
        /**
         *Determineifthemoderationdiscarddialogisdisplayed.
         */
        hasModerationDiscardDialog:attr({
            default:false,
        }),
        /**
         *Determineifthemoderationrejectdialogisdisplayed.
         */
        hasModerationRejectDialog:attr({
            default:false,
        }),
        /**
         *Determineswhether`this.thread`shouldbedisplayed.
         */
        hasThreadView:attr({
            compute:'_computeHasThreadView',
            dependencies:[
                'activeMobileNavbarTabId',
                'deviceIsMobile',
                'isOpen',
                'thread',
                'threadModel',
            ],
        }),
        /**
         *Formattedinitthreadonopeningdiscussforthefirsttime,
         *whennoactivethreadisdefined.Usefultosetathreadto
         *openwithoutknowingitslocalidinadvance.
         *Supporttwoformats:
         *   {string}<threadModel>_<threadId>
         *   {int}<channelId>withdefaultmodelof'mail.channel'
         */
        initActiveId:attr({
            default:'mail.box_inbox',
        }),
        /**
         *Determinewhethercurrentuseriscurrentlyaddingachannelfrom
         *thesidebar.
         */
        isAddingChannel:attr({
            compute:'_computeIsAddingChannel',
            default:false,
            dependencies:['isOpen'],
        }),
        /**
         *Determinewhethercurrentuseriscurrentlyaddingachatfrom
         *thesidebar.
         */
        isAddingChat:attr({
            compute:'_computeIsAddingChat',
            default:false,
            dependencies:['isOpen'],
        }),
        /**
         *Determinewhetherthisdiscussshouldbefocusedatnextrender.
         */
        isDoFocus:attr({
            default:false,
        }),
        /**
         *Whetherthediscussappisopenornot.Usefultodetermine
         *whetherthediscussorchatwindowlogicshouldbeapplied.
         */
        isOpen:attr({
            default:false,
        }),
        isReplyingToMessage:attr({
            compute:'_computeIsReplyingToMessage',
            default:false,
            dependencies:['replyingToMessage'],
        }),
        isThreadPinned:attr({
            related:'thread.isPinned',
        }),
        /**
         *Themenu_idofdiscussapp,receivedonmail/init_messagingand
         *usedtoopendiscussfromelsewhere.
         */
        menu_id:attr({
            default:null,
        }),
        messaging:one2one('mail.messaging',{
            inverse:'discuss',
        }),
        messagingInbox:many2one('mail.thread',{
            related:'messaging.inbox',
        }),
        renamingThreads:one2many('mail.thread'),
        /**
         *ThemessagethatiscurrentlyselectedasbeingrepliedtoinInbox.
         *Thereisonlyonereplycomposershownatatime,whichdependson
         *thisselectedmessage.
         */
        replyingToMessage:many2one('mail.message',{
            compute:'_computeReplyingToMessage',
            dependencies:[
                'isOpen',
                'replyingToMessage',
            ],
        }),
        /**
         *ThethreadconcernedbythereplyfeatureinInbox.Itdependsonthe
         *messagesettobereplied,andshouldbeconsideredread-only.
         */
        replyingToMessageOriginThread:many2one('mail.thread',{
            related:'replyingToMessage.originThread',
        }),
        /**
         *ThecomposertodisplayforthereplyfeatureinInbox.Itdepends
         *onthemessagesettobereplied,andshouldbeconsideredread-only.
         */
        replyingToMessageOriginThreadComposer:one2one('mail.composer',{
            inverse:'discussAsReplying',
            related:'replyingToMessageOriginThread.composer',
        }),
        /**
         *Quicksearchinputvalueinthediscusssidebar(desktop).Useful
         *tofilterchannelsandchatsbasedonthisinputcontent.
         */
        sidebarQuickSearchValue:attr({
            default:"",
        }),
        /**
         *Determinesthedomaintoapplywhenfetchingmessagesfor`this.thread`.
         *Thisvalueshouldonlybewrittenbythecontrolpanel.
         */
        stringifiedDomain:attr({
            default:'[]',
        }),
        /**
         *Determinesthe`mail.thread`thatshouldbedisplayedby`this`.
         */
        thread:many2one('mail.thread',{
            compute:'_computeThread',
            dependencies:[
                'activeMobileNavbarTabId',
                'deviceIsMobile',
                'isThreadPinned',
                'messaging',
                'messagingInbox',
                'thread',
                'threadModel',
            ],
        }),
        threadId:attr({
            related:'thread.id',
        }),
        threadModel:attr({
            related:'thread.model',
        }),
        /**
         *Statesthe`mail.thread_view`displaying`this.thread`.
         */
        threadView:one2one('mail.thread_view',{
            related:'threadViewer.threadView',
        }),
        /**
         *Determinesthe`mail.thread_viewer`managingthedisplayof`this.thread`.
         */
        threadViewer:one2one('mail.thread_viewer',{
            default:[['create']],
            inverse:'discuss',
            isCausal:true,
        }),
    };

    Discuss.modelName='mail.discuss';

    returnDiscuss;
}

registerNewModel('mail.discuss',factory);

});

flectra.define('mail/static/src/models/chat_window_manager/chat_window_manager.js',function(require){
'usestrict';

const{registerNewModel}=require('mail/static/src/model/model_core.js');
const{attr,many2one,one2many,one2one}=require('mail/static/src/model/model_field.js');

functionfactory(dependencies){

    constBASE_VISUAL={
        /**
         *Amountofvisibleslotsavailableforchatwindows.
         */
        availableVisibleSlots:0,
        /**
         *Datarelatedtothehiddenmenu.
         */
        hidden:{
            /**
             *Listofhiddendockedchatwindows.Usefultocomputecounter.
             *Chatwindowsareorderedbytheir`chatWindows`order.
             */
            chatWindowLocalIds:[],
            /**
             *Whetherhiddenmenuisvisibleornot
             */
            isVisible:false,
            /**
             *Offsetofhiddenmenustartingpointfromthestartingpoint
             *ofchatwindowmanager.Makesonlysenseifitisvisible.
             */
            offset:0,
        },
        /**
         *Datarelatedtovisiblechatwindows.Indexdetermineorderof
         *dockedchatwindows.
         *
         *Value:
         *
         * {
         *     chatWindowLocalId,
         *     offset,
         * }
         *
         *Offsetisoffsetofstartingpointofdockedchatwindowfrom
         *startingpointofdockchatwindowmanager.Dockedchatwindows
         *areorderedbytheir`chatWindows`order
         */
        visible:[],
    };


    classChatWindowManagerextendsdependencies['mail.model']{

        //----------------------------------------------------------------------
        //Public
        //----------------------------------------------------------------------

        /**
         *Closeallchatwindows.
         *
         */
        closeAll(){
            constchatWindows=this.allOrdered;
            for(constchatWindowofchatWindows){
                chatWindow.close();
            }
        }

        closeHiddenMenu(){
            this.update({isHiddenMenuOpen:false});
        }

        /**
         *Closesallchatwindowsrelatedtothegiventhread.
         *
         *@param{mail.thread}thread
         *@param{Object}[options]
         */
        closeThread(thread,options){
            for(constchatWindowofthis.chatWindows){
                if(chatWindow.thread===thread){
                    chatWindow.close(options);
                }
            }
        }

        openHiddenMenu(){
            this.update({isHiddenMenuOpen:true});
        }

        openNewMessage(){
            letnewMessageChatWindow=this.newMessageChatWindow;
            if(!newMessageChatWindow){
                newMessageChatWindow=this.env.models['mail.chat_window'].create({
                    manager:[['link',this]],
                });
            }
            newMessageChatWindow.makeActive();
        }

        /**
         *@param{mail.thread}thread
         *@param{Object}[param1={}]
         *@param{boolean}[param1.isFolded=false]
         *@param{boolean}[param1.makeActive=false]
         *@param{boolean}[param1.notifyServer]
         *@param{boolean}[param1.replaceNewMessage=false]
         */
        openThread(thread,{
            isFolded=false,
            makeActive=false,
            notifyServer,
            replaceNewMessage=false
        }={}){
            if(notifyServer===undefined){
                notifyServer=!this.env.messaging.device.isMobile;
            }
            letchatWindow=this.chatWindows.find(chatWindow=>
                chatWindow.thread===thread
            );
            if(!chatWindow){
                chatWindow=this.env.models['mail.chat_window'].create({
                    isFolded,
                    manager:[['link',this]],
                    thread:[['link',thread]],
                });
            }else{
                chatWindow.update({isFolded});
            }
            if(replaceNewMessage&&this.newMessageChatWindow){
                this.swap(chatWindow,this.newMessageChatWindow);
                this.newMessageChatWindow.close();
            }
            if(makeActive){
                //avoiddoublenotifyatthisstep,itwillalreadybedoneat
                //theendofthecurrentmethod
                chatWindow.makeActive({notifyServer:false});
            }
            //Fluxspecific:notifyserverofchatwindowbeingopened.
            if(notifyServer){
                constfoldState=chatWindow.isFolded?'folded':'open';
                thread.notifyFoldStateToServer(foldState);
            }
        }

        /**
         *Shiftprovidedchatwindowtotheleftonscreen.
         *
         *@param{mail.chat_window}chatWindow
         */
        shiftLeft(chatWindow){
            constchatWindows=this.allOrdered;
            constindex=chatWindows.findIndex(cw=>cw===chatWindow);
            if(index===chatWindows.length-1){
                //alreadyleft-most
                return;
            }
            constotherChatWindow=chatWindows[index+1];
            const_newOrdered=[...this._ordered];
            _newOrdered[index]=otherChatWindow.localId;
            _newOrdered[index+1]=chatWindow.localId;
            this.update({_ordered:_newOrdered});
            chatWindow.focus();
            for(constloopedChatWindowof[chatWindow,otherChatWindow]){
                if(loopedChatWindow.threadView){
                    loopedChatWindow.threadView.addComponentHint('adjust-scroll');
                }
            }
        }

        /**
         *Shiftprovidedchatwindowtotherightonscreen.
         *
         *@param{mail.chat_window}chatWindow
         */
        shiftRight(chatWindow){
            constchatWindows=this.allOrdered;
            constindex=chatWindows.findIndex(cw=>cw===chatWindow);
            if(index===0){
                //alreadyright-most
                return;
            }
            constotherChatWindow=chatWindows[index-1];
            const_newOrdered=[...this._ordered];
            _newOrdered[index]=otherChatWindow.localId;
            _newOrdered[index-1]=chatWindow.localId;
            this.update({_ordered:_newOrdered});
            chatWindow.focus();
            for(constloopedChatWindowof[chatWindow,otherChatWindow]){
                if(loopedChatWindow.threadView){
                    loopedChatWindow.threadView.addComponentHint('adjust-scroll');
                }
            }
        }

        /**
         *@param{mail.chat_window}chatWindow1
         *@param{mail.chat_window}chatWindow2
         */
        swap(chatWindow1,chatWindow2){
            constordered=this.allOrdered;
            constindex1=ordered.findIndex(chatWindow=>chatWindow===chatWindow1);
            constindex2=ordered.findIndex(chatWindow=>chatWindow===chatWindow2);
            if(index1===-1||index2===-1){
                return;
            }
            const_newOrdered=[...this._ordered];
            _newOrdered[index1]=chatWindow2.localId;
            _newOrdered[index2]=chatWindow1.localId;
            this.update({_ordered:_newOrdered});
            for(constchatWindowof[chatWindow1,chatWindow2]){
                if(chatWindow.threadView){
                    chatWindow.threadView.addComponentHint('adjust-scroll');
                }
            }
        }

        //----------------------------------------------------------------------
        //Private
        //----------------------------------------------------------------------

        /**
         *@private
         *@returns{string[]}
         */
        _compute_ordered(){
            //removeunlinkedchatWindows
            const_ordered=this._ordered.filter(chatWindowLocalId=>
                this.chatWindows.includes(this.env.models['mail.chat_window'].get(chatWindowLocalId))
            );
            //addlinkedchatWindows
            for(constchatWindowofthis.chatWindows){
                if(!_ordered.includes(chatWindow.localId)){
                    _ordered.push(chatWindow.localId);
                }
            }
            return_ordered;
        }

        /**
         *//FIXME:dependentonimplementationthatusesarbitraryorderinrelations!!
         *
         *@private
         *@returns{mail.chat_window}
         */
        _computeAllOrdered(){
            return[['replace',this._ordered.map(chatWindowLocalId=>
                this.env.models['mail.chat_window'].get(chatWindowLocalId)
            )]];
        }

        /**
         *@private
         *@returns{mail.chat_window[]}
         */
        _computeAllOrderedHidden(){
            return[['replace',this.visual.hidden.chatWindowLocalIds.map(chatWindowLocalId=>
                this.env.models['mail.chat_window'].get(chatWindowLocalId)
            )]];
        }

        /**
         *@private
         *@returns{mail.chat_window[]}
         */
        _computeAllOrderedVisible(){
            return[['replace',this.visual.visible.map(({chatWindowLocalId})=>
                this.env.models['mail.chat_window'].get(chatWindowLocalId)
            )]];
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeHasHiddenChatWindows(){
            returnthis.allOrderedHidden.length>0;
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeHasVisibleChatWindows(){
            returnthis.allOrderedVisible.length>0;
        }

        /**
         *@private
         *@returns{mail.chat_window|undefined}
         */
        _computeLastVisible(){
            const{length:l,[l-1]:lastVisible}=this.allOrderedVisible;
            if(!lastVisible){
                return[['unlink']];
            }
            return[['link',lastVisible]];
        }

        /**
         *@private
         *@returns{mail.chat_window|undefined}
         */
        _computeNewMessageChatWindow(){
            constchatWindow=this.allOrdered.find(chatWindow=>!chatWindow.thread);
            if(!chatWindow){
                return[['unlink']];
            }
            return[['link',chatWindow]];
        }

        /**
         *@private
         *@returns{integer}
         */
        _computeUnreadHiddenConversationAmount(){
            constallHiddenWithThread=this.allOrderedHidden.filter(
                chatWindow=>chatWindow.thread
            );
            letamount=0;
            for(constchatWindowofallHiddenWithThread){
                if(chatWindow.thread.localMessageUnreadCounter>0){
                    amount++;
                }
            }
            returnamount;
        }

        /**
         *@private
         *@returns{Object}
         */
        _computeVisual(){
            letvisual=JSON.parse(JSON.stringify(BASE_VISUAL));
            if(!this.env.messaging){
                returnvisual;
            }
            constdevice=this.env.messaging.device;
            constdiscuss=this.env.messaging.discuss;
            constBETWEEN_GAP_WIDTH=5;
            constCHAT_WINDOW_WIDTH=325;
            constEND_GAP_WIDTH=device.isMobile?0:10;
            constGLOBAL_WINDOW_WIDTH=device.globalWindowInnerWidth;
            constHIDDEN_MENU_WIDTH=200;//maxwidth,includingwidthofdropuplistitems
            constSTART_GAP_WIDTH=device.isMobile?0:10;
            constchatWindows=this.allOrdered;
            if(!device.isMobile&&discuss.isOpen){
                returnvisual;
            }
            if(!chatWindows.length){
                returnvisual;
            }
            constrelativeGlobalWindowWidth=GLOBAL_WINDOW_WIDTH-START_GAP_WIDTH-END_GAP_WIDTH;
            letmaxAmountWithoutHidden=Math.floor(
                relativeGlobalWindowWidth/(CHAT_WINDOW_WIDTH+BETWEEN_GAP_WIDTH));
            letmaxAmountWithHidden=Math.floor(
                (relativeGlobalWindowWidth-HIDDEN_MENU_WIDTH-BETWEEN_GAP_WIDTH)/
                (CHAT_WINDOW_WIDTH+BETWEEN_GAP_WIDTH));
            if(device.isMobile){
                maxAmountWithoutHidden=1;
                maxAmountWithHidden=1;
            }
            if(chatWindows.length<=maxAmountWithoutHidden){
                //allvisible
                for(leti=0;i<chatWindows.length;i++){
                    constchatWindowLocalId=chatWindows[i].localId;
                    constoffset=START_GAP_WIDTH+i*(CHAT_WINDOW_WIDTH+BETWEEN_GAP_WIDTH);
                    visual.visible.push({chatWindowLocalId,offset});
                }
                visual.availableVisibleSlots=maxAmountWithoutHidden;
            }elseif(maxAmountWithHidden>0){
                //somevisible,somehidden
                for(leti=0;i<maxAmountWithHidden;i++){
                    constchatWindowLocalId=chatWindows[i].localId;
                    constoffset=START_GAP_WIDTH+i*(CHAT_WINDOW_WIDTH+BETWEEN_GAP_WIDTH);
                    visual.visible.push({chatWindowLocalId,offset});
                }
                if(chatWindows.length>maxAmountWithHidden){
                    visual.hidden.isVisible=!device.isMobile;
                    visual.hidden.offset=visual.visible[maxAmountWithHidden-1].offset
                        +CHAT_WINDOW_WIDTH+BETWEEN_GAP_WIDTH;
                }
                for(letj=maxAmountWithHidden;j<chatWindows.length;j++){
                    visual.hidden.chatWindowLocalIds.push(chatWindows[j].localId);
                }
                visual.availableVisibleSlots=maxAmountWithHidden;
            }else{
                //allhidden
                visual.hidden.isVisible=!device.isMobile;
                visual.hidden.offset=START_GAP_WIDTH;
                visual.hidden.chatWindowLocalIds.concat(chatWindows.map(chatWindow=>chatWindow.localId));
                console.warn('cannotdisplayanyvisiblechatwindows(screenistoosmall)');
                visual.availableVisibleSlots=0;
            }
            returnvisual;
        }

    }

    ChatWindowManager.fields={
        /**
         *Listoforderedchatwindows(listoflocalids)
         */
        _ordered:attr({
            compute:'_compute_ordered',
            default:[],
            dependencies:[
                'chatWindows',
            ],
        }),
        //FIXME:dependentonimplementationthatusesarbitraryorderinrelations!!
        allOrdered:one2many('mail.chat_window',{
            compute:'_computeAllOrdered',
            dependencies:[
                '_ordered',
            ],
        }),
        allOrderedThread:one2many('mail.thread',{
            related:'allOrdered.thread',
        }),
        allOrderedHidden:one2many('mail.chat_window',{
            compute:'_computeAllOrderedHidden',
            dependencies:['visual'],
        }),
        allOrderedHiddenThread:one2many('mail.thread',{
            related:'allOrderedHidden.thread',
        }),
        allOrderedHiddenThreadMessageUnreadCounter:attr({
            related:'allOrderedHiddenThread.localMessageUnreadCounter',
        }),
        allOrderedVisible:one2many('mail.chat_window',{
            compute:'_computeAllOrderedVisible',
            dependencies:['visual'],
        }),
        chatWindows:one2many('mail.chat_window',{
            inverse:'manager',
            isCausal:true,
        }),
        device:one2one('mail.device',{
            related:'messaging.device',
        }),
        deviceGlobalWindowInnerWidth:attr({
            related:'device.globalWindowInnerWidth',
        }),
        deviceIsMobile:attr({
            related:'device.isMobile',
        }),
        discuss:one2one('mail.discuss',{
            related:'messaging.discuss',
        }),
        discussIsOpen:attr({
            related:'discuss.isOpen',
        }),
        hasHiddenChatWindows:attr({
            compute:'_computeHasHiddenChatWindows',
            dependencies:['allOrderedHidden'],
        }),
        hasVisibleChatWindows:attr({
            compute:'_computeHasVisibleChatWindows',
            dependencies:['allOrderedVisible'],
        }),
        isHiddenMenuOpen:attr({
            default:false,
        }),
        lastVisible:many2one('mail.chat_window',{
            compute:'_computeLastVisible',
            dependencies:['allOrderedVisible'],
        }),
        messaging:one2one('mail.messaging',{
            inverse:'chatWindowManager',
        }),
        newMessageChatWindow:one2one('mail.chat_window',{
            compute:'_computeNewMessageChatWindow',
            dependencies:[
                'allOrdered',
                'allOrderedThread',
            ],
        }),
        unreadHiddenConversationAmount:attr({
            compute:'_computeUnreadHiddenConversationAmount',
            dependencies:['allOrderedHiddenThreadMessageUnreadCounter'],
        }),
        visual:attr({
            compute:'_computeVisual',
            default:BASE_VISUAL,
            dependencies:[
                'allOrdered',
                'deviceGlobalWindowInnerWidth',
                'deviceIsMobile',
                'discussIsOpen',
            ],
        }),
    };

    ChatWindowManager.modelName='mail.chat_window_manager';

    returnChatWindowManager;
}

registerNewModel('mail.chat_window_manager',factory);

});

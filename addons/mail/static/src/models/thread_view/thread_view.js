flectra.define('mail/static/src/models/thread_view/thread_view.js',function(require){
'usestrict';

const{registerNewModel}=require('mail/static/src/model/model_core.js');
const{RecordDeletedError}=require('mail/static/src/model/model_errors.js');
const{attr,many2many,many2one,one2one}=require('mail/static/src/model/model_field.js');
const{clear}=require('mail/static/src/model/model_field_command.js');

functionfactory(dependencies){

    classThreadViewextendsdependencies['mail.model']{

        /**
         *@override
         */
        _willDelete(){
            this.env.browser.clearTimeout(this._loaderTimeout);
            returnsuper._willDelete(...arguments);
        }

        //----------------------------------------------------------------------
        //Public
        //----------------------------------------------------------------------

        /**
         *Thisfunctionregisterahintforthecomponentrelatedtothis
         *record.Hintsareinformationonchangesaroundthisviewerthat
         *makerequireadjustmentonthecomponent.Forinstance,ifthis
         *ThreadViewinitiatedathreadcacheloadanditnowhasbecome
         *loaded,thenitmayneedtoauto-scrolltolastmessage.
         *
         *@param{string}hintTypenameofthehint.Usedtodeterminewhat's
         *  thebroadtypeofadjustementthecomponenthastodo.
         *@param{any}[hintData]dataofthehint.Usedtofine-tune
         *  adjustmentsonthecomponent.
         */
        addComponentHint(hintType,hintData){
            consthint={data:hintData,type:hintType};
            this.update({
                componentHintList:this.componentHintList.concat([hint]),
            });
        }

        /**
         *@param{Object}hint
         */
        markComponentHintProcessed(hint){
            this.update({
                componentHintList:this.componentHintList.filter(h=>h!==hint),
            });
            this.env.messagingBus.trigger('o-thread-view-hint-processed',{
                hint,
                threadViewer:this.threadViewer,
            });
        }

        /**
         *@param{mail.message}message
         */
        handleVisibleMessage(message){
            if(!this.lastVisibleMessage||this.lastVisibleMessage.id<message.id){
                this.update({lastVisibleMessage:[['link',message]]});
            }
        }

        //----------------------------------------------------------------------
        //Private
        //----------------------------------------------------------------------

        /**
         *@private
         *@returns{mail.messaging}
         */
        _computeMessaging(){
            return[['link',this.env.messaging]];
        }

        /**
         *@private
         *@returns{string[]}
         */
        _computeTextInputSendShortcuts(){
            if(!this.thread){
                return;
            }
            constisMailingList=this.thread.model==='mail.channel'&&this.thread.mass_mailing;
            //Actuallyinmobilethereisasendbutton,soweneedthere'enter'toallownewline.
            //Hence,wewanttouseadifferentshortcut'ctrl/metaenter'tosendforsmallscreen
            //sizewithanon-mailingchannel.
            //heresendwillbedoneonclickingthebuttonorusingthe'ctrl/metaenter'shortcut.
            if(this.env.messaging.device.isMobile||isMailingList){
                return['ctrl-enter','meta-enter'];
            }
            return['enter'];
        }

        /**
         *@private
         *@returns{integer|undefined}
         */
        _computeThreadCacheInitialScrollHeight(){
            if(!this.threadCache){
                returnclear();
            }
            constthreadCacheInitialScrollHeight=this.threadCacheInitialScrollHeights[this.threadCache.localId];
            if(threadCacheInitialScrollHeight!==undefined){
                returnthreadCacheInitialScrollHeight;
            }
            returnclear();
        }

        /**
         *@private
         *@returns{integer|undefined}
         */
        _computeThreadCacheInitialScrollPosition(){
            if(!this.threadCache){
                returnclear();
            }
            constthreadCacheInitialScrollPosition=this.threadCacheInitialScrollPositions[this.threadCache.localId];
            if(threadCacheInitialScrollPosition!==undefined){
                returnthreadCacheInitialScrollPosition;
            }
            returnclear();
        }

        /**
         *Notarealfield,usedtotrigger`thread.markAsSeen`whenoneof
         *thedependencieschanges.
         *
         *@private
         *@returns{boolean}
         */
        _computeThreadShouldBeSetAsSeen(){
            if(!this.thread){
                return;
            }
            if(!this.thread.lastNonTransientMessage){
                return;
            }
            if(!this.lastVisibleMessage){
                return;
            }
            if(this.lastVisibleMessage!==this.lastMessage){
                return;
            }
            if(!this.hasComposerFocus){
                //FIXMEconditionshouldnotbeon"composerisfocused"but"threadViewisactive"
                //Seetask-2277543
                return;
            }
            this.thread.markAsSeen(this.thread.lastNonTransientMessage).catch(e=>{
                //preventcrashwhenexecutingcomputeduringdestroy
                if(!(einstanceofRecordDeletedError)){
                    throwe;
                }
            });
        }

        /**
         *@private
         */
        _onThreadCacheChanged(){
            if(this.threadCache){
                //clearobsoletehints
                this.update({componentHintList:clear()});
                this.addComponentHint('change-of-thread-cache');
                this.threadCache.update({
                    isCacheRefreshRequested:true,
                    isMarkAllAsReadRequested:true,
                });
                this.update({lastVisibleMessage:[['unlink']]});
            }
        }

        /**
         *@private
         */
        _onThreadCacheIsLoadingChanged(){
            if(this.threadCache&&this.threadCache.isLoading){
                if(!this.isLoading&&!this.isPreparingLoading){
                    this.update({isPreparingLoading:true});
                    this.async(()=>
                        newPromise(resolve=>{
                            this._loaderTimeout=this.env.browser.setTimeout(resolve,400);
                        }
                    )).then(()=>{
                        constisLoading=this.threadCache
                            ?this.threadCache.isLoading
                            :false;
                        this.update({isLoading,isPreparingLoading:false});
                    });
                }
                return;
            }
            this.env.browser.clearTimeout(this._loaderTimeout);
            if(this.thread){
                this.update({isLoading:false,isPreparingLoading:false});
            }
        }
    }

    ThreadView.fields={
        checkedMessages:many2many('mail.message',{
            related:'threadCache.checkedMessages',
        }),
        /**
         *Listofcomponenthints.Hintscontaininformationthathelp
         *componentsmakeUI/UXdecisionsbasedontheirUIstate.
         *Forinstance,onreceivingnewmessagesandthelastmessage
         *isvisible,itshouldauto-scrolltothisnewlastmessage.
         *
         *Formatofacomponenthint:
         *
         *  {
         *      type:{string}thenameofthecomponenthint.Useful
         *                     forcomponentstodispatchbehaviour
         *                     basedonitstype.
         *      data:{Object}datarelatedtothecomponenthint.
         *                     Forinstance,ifhintsuggeststoscroll
         *                     toacertainmessage,datamaycontain
         *                     messageid.
         *  }
         */
        componentHintList:attr({
            default:[],
        }),
        composer:many2one('mail.composer',{
            related:'thread.composer',
        }),
        /**
         *Servesascomputedependency.
         */
        device:one2one('mail.device',{
            related:'messaging.device',
        }),
        /**
         *Servesascomputedependency.
         */
        deviceIsMobile:attr({
            related:'device.isMobile',
        }),
        hasComposerFocus:attr({
            related:'composer.hasFocus',
        }),
        /**
         *Stateswhether`this.threadCache`iscurrentlyloadingmessages.
         *
         *Thisfieldisrelatedto`this.threadCache.isLoading`butwitha
         *delayonitsupdatetoavoidflickeringontheUI.
         *
         *Itiscomputedthrough`_onThreadCacheIsLoadingChanged`anditshould
         *otherwisebeconsideredread-only.
         */
        isLoading:attr({
            default:false,
        }),
        /**
         *Stateswhether`this`isawareof`this.threadCache`currently
         *loadingmessages,but`this`isnotyetreadytodisplaythatloading
         *ontheUI.
         *
         *Thisfieldiscomputedthrough`_onThreadCacheIsLoadingChanged`and
         *itshouldotherwisebeconsideredread-only.
         *
         *@see`this.isLoading`
         */
        isPreparingLoading:attr({
            default:false,
        }),
        /**
         *Determineswhether`this`shouldautomaticallyscrollonreceiving
         *anewmessage.Detectionofnewmessageisdonethroughthecomponent
         *hint`message-received`.
         */
        hasAutoScrollOnMessageReceived:attr({
            default:true,
        }),
        /**
         *Lastmessageinthecontextofthecurrentlydisplayedthreadcache.
         */
        lastMessage:many2one('mail.message',{
            related:'thread.lastMessage',
        }),
        /**
         *Servesascomputedependency.
         */
        lastNonTransientMessage:many2one('mail.message',{
            related:'thread.lastNonTransientMessage',
        }),
        /**
         *MostrecentmessageinthisThreadViewthathasbeenshowntothe
         *currentpartnerinthecurrentlydisplayedthreadcache.
         */
        lastVisibleMessage:many2one('mail.message'),
        messages:many2many('mail.message',{
            related:'threadCache.messages',
        }),
        /**
         *Servesascomputedependency.
         */
        messaging:many2one('mail.messaging',{
            compute:'_computeMessaging',
        }),
        nonEmptyMessages:many2many('mail.message',{
            related:'threadCache.nonEmptyMessages',
        }),
        /**
         *Notarealfield,usedtotrigger`_onThreadCacheChanged`whenoneof
         *thedependencieschanges.
         */
        onThreadCacheChanged:attr({
            compute:'_onThreadCacheChanged',
            dependencies:[
                'threadCache'
            ],
        }),
        /**
         *Notarealfield,usedtotrigger`_onThreadCacheIsLoadingChanged`
         *whenoneofthedependencieschanges.
         *
         *@see`this.isLoading`
         */
        onThreadCacheIsLoadingChanged:attr({
            compute:'_onThreadCacheIsLoadingChanged',
            dependencies:[
                'threadCache',
                'threadCacheIsLoading',
            ],
        }),
        /**
         *Determinesthedomaintoapplywhenfetchingmessagesfor`this.thread`.
         */
        stringifiedDomain:attr({
            related:'threadViewer.stringifiedDomain',
        }),
        /**
         *Determinesthekeyboardshortcutsthatareavailabletosendamessage
         *fromthecomposerofthisthreadviewer.
         */
        textInputSendShortcuts:attr({
            compute:'_computeTextInputSendShortcuts',
            dependencies:[
                'device',
                'deviceIsMobile',
                'thread',
                'threadMassMailing',
                'threadModel',
            ],
        }),
        /**
         *Determinesthe`mail.thread`currentlydisplayedby`this`.
         */
        thread:many2one('mail.thread',{
            inverse:'threadViews',
            related:'threadViewer.thread',
        }),
        /**
         *Statesthe`mail.thread_cache`currentlydisplayedby`this`.
         */
        threadCache:many2one('mail.thread_cache',{
            inverse:'threadViews',
            related:'threadViewer.threadCache',
        }),
        threadCacheInitialScrollHeight:attr({
            compute:'_computeThreadCacheInitialScrollHeight',
            dependencies:[
                'threadCache',
                'threadCacheInitialScrollHeights',
            ],
        }),
        threadCacheInitialScrollPosition:attr({
            compute:'_computeThreadCacheInitialScrollPosition',
            dependencies:[
                'threadCache',
                'threadCacheInitialScrollPositions',
            ],
        }),
        /**
         *Servesascomputedependency.
         */
        threadCacheIsLoading:attr({
            related:'threadCache.isLoading',
        }),
        /**
         *Listofsavedinitialscrollheightsofthreadcaches.
         */
        threadCacheInitialScrollHeights:attr({
            default:{},
            related:'threadViewer.threadCacheInitialScrollHeights',
        }),
        /**
         *Listofsavedinitialscrollpositionsofthreadcaches.
         */
        threadCacheInitialScrollPositions:attr({
            default:{},
            related:'threadViewer.threadCacheInitialScrollPositions',
        }),
        /**
         *Servesascomputedependency.
         */
        threadMassMailing:attr({
            related:'thread.mass_mailing',
        }),
        /**
         *Servesascomputedependency.
         */
        threadModel:attr({
            related:'thread.model',
        }),
        /**
         *Notarealfield,usedtotrigger`thread.markAsSeen`whenoneof
         *thedependencieschanges.
         */
        threadShouldBeSetAsSeen:attr({
            compute:'_computeThreadShouldBeSetAsSeen',
            dependencies:[
                'hasComposerFocus',
                'lastMessage',
                'lastNonTransientMessage',
                'lastVisibleMessage',
                'threadCache',
            ],
        }),
        /**
         *Determinesthe`mail.thread_viewer`currentlymanaging`this`.
         */
        threadViewer:one2one('mail.thread_viewer',{
            inverse:'threadView',
        }),
        uncheckedMessages:many2many('mail.message',{
            related:'threadCache.uncheckedMessages',
        }),
    };

    ThreadView.modelName='mail.thread_view';

    returnThreadView;
}

registerNewModel('mail.thread_view',factory);

});

flectra.define('mail/static/src/models/partner/partner.js',function(require){
'usestrict';

const{registerNewModel}=require('mail/static/src/model/model_core.js');
const{attr,many2many,many2one,one2many,one2one}=require('mail/static/src/model/model_field.js');
const{cleanSearchTerm}=require('mail/static/src/utils/utils.js');

functionfactory(dependencies){

    classPartnerextendsdependencies['mail.model']{

        //----------------------------------------------------------------------
        //Public
        //----------------------------------------------------------------------

        /**
         *@static
         *@private
         *@param{Object}data
         *@return{Object}
         */
        staticconvertData(data){
            constdata2={};
            if('active'indata){
                data2.active=data.active;
            }
            if('country'indata){
                if(!data.country){
                    data2.country=[['unlink-all']];
                }else{
                    data2.country=[['insert',{
                        id:data.country[0],
                        name:data.country[1],
                    }]];
                }
            }
            if('display_name'indata){
                data2.display_name=data.display_name;
            }
            if('email'indata){
                data2.email=data.email;
            }
            if('id'indata){
                data2.id=data.id;
            }
            if('im_status'indata){
                data2.im_status=data.im_status;
            }
            if('name'indata){
                data2.name=data.name;
            }

            //relation
            if('user_id'indata){
                if(!data.user_id){
                    data2.user=[['unlink-all']];
                }else{
                    letuser={};
                    if(Array.isArray(data.user_id)){
                        user={
                            id:data.user_id[0],
                            display_name:data.user_id[1],
                        };
                    }else{
                        user={
                            id:data.user_id,
                        };
                    }
                    user.isInternalUser=data.is_internal_user;
                    data2.user=[['insert',user]];
                }
            }

            returndata2;
        }

        /**
         *Fetchespartnersmatchingthegivensearchtermtoextendthe
         *JSknowledgeandtoupdatethesuggestionlistaccordingly.
         *
         *@static
         *@param{string}searchTerm
         *@param{Object}[options={}]
         *@param{mail.thread}[options.thread]prioritizeand/orrestrict
         * resultinthecontextofgiventhread
         */
        staticasyncfetchSuggestions(searchTerm,{thread}={}){
            constkwargs={search:searchTerm};
            constisNonPublicChannel=thread&&thread.model==='mail.channel'&&thread.public!=='public';
            if(isNonPublicChannel){
                kwargs.channel_id=thread.id;
            }
            const[
                mainSuggestedPartners,
                extraSuggestedPartners,
            ]=awaitthis.env.services.rpc(
                {
                    model:'res.partner',
                    method:'get_mention_suggestions',
                    kwargs,
                },
                {shadow:true},
            );
            constpartnersData=mainSuggestedPartners.concat(extraSuggestedPartners);
            constpartners=this.env.models['mail.partner'].insert(partnersData.map(data=>
                this.env.models['mail.partner'].convertData(data)
            ));
            if(isNonPublicChannel){
                thread.update({members:[['link',partners]]});
            }
        }

        /**
         *Searchforpartnersmatching`keyword`.
         *
         *@static
         *@param{Object}param0
         *@param{function}param0.callback
         *@param{string}param0.keyword
         *@param{integer}[param0.limit=10]
         */
        staticasyncimSearch({callback,keyword,limit=10}){
            //prefetchedpartners
            letpartners=[];
            constcleanedSearchTerm=cleanSearchTerm(keyword);
            constcurrentPartner=this.env.messaging.currentPartner;
            for(constpartnerofthis.all(partner=>partner.active)){
                if(partners.length<limit){
                    if(
                        partner!==currentPartner&&
                        partner.name&&
                        partner.user&&
                        cleanSearchTerm(partner.name).includes(cleanedSearchTerm)
                    ){
                        partners.push(partner);
                    }
                }
            }
            if(!partners.length){
                constpartnersData=awaitthis.env.services.rpc(
                    {
                        model:'res.partner',
                        method:'im_search',
                        args:[keyword,limit]
                    },
                    {shadow:true}
                );
                constnewPartners=this.insert(partnersData.map(
                    partnerData=>this.convertData(partnerData)
                ));
                partners.push(...newPartners);
            }
            callback(partners);
        }

        /**
         *Returnspartnersthatmatchthegivensearchterm.
         *
         *@static
         *@param{string}searchTerm
         *@param{Object}[options={}]
         *@param{mail.thread}[options.thread]prioritizeand/orrestrict
         * resultinthecontextofgiventhread
         *@returns{[mail.partner[],mail.partner[]]}
         */
        staticsearchSuggestions(searchTerm,{thread}={}){
            letpartners;
            constisNonPublicChannel=thread&&thread.model==='mail.channel'&&thread.public!=='public';
            if(isNonPublicChannel){
                //Onlyreturnthechannelmemberswheninthecontextofa
                //non-publicchannel.Indeed,themessagewiththemention
                //wouldbenotifiedtothementionedpartner,sothisprevents
                //frominadvertentlyleakingtheprivatemessagetothe
                //mentionedpartner.
                partners=thread.members;
            }else{
                partners=this.env.models['mail.partner'].all();
            }
            constcleanedSearchTerm=cleanSearchTerm(searchTerm);
            constmainSuggestionList=[];
            constextraSuggestionList=[];
            for(constpartnerofpartners){
                if(
                    (!partner.active&&partner!==this.env.messaging.partnerRoot)||
                    partner.id<=0||
                    this.env.messaging.publicPartners.includes(partner)
                ){
                    //ignorearchivedpartners(exceptFlectraBot),temporary
                    //partners(livechatguests),publicpartners(technical)
                    continue;
                }
                if(!partner.name){
                    continue;
                }
                if(
                    (cleanSearchTerm(partner.name).includes(cleanedSearchTerm))||
                    (partner.email&&cleanSearchTerm(partner.email).includes(cleanedSearchTerm))
                ){
                    if(partner.user){
                        mainSuggestionList.push(partner);
                    }else{
                        extraSuggestionList.push(partner);
                    }
                }
            }
            return[mainSuggestionList,extraSuggestionList];
        }

        /**
         *@static
         */
        staticasyncstartLoopFetchImStatus(){
            awaitthis._fetchImStatus();
            this._loopFetchImStatus();
        }

        /**
         *Checkswhetherthispartnerhasarelateduserandlinksthemif
         *applicable.
         */
        asynccheckIsUser(){
            constuserIds=awaitthis.async(()=>this.env.services.rpc({
                model:'res.users',
                method:'search',
                args:[[['partner_id','=',this.id]]],
                kwargs:{
                    context:{active_test:false},
                },
            },{shadow:true}));
            this.update({hasCheckedUser:true});
            if(userIds.length>0){
                this.update({user:[['insert',{id:userIds[0]}]]});
            }
        }

        /**
         *Getsthechatbetweentheuserofthispartnerandthecurrentuser.
         *
         *Ifachatisnotappropriate,anotificationisdisplayedinstead.
         *
         *@returns{mail.thread|undefined}
         */
        asyncgetChat(){
            if(!this.user&&!this.hasCheckedUser){
                awaitthis.async(()=>this.checkIsUser());
            }
            //preventchattingwithnon-users
            if(!this.user){
                this.env.services['notification'].notify({
                    message:this.env._t("Youcanonlychatwithpartnersthathaveadedicateduser."),
                    type:'info',
                });
                return;
            }
            returnthis.user.getChat();
        }

        /**
         *Returnsthetextthatidentifiesthispartnerinamention.
         *
         *@returns{string}
         */
        getMentionText(){
            returnthis.name;
        }

        /**
         *Returnsasortfunctiontodeterminetheorderofdisplayofpartners
         *inthesuggestionlist.
         *
         *@static
         *@param{string}searchTerm
         *@param{Object}[options={}]
         *@param{mail.thread}[options.thread]prioritizeresultinthe
         * contextofgiventhread
         *@returns{function}
         */
        staticgetSuggestionSortFunction(searchTerm,{thread}={}){
            constcleanedSearchTerm=cleanSearchTerm(searchTerm);
            return(a,b)=>{
                constisAInternalUser=a.user&&a.user.isInternalUser;
                constisBInternalUser=b.user&&b.user.isInternalUser;
                if(isAInternalUser&&!isBInternalUser){
                    return-1;
                }
                if(!isAInternalUser&&isBInternalUser){
                    return1;
                }
                if(thread&&thread.model==='mail.channel'){
                    constisAMember=thread.members.includes(a);
                    constisBMember=thread.members.includes(b);
                    if(isAMember&&!isBMember){
                        return-1;
                    }
                    if(!isAMember&&isBMember){
                        return1;
                    }
                }
                if(thread){
                    constisAFollower=thread.followersPartner.includes(a);
                    constisBFollower=thread.followersPartner.includes(b);
                    if(isAFollower&&!isBFollower){
                        return-1;
                    }
                    if(!isAFollower&&isBFollower){
                        return1;
                    }
                }
                constcleanedAName=cleanSearchTerm(a.name||'');
                constcleanedBName=cleanSearchTerm(b.name||'');
                if(cleanedAName.startsWith(cleanedSearchTerm)&&!cleanedBName.startsWith(cleanedSearchTerm)){
                    return-1;
                }
                if(!cleanedAName.startsWith(cleanedSearchTerm)&&cleanedBName.startsWith(cleanedSearchTerm)){
                    return1;
                }
                if(cleanedAName<cleanedBName){
                    return-1;
                }
                if(cleanedAName>cleanedBName){
                    return1;
                }
                constcleanedAEmail=cleanSearchTerm(a.email||'');
                constcleanedBEmail=cleanSearchTerm(b.email||'');
                if(cleanedAEmail.startsWith(cleanedSearchTerm)&&!cleanedAEmail.startsWith(cleanedSearchTerm)){
                    return-1;
                }
                if(!cleanedBEmail.startsWith(cleanedSearchTerm)&&cleanedBEmail.startsWith(cleanedSearchTerm)){
                    return1;
                }
                if(cleanedAEmail<cleanedBEmail){
                    return-1;
                }
                if(cleanedAEmail>cleanedBEmail){
                    return1;
                }
                returna.id-b.id;
            };
        }

        /**
         *Opensachatbetweentheuserofthispartnerandthecurrentuser
         *andreturnsit.
         *
         *Ifachatisnotappropriate,anotificationisdisplayedinstead.
         *
         *@param{Object}[options]forwardedto@see`mail.thread:open()`
         *@returns{mail.thread|undefined}
         */
        asyncopenChat(options){
            constchat=awaitthis.async(()=>this.getChat());
            if(!chat){
                return;
            }
            awaitthis.async(()=>chat.open(options));
            returnchat;
        }

        /**
         *Opensthemostappropriateviewthatisaprofileforthispartner.
         */
        asyncopenProfile(){
            returnthis.env.messaging.openDocument({
                id:this.id,
                model:'res.partner',
            });
        }

        //----------------------------------------------------------------------
        //Private
        //----------------------------------------------------------------------

        /**
         *@private
         *@returns{string}
         */
        _computeAvatarUrl(){
            return`/web/image/res.partner/${this.id}/image_128`;
        }

        /**
         *@override
         */
        static_createRecordLocalId(data){
            return`${this.modelName}_${data.id}`;
        }

        /**
         *@static
         *@private
         */
        staticasync_fetchImStatus(){
            constpartnerIds=[];
            for(constpartnerofthis.all()){
                if(partner.im_status!=='im_partner'&&partner.id>0){
                    partnerIds.push(partner.id);
                }
            }
            if(partnerIds.length===0){
                return;
            }
            constdataList=awaitthis.env.services.rpc({
                route:'/longpolling/im_status',
                params:{
                    partner_ids:partnerIds,
                },
            },{shadow:true});
            this.insert(dataList);
        }

        /**
         *@static
         *@private
         */
        static_loopFetchImStatus(){
            setTimeout(async()=>{
                awaitthis._fetchImStatus();
                this._loopFetchImStatus();
            },50*1000);
        }

        /**
         *@private
         *@returns{string|undefined}
         */
        _computeDisplayName(){
            returnthis.display_name||this.user&&this.user.display_name;
        }

        /**
         *@private
         *@returns{mail.messaging}
         */
        _computeMessaging(){
            return[['link',this.env.messaging]];
        }

        /**
         *@private
         *@returns{string|undefined}
         */
        _computeNameOrDisplayName(){
            returnthis.name||this.display_name;
        }

    }

    Partner.fields={
        active:attr({
            default:true,
        }),
        avatarUrl:attr({
            compute:'_computeAvatarUrl',
            dependencies:[
                'id',
            ],
        }),
        correspondentThreads:one2many('mail.thread',{
            inverse:'correspondent',
        }),
        country:many2one('mail.country'),
        /**
         *Deprecated.
         *Statesthe`display_name`ofthispartner,asreturnedbytheserver.
         *Thevalueofthisfieldisunreliable(notablyitsvaluedependson
         *contextonwhichitwasreceived)thereforeitshouldonlybeusedas
         *adefaultiftheactual`name`ismissing(@see`nameOrDisplayName`).
         *Andifaspecificnameformatisrequired,itshouldbecomputedfrom
         *relevantfieldsinstead.
         */
        display_name:attr({
            compute:'_computeDisplayName',
            default:"",
            dependencies:[
                'display_name',
                'userDisplayName',
            ],
        }),
        email:attr(),
        failureNotifications:one2many('mail.notification',{
            related:'messagesAsAuthor.failureNotifications',
        }),
        /**
         *Whetheranattemptwasalreadymadetofetchtheusercorresponding
         *tothispartner.ThispreventsdoingthesameRPCmultipletimes.
         */
        hasCheckedUser:attr({
            default:false,
        }),
        id:attr(),
        im_status:attr(),
        memberThreads:many2many('mail.thread',{
            inverse:'members',
        }),
        messagesAsAuthor:one2many('mail.message',{
            inverse:'author',
        }),
        /**
         *Servesascomputedependency.
         */
        messaging:many2one('mail.messaging',{
            compute:'_computeMessaging',
        }),
        model:attr({
            default:'res.partner',
        }),
        /**
         *Channelsthataremoderatedbythispartner.
         */
        moderatedChannels:many2many('mail.thread',{
            inverse:'moderators',
        }),
        name:attr(),
        nameOrDisplayName:attr({
            compute:'_computeNameOrDisplayName',
            dependencies:[
                'display_name',
                'name',
            ],
        }),
        user:one2one('mail.user',{
            inverse:'partner',
        }),
        /**
         *Servesascomputedependency.
         */
        userDisplayName:attr({
            related:'user.display_name',
        }),
    };

    Partner.modelName='mail.partner';

    returnPartner;
}

registerNewModel('mail.partner',factory);

});

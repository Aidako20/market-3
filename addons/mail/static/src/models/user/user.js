flectra.define('mail/static/src/models/user/user.js',function(require){
'usestrict';

const{registerNewModel}=require('mail/static/src/model/model_core.js');
const{attr,one2one}=require('mail/static/src/model/model_field.js');

functionfactory(dependencies){

    classUserextendsdependencies['mail.model']{

        /**
         *@override
         */
        _willDelete(){
            if(this.env.messaging){
                if(this===this.env.messaging.currentUser){
                    this.env.messaging.update({currentUser:[['unlink']]});
                }
            }
            returnsuper._willDelete(...arguments);
        }

        //----------------------------------------------------------------------
        //Public
        //----------------------------------------------------------------------

        /**
         *@static
         *@param{Object}data
         *@returns{Object}
         */
        staticconvertData(data){
            constdata2={};
            if('id'indata){
                data2.id=data.id;
            }
            if('partner_id'indata){
                if(!data.partner_id){
                    data2.partner=[['unlink']];
                }else{
                    constpartnerNameGet=data['partner_id'];
                    constpartnerData={
                        display_name:partnerNameGet[1],
                        id:partnerNameGet[0],
                    };
                    data2.partner=[['insert',partnerData]];
                }
            }
            returndata2;
        }

        /**
         *Performsthe`read`RPCon`res.users`.
         *
         *@static
         *@param{Object}param0
         *@param{Object}param0.context
         *@param{string[]}param0.fields
         *@param{integer[]}param0.ids
         */
        staticasyncperformRpcRead({context,fields,ids}){
            constusersData=awaitthis.env.services.rpc({
                model:'res.users',
                method:'read',
                args:[ids,fields],
                kwargs:{
                    context,
                },
            },{shadow:true});
            returnthis.env.models['mail.user'].insert(usersData.map(userData=>
                this.env.models['mail.user'].convertData(userData)
            ));
        }

        /**
         *Fetchesthepartnerofthisuser.
         */
        asyncfetchPartner(){
            returnthis.env.models['mail.user'].performRpcRead({
                ids:[this.id],
                fields:['partner_id'],
                context:{active_test:false},
            });
        }

        /**
         *Getsthechatbetweenthisuserandthecurrentuser.
         *
         *Ifachatisnotappropriate,anotificationisdisplayedinstead.
         *
         *@returns{mail.thread|undefined}
         */
        asyncgetChat(){
            if(!this.partner){
                awaitthis.async(()=>this.fetchPartner());
            }
            if(!this.partner){
                //Thisuserhasbeendeletedfromtheserverorneverexisted:
                //-Validityofidisnotverifiedatinsert.
                //-Thereisnobusnotificationincaseofuserdeletefrom
                //  anothertaborbyanotheruser.
                this.env.services['notification'].notify({
                    message:this.env._t("Youcanonlychatwithexistingusers."),
                    type:'warning',
                });
                return;
            }
            //inothercasesachatwouldbevalid,finditortrytocreateit
            letchat=this.env.models['mail.thread'].find(thread=>
                thread.channel_type==='chat'&&
                thread.correspondent===this.partner&&
                thread.model==='mail.channel'&&
                thread.public==='private'
            );
            if(!chat||!chat.isPinned){
                //ifchatisnotpinnedthenithastobepinnedclient-side
                //andserver-side,whichisasideeffectoffollowingrpc
                chat=awaitthis.async(()=>
                    this.env.models['mail.thread'].performRpcCreateChat({
                        partnerIds:[this.partner.id],
                    })
                );
            }
            if(!chat){
                this.env.services['notification'].notify({
                    message:this.env._t("Anunexpectederroroccurredduringthecreationofthechat."),
                    type:'warning',
                });
                return;
            }
            returnchat;
        }

        /**
         *Opensachatbetweenthisuserandthecurrentuserandreturnsit.
         *
         *Ifachatisnotappropriate,anotificationisdisplayedinstead.
         *
         *@param{Object}[options]forwardedto@see`mail.thread:open()`
         *@returns{mail.thread|undefined}
         */
        asyncopenChat(options){
            constchat=awaitthis.async(()=>this.getChat());
            if(!chat){
                return;
            }
            awaitthis.async(()=>chat.open(options));
            returnchat;
        }

        /**
         *Opensthemostappropriateviewthatisaprofileforthisuser.
         *Becauseuserisarathertechnicalmodeltoallowlogin,it'sthe
         *partnerprofilethatcontainsthemostusefulinformation.
         *
         *@override
         */
        asyncopenProfile(){
            if(!this.partner){
                awaitthis.async(()=>this.fetchPartner());
            }
            if(!this.partner){
                //Thisuserhasbeendeletedfromtheserverorneverexisted:
                //-Validityofidisnotverifiedatinsert.
                //-Thereisnobusnotificationincaseofuserdeletefrom
                //  anothertaborbyanotheruser.
                this.env.services['notification'].notify({
                    message:this.env._t("Youcanonlyopentheprofileofexistingusers."),
                    type:'warning',
                });
                return;
            }
            returnthis.partner.openProfile();
        }

        //----------------------------------------------------------------------
        //Private
        //----------------------------------------------------------------------

        /**
         *@override
         */
        static_createRecordLocalId(data){
            return`${this.modelName}_${data.id}`;
        }

        /**
         *@private
         *@returns{string|undefined}
         */
        _computeDisplayName(){
            returnthis.display_name||this.partner&&this.partner.display_name;
        }

        /**
         *@private
         *@returns{string|undefined}
         */
        _computeNameOrDisplayName(){
            returnthis.partner&&this.partner.nameOrDisplayName||this.display_name;
        }
    }

    User.fields={
        id:attr(),
        /**
         *Determineswhetherthisuserisaninternaluser.Aninternaluseris
         *amemberofthegroup`base.group_user`.Thisistheinverseofthe
         *`share`fieldinpython.
         */
        isInternalUser:attr(),
        display_name:attr({
            compute:'_computeDisplayName',
            dependencies:[
                'display_name',
                'partnerDisplayName',
            ],
        }),
        model:attr({
            default:'res.user',
        }),
        nameOrDisplayName:attr({
            compute:'_computeNameOrDisplayName',
            dependencies:[
                'display_name',
                'partnerNameOrDisplayName',
            ]
        }),
        partner:one2one('mail.partner',{
            inverse:'user',
        }),
        /**
         *Servesascomputedependency.
         */
        partnerDisplayName:attr({
            related:'partner.display_name',
        }),
        /**
         *Servesascomputedependency.
         */
        partnerNameOrDisplayName:attr({
            related:'partner.nameOrDisplayName',
        }),
    };

    User.modelName='mail.user';

    returnUser;
}

registerNewModel('mail.user',factory);

});

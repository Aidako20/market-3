flectra.define('mail/static/src/models/message_seen_indicator/message_seen_indicator.js',function(require){
'usestrict';

const{registerNewModel}=require('mail/static/src/model/model_core.js');
const{attr,many2many,many2one,one2many}=require('mail/static/src/model/model_field.js');

functionfactory(dependencies){

    classMessageSeenIndicatorextendsdependencies['mail.model']{

        //----------------------------------------------------------------------
        //Public
        //----------------------------------------------------------------------

        /**
         *@static
         *@param{mail.thread}[channel]theconcernedthread
         */
        staticrecomputeFetchedValues(channel=undefined){
            constindicatorFindFunction=channel?localIndicator=>localIndicator.thread===channel:undefined;
            constindicators=this.env.models['mail.message_seen_indicator'].all(indicatorFindFunction);
            for(constindicatorofindicators){
                indicator.update({
                    hasEveryoneFetched:indicator._computeHasEveryoneFetched(),
                    hasSomeoneFetched:indicator._computeHasSomeoneFetched(),
                    partnersThatHaveFetched:indicator._computePartnersThatHaveFetched(),
                });
            }
        }

        /**
         *@static
         *@param{mail.thread}[channel]theconcernedthread
         */
        staticrecomputeSeenValues(channel=undefined){
            constindicatorFindFunction=channel?localIndicator=>localIndicator.thread===channel:undefined;
            constindicators=this.env.models['mail.message_seen_indicator'].all(indicatorFindFunction);
            for(constindicatorofindicators){
                indicator.update({
                    hasEveryoneSeen:indicator._computeHasEveryoneSeen(),
                    hasSomeoneFetched:indicator._computeHasSomeoneFetched(),
                    hasSomeoneSeen:indicator._computeHasSomeoneSeen(),
                    isMessagePreviousToLastCurrentPartnerMessageSeenByEveryone:
                        indicator._computeIsMessagePreviousToLastCurrentPartnerMessageSeenByEveryone(),
                    partnersThatHaveFetched:indicator._computePartnersThatHaveFetched(),
                    partnersThatHaveSeen:indicator._computePartnersThatHaveSeen(),
                });
            }
        }

        //----------------------------------------------------------------------
        //Private
        //----------------------------------------------------------------------

        /**
         *@override
         */
        static_createRecordLocalId(data){
            const{channelId,messageId}=data;
            return`${this.modelName}_${channelId}_${messageId}`;
        }

        /**
         *Manuallycalledasnotalwayscalledwhennecessary
         *
         *@private
         *@returns{boolean}
         *@seecomputeFetchedValues
         *@seecomputeSeenValues
         */
        _computeHasEveryoneFetched(){
            if(!this.message||!this.thread||!this.thread.partnerSeenInfos){
                returnfalse;
            }
            constotherPartnerSeenInfosDidNotFetch=
                this.thread.partnerSeenInfos.filter(partnerSeenInfo=>
                    partnerSeenInfo.partner!==this.message.author&&
                    (
                        !partnerSeenInfo.lastFetchedMessage||
                        partnerSeenInfo.lastFetchedMessage.id<this.message.id
                    )
            );
            returnotherPartnerSeenInfosDidNotFetch.length===0;
        }

        /**
         *Manuallycalledasnotalwayscalledwhennecessary
         *
         *@private
         *@returns{boolean}
         *@seecomputeSeenValues
         */
        _computeHasEveryoneSeen(){
            if(!this.message||!this.thread||!this.thread.partnerSeenInfos){
                returnfalse;
            }
            constotherPartnerSeenInfosDidNotSee=
                this.thread.partnerSeenInfos.filter(partnerSeenInfo=>
                    partnerSeenInfo.partner!==this.message.author&&
                    (
                        !partnerSeenInfo.lastSeenMessage||
                        partnerSeenInfo.lastSeenMessage.id<this.message.id
                    )
            );
            returnotherPartnerSeenInfosDidNotSee.length===0;
        }

        /**
         *Manuallycalledasnotalwayscalledwhennecessary
         *
         *@private
         *@returns{boolean}
         *@seecomputeFetchedValues
         *@seecomputeSeenValues
         */
        _computeHasSomeoneFetched(){
            if(!this.message||!this.thread||!this.thread.partnerSeenInfos){
                returnfalse;
            }
            constotherPartnerSeenInfosFetched=
                this.thread.partnerSeenInfos.filter(partnerSeenInfo=>
                    partnerSeenInfo.partner!==this.message.author&&
                    partnerSeenInfo.lastFetchedMessage&&
                    partnerSeenInfo.lastFetchedMessage.id>=this.message.id
            );
            returnotherPartnerSeenInfosFetched.length>0;
        }

        /**
         *Manuallycalledasnotalwayscalledwhennecessary
         *
         *@private
         *@returns{boolean}
         *@seecomputeSeenValues
         */
        _computeHasSomeoneSeen(){
            if(!this.message||!this.thread||!this.thread.partnerSeenInfos){
                returnfalse;
            }
            constotherPartnerSeenInfosSeen=
                this.thread.partnerSeenInfos.filter(partnerSeenInfo=>
                    partnerSeenInfo.partner!==this.message.author&&
                    partnerSeenInfo.lastSeenMessage&&
                    partnerSeenInfo.lastSeenMessage.id>=this.message.id
            );
            returnotherPartnerSeenInfosSeen.length>0;
        }

        /**
         *Manuallycalledasnotalwayscalledwhennecessary
         *
         *@private
         *@returns{boolean}
         *@seecomputeSeenValues
         */
        _computeIsMessagePreviousToLastCurrentPartnerMessageSeenByEveryone(){
            if(
                !this.message||
                !this.thread||
                !this.thread.lastCurrentPartnerMessageSeenByEveryone
            ){
                returnfalse;
            }
            returnthis.message.id<this.thread.lastCurrentPartnerMessageSeenByEveryone.id;
        }

        /**
         *Manuallycalledasnotalwayscalledwhennecessary
         *
         *@private
         *@returns{mail.partner[]}
         *@seecomputeFetchedValues
         *@seecomputeSeenValues
         */
        _computePartnersThatHaveFetched(){
            if(!this.message||!this.thread||!this.thread.partnerSeenInfos){
                return[['unlink-all']];
            }
            constotherPartnersThatHaveFetched=this.thread.partnerSeenInfos
                .filter(partnerSeenInfo=>
                    /**
                     *Relationmaynotbesetyetimmediately
                     *@seemail.thread_partner_seen_info:partnerIdfield
                     *FIXMEtask-2278551
                     */
                    partnerSeenInfo.partner&&
                    partnerSeenInfo.partner!==this.message.author&&
                    partnerSeenInfo.lastFetchedMessage&&
                    partnerSeenInfo.lastFetchedMessage.id>=this.message.id
                )
                .map(partnerSeenInfo=>partnerSeenInfo.partner);
            if(otherPartnersThatHaveFetched.length===0){
                return[['unlink-all']];
            }
            return[['replace',otherPartnersThatHaveFetched]];
        }

        /**
         *Manuallycalledasnotalwayscalledwhennecessary
         *
         *@private
         *@returns{mail.partner[]}
         *@seecomputeSeenValues
         */
        _computePartnersThatHaveSeen(){
            if(!this.message||!this.thread||!this.thread.partnerSeenInfos){
                return[['unlink-all']];
            }
            constotherPartnersThatHaveSeen=this.thread.partnerSeenInfos
                .filter(partnerSeenInfo=>
                    /**
                     *Relationmaynotbesetyetimmediately
                     *@seemail.thread_partner_seen_info:partnerIdfield
                     *FIXMEtask-2278551
                     */
                    partnerSeenInfo.partner&&
                    partnerSeenInfo.partner!==this.message.author&&
                    partnerSeenInfo.lastSeenMessage&&
                    partnerSeenInfo.lastSeenMessage.id>=this.message.id)
                .map(partnerSeenInfo=>partnerSeenInfo.partner);
            if(otherPartnersThatHaveSeen.length===0){
                return[['unlink-all']];
            }
            return[['replace',otherPartnersThatHaveSeen]];
        }

        /**
         *@private
         *@returns{mail.message}
         */
        _computeMessage(){
            return[['insert',{id:this.messageId}]];
        }

        /**
         *@private
         *@returns{mail.thread}
         */
        _computeThread(){
            return[['insert',{
                id:this.channelId,
                model:'mail.channel',
            }]];
        }
    }

    MessageSeenIndicator.modelName='mail.message_seen_indicator';

    MessageSeenIndicator.fields={
        /**
         *Theidofthechannelthisseenindicatorisrelatedto.
         *
         *Shouldwriteonthisfieldtosetrelationbetweenthechanneland
         *thisseenindicator,noton`thread`.
         *
         *Reasonfornotsettingtherelationdirectlyisthenecessityto
         *uniquelyidentifyaseenindicatorbasedonchannelandmessagefromdata.
         *Relationaldataarelistofcommands,whichisproblematictodeduce
         *identifyingrecords.
         *
         *TODO:task-2322536(normalizerelationaldata)&task-2323665
         *(requiredfields)shouldimproveandletusjustusetherelational
         *fields.
         */
        channelId:attr(),
        hasEveryoneFetched:attr({
            compute:'_computeHasEveryoneFetched',
            default:false,
            dependencies:['messageAuthor','messageId','threadPartnerSeenInfos'],
        }),
        hasEveryoneSeen:attr({
            compute:'_computeHasEveryoneSeen',
            default:false,
            dependencies:['messageAuthor','messageId','threadPartnerSeenInfos'],
        }),
        hasSomeoneFetched:attr({
            compute:'_computeHasSomeoneFetched',
            default:false,
            dependencies:['messageAuthor','messageId','threadPartnerSeenInfos'],
        }),
        hasSomeoneSeen:attr({
            compute:'_computeHasSomeoneSeen',
            default:false,
            dependencies:['messageAuthor','messageId','threadPartnerSeenInfos'],
        }),
        id:attr(),
        isMessagePreviousToLastCurrentPartnerMessageSeenByEveryone:attr({
            compute:'_computeIsMessagePreviousToLastCurrentPartnerMessageSeenByEveryone',
            default:false,
            dependencies:[
                'messageId',
                'threadLastCurrentPartnerMessageSeenByEveryone',
            ],
        }),
        /**
         *Themessageconcernedbythisseenindicator.
         *ThisisautomaticallycomputedbasedonmessageIdfield.
         *@seemessageId
         */
        message:many2one('mail.message',{
            compute:'_computeMessage',
            dependencies:[
                'messageId',
            ],
        }),
        messageAuthor:many2one('mail.partner',{
            related:'message.author',
        }),
        /**
         *Theidofthemessagethisseenindicatorisrelatedto.
         *
         *Shouldwriteonthisfieldtosetrelationbetweenthechanneland
         *thisseenindicator,noton`message`.
         *
         *Reasonfornotsettingtherelationdirectlyisthenecessityto
         *uniquelyidentifyaseenindicatorbasedonchannelandmessagefromdata.
         *Relationaldataarelistofcommands,whichisproblematictodeduce
         *identifyingrecords.
         *
         *TODO:task-2322536(normalizerelationaldata)&task-2323665
         *(requiredfields)shouldimproveandletusjustusetherelational
         *fields.
         */
        messageId:attr(),
        partnersThatHaveFetched:many2many('mail.partner',{
            compute:'_computePartnersThatHaveFetched',
            dependencies:['messageAuthor','messageId','threadPartnerSeenInfos'],
        }),
        partnersThatHaveSeen:many2many('mail.partner',{
            compute:'_computePartnersThatHaveSeen',
            dependencies:['messageAuthor','messageId','threadPartnerSeenInfos'],
        }),
        /**
         *Thethreadconcernedbythisseenindicator.
         *ThisisautomaticallycomputedbasedonchannelIdfield.
         *@seechannelId
         */
        thread:many2one('mail.thread',{
            compute:'_computeThread',
            dependencies:[
                'channelId',
            ],
            inverse:'messageSeenIndicators'
        }),
        threadPartnerSeenInfos:one2many('mail.thread_partner_seen_info',{
            related:'thread.partnerSeenInfos',
        }),
        threadLastCurrentPartnerMessageSeenByEveryone:many2one('mail.message',{
            related:'thread.lastCurrentPartnerMessageSeenByEveryone',
        }),
    };

    returnMessageSeenIndicator;
}

registerNewModel('mail.message_seen_indicator',factory);

});

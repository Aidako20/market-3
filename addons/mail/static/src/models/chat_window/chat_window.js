flectra.define('mail/static/src/models/chat_window/chat_window.js',function(require){
'usestrict';

const{registerNewModel}=require('mail/static/src/model/model_core.js');
const{attr,many2one,one2many,one2one}=require('mail/static/src/model/model_field.js');
const{clear}=require('mail/static/src/model/model_field_command.js');

functionfactory(dependencies){

    classChatWindowextendsdependencies['mail.model']{

        /**
         *@override
         */
        _created(){
            constres=super._created(...arguments);
            this._onShowHomeMenu.bind(this);
            this._onHideHomeMenu.bind(this);

            this.env.messagingBus.on('hide_home_menu',this,this._onHideHomeMenu);
            this.env.messagingBus.on('show_home_menu',this,this._onShowHomeMenu);
            returnres;
        }

        /**
         *@override
         */
        _willDelete(){
            this.env.messagingBus.off('hide_home_menu',this,this._onHideHomeMenu);
            this.env.messagingBus.off('show_home_menu',this,this._onShowHomeMenu);
            returnsuper._willDelete(...arguments);
        }

        //----------------------------------------------------------------------
        //Public
        //----------------------------------------------------------------------

        /**
         *Closethischatwindow.
         *
         *@param{Object}[param0={}]
         *@param{boolean}[param0.notifyServer]
         */
        close({notifyServer}={}){
            if(notifyServer===undefined){
                notifyServer=!this.env.messaging.device.isMobile;
            }
            constthread=this.thread;
            this.delete();
            //Fluxspecific:'closed'foldstateshouldonlybesavedonthe
            //serverwhenmanuallyclosingthechatwindow.Deleteatdestroy
            //orsyncfromservervalueforexampleshouldnotsavethevalue.
            if(thread&&notifyServer){
                thread.notifyFoldStateToServer('closed');
            }
            if(this.env.device.isMobile&&!this.env.messaging.discuss.isOpen){
                //Ifweareinmobileanddiscussisnotopen,itmeansthe
                //chatwindowwasopenedfromthemessagingmenu.Inthat
                //caseitshouldbere-openedtosimulateitwasalways
                //thereinthebackground.
                this.env.messaging.messagingMenu.update({isOpen:true});
            }
        }

        expand(){
            if(this.thread){
                this.thread.open({expanded:true});
            }
        }

        /**
         *Programmaticallyauto-focusanexistingchatwindow.
         */
        focus(){
            this.update({isDoFocus:true});
        }

        focusNextVisibleUnfoldedChatWindow(){
            constnextVisibleUnfoldedChatWindow=this._getNextVisibleUnfoldedChatWindow();
            if(nextVisibleUnfoldedChatWindow){
                nextVisibleUnfoldedChatWindow.focus();
            }
        }

        focusPreviousVisibleUnfoldedChatWindow(){
            constpreviousVisibleUnfoldedChatWindow=
                this._getNextVisibleUnfoldedChatWindow({reverse:true});
            if(previousVisibleUnfoldedChatWindow){
                previousVisibleUnfoldedChatWindow.focus();
            }
        }

        /**
         *@param{Object}[param0={}]
         *@param{boolean}[param0.notifyServer]
         */
        fold({notifyServer}={}){
            if(notifyServer===undefined){
                notifyServer=!this.env.messaging.device.isMobile;
            }
            this.update({isFolded:true});
            //Fluxspecific:manuallyfoldingthechatwindowshouldsavethe
            //newstateontheserver.
            if(this.thread&&notifyServer){
                this.thread.notifyFoldStateToServer('folded');
            }
        }

        /**
         *Makesthischatwindowactive,whichconsistsofmakingitvisible,
         *unfoldingit,andfocusingit.
         *
         *@param{Object}[options]
         */
        makeActive(options){
            this.makeVisible();
            this.unfold(options);
            this.focus();
        }

        /**
         *Makesthischatwindowvisiblebyswappingitwiththelastvisible
         *chatwindow,ordonothingifitisalreadyvisible.
         */
        makeVisible(){
            if(this.isVisible){
                return;
            }
            constlastVisible=this.manager.lastVisible;
            this.manager.swap(this,lastVisible);
        }

        /**
         *Shiftthischatwindowtotheleftonscreen.
         */
        shiftLeft(){
            this.manager.shiftLeft(this);
        }

        /**
         *Shiftthischatwindowtotherightonscreen.
         */
        shiftRight(){
            this.manager.shiftRight(this);
        }

        /**
         *@param{Object}[param0={}]
         *@param{boolean}[param0.notifyServer]
         */
        unfold({notifyServer}={}){
            if(notifyServer===undefined){
                notifyServer=!this.env.messaging.device.isMobile;
            }
            this.update({isFolded:false});
            //Fluxspecific:manuallyopeningthechatwindowshouldsavethe
            //newstateontheserver.
            if(this.thread&&notifyServer){
                this.thread.notifyFoldStateToServer('open');
            }
        }

        //----------------------------------------------------------------------
        //Private
        //----------------------------------------------------------------------

        /**
         *@private
         *@returns{boolean}
         */
        _computeHasNewMessageForm(){
            returnthis.isVisible&&!this.isFolded&&!this.thread;
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeHasShiftLeft(){
            if(!this.manager){
                returnfalse;
            }
            constallVisible=this.manager.allOrderedVisible;
            constindex=allVisible.findIndex(visible=>visible===this);
            if(index===-1){
                returnfalse;
            }
            returnindex<allVisible.length-1;
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeHasShiftRight(){
            if(!this.manager){
                returnfalse;
            }
            constindex=this.manager.allOrderedVisible.findIndex(visible=>visible===this);
            if(index===-1){
                returnfalse;
            }
            returnindex>0;
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeHasThreadView(){
            returnthis.isVisible&&!this.isFolded&&this.thread;
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeIsFolded(){
            constthread=this.thread;
            if(thread){
                returnthread.foldState==='folded';
            }
            returnthis.isFolded;
        }

        /**
         *@private
         *@returns{boolean}
         */
        _computeIsVisible(){
            if(!this.manager){
                returnfalse;
            }
            returnthis.manager.allOrderedVisible.includes(this);
        }

        /**
         *@private
         *@returns{string}
         */
        _computeName(){
            if(this.thread){
                returnthis.thread.displayName;
            }
            returnthis.env._t("Newmessage");
        }

        /**
         *@private
         *@returns{integer|undefined}
         */
        _computeVisibleIndex(){
            if(!this.manager){
                returnclear();
            }
            constvisible=this.manager.visual.visible;
            constindex=visible.findIndex(visible=>visible.chatWindowLocalId===this.localId);
            if(index===-1){
                returnclear();
            }
            returnindex;
        }

        /**
         *@private
         *@returns{integer}
         */
        _computeVisibleOffset(){
            if(!this.manager){
                return0;
            }
            constvisible=this.manager.visual.visible;
            constindex=visible.findIndex(visible=>visible.chatWindowLocalId===this.localId);
            if(index===-1){
                return0;
            }
            returnvisible[index].offset;
        }

        /**
         *Cyclestothenextpossiblevisibleandunfoldedchatwindowstarting
         *fromthe`currentChatWindow`,followingthenaturalorderbasedonthe
         *currenttextdirection,andwiththepossibilityto`reverse`basedon
         *thegivenparameter.
         *
         *@private
         *@param{Object}[param0={}]
         *@param{boolean}[param0.reverse=false]
         *@returns{mail.chat_window|undefined}
         */
        _getNextVisibleUnfoldedChatWindow({reverse=false}={}){
            constorderedVisible=this.manager.allOrderedVisible;
            /**
             *Returnindexofnextvisiblechatwindowofagivenvisiblechat
             *windowindex.Thedirectionof"next"chatwindowdependson
             *`reverse`option.
             *
             *@param{integer}index
             *@returns{integer}
             */
            const_getNextIndex=index=>{
                constdirectionOffset=reverse?1:-1;
                letnextIndex=index+directionOffset;
                if(nextIndex>orderedVisible.length-1){
                    nextIndex=0;
                }
                if(nextIndex<0){
                    nextIndex=orderedVisible.length-1;
                }
                returnnextIndex;
            };

            constcurrentIndex=orderedVisible.findIndex(visible=>visible===this);
            letnextIndex=_getNextIndex(currentIndex);
            letnextToFocus=orderedVisible[nextIndex];
            while(nextToFocus.isFolded){
                nextIndex=_getNextIndex(nextIndex);
                nextToFocus=orderedVisible[nextIndex];
            }
            returnnextToFocus;
        }

        //----------------------------------------------------------------------
        //Handlers
        //----------------------------------------------------------------------

        /**
         *@private
         */
        async_onHideHomeMenu(){
            if(!this.threadView){
                return;
            }
            this.threadView.addComponentHint('home-menu-hidden');
        }

        /**
         *@private
         */
        async_onShowHomeMenu(){
            if(!this.threadView){
                return;
            }
            this.threadView.addComponentHint('home-menu-shown');
        }

    }

    ChatWindow.fields={
        /**
         *Determineswhether"newmessageform"shouldbedisplayed.
         */
        hasNewMessageForm:attr({
            compute:'_computeHasNewMessageForm',
            dependencies:[
                'isFolded',
                'isVisible',
                'thread',
            ],
        }),
        hasShiftLeft:attr({
            compute:'_computeHasShiftLeft',
            dependencies:['managerAllOrderedVisible'],
            default:false,
        }),
        hasShiftRight:attr({
            compute:'_computeHasShiftRight',
            dependencies:['managerAllOrderedVisible'],
            default:false,
        }),
        /**
         *Determineswhether`this.thread`shouldbedisplayed.
         */
        hasThreadView:attr({
            compute:'_computeHasThreadView',
            dependencies:[
                'isFolded',
                'isVisible',
                'thread',
            ],
        }),
        /**
         *Determinewhetherthechatwindowshouldbeprogrammatically
         *focusedbyobservedcomponentofchatwindow.Thosecomponents
         *areresponsibletounmarkthisrecordafterwards,otherwise
         *anyre-renderwillprogrammaticallysetfocusagain!
         */
        isDoFocus:attr({
            default:false,
        }),
        /**
         *Stateswhether`this`isfocused.Usefulforvisualclue.
         */
        isFocused:attr({
            default:false,
        }),
        /**
         *Determineswhether`this`isfolded.
         */
        isFolded:attr({
            default:false,
        }),
        /**
         *Stateswhether`this`isvisibleornot.Shouldbeconsidered
         *read-only.Settingthisvaluemanuallywillnotmakeitvisible.
         *@see`makeVisible`
         */
        isVisible:attr({
            compute:'_computeIsVisible',
            dependencies:[
                'managerAllOrderedVisible',
            ],
        }),
        manager:many2one('mail.chat_window_manager',{
            inverse:'chatWindows',
        }),
        managerAllOrderedVisible:one2many('mail.chat_window',{
            related:'manager.allOrderedVisible',
        }),
        managerVisual:attr({
            related:'manager.visual',
        }),
        name:attr({
            compute:'_computeName',
            dependencies:[
                'thread',
                'threadDisplayName',
            ],
        }),
        /**
         *Determinesthe`mail.thread`thatshouldbedisplayedby`this`.
         *Ifno`mail.thread`islinked,`this`isconsidered"newmessage".
         */
        thread:one2one('mail.thread',{
            inverse:'chatWindow',
        }),
        threadDisplayName:attr({
            related:'thread.displayName',
        }),
        /**
         *Statesthe`mail.thread_view`displaying`this.thread`.
         */
        threadView:one2one('mail.thread_view',{
            related:'threadViewer.threadView',
        }),
        /**
         *Determinesthe`mail.thread_viewer`managingthedisplayof`this.thread`.
         */
        threadViewer:one2one('mail.thread_viewer',{
            default:[['create']],
            inverse:'chatWindow',
            isCausal:true,
        }),
        /**
         *Thisfieldhandlethe"order"(index)ofthevisiblechatWindowinsidetheUI.
         *
         *UsingLTR,theright-mostchatwindowhasindex0,andthenumberisincrementingfromrighttoleft.
         *UsingRTL,theleft-mostchatwindowhasindex0,andthenumberisincrementingfromlefttoright.
         */
        visibleIndex:attr({
            compute:'_computeVisibleIndex',
            dependencies:[
                'manager',
                'managerVisual',
            ],
        }),
        visibleOffset:attr({
            compute:'_computeVisibleOffset',
            dependencies:['managerVisual'],
        }),
    };

    ChatWindow.modelName='mail.chat_window';

    returnChatWindow;
}

registerNewModel('mail.chat_window',factory);

});

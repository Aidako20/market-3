flectra.define('mail/static/src/model/model_manager.js',function(require){
'usestrict';

const{registry}=require('mail/static/src/model/model_core.js');
constModelField=require('mail/static/src/model/model_field.js');
const{patchClassMethods,patchInstanceMethods}=require('mail/static/src/utils/utils.js');

/**
 *Innerseparatorusedbetweenbitsofinformationinstringthatisusedto
 *identifyadependentofafield.Usefultodeterminewhichrecordandfield
 *toregisterforcomputeduringthisupdatecycle.
 */
constDEPENDENT_INNER_SEPARATOR="--//--//--";

/**
 *Objectthatmanagemodelsandrecords,notablytheirupdatecycle:whenever
 *somerecordsarerequestedforupdate(eitherwithmodelstaticmethod
 *`create()`orrecordmethod`update()`),thisobjectprocessesthemwith
 *directfield&andcomputedfieldupdates.
 */
classModelManager{

    //--------------------------------------------------------------------------
    //Public
    //--------------------------------------------------------------------------

    constructor(env){
        /**
         *Innerseparatorusedinsidestringtorepresentdependents.
         *Setaspublicattributesothatitcanbeusedbymodelfield.
         */
        this.DEPENDENT_INNER_SEPARATOR=DEPENDENT_INNER_SEPARATOR;
        /**
         *Themessagingenv.
         */
        this.env=env;

        //----------------------------------------------------------------------
        //Variousvariablesthatarenecessarytohandleanupdatecycle.The
        //goalofhavinganupdatecycleistodelaytheexecutionofcomputes,
        //life-cyclehooksandpotentialUIre-rendersuntilthelastpossible
        //moment,forperformancereasons.
        //----------------------------------------------------------------------

        /**
         *Setofrecordsthathavebeencreatedduringthecurrentupdate
         *cycle.Usefultotrigger`_created()`hookmethods.
         */
        this._createdRecords=newSet();
        /**
         *Trackswhethersomethinghaschangedduringthecurrentupdatecycle.
         *Usefultonotifycomponents(throughthestore)thatsomerecords
         *havebeenchanged.
         */
        this._hasAnyChangeDuringCycle=false;
        /**
         *Setofrecordsthathavebeenupdatedduringthecurrentupdate
         *cycle.Usefultoallowobservers(typicallycomponents)todetect
         *whetherspecificrecordshavebeenchanged.
         */
        this._updatedRecords=newSet();
        /**
         *Fieldsflaggedtocallcomputeduringanupdatecycle.
         *Forinstance,whenafieldwithdependentsgotupdate,dependent
         *fieldsshouldupdatethemselvesbyinvokingcomputeatendof
         *updatecycle.Keyisofformat
         *<record-local-id><DEPENDENT_INNER_SEPARATOR><fieldName>,and
         *determinerecordandfieldtobecomputed.Keysarestringsbecause
         *itmustcontainonlyoneoccurrenceofpairrecord/field,andwewant
         *O(1)reads/writes.
         */
        this._toComputeFields=newMap();
        /**
         *Mapof"updateafter"onrecordsthathavebeenregistered.
         *Theseareprocessedafteranyexplicitupdateandcomputed/related
         *fields.
         */
        this._toUpdateAfters=newMap();
    }

    /**
     *CalledwhenallJSmodulesthatregisterorpatchmodelshavebeen
     *done.Thislaunchesgenerationofmodels.
     */
    start(){
        /**
         *Generatethemodels.
         */
        Object.assign(this.env.models,this._generateModels());
    }

    //--------------------------------------------------------------------------
    //Public
    //--------------------------------------------------------------------------

    /**
     *Returnsallrecordsofprovidedmodelthatmatchprovidedcriteria.
     *
     *@param{mail.model}Modelclass
     *@param{function}[filterFunc]
     *@returns{mail.model[]}recordsmatchingcriteria.
     */
    all(Model,filterFunc){
        constallRecords=Object.values(Model.__records);
        if(filterFunc){
            returnallRecords.filter(filterFunc);
        }
        returnallRecords;
    }

    /**
     *Registerarecordthathasbeencreated,andmanageupdateofrecords
     *fromthisrecordcreation.
     *
     *@param{mail.model}Modelclass
     *@param{Object|Object[]}[data={}]
     * Ifdataisaniterable,multiplerecordswillbecreated.
     *@returns{mail.model|mail.model[]}newlycreatedrecord(s)
     */
    create(Model,data={}){
        constres=this._create(Model,data);
        this._flushUpdateCycle();
        returnres;
    }

    /**
     *Deletetherecord.Afterthisoperation,it'sasifthisrecordnever
     *existed.Notethatrelationareremoved,whichmaydeletemorerelations
     *ifsomeofthemarecausal.
     *
     *@param{mail.model}record
     */
    delete(record){
        this._delete(record);
        this._flushUpdateCycle();
    }

    /**
     *Deleteallrecords.
     */
    deleteAll(){
        for(constModelofObject.values(this.env.models)){
            for(constrecordofObject.values(Model.__records)){
                this._delete(record);
            }
        }
        this._flushUpdateCycle();
    }

    /**
     *Returnswhetherthegivenrecordstillexists.
     *
     *@param{mail.model}Modelclass
     *@param{mail.model}record
     *@returns{boolean}
     */
    exists(Model,record){
        returnModel.__records[record.localId]?true:false;
    }

    /**
     *Gettherecordofprovidedmodelthathasprovided
     *criteria,ifitexists.
     *
     *@param{mail.model}Modelclass
     *@param{function}findFunc
     *@returns{mail.model|undefined}therecordofmodelmatchingcriteria,if
     *  exists.
     */
    find(Model,findFunc){
        returnthis.all(Model).find(findFunc);
    }

    /**
     *Getstheuniquerecordofprovidedmodelthatmatchesthegiven
     *identifyingdata,ifitexists.
     *@see`_createRecordLocalId`forcriteriaofidentification.
     *
     *@param{mail.model}Modelclass
     *@param{Object}data
     *@returns{mail.model|undefined}
     */
    findFromIdentifyingData(Model,data){
        constlocalId=Model._createRecordLocalId(data);
        returnModel.get(localId);
    }

    /**
     *Thismethodreturnstherecordofprovidedmodelthatmatchesprovided
     *localid.Usefultoconvertalocalidtoarecord.
     *Notethatevenifthere'sarecordinthesystemhavingprovidedlocal
     *id,iftheresultingrecordisnotaninstanceofthismodel,thisgetter
     *assumestherecorddoesnotexist.
     *
     *@param{mail.model}Modelclass
     *@param{string}localId
     *@param{Object}param2
     *@param{boolean}[param2.isCheckingInheritance=false]
     *@returns{mail.model|undefined}record,ifexists
     */
    get(Model,localId,{isCheckingInheritance=false}={}){
        if(!localId){
            return;
        }
        constrecord=Model.__records[localId];
        if(record){
            returnrecord;
        }
        if(!isCheckingInheritance){
            return;
        }
        //supportforinheritedmodels(eg.relationtargeting`mail.model`)
        for(constSubModelofObject.values(this.env.models)){
            if(!(SubModel.prototypeinstanceofModel)){
                continue;
            }
            constrecord=SubModel.__records[localId];
            if(record){
                returnrecord;
            }
        }
        return;
    }

    /**
     *ThismethodcreatesarecordorupdatesoneofprovidedModel,basedon
     *provideddata.Thismethodassumesthatrecordsareuniquelyidentifiable
     *per"uniquefind"criteriafromdataonModel.
     *
     *@param{mail.model}Modelclass
     *@param{Object|Object[]}data
     * Ifdataisaniterable,multiplerecordswillbecreated/updated.
     *@returns{mail.model|mail.model[]}createdorupdatedrecord(s).
     */
    insert(Model,data){
        constres=this._insert(Model,data);
        this._flushUpdateCycle();
        returnres;
    }

    /**
     *Processanupdateonprovidedrecordwithprovideddata.Updating
     *arecordconsistsofapplyingdirectupdatesfirst(i.e.explicit
     *onesfrom`data`)andthenindirectones(i.e.compute/relatedfields
     *and"afterupdates").
     *
     *@param{mail.model}record
     *@param{Object}data
     *@returns{boolean}whetheranyvaluechangedforthecurrentrecord
     */
    update(record,data){
        constres=this._update(record,data);
        this._flushUpdateCycle();
        returnres;
    }

    //--------------------------------------------------------------------------
    //Private
    //--------------------------------------------------------------------------

    /**
     *@private
     *@param{mail.model}Modelclass
     *@param{Object}patch
     */
    _applyModelPatchFields(Model,patch){
        for(const[fieldName,field]ofObject.entries(patch)){
            if(!Model.fields[fieldName]){
                Model.fields[fieldName]=field;
            }else{
                Object.assign(Model.fields[fieldName].dependencies,field.dependencies);
            }
        }
    }

    /**
     *@private
     *@param{Object}Models
     *@throws{Error}incasesomedeclaredfieldsarenotcorrect.
     */
    _checkDeclaredFieldsOnModels(Models){
        for(constModelofObject.values(Models)){
            for(constfieldNameinModel.fields){
                constfield=Model.fields[fieldName];
                //0.Getparenteddeclaredfields
                constparentedMatchingFields=[];
                letTargetModel=Model.__proto__;
                while(Models[TargetModel.modelName]){
                    if(TargetModel.fields){
                        constmatchingField=TargetModel.fields[fieldName];
                        if(matchingField){
                            parentedMatchingFields.push(matchingField);
                        }
                    }
                    TargetModel=TargetModel.__proto__;
                }
                //1.Fieldtypeisrequired.
                if(!(['attribute','relation'].includes(field.fieldType))){
                    thrownewError(`Field"${Model.modelName}/${fieldName}"hasunsupportedtype${field.fieldType}.`);
                }
                //2.Invalidkeysbasedonfieldtype.
                if(field.fieldType==='attribute'){
                    constinvalidKeys=Object.keys(field).filter(key=>
                        ![
                            'compute',
                            'default',
                            'dependencies',
                            'fieldType',
                            'related',
                        ].includes(key)
                    );
                    if(invalidKeys.length>0){
                        thrownewError(`Field"${Model.modelName}/${fieldName}"containssomeinvalidkeys:"${invalidKeys.join(",")}".`);
                    }
                }
                if(field.fieldType==='relation'){
                    constinvalidKeys=Object.keys(field).filter(key=>
                        ![
                            'compute',
                            'default',
                            'dependencies',
                            'fieldType',
                            'inverse',
                            'isCausal',
                            'related',
                            'relationType',
                            'to',
                        ].includes(key)
                    );
                    if(invalidKeys.length>0){
                        thrownewError(`Field"${Model.modelName}/${fieldName}"containssomeinvalidkeys:"${invalidKeys.join(",")}".`);
                    }
                    if(!Models[field.to]){
                        thrownewError(`Relationalfield"${Model.modelName}/${fieldName}"targetstounknownmodelname"${field.to}".`);
                    }
                    if(field.isCausal&&!(['one2many','one2one'].includes(field.relationType))){
                        thrownewError(`Relationalfield"${Model.modelName}/${fieldName}"has"isCausal"truewitharelationoftype"${field.relationType}"but"isCausal"isonlysupportedfor"one2many"and"one2one".`);
                    }
                }
                //3.Computedfield.
                if(field.compute&&!(typeoffield.compute==='string')){
                    thrownewError(`Field"${Model.modelName}/${fieldName}"property"compute"mustbeastring(instancemethodname).`);
                }
                if(field.compute&&!(Model.prototype[field.compute])){
                    thrownewError(`Field"${Model.modelName}/${fieldName}"property"compute"doesnotrefertoaninstancemethodofthisModel.`);
                }
                if(
                    field.dependencies&&
                    (!field.compute&&!parentedMatchingFields.some(field=>field.compute))
                ){
                    thrownewError(`Field"${Model.modelName}/${fieldName}containsdependendenciesbutnocomputemethodinitselforparentedmatchingfields(dependenciesonlymakesenseforcomputefields)."`);
                }
                if(
                    (field.compute||parentedMatchingFields.some(field=>field.compute))&&
                    (field.dependencies||parentedMatchingFields.some(field=>field.dependencies))
                ){
                    if(!(field.dependenciesinstanceofArray)){
                        thrownewError(`Computefield"${Model.modelName}/${fieldName}"dependenciesmustbeanarrayoffieldnames.`);
                    }
                    constunknownDependencies=field.dependencies.every(dependency=>!(Model.fields[dependency]));
                    if(unknownDependencies.length>0){
                        thrownewError(`Computefield"${Model.modelName}/${fieldName}"containssomeunknowndependencies:"${unknownDependencies.join(",")}".`);
                    }
                }
                //4.Relatedfield.
                if(field.compute&&field.related){
                    thrownewError(`Field"${Model.modelName}/${fieldName}"cannotbearelatedandcomputefieldatthesametime.`);
                }
                if(field.related){
                    if(!(typeoffield.related==='string')){
                        thrownewError(`Field"${Model.modelName}/${fieldName}"property"related"hasinvalidformat.`);
                    }
                    const[relationName,relatedFieldName,other]=field.related.split('.');
                    if(!relationName||!relatedFieldName||other){
                        thrownewError(`Field"${Model.modelName}/${fieldName}"property"related"hasinvalidformat.`);
                    }
                    //findrelationonselforparents.
                    letrelatedRelation;
                    letTargetModel=Model;
                    while(Models[TargetModel.modelName]&&!relatedRelation){
                        if(TargetModel.fields){
                            relatedRelation=TargetModel.fields[relationName];
                        }
                        TargetModel=TargetModel.__proto__;
                    }
                    if(!relatedRelation){
                        thrownewError(`Relatedfield"${Model.modelName}/${fieldName}"relatestounknownrelationname"${relationName}".`);
                    }
                    if(relatedRelation.fieldType!=='relation'){
                        thrownewError(`Relatedfield"${Model.modelName}/${fieldName}"relatestonon-relationalfield"${relationName}".`);
                    }
                    //Assumingrelatedrelationisvalid...
                    //findfieldnameonrelatedmodeloranyparents.
                    constRelatedModel=Models[relatedRelation.to];
                    letrelatedField;
                    TargetModel=RelatedModel;
                    while(Models[TargetModel.modelName]&&!relatedField){
                        if(TargetModel.fields){
                            relatedField=TargetModel.fields[relatedFieldName];
                        }
                        TargetModel=TargetModel.__proto__;
                    }
                    if(!relatedField){
                        thrownewError(`Relatedfield"${Model.modelName}/${fieldName}"relatestounknownrelatedmodelfield"${relatedFieldName}".`);
                    }
                    if(relatedField.fieldType!==field.fieldType){
                        thrownewError(`Relatedfield"${Model.modelName}/${fieldName}"hasmismatchtypewithitsrelatedmodelfield.`);
                    }
                    if(
                        relatedField.fieldType==='relation'&&
                        relatedField.to!==field.to
                    ){
                        thrownewError(`Relatedfield"${Model.modelName}/${fieldName}"hasmismatchtargetmodelnamewithitsrelatedmodelfield.`);
                    }
                }
            }
        }
    }

    /**
     *@private
     *@param{Object}Models
     *@throws{Error}incasesomefieldsarenotcorrect.
     */
    _checkProcessedFieldsOnModels(Models){
        for(constModelofObject.values(Models)){
            for(constfieldNameinModel.fields){
                constfield=Model.fields[fieldName];
                if(!(['attribute','relation'].includes(field.fieldType))){
                    thrownewError(`Field"${Model.modelName}/${fieldName}"hasunsupportedtype${field.fieldType}.`);
                }
                if(field.compute&&field.related){
                    thrownewError(`Field"${Model.modelName}/${fieldName}"cannotbearelatedandcomputefieldatthesametime.`);
                }
                if(field.fieldType==='attribute'){
                    continue;
                }
                if(!field.relationType){
                    thrownewError(
                        `Field"${Model.modelName}/${fieldName}"mustdefinearelationtypein"relationType".`
                    );
                }
                if(!(['one2one','one2many','many2one','many2many'].includes(field.relationType))){
                    thrownewError(
                        `Field"${Model.modelName}/${fieldName}"hasinvalidrelationtype"${field.relationType}".`
                    );
                }
                if(!field.inverse){
                    thrownewError(
                        `Field"${
                            Model.modelName
                        }/${
                            fieldName
                        }"mustdefineaninverserelationnamein"inverse".`
                    );
                }
                if(!field.to){
                    thrownewError(
                        `Relation"${
                            Model.modelNames
                        }/${
                            fieldName
                        }"mustdefineamodelnamein"to"(1stpositionalparameterofrelationfieldhelpers).`
                    );
                }
                constRelatedModel=Models[field.to];
                if(!RelatedModel){
                    thrownewError(
                        `Modelnameofrelation"${Model.modelName}/${fieldName}"doesnotexist.`
                    );
                }
                constinverseField=RelatedModel.fields[field.inverse];
                if(!inverseField){
                    thrownewError(
                        `Relation"${
                            Model.modelName
                        }/${
                            fieldName
                        }"hasnoinversefield"${RelatedModel.modelName}/${field.inverse}".`
                    );
                }
                if(inverseField.inverse!==fieldName){
                    thrownewError(
                        `Inversefieldnameofrelation"${
                            Model.modelName
                        }/${
                            fieldName
                        }"doesnotmatchwithfieldnameofrelation"${
                            RelatedModel.modelName
                        }/${
                            inverseField.inverse
                        }".`
                    );
                }
                constallSelfAndParentNames=[];
                letTargetModel=Model;
                while(TargetModel){
                    allSelfAndParentNames.push(TargetModel.modelName);
                    TargetModel=TargetModel.__proto__;
                }
                if(!allSelfAndParentNames.includes(inverseField.to)){
                    thrownewError(
                        `Relation"${
                            Model.modelName
                        }/${
                            fieldName
                        }"hasinverserelation"${
                            RelatedModel.modelName
                        }/${
                            field.inverse
                        }"misconfigured(currently"${
                            inverseField.to
                        }",shouldinsteadrefertothismodelorparentedmodels:${
                            allSelfAndParentNames.map(name=>`"${name}"`).join(',')
                        }?)`
                    );
                }
                if(
                    (field.relationType==='many2many'&&inverseField.relationType!=='many2many')||
                    (field.relationType==='one2one'&&inverseField.relationType!=='one2one')||
                    (field.relationType==='one2many'&&inverseField.relationType!=='many2one')||
                    (field.relationType==='many2one'&&inverseField.relationType!=='one2many')
                ){
                    thrownewError(
                        `Mismatchrelationstypes"${
                            Model.modelName
                        }/${
                            fieldName
                        }"(${
                            field.relationType
                        })and"${
                            RelatedModel.modelName
                        }/${
                            field.inverse
                        }"(${
                            inverseField.relationType
                        }).`
                    );
                }
            }
        }
    }

    /**
     *@private
     *@param{mail.model}Modelclass
     *@param{Object|Object[]}[data={}]
     *@returns{mail.model|mail.model[]}
     */
    _create(Model,data={}){
        constisMulti=typeofdata[Symbol.iterator]==='function';
        constdataList=isMulti?data:[data];
        constrecords=[];
        for(constdataofdataList){
            /**
             *1.Ensuretherecordcanbecreated:localIdmustbeunique.
             */
            constlocalId=Model._createRecordLocalId(data);
            if(Model.get(localId)){
                throwError(`Arecordalreadyexistsformodel"${Model.modelName}"withlocalId"${localId}".`);
            }
            /**
             *2.Preparerecordstate.Assignvariouskeysandvaluesthatare
             *expectedtobefoundoneveryrecord.
             */
            constrecord=newModel({valid:true});
            Object.assign(record,{
                //Themessagingenv.
                env:this.env,
                //Theuniquerecordidentifier.
                localId,
                //Fieldvaluesofrecord.
                __values:{},
                //revNumberofrecordfordetectingchangesinuseStore.
                __state:0,
            });
            //EnsureX2manyrelationsareSetinitially(otherfieldscanstayundefined).
            for(constfieldofModel.__fieldList){
                if(field.fieldType==='relation'){
                    if(['one2many','many2many'].includes(field.relationType)){
                        record.__values[field.fieldName]=newSet();
                    }
                }
            }
            /**
             *3.Registerrecordandinvokethelife-cyclehook`_willCreate.`
             *Afterthissteptherecordisinafunctioningstateanditis
             *consideredexisting.
             */
            Model.__records[record.localId]=record;
            record._willCreate();
            /**
             *4.Writeprovideddata,defaultdata,andregistercomputes.
             */
            constdata2={};
            for(constfieldofModel.__fieldList){
                //`undefined`shouldhavethesameeffectasnotpassingthefield
                if(data[field.fieldName]!==undefined){
                    data2[field.fieldName]=data[field.fieldName];
                }else{
                    data2[field.fieldName]=field.default;
                }
                if(field.compute||field.related){
                    //newrecordshouldalwaysinvokecomputedfields.
                    this._registerToComputeField(record,field);
                }
            }
            this._update(record,data2);
            /**
             *5.Registerpostprocessingoperationthataretobedelayedat
             *theendoftheupdatecycle.
             */
            this._createdRecords.add(record);
            this._hasAnyChangeDuringCycle=true;

            records.push(record);
        }
        returnisMulti?records:records[0];
    }

    /**
     *@private
     *@param{mail.model}record
     */
    _delete(record){
        constModel=record.constructor;
        if(!record.exists()){
            throwError(`Cannotdeletealreadydeletedrecord${record.localId}.`);
        }
        record._willDelete();
        for(constfieldofModel.__fieldList){
            if(field.fieldType==='relation'){
                //ensureinversesareproperlyunlinked
                field.parseAndExecuteCommands(record,[['unlink-all']]);
            }
        }
        this._hasAnyChangeDuringCycle=true;
        //TODOideallydeletingtherecordshouldbedoneatthetopofthe
        //method,anditshouldn'tbeneededtomanuallyremove
        //_toComputeFieldsand_toUpdateAfters,butitisnotpossibleuntil
        //relatedarealsoproperlyunlinkedduring`set`
        this._createdRecords.delete(record);
        this._toComputeFields.delete(record);
        this._toUpdateAfters.delete(record);
        deleteModel.__records[record.localId];
    }

    /**
     *Terminatesanupdatecyclebyexecutingitspendingoperations:execute
     *computedfields,executelife-cyclehooks,updaterevnumbers.
     *
     *@private
     */
    _flushUpdateCycle(func){
        //Executionofcomputes
        while(this._toComputeFields.size>0){
            for(const[record,fields]ofthis._toComputeFields){
                //deleteateverysteptoavoidrecursion,indeeddoCompute
                //mighttriggeranupdatecycleitself
                this._toComputeFields.delete(record);
                if(!record.exists()){
                    throwError(`Cannotexecutecomputesforalreadydeletedrecord${record.localId}.`);
                }
                while(fields.size>0){
                    for(constfieldoffields){
                        //deleteateverysteptoavoidrecursion
                        fields.delete(field);
                        if(field.compute){
                            this._update(record,{[field.fieldName]:record[field.compute]()});
                            continue;
                        }
                        if(field.related){
                            this._update(record,{[field.fieldName]:field.computeRelated(record)});
                            continue;
                        }
                        thrownewError("Nocomputemethoddefinedonthisfielddefinition");
                    }
                }
            }
        }

        //Executionof_updateAfter
        while(this._toUpdateAfters.size>0){
            for(const[record,previous]ofthis._toUpdateAfters){
                //deleteateverysteptoavoidrecursion,indeed_updateAfter
                //mighttriggeranupdatecycleitself
                this._toUpdateAfters.delete(record);
                if(!record.exists()){
                    throwError(`Cannot_updateAfterforalreadydeletedrecord${record.localId}.`);
                }
                record._updateAfter(previous);
            }
        }

        //Executionof_created
        while(this._createdRecords.size>0){
            for(constrecordofthis._createdRecords){
                //deleteateverysteptoavoidrecursion,indeed_created
                //mighttriggeranupdatecycleitself
                this._createdRecords.delete(record);
                if(!record.exists()){
                    throwError(`Cannotcall_createdforalreadydeletedrecord${record.localId}.`);
                }
                record._created();
            }
        }

        //Incrementrecordrevnumber(foruseStorecomparison)
        for(constrecordofthis._updatedRecords){
            record.__state++;
        }
        this._updatedRecords.clear();

        //TriggeratmostoneuseStorecallperupdatecycle
        if(this._hasAnyChangeDuringCycle){
            this.env.store.state.messagingRevNumber++;
            this._hasAnyChangeDuringCycle=false;
        }
    }

    /**
     *@private
     *@returns{Object}
     *@throws{Error}incaseitcannotgeneratemodels.
     */
    _generateModels(){
        constallNames=Object.keys(registry);
        constModels={};
        constgeneratedNames=[];
        lettoGenerateNames=[...allNames];
        while(toGenerateNames.length>0){
            constgeneratable=toGenerateNames.map(name=>registry[name]).find(entry=>{
                letisGenerateable=true;
                for(constdependencyNameofentry.dependencies){
                    if(!generatedNames.includes(dependencyName)){
                        isGenerateable=false;
                    }
                }
                returnisGenerateable;
            });
            if(!generatable){
                thrownewError(`CannotgeneratefollowingModel:${toGenerateNames.join(',')}`);
            }
            if(!generatable.factory){
                thrownewError(`MissingfactoryforthefollowingModel:${generatable.name}(maybecheckfortypoinname?)`);
            }
            //MakeenvironmentaccessiblefromModel.
            constModel=generatable.factory(Models);
            Model.env=this.env;
            /**
            *Containsallrecords.keyislocalid,whilevalueistherecord.
            */
            Model.__records={};
            for(constpatchofgeneratable.patches){
                switch(patch.type){
                    case'class':
                        patchClassMethods(Model,patch.name,patch.patch);
                        break;
                    case'instance':
                        patchInstanceMethods(Model,patch.name,patch.patch);
                        break;
                    case'field':
                        this._applyModelPatchFields(Model,patch.patch);
                        break;
                }
            }
            if(!Object.prototype.hasOwnProperty.call(Model,'modelName')){
                thrownewError(`Missingstaticproperty"modelName"onModelclass"${Model.name}".`);
            }
            if(generatedNames.includes(Model.modelName)){
                thrownewError(`Duplicatemodelname"${Model.modelName}"sharedon2distinctModelclasses.`);
            }
            Models[Model.modelName]=Model;
            generatedNames.push(Model.modelName);
            toGenerateNames=toGenerateNames.filter(name=>name!==Model.modelName);
        }
        /**
         *Checkthatdeclaredmodelfieldsarecorrect.
         */
        this._checkDeclaredFieldsOnModels(Models);
        /**
         *Processdeclaredmodelfieldsdefinitions,sothatthesefield
         *definitionsaremucheasiertouseinthesystem.Forinstance,all
         *relationalfielddefinitionshaveaninverse,orfieldstrackalltheir
         *dependents.
         */
        this._processDeclaredFieldsOnModels(Models);
        /**
         *Checkthatallmodelfieldsarecorrect,notablyonerelation
         *shouldhavematchingreversedrelation.
         */
        this._checkProcessedFieldsOnModels(Models);
        returnModels;
    }

    /**
     *@private
     *@param{mail.model}
     *@param{Object|Object[]}data
     *@returns{mail.model|mail.model[]}
     */
    _insert(Model,data){
        constisMulti=typeofdata[Symbol.iterator]==='function';
        constdataList=isMulti?data:[data];
        constrecords=[];
        for(constdataofdataList){
            letrecord=Model.findFromIdentifyingData(data);
            if(!record){
                record=this._create(Model,data);
            }else{
                this._update(record,data);
            }
            records.push(record);
        }
        returnisMulti?records:records[0];
    }

    /**
     *@private
     *@param{mail.model}Modelclass
     *@param{ModelField}field
     *@returns{ModelField}
     */
    _makeInverseRelationField(Model,field){
        constrelFunc=
            field.relationType==='many2many'?ModelField.many2many
            :field.relationType==='many2one'?ModelField.one2many
            :field.relationType==='one2many'?ModelField.many2one
            :field.relationType==='one2one'?ModelField.one2one
            :undefined;
        if(!relFunc){
            thrownewError(`CannotcomputeinverseRelationof"${Model.modelName}/${field.fieldName}".`);
        }
        constinverseField=newModelField(Object.assign(
            {},
            relFunc(Model.modelName,{inverse:field.fieldName}),
            {
                env:this.env,
                fieldName:`_inverse_${Model.modelName}/${field.fieldName}`,
                modelManager:this,
            }
        ));
        returninverseField;
    }

    /**
     *Thisfunctionprocessesdefinitionofdeclaredfieldsinprovidedmodels.
     *Basically,modelshavefieldsdeclaredinstaticprop`fields`,andthis
     *functionprocessesandmodifiestheminplacesothattheyarefully
     *configured.Forinstance,modelrelationsneedbi-directionalmapping,but
     *inverserelationmaybeomittedindeclaredfield:thisfunctionauto-fill
     *thisinverserelation.
     *
     *@private
     *@param{Object}Models
     */
    _processDeclaredFieldsOnModels(Models){
        /**
         *1.Preparefields.
         */
        for(constModelofObject.values(Models)){
            if(!Object.prototype.hasOwnProperty.call(Model,'fields')){
                Model.fields={};
            }
            Model.inverseRelations=[];
            //Makefieldsawareoftheirfieldname.
            for(const[fieldName,fieldData]ofObject.entries(Model.fields)){
                Model.fields[fieldName]=newModelField(Object.assign({},fieldData,{
                    env:this.env,
                    fieldName,
                    modelManager:this,
                }));
            }
        }
        /**
         *2.Auto-generatedefinitionsofundeclaredinverserelations.
         */
        for(constModelofObject.values(Models)){
            for(constfieldofObject.values(Model.fields)){
                if(field.fieldType!=='relation'){
                    continue;
                }
                if(field.inverse){
                    continue;
                }
                constRelatedModel=Models[field.to];
                constinverseField=this._makeInverseRelationField(Model,field);
                field.inverse=inverseField.fieldName;
                RelatedModel.fields[inverseField.fieldName]=inverseField;
            }
        }
        /**
         *3.Generatedependentsandinverse-relatesonfields.
         *Fielddefinitionsarenotyetcombined,soregistrationof`dependents`
         *mayhavetowalkstructuralhierarchyofmodelsinordertofind
         *theappropriatefield.Also,whiledependenciesaredefinedjustwith
         *fieldnames,dependentsrequireanadditionaldatacalleda"hash"
         *(=fieldid),whichisawaytoidentifydependentsinaninverse
         *relation.Thisisnecessarybecausedependentsareasubsetofaninverse
         *relation.
         */
        for(constModelofObject.values(Models)){
            for(constfieldofObject.values(Model.fields)){
                for(constdependencyFieldNameoffield.dependencies){
                    letTargetModel=Model;
                    letdependencyField=TargetModel.fields[dependencyFieldName];
                    while(!dependencyField){
                        TargetModel=TargetModel.__proto__;
                        dependencyField=TargetModel.fields[dependencyFieldName];
                    }
                    constdependent=[field.id,field.fieldName].join(DEPENDENT_INNER_SEPARATOR);
                    dependencyField.dependents=[
                        ...newSet(dependencyField.dependents.concat([dependent]))
                    ];
                }
                if(field.related){
                    const[relationName,relatedFieldName]=field.related.split('.');
                    letTargetModel=Model;
                    letrelationField=TargetModel.fields[relationName];
                    while(!relationField){
                        TargetModel=TargetModel.__proto__;
                        relationField=TargetModel.fields[relationName];
                    }
                    constrelationFieldDependent=[
                        field.id,
                        field.fieldName,
                    ].join(DEPENDENT_INNER_SEPARATOR);
                    relationField.dependents=[
                        ...newSet(relationField.dependents.concat([relationFieldDependent]))
                    ];
                    constOtherModel=Models[relationField.to];
                    letOtherTargetModel=OtherModel;
                    letrelatedField=OtherTargetModel.fields[relatedFieldName];
                    while(!relatedField){
                        OtherTargetModel=OtherTargetModel.__proto__;
                        relatedField=OtherTargetModel.fields[relatedFieldName];
                    }
                    constrelatedFieldDependent=[
                        field.id,
                        relationField.inverse,
                        field.fieldName,
                    ].join(DEPENDENT_INNER_SEPARATOR);
                    relatedField.dependents=[
                        ...newSet(
                            relatedField.dependents.concat([relatedFieldDependent])
                        )
                    ];
                }
            }
        }
        /**
         *4.Extenddefinitionoffieldsofamodelwiththedefinitionof
         *fieldsofitsparents.Fielddefinitionsonselfhasprecedenceover
         *parentedfields.
         */
        for(constModelofObject.values(Models)){
            Model.__combinedFields={};
            for(constfieldofObject.values(Model.fields)){
                Model.__combinedFields[field.fieldName]=field;
            }
            letTargetModel=Model.__proto__;
            while(TargetModel&&TargetModel.fields){
                for(consttargetFieldofObject.values(TargetModel.fields)){
                    constfield=Model.__combinedFields[targetField.fieldName];
                    if(field){
                        Model.__combinedFields[targetField.fieldName]=field.combine(targetField);
                    }else{
                        Model.__combinedFields[targetField.fieldName]=targetField;
                    }
                }
                TargetModel=TargetModel.__proto__;
            }
        }
        /**
         *5.Registerfinalfieldsandmakefieldaccessors,toredirectsfield
         *accesstofieldgetterandtopreventfieldfrombeingwritten
         *withoutcallingupdate(whichisnecessarytoprocessupdatecycle).
         */
        for(constModelofObject.values(Models)){
            //ObjectwithfieldName/fieldaskey/valuepair,forquickaccess.
            Model.__fieldMap=Model.__combinedFields;
            //Listofallfields,foriterating.
            Model.__fieldList=Object.values(Model.__fieldMap);
            //Addfieldaccessors.
            for(constfieldofModel.__fieldList){
                Object.defineProperty(Model.prototype,field.fieldName,{
                    get(){
                        returnfield.get(this);//thisisboundtorecord
                    },
                });
            }
            deleteModel.__combinedFields;
        }
    }

    /**
     *Registerscomputeofdependentsforthegivenfield,ifapplicable.
     *
     *@private
     *@param{mail.model}record
     *@param{ModelField}field
     */
    _registerComputeOfDependents(record,field){
        constModel=record.constructor;
        for(constdependentoffield.dependents){
            const[hash,fieldName1,fieldName2]=dependent.split(
                this.DEPENDENT_INNER_SEPARATOR
            );
            constfield1=Model.__fieldMap[fieldName1];
            if(fieldName2){
                //"fieldName1.fieldName2"->dependentisonanotherrecord
                if(['one2many','many2many'].includes(field1.relationType)){
                    for(constotherRecordofrecord[fieldName1]){
                        constOtherModel=otherRecord.constructor;
                        constfield2=OtherModel.__fieldMap[fieldName2];
                        if(field2&&field2.hashes.includes(hash)){
                            this._registerToComputeField(otherRecord,field2);
                        }
                    }
                }else{
                    constotherRecord=record[fieldName1];
                    if(!otherRecord){
                        continue;
                    }
                    constOtherModel=otherRecord.constructor;
                    constfield2=OtherModel.__fieldMap[fieldName2];
                    if(field2&&field2.hashes.includes(hash)){
                        this._registerToComputeField(otherRecord,field2);
                    }
                }
            }else{
                //"fieldName1"only->dependentisoncurrentrecord
                if(field1&&field1.hashes.includes(hash)){
                    this._registerToComputeField(record,field1);
                }
            }
        }
    }

    /**
     *Registerapairrecord/fieldforthecomputestepoftheupdatecyclein
     *progress.
     *
     *@private
     *@param{mail.model}record
     *@param{ModelField}field
     */
    _registerToComputeField(record,field){
        if(!this._toComputeFields.has(record)){
            this._toComputeFields.set(record,newSet());
        }
        this._toComputeFields.get(record).add(field);
    }

    /**
     *@private
     *@param{mail.model}record
     *@param{Object}data
     *@param{Object}[options]
     *@returns{boolean}whetheranyvaluechangedforthecurrentrecord
     */
    _update(record,data,options){
        if(!record.exists()){
            throwError(`Cannotupdatealreadydeletedrecord${record.localId}.`);
        }
        if(!this._toUpdateAfters.has(record)){
            //queueupdateAfterbeforecallingfield.settoensureprevious
            //containsthevalueatthestartofupdatecycle
            this._toUpdateAfters.set(record,record._updateBefore());
        }
        constModel=record.constructor;
        lethasChanged=false;
        for(constfieldNameofObject.keys(data)){
            if(data[fieldName]===undefined){
                //`undefined`shouldhavethesameeffectasnotpassingthefield
                continue;
            }
            constfield=Model.__fieldMap[fieldName];
            if(!field){
                thrownewError(`Cannotcreate/updaterecordwithdataunrelatedtoafield.(model:"${Model.modelName}",non-fieldattemptedupdate:"${fieldName}")`);
            }
            constnewVal=data[fieldName];
            if(!field.parseAndExecuteCommands(record,newVal,options)){
                continue;
            }
            hasChanged=true;
            //flagalldependentfieldsforcompute
            this._registerComputeOfDependents(record,field);
        }
        if(hasChanged){
            this._updatedRecords.add(record);
            this._hasAnyChangeDuringCycle=true;
        }
        returnhasChanged;
    }

}

returnModelManager;

});

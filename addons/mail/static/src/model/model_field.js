flectra.define('mail/static/src/model/model_field.js',function(require){
'usestrict';

const{clear,FieldCommand}=require('mail/static/src/model/model_field_command.js');

/**
 *Classwhoseinstancesrepresentfieldonamodel.
 *Thesefielddefinitionsaregeneratedfromdeclaredfieldsinstaticprop
 *`fields`onthemodel.
 */
classModelField{

    //--------------------------------------------------------------------------
    //Public
    //--------------------------------------------------------------------------

    constructor({
        compute,
        default:def,
        dependencies=[],
        dependents=[],
        env,
        fieldName,
        fieldType,
        hashes:extraHashes=[],
        inverse,
        isCausal=false,
        related,
        relationType,
        to,
    }={}){
        constid=_.uniqueId('field_');
        /**
         *Ifset,thisfieldactsasacomputedfield,andthisprop
         *containsthenameoftheinstancemethodthatcomputesthevalue
         *forthisfield.Thiscomputemethodiscalledoncreationofrecord
         *andwheneversomeofitsdependencieschange.@seedependencies
         */
        this.compute=compute;
        /**
         *Defaultvalueforthisfield.Usedoncreationofthisfield,to
         *setavaluebydefault.
         */
        this.default=def;
        /**
         *Listoffieldoncurrentrecordthatthisfielddependsonforits
         *`compute`method.Usefultodeterminewhetherthisfieldshouldbe
         *registeredforrecomputationwhensomerecordfieldshavechanged.
         *Thislistmustbedeclaredinmodeldefinition,orcomputemethod
         *isonlycomputedonce.
         */
        this.dependencies=dependencies;
        /**
         *Listoffieldsthataredependentofthisfield.Theyshouldnever
         *bedeclared,andareautomaticallygeneratedwhileprocessing
         *declaredfields.Thisispopulatedbycompute`dependencies`and
         *`related`.
         */
        this.dependents=dependents;
        /**
         *Themessagingenv.
         */
        this.env=env;
        /**
         *Nameofthefieldinthedefinitionoffieldsonmodel.
         */
        this.fieldName=fieldName;
        /**
         *Typeofthisfield.2typesoffieldsarecurrentlysupported:
         *
         *  1.'attribute':fieldsthatstoreprimitivevalueslikeintegers,
         *                  booleans,strings,objects,array,etc.
         *
         *  2.'relation':fieldsthatrelatetosomeotherrecords.
         */
        this.fieldType=fieldType;
        /**
         *Listofhashesregisteredonthisfielddefinition.Technical
         *propthatisspecificallyusedinprocessingofdependent
         *fields,usefultoclearlyidentifywhichfieldsofarelationare
         *dependentsandmustberegisteredforcomputed.Indeed,notall
         *relatedrecordsmayhaveafieldthatdependsonchangedfield,
         *especiallywhendependencyisdefinedonsub-modelonarelationin
         *asuper-model.
         *
         *Toillustratethepurposeofthishash,supposefollowingdefinition
         *ofmodelsandfields:
         *
         *-3models(A,B,C)and3fields(x,y,z)
         *-A.fields:{x:one2one(C,inverse:x')}
         *-BextendsA
         *-B.fields:{z:related(x.y)}
         *-C.fields:{y:attribute}
         *
         *Visually:
         *              x'
         *         <-----------
         *       A----------->C{y}
         *       ^     x
         *       |
         *       |(extends)
         *       |
         *       B{z=x.y}
         *
         *Ifzhasadependencyonx.y,itmeansyhasadependentonx'.z.
         *NotethatfieldzexistsonBbutnotonallA.Todeterminewhich
         *kindsofrecordsinrelationx'aredependentony,yisawareofan
         *hashonthisdependent,andanydependentswhohasthishashinlist
         *ofhashesareactualdependents.
         */
        this.hashes=extraHashes.concat([id]);
        /**
         *Identificationforthisfielddefinition.Usefultomapadependent
         *fromadependency.Indeed,declaredfielddefinitionsuse
         *'dependencies'buttechnicalprocessneedinverseas'dependents'.
         *Dependenciesjustneednameoffields,butdependentscannotjust
         *relyoninversefieldnamesbecausethesedependentsareasubset.
         */
        this.id=id;
        /**
         *Thisproponlymakessenseinarelationalfield.Thiscontains
         *thenameofthefieldnameintheinverserelation.Thismaynot
         *bedefinedindeclaredfielddefinitions,butprocessedrelational
         *fielddefinitionsalwayshaveinverses.
         */
        this.inverse=inverse;
        /**
         *Thisproponlymakessenseinarelationalfield.Ifset,whenthis
         *relationisremoved,therelatedrecordisautomaticallydeleted.
         */
        this.isCausal=isCausal;
        /**
         *Ifset,thisfieldactsasarelatedfield,andthispropcontains
         *astringthatreferencestherelatedfield.Itshouldhavethe
         *followingformat:'<relationName>.<relatedFieldName>',where
         *<relationName>isarelationalfieldnameonthismodeloraparent
         *model(note:coulditselfbecomputedorrelated),and
         *<relatedFieldName>isthenameoffieldontherecordsthatare
         *relatedtocurrentrecordfromthisrelation.Whentherearemore
         *thanonerecordintherelation,itmapsallrelatedfieldsper
         *recordinrelation.
         *
         *FIXME:currentlyflattenmapduetobug,improvementisplanned
         *seeTask-id2261221
         */
        this.related=related;
        /**
         *Thisproponlymakessenseinarelationalfield.Determinewhich
         *typeofrelationthereisbetweencurrentrecordandotherrecords.
         *4typesofrelationaresupported:'one2one','one2many','many2one'
         *and'many2many'.
         */
        this.relationType=relationType;
        /**
         *Thisproponlymakessenseinarelationalfield.Determinewhich
         *modelnamethisrelationrefersto.
         */
        this.to=to;

        if(!this.default&&this.fieldType==='relation'){
            //defaultvalueforrelationalfieldsistheemptycommand
            this.default=[];
        }
    }

    /**
     *Defineanattributefield.
     *
     *@param{Object}[options]
     *@returns{Object}
     */
    staticattr(options){
        returnObject.assign({fieldType:'attribute'},options);
    }

    /**
     *Defineamany2manyfield.
     *
     *@param{string}modelName
     *@param{Object}[options]
     *@returns{Object}
     */
    staticmany2many(modelName,options){
        returnModelField._relation(modelName,Object.assign({},options,{relationType:'many2many'}));
    }

    /**
     *Defineamany2onefield.
     *
     *@param{string}modelName
     *@param{Object}[options]
     *@returns{Object}
     */
    staticmany2one(modelName,options){
        returnModelField._relation(modelName,Object.assign({},options,{relationType:'many2one'}));
    }

    /**
     *Defineaone2manyfield.
     *
     *@param{string}modelName
     *@param{Object}[options]
     *@returns{Object}
     */
    staticone2many(modelName,options){
        returnModelField._relation(modelName,Object.assign({},options,{relationType:'one2many'}));
    }

    /**
     *Defineaone2onefield.
     *
     *@param{string}modelName
     *@param{Object}[options]
     *@returns{Object}
     */
    staticone2one(modelName,options){
        returnModelField._relation(modelName,Object.assign({},options,{relationType:'one2one'}));
    }

    /**
     *Clearsthevalueofthisfieldonthegivenrecord.Itconsistsof
     *settingthistoitsdefaultvalue.Inparticular,using`clear`isthe
     *onlywaytowrite`undefined`onafield,aslongas`undefined`isits
     *defaultvalue.Relationalfieldsarealwaysunlinkedbeforethedefault
     *isapplied.
     *
     *@param{mail.model}record
     *@param{options}[options]
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    clear(record,options){
        lethasChanged=false;
        if(this.fieldType==='relation'){
            if(this.parseAndExecuteCommands(record,[['unlink-all']],options)){
                hasChanged=true;
            }
        }
        if(this.parseAndExecuteCommands(record,this.default,options)){
            hasChanged=true;
        }
        returnhasChanged;
    }

    /**
     *Combinecurrentfielddefinitionwithprovidedfielddefinitionand
     *returnthecombinedfielddefinition.Usefultotracklistofhashesof
     *agivenfield,whichisnecessaryfortheworkingofdependentfields
     *(computedandrelatedfields).
     *
     *@param{ModelField}field
     *@returns{ModelField}
     */
    combine(field){
        returnnewModelField(Object.assign({},this,{
            dependencies:this.dependencies.concat(field.dependencies),
            hashes:this.hashes.concat(field.hashes),
        }));
    }

    /**
     *Computemethodwhenthisfieldisrelated.
     *
     *@private
     *@param{mail.model}record
     */
    computeRelated(record){
        const[relationName,relatedFieldName]=this.related.split('.');
        constModel=record.constructor;
        constrelationField=Model.__fieldMap[relationName];
        if(['one2many','many2many'].includes(relationField.relationType)){
            constnewVal=[];
            for(constotherRecordofrecord[relationName]){
                constOtherModel=otherRecord.constructor;
                constotherField=OtherModel.__fieldMap[relatedFieldName];
                constotherValue=otherField.get(otherRecord);
                if(otherValue){
                    if(otherValueinstanceofArray){
                        //avoidnestedarrayifotherFieldisx2manytoo
                        //TODOIMPtask-2261221
                        for(constvofotherValue){
                            newVal.push(v);
                        }
                    }else{
                        newVal.push(otherValue);
                    }
                }
            }
            if(this.fieldType==='relation'){
                return[['replace',newVal]];
            }
            returnnewVal;
        }
        constotherRecord=record[relationName];
        if(otherRecord){
            constOtherModel=otherRecord.constructor;
            constotherField=OtherModel.__fieldMap[relatedFieldName];
            constnewVal=otherField.get(otherRecord);
            if(newVal===undefined){
                returnclear();
            }
            if(this.fieldType==='relation'){
                return[['replace',newVal]];
            }
            returnnewVal;
        }
        returnclear();
    }

    /**
     *Getthevalueassociatedtothisfield.Relationsmustconvertrecord
     *localidstorecords.
     *
     *@param{mail.model}record
     *@returns{any}
     */
    get(record){
        if(this.fieldType==='attribute'){
            returnthis.read(record);
        }
        if(this.fieldType==='relation'){
            if(['one2one','many2one'].includes(this.relationType)){
                returnthis.read(record);
            }
            return[...this.read(record)];
        }
        thrownewError(`cannotgetfieldwithunsupportedtype${this.fieldType}.`);
    }

    /**
     *ParsesnewValforcommand(s)andexecutesthem.
     *
     *@param{mail.model}record
     *@param{any}newVal
     *@param{Object}[options]
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    parseAndExecuteCommands(record,newVal,options){
        if(newValinstanceofFieldCommand){
            //singlecommandgiven
            returnnewVal.execute(this,record,options);
        }
        if(newValinstanceofArray&&newVal[0]instanceofFieldCommand){
            //multicommandgiven
            lethasChanged=false;
            for(constcommandofnewVal){
                if(command.execute(this,record,options)){
                    hasChanged=true;
                }
            }
            returnhasChanged;
        }
        //notacommand
        returnthis.set(record,newVal,options);
    }

    /**
     *Gettherawvalueassociatedtothisfield.Forrelations,thismeans
     *thelocalidorlistoflocalidsofrecordsinthisrelationalfield.
     *
     *@param{mail.model}record
     *@returns{any}
     */
    read(record){
        returnrecord.__values[this.fieldName];
    }

    /**
     *Setavalueonthisfield.Theformatofthevaluecomesfrombusiness
     *code.
     *
     *@param{mail.model}record
     *@param{any}newVal
     *@param{Object}[options]
     *@param{boolean}[options.hasToUpdateInverse]whetherupdatingthe
     * currentfieldshouldalsoupdateitsinversefield.Onlyappliesto
     * relationalfields.Typicallysettofalseonlyduringtheprocessof
     * updatingtheinversefielditself,toavoidunnecessaryrecursion.
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    set(record,newVal,options){
        constcurrentValue=this.read(record);
        if(this.fieldType==='attribute'){
            if(currentValue===newVal){
                returnfalse;
            }
            record.__values[this.fieldName]=newVal;
            returntrue;
        }
        if(this.fieldType==='relation'){
            lethasChanged=false;
            for(constvalofnewVal){
                switch(val[0]){
                    case'create':
                        if(this._setRelationCreate(record,val[1],options)){
                            hasChanged=true;
                        }
                        break;
                    case'insert':
                        if(this._setRelationInsert(record,val[1],options)){
                            hasChanged=true;
                        }
                        break;
                    case'insert-and-replace':
                        if(this._setRelationInsertAndReplace(record,val[1],options)){
                            hasChanged=true;
                        }
                        break;
                    case'link':
                        if(this._setRelationLink(record,val[1],options)){
                            hasChanged=true;
                        }
                        break;
                    case'replace':
                        if(this._setRelationReplace(record,val[1],options)){
                            hasChanged=true;
                        }
                        break;
                    case'unlink':
                        if(this._setRelationUnlink(record,val[1],options)){
                            hasChanged=true;
                        }
                        break;
                    case'unlink-all':
                        if(this._setRelationUnlink(record,this.get(record),options)){
                            hasChanged=true;
                        }
                        break;
                }
            }
            returnhasChanged;
        }
    }

    //--------------------------------------------------------------------------
    //Private
    //--------------------------------------------------------------------------

    /**
     *@private
     *@param{string}modelName
     *@param{Object}[options]
     */
    static_relation(modelName,options){
        returnObject.assign({
            fieldType:'relation',
            to:modelName,
        },options);
    }

    /**
     *Convertsgivenvaluetoexpectedformatforx2manyprocessing,whichis
     *aniterableofrecords.
     *
     *@private
     *@param{mail.model|mail.model[]}newValue
     *@param{Object}[param1={}]
     *@param{boolean}[param1.hasToVerify=true]whetherthevaluehastobe
     * verified@see`_verifyRelationalValue`
     *@returns{mail.model[]}
     */
    _convertX2ManyValue(newValue,{hasToVerify=true}={}){
        if(typeofnewValue[Symbol.iterator]==='function'){
            if(hasToVerify){
                for(constvalueofnewValue){
                    this._verifyRelationalValue(value);
                }
            }
            returnnewValue;
        }
        if(hasToVerify){
            this._verifyRelationalValue(newValue);
        }
        return[newValue];
    }

    /**
     *Setonthisrelationalfieldin'create'mode.Basicallydataprovided
     *duringsetonthisrelationalfieldcontaindatatocreatenewrecords,
     *whichthemselvesmustbelinkedtorecordofthisfieldbymeansof
     *thisfield.
     *
     *@private
     *@param{mail.model}record
     *@param{Object|Object[]}data
     *@param{Object}[options]
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    _setRelationCreate(record,data,options){
        constOtherModel=this.env.models[this.to];
        constother=this.env.modelManager._create(OtherModel,data);
        returnthis._setRelationLink(record,other,options);
    }

    /**
     *Setonthisrelationalfieldin'insert'mode.Basicallydataprovided
     *duringsetonthisrelationalfieldcontaindatatoinsertrecords,
     *whichthemselvesmustbelinkedtorecordofthisfieldbymeansof
     *thisfield.
     *
     *@private
     *@param{mail.model}record
     *@param{Object|Object[]}data
     *@param{Object}[options]
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    _setRelationInsert(record,data,options){
        constOtherModel=this.env.models[this.to];
        constother=this.env.modelManager._insert(OtherModel,data);
        returnthis._setRelationLink(record,other,options);
    }

    /**
     *Setonthisrelationalfieldin'insert-and-repalce'mode.Basically
     *dataprovidedduringsetonthisrelationalfieldcontaindatatoinsert
     *records,whichthemselvesmustreplacevalueonthisfield.
     *
     *@private
     *@param{mail.model}record
     *@param{Object|Object[]}data
     *@param{Object}[options]
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    _setRelationInsertAndReplace(record,data,options){
        constOtherModel=this.env.models[this.to];
        constnewValue=this.env.modelManager._insert(OtherModel,data);
        returnthis._setRelationReplace(record,newValue,options);
    }

    /**
     *Seta'link'operationonthisrelationalfield.
     *
     *@private
     *@param{mail.model|mail.model[]}newValue
     *@param{Object}[options]
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    _setRelationLink(record,newValue,options){
        switch(this.relationType){
            case'many2many':
            case'one2many':
                returnthis._setRelationLinkX2Many(record,newValue,options);
            case'many2one':
            case'one2one':
                returnthis._setRelationLinkX2One(record,newValue,options);
        }
    }

    /**
     *Handlingofa`set`'link'ofax2manyrelationalfield.
     *
     *@private
     *@param{mail.model}record
     *@param{mail.model|mail.model[]}newValue
     *@param{Object}[param2={}]
     *@param{boolean}[param2.hasToUpdateInverse=true]whetherupdatingthe
     * currentfieldshouldalsoupdateitsinversefield.Typicallysetto
     * falseonlyduringtheprocessofupdatingtheinversefielditself,to
     * avoidunnecessaryrecursion.
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    _setRelationLinkX2Many(record,newValue,{hasToUpdateInverse=true}={}){
        constrecordsToLink=this._convertX2ManyValue(newValue);
        constotherRecords=this.read(record);

        lethasChanged=false;
        for(constrecordToLinkofrecordsToLink){
            //otherrecordalreadylinked,avoidlinkingtwice
            if(otherRecords.has(recordToLink)){
                continue;
            }
            hasChanged=true;
            //linkotherrecordstocurrentrecord
            otherRecords.add(recordToLink);
            //linkcurrentrecordtootherrecords
            if(hasToUpdateInverse){
                this.env.modelManager._update(
                    recordToLink,
                    {[this.inverse]:[['link',record]]},
                    {hasToUpdateInverse:false}
                );
            }
        }
        returnhasChanged;
    }

    /**
     *Handlingofa`set`'link'ofanx2onerelationalfield.
     *
     *@private
     *@param{mail.model}record
     *@param{mail.model}recordToLink
     *@param{Object}[param2={}]
     *@param{boolean}[param2.hasToUpdateInverse=true]whetherupdatingthe
     * currentfieldshouldalsoupdateitsinversefield.Typicallysetto
     * falseonlyduringtheprocessofupdatingtheinversefielditself,to
     * avoidunnecessaryrecursion.
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    _setRelationLinkX2One(record,recordToLink,{hasToUpdateInverse=true}={}){
        this._verifyRelationalValue(recordToLink);
        constprevOtherRecord=this.read(record);
        //otherrecordalreadylinked,avoidlinkingtwice
        if(prevOtherRecord===recordToLink){
            returnfalse;
        }
        //unlinktoproperlyupdatepreviousinversebeforelinkingnewvalue
        this._setRelationUnlinkX2One(record,{hasToUpdateInverse});
        //linkotherrecordtocurrentrecord
        record.__values[this.fieldName]=recordToLink;
        //linkcurrentrecordtootherrecord
        if(hasToUpdateInverse){
            this.env.modelManager._update(
                recordToLink,
                {[this.inverse]:[['link',record]]},
                {hasToUpdateInverse:false}
            );
        }
        returntrue;
    }

    /**
     *Seta'replace'operationonthisrelationalfield.
     *
     *@private
     *@param{mail.model}record
     *@param{mail.model|mail.model[]}newValue
     *@param{Object}[options]
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    _setRelationReplace(record,newValue,options){
        if(['one2one','many2one'].includes(this.relationType)){
            //forx2onereplaceisjustlink
            returnthis._setRelationLinkX2One(record,newValue,options);
        }

        //forx2many:smartprocesstoavoidunnecessaryunlink/link
        lethasChanged=false;
        lethasToReorder=false;
        constotherRecordsSet=this.read(record);
        constotherRecordsList=[...otherRecordsSet];
        constrecordsToReplaceList=[...this._convertX2ManyValue(newValue)];
        constrecordsToReplaceSet=newSet(recordsToReplaceList);

        //recordstolink
        constrecordsToLink=[];
        for(leti=0;i<recordsToReplaceList.length;i++){
            constrecordToReplace=recordsToReplaceList[i];
            if(!otherRecordsSet.has(recordToReplace)){
                recordsToLink.push(recordToReplace);
            }
            if(otherRecordsList[i]!==recordToReplace){
                hasToReorder=true;
            }
        }
        if(this._setRelationLinkX2Many(record,recordsToLink,options)){
            hasChanged=true;
        }

        //recordstounlink
        constrecordsToUnlink=[];
        for(leti=0;i<otherRecordsList.length;i++){
            constotherRecord=otherRecordsList[i];
            if(!recordsToReplaceSet.has(otherRecord)){
                recordsToUnlink.push(otherRecord);
            }
            if(recordsToReplaceList[i]!==otherRecord){
                hasToReorder=true;
            }
        }
        if(this._setRelationUnlinkX2Many(record,recordsToUnlink,options)){
            hasChanged=true;
        }

        //reorderresult
        if(hasToReorder){
            otherRecordsSet.clear();
            for(constrecordofrecordsToReplaceList){
                otherRecordsSet.add(record);
            }
            hasChanged=true;
        }
        returnhasChanged;
    }

    /**
     *Setan'unlink'operationonthisrelationalfield.
     *
     *@private
     *@param{mail.model}record
     *@param{mail.model|mail.model[]}newValue
     *@param{Object}[options]
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    _setRelationUnlink(record,newValue,options){
        switch(this.relationType){
            case'many2many':
            case'one2many':
                returnthis._setRelationUnlinkX2Many(record,newValue,options);
            case'many2one':
            case'one2one':
                returnthis._setRelationUnlinkX2One(record,options);
        }
    }

    /**
     *Handlingofa`set`'unlink'ofax2manyrelationalfield.
     *
     *@private
     *@param{mail.model}record
     *@param{mail.model|mail.model[]}newValue
     *@param{Object}[param2={}]
     *@param{boolean}[param2.hasToUpdateInverse=true]whetherupdatingthe
     * currentfieldshouldalsoupdateitsinversefield.Typicallysetto
     * falseonlyduringtheprocessofupdatingtheinversefielditself,to
     * avoidunnecessaryrecursion.
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    _setRelationUnlinkX2Many(record,newValue,{hasToUpdateInverse=true}={}){
        constrecordsToUnlink=this._convertX2ManyValue(
            newValue,
            {hasToVerify:false}
        );
        constotherRecords=this.read(record);

        lethasChanged=false;
        for(constrecordToUnlinkofrecordsToUnlink){
            //unlinkotherrecordfromcurrentrecord
            constwasLinked=otherRecords.delete(recordToUnlink);
            if(!wasLinked){
                continue;
            }
            hasChanged=true;
            //unlinkcurrentrecordfromotherrecords
            if(hasToUpdateInverse){
                if(!recordToUnlink.exists()){
                    //Thiscaseshouldneverhappenideally,butthecurrent
                    //wayofhandlingrelatedrelationalfieldsmakeitsothat
                    //deletedrecordsarenotalwaysreflectedimmediatelyin
                    //theserelatedfields.
                    continue;
                }
                //applycausality
                if(this.isCausal){
                    this.env.modelManager._delete(recordToUnlink);
                }else{
                    this.env.modelManager._update(
                        recordToUnlink,
                        {[this.inverse]:[['unlink',record]]},
                        {hasToUpdateInverse:false}
                    );
                }
            }
        }
        returnhasChanged;
    }

    /**
     *Handlingofa`set`'unlink'ofax2onerelationalfield.
     *
     *@private
     *@param{mail.model}record
     *@param{Object}[param1={}]
     *@param{boolean}[param1.hasToUpdateInverse=true]whetherupdatingthe
     * currentfieldshouldalsoupdateitsinversefield.Typicallysetto
     * falseonlyduringtheprocessofupdatingtheinversefielditself,to
     * avoidunnecessaryrecursion.
     *@returns{boolean}whetherthevaluechangedforthecurrentfield
     */
    _setRelationUnlinkX2One(record,{hasToUpdateInverse=true}={}){
        constotherRecord=this.read(record);
        //otherrecordalreadyunlinked,avoiduselessprocessing
        if(!otherRecord){
            returnfalse;
        }
        //unlinkotherrecordfromcurrentrecord
        record.__values[this.fieldName]=undefined;
        //unlinkcurrentrecordfromotherrecord
        if(hasToUpdateInverse){
            if(!otherRecord.exists()){
                //Thiscaseshouldneverhappenideally,butthecurrent
                //wayofhandlingrelatedrelationalfieldsmakeitsothat
                //deletedrecordsarenotalwaysreflectedimmediatelyin
                //theserelatedfields.
                return;
            }
            //applycausality
            if(this.isCausal){
                this.env.modelManager._delete(otherRecord);
            }else{
                this.env.modelManager._update(
                    otherRecord,
                    {[this.inverse]:[['unlink',record]]},
                    {hasToUpdateInverse:false}
                );
            }
        }
        returntrue;
    }

    /**
     *Verifiesthegivenrelationalvaluemakessenseforthecurrentfield.
     *Inparticularthegivenvaluemustbearecord,itmustbenon-deleted,
     *anditmustoriginatesfromrelational`to`model(oritssubclasses).
     *
     *@private
     *@param{mail.model}record
     *@throws{Error}ifrecorddoesnotsatisfyrelatedmodel
     */
    _verifyRelationalValue(record){
        constOtherModel=this.env.models[this.to];
        if(!OtherModel.get(record.localId,{isCheckingInheritance:true})){
            throwError(`Record${record.localId}isnotvalidforrelationalfield${this.fieldName}.`);
        }
    }

}

returnModelField;

});

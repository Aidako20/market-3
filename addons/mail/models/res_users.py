#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

fromcollectionsimportdefaultdict

fromflectraimport_,api,exceptions,fields,models,modules
fromflectra.addons.base.models.res_usersimportis_selection_groups


classUsers(models.Model):
    """Updateofres.usersclass
        -addapreferenceaboutsendingemailsaboutnotifications
        -makeanewuserfollowitself
        -addawelcomemessage
        -addsuggestionpreference
        -ifaddinggroupstoauser,checkmail.channelslinkedtothisuser
          group,andtheuser.Thisisdonebyoverridingthewritemethod.
    """
    _name='res.users'
    _inherit=['res.users']
    _description='Users'

    notification_type=fields.Selection([
        ('email','HandlebyEmails'),
        ('inbox','HandleinFlectra')],
        'Notification',required=True,default='email',
        help="PolicyonhowtohandleChatternotifications:\n"
             "-HandlebyEmails:notificationsaresenttoyouremailaddress\n"
             "-HandleinFlectra:notificationsappearinyourFlectraInbox")
    #channel-specific:moderation
    is_moderator=fields.Boolean(string='Ismoderator',compute='_compute_is_moderator')
    moderation_counter=fields.Integer(string='Moderationcount',compute='_compute_moderation_counter')
    moderation_channel_ids=fields.Many2many(
        'mail.channel','mail_channel_moderator_rel',
        string='Moderatedchannels')

    @api.depends('moderation_channel_ids.moderation','moderation_channel_ids.moderator_ids')
    def_compute_is_moderator(self):
        moderated=self.env['mail.channel'].search([
            ('id','in',self.mapped('moderation_channel_ids').ids),
            ('moderation','=',True),
            ('moderator_ids','in',self.ids)
        ])
        user_ids=moderated.mapped('moderator_ids')
        foruserinself:
            user.is_moderator=userinuser_ids

    def_compute_moderation_counter(self):
        self._cr.execute("""
SELECTchannel_moderator.res_users_id,COUNT(msg.id)
FROM"mail_channel_moderator_rel"ASchannel_moderator
JOIN"mail_message"ASmsg
ONchannel_moderator.mail_channel_id=msg.res_id
    ANDchannel_moderator.res_users_idIN%s
    ANDmsg.model='mail.channel'
    ANDmsg.moderation_status='pending_moderation'
GROUPBYchannel_moderator.res_users_id""",[tuple(self.ids)])
        result=dict(self._cr.fetchall())
        foruserinself:
            user.moderation_counter=result.get(user.id,0)

    def__init__(self,pool,cr):
        """Overrideof__init__toaddaccessrightsonnotification_email_send
            fields.Accessrightsaredisabledbydefault,butallowedonsome
            specificfieldsdefinedinself.SELF_{READ/WRITE}ABLE_FIELDS.
        """
        init_res=super(Users,self).__init__(pool,cr)
        #duplicatelisttoavoidmodifyingtheoriginalreference
        pool[self._name].SELF_WRITEABLE_FIELDS=list(self.SELF_WRITEABLE_FIELDS)
        pool[self._name].SELF_WRITEABLE_FIELDS.extend(['notification_type'])
        #duplicatelisttoavoidmodifyingtheoriginalreference
        pool[self._name].SELF_READABLE_FIELDS=list(self.SELF_READABLE_FIELDS)
        pool[self._name].SELF_READABLE_FIELDS.extend(['notification_type'])
        returninit_res

    @api.model_create_multi
    defcreate(self,vals_list):
        forvaluesinvals_list:
            ifnotvalues.get('login',False):
                action=self.env.ref('base.action_res_users')
                msg=_("Youcannotcreateanewuserfromhere.\nTocreatenewuserpleasegotoconfigurationpanel.")
                raiseexceptions.RedirectWarning(msg,action.id,_('Gototheconfigurationpanel'))

        users=super(Users,self).create(vals_list)
        #Auto-subscribetochannels
        self.env['mail.channel'].search([('group_ids','in',users.groups_id.ids)])._subscribe_users()
        returnusers

    defwrite(self,vals):
        write_res=super(Users,self).write(vals)
        if'active'invalsandnotvals['active']:
            self._unsubscribe_from_channels()
        sel_groups=[vals[k]forkinvalsifis_selection_groups(k)andvals[k]]
        ifvals.get('groups_id'):
            #form:{'group_ids':[(3,10),(3,3),(4,10),(4,3)]}or{'group_ids':[(6,0,[ids]}
            user_group_ids=[command[1]forcommandinvals['groups_id']ifcommand[0]==4]
            user_group_ids+=[idforcommandinvals['groups_id']ifcommand[0]==6foridincommand[2]]
            self.env['mail.channel'].search([('group_ids','in',user_group_ids)])._subscribe_users()
        elifsel_groups:
            self.env['mail.channel'].search([('group_ids','in',sel_groups)])._subscribe_users()
        returnwrite_res

    defunlink(self):
        self._unsubscribe_from_channels()
        returnsuper().unlink()

    def_unsubscribe_from_channels(self):
        """Thismethodun-subscribesusersfromprivatemailchannels.Mainpurposeofthis
            methodistopreventsendinginternalcommunicationtoarchived/deletedusers.
            Wedonotun-subscribesusersfrompublicchannelsbecauseinmostcommoncases,
            publicchannelsaremailinglist(e-mailbased)andsousersshouldalwaysreceive
            updatesfrompublicchannelsuntiltheymanuallyun-subscribethemselves.
        """
        self.mapped('partner_id.channel_ids').filtered(lambdac:c.public!='public'andc.channel_type=='channel').write({
            'channel_partner_ids':[(3,pid)forpidinself.mapped('partner_id').ids]
        })

    @api.model
    defsystray_get_activities(self):
        query="""SELECTarray_agg(res_id)asres_ids,m.id,count(*),
                    CASE
                        WHEN%(today)s::date-act.date_deadline::date=0Then'today'
                        WHEN%(today)s::date-act.date_deadline::date>0Then'overdue'
                        WHEN%(today)s::date-act.date_deadline::date<0Then'planned'
                    ENDASstates
                FROMmail_activityASact
                JOINir_modelASmONact.res_model_id=m.id
                WHEREuser_id=%(user_id)s
                GROUPBYm.id,states;
                """
        self.env.cr.execute(query,{
            'today':fields.Date.context_today(self),
            'user_id':self.env.uid,
        })
        activity_data=self.env.cr.dictfetchall()
        records_by_state_by_model=defaultdict(lambda:{"today":set(),"overdue":set(),"planned":set(),"all":set()})
        fordatainactivity_data:
            records_by_state_by_model[data["id"]][data["states"]]=set(data["res_ids"])
            records_by_state_by_model[data["id"]]["all"]=records_by_state_by_model[data["id"]]["all"]|set(data["res_ids"])
        user_activities={}
        formodel_idinrecords_by_state_by_model:
            model_dic=records_by_state_by_model[model_id]
            model=self.env["ir.model"].browse(model_id).with_prefetch(tuple(records_by_state_by_model.keys()))
            allowed_records=self.env[model.model].search([("id","in",tuple(model_dic["all"]))])
            ifnotallowed_records:
                continue
            module=self.env[model.model]._original_module
            icon=moduleandmodules.module.get_module_icon(module)
            today=len(model_dic["today"]&set(allowed_records.ids))
            overdue=len(model_dic["overdue"]&set(allowed_records.ids))
            user_activities[model.model]={
                "name":model.name,
                "model":model.model,
                "type":"activity",
                "icon":icon,
                "total_count":today+overdue,
                "today_count":today,
                "overdue_count":overdue,
                "planned_count":len(model_dic["planned"]&set(allowed_records.ids)),
                "actions":[
                    {
                        "icon":"fa-clock-o",
                        "name":"Summary",
                    }
                ],
            }
        returnlist(user_activities.values())


classres_groups_mail_channel(models.Model):
    """Updateofres.groupsclass
        -ifaddingusersfromagroup,checkmail.channelslinkedtothisuser
          groupandsubscribethem.Thisisdonebyoverridingthewritemethod.
    """
    _name='res.groups'
    _inherit='res.groups'
    _description='AccessGroups'

    defwrite(self,vals,context=None):
        write_res=super(res_groups_mail_channel,self).write(vals)
        ifvals.get('users'):
            #form:{'group_ids':[(3,10),(3,3),(4,10),(4,3)]}or{'group_ids':[(6,0,[ids]}
            user_ids=[command[1]forcommandinvals['users']ifcommand[0]==4]
            user_ids+=[idforcommandinvals['users']ifcommand[0]==6foridincommand[2]]
            self.env['mail.channel'].search([('group_ids','in',self._ids)])._subscribe_users()
        returnwrite_res

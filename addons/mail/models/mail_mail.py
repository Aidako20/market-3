#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

importast
importbase64
importdatetime
importlogging
importpsycopg2
importsmtplib
importthreading
importre

fromcollectionsimportdefaultdict

fromflectraimport_,api,fields,models
fromflectraimporttools
fromflectra.addons.base.models.ir_mail_serverimportMailDeliveryException

_logger=logging.getLogger(__name__)


classMailMail(models.Model):
    """ModelholdingRFC2822emailmessagestosend.Thismodelalsoprovides
        facilitiestoqueueandsendnewemailmessages. """
    _name='mail.mail'
    _description='OutgoingMails'
    _inherits={'mail.message':'mail_message_id'}
    _order='iddesc'
    _rec_name='subject'

    #content
    mail_message_id=fields.Many2one('mail.message','Message',required=True,ondelete='cascade',index=True,auto_join=True)
    body_html=fields.Text('Rich-textContents',help="Rich-text/HTMLmessage")
    references=fields.Text('References',help='Messagereferences,suchasidentifiersofpreviousmessages',readonly=1)
    headers=fields.Text('Headers',copy=False)
    #Auto-detectedbasedoncreate()-if'mail_message_id'waspassedthenthismailisanotification
    #andduringunlink()wewillnotcascadedeletetheparentanditsattachments
    notification=fields.Boolean('IsNotification',help='Mailhasbeencreatedtonotifypeopleofanexistingmail.message')
    #recipients:includeinactivepartners(theymayhavebeenarchivedafter
    #themessagewassent,buttheyshouldremainvisibleintherelation)
    email_to=fields.Text('To',help='Messagerecipients(emails)')
    email_cc=fields.Char('Cc',help='Carboncopymessagerecipients')
    recipient_ids=fields.Many2many('res.partner',string='To(Partners)',
        context={'active_test':False})
    #process
    state=fields.Selection([
        ('outgoing','Outgoing'),
        ('sent','Sent'),
        ('received','Received'),
        ('exception','DeliveryFailed'),
        ('cancel','Cancelled'),
    ],'Status',readonly=True,copy=False,default='outgoing')
    auto_delete=fields.Boolean(
        'AutoDelete',
        help="Thisoptionpermanentlyremovesanytrackofemailafterit'sbeensent,includingfromtheTechnicalmenuintheSettings,inordertopreservestoragespaceofyourFlectradatabase.")
    failure_reason=fields.Text(
        'FailureReason',readonly=1,
        help="Failurereason.Thisisusuallytheexceptionthrownbytheemailserver,storedtoeasethedebuggingofmailingissues.")
    scheduled_date=fields.Char('ScheduledSendDate',
        help="Ifset,thequeuemanagerwillsendtheemailafterthedate.Ifnotset,theemailwillbesendassoonaspossible.")

    @api.model_create_multi
    defcreate(self,values_list):
        #notificationfield:ifnotset,setifmailcomesfromanexistingmail.message
        forvaluesinvalues_list:
            if'notification'notinvaluesandvalues.get('mail_message_id'):
                values['notification']=True

        new_mails=super(MailMail,self).create(values_list)

        new_mails_w_attach=self
        formail,valuesinzip(new_mails,values_list):
            ifvalues.get('attachment_ids'):
                new_mails_w_attach+=mail
        ifnew_mails_w_attach:
            new_mails_w_attach.mapped('attachment_ids').check(mode='read')

        returnnew_mails

    defwrite(self,vals):
        res=super(MailMail,self).write(vals)
        ifvals.get('attachment_ids'):
            formailinself:
                mail.attachment_ids.check(mode='read')
        returnres

    defunlink(self):
        #cascade-deletetheparentmessageforallmailsthatarenotcreatedforanotification
        mail_msg_cascade_ids=[mail.mail_message_id.idformailinselfifnotmail.notification]
        res=super(MailMail,self).unlink()
        ifmail_msg_cascade_ids:
            self.env['mail.message'].browse(mail_msg_cascade_ids).unlink()
        returnres

    @api.model
    defdefault_get(self,fields):
        #protectionfor`default_type`valuesleakingfrommenuactioncontext(e.g.forinvoices)
        #Toremovewhenautomaticcontextpropagationisremovedinwebclient
        ifself._context.get('default_type')notinself._fields['message_type'].base_field.selection:
            self=self.with_context(dict(self._context,default_type=None))
        ifself._context.get('default_state')notinself._fields['state'].base_field.selection:
            self=self.with_context(dict(self._context,default_state='outgoing'))
        returnsuper(MailMail,self).default_get(fields)

    defmark_outgoing(self):
        returnself.write({'state':'outgoing'})

    defcancel(self):
        returnself.write({'state':'cancel'})

    @api.model
    defprocess_email_queue(self,ids=None):
        """Sendimmediatelyqueuedmessages,committingaftereach
           messageissent-thisisnottransactionalandshould
           notbecalledduringanothertransaction!

           :paramlistids:optionallistofemailsidstosend.Ifpassed
                            nosearchisperformed,andtheseidsareused
                            instead.
           :paramdictcontext:ifa'filters'keyispresentincontext,
                                thisvaluewillbeusedasanadditional
                                filtertofurtherrestricttheoutgoing
                                messagestosend(bydefaultall'outgoing'
                                messagesaresent).
        """
        filters=['&',
                   ('state','=','outgoing'),
                   '|',
                   ('scheduled_date','<',datetime.datetime.now()),
                   ('scheduled_date','=',False)]
        if'filters'inself._context:
            filters.extend(self._context['filters'])
        #TODO:makelimitconfigurable
        filtered_ids=self.search(filters,limit=10000).ids
        ifnotids:
            ids=filtered_ids
        else:
            ids=list(set(filtered_ids)&set(ids))
        ids.sort()

        res=None
        try:
            #auto-commitexceptintestingmode
            auto_commit=notgetattr(threading.currentThread(),'testing',False)
            res=self.browse(ids).send(auto_commit=auto_commit)
        exceptException:
            _logger.exception("Failedprocessingmailqueue")
        returnres

    def_postprocess_sent_message(self,success_pids,failure_reason=False,failure_type=None):
        """Performanypost-processingnecessaryaftersending``mail``
        successfully,includingdeletingitcompletelyalongwithits
        attachmentifthe``auto_delete``flagofthemailwasset.
        Overriddenbysubclassesforextrapost-processingbehaviors.

        :return:True
        """
        notif_mails_ids=[mail.idformailinselfifmail.notification]
        ifnotif_mails_ids:
            notifications=self.env['mail.notification'].search([
                ('notification_type','=','email'),
                ('mail_id','in',notif_mails_ids),
                ('notification_status','notin',('sent','canceled'))
            ])
            ifnotifications:
                #findallnotificationlinkedtoafailure
                failed=self.env['mail.notification']
                iffailure_type:
                    failed=notifications.filtered(lambdanotif:notif.res_partner_idnotinsuccess_pids)
                (notifications-failed).sudo().write({
                    'notification_status':'sent',
                    'failure_type':'',
                    'failure_reason':'',
                })
                iffailed:
                    failed.sudo().write({
                        'notification_status':'exception',
                        'failure_type':failure_type,
                        'failure_reason':failure_reason,
                    })
                    messages=notifications.mapped('mail_message_id').filtered(lambdam:m.is_thread_message())
                    #TDETODO:couldbegreattonotifymessage-based,notnotifications-based,tolessennumberofnotifs
                    messages._notify_message_notification_update() #notifyuserthatwehaveafailure
        ifnotfailure_typeorfailure_type=='RECIPIENT': #ifwehaveanothererror,wewanttokeepthemail.
            mail_to_delete_ids=[mail.idformailinselfifmail.auto_delete]
            self.browse(mail_to_delete_ids).sudo().unlink()
        returnTrue

    #------------------------------------------------------
    #mail_mailformatting,toolsandsendmechanism
    #------------------------------------------------------

    def_send_prepare_body(self):
        """Returnaspecificir_emailbody.Themainpurposeofthismethod
        istobeinheritedtoaddcustomcontentdependingonsomemodule."""
        self.ensure_one()
        returnself.body_htmlor''

    def_send_prepare_values(self,partner=None):
        """Returnadictionaryforspecificemailvalues,dependingona
        partner,orgenerictothewholerecipientsgivenbymail.email_to.

            :paramModelpartner:specificrecipientpartner
        """
        self.ensure_one()
        body=self._send_prepare_body()
        body_alternative=tools.html2plaintext(body)
        ifpartner:
            emails_normalized=tools.email_normalize_all(partner.email)
            ifemails_normalized:
                email_to=[
                    tools.formataddr((partner.nameor"False",emailor"False"))
                    foremailinemails_normalized
                ]
            else:
                email_to=[tools.formataddr((partner.nameor"False",partner.emailor"False"))]
        else:
            email_to=tools.email_split_and_format(self.email_to)
        res={
            'body':body,
            'body_alternative':body_alternative,
            'email_to':email_to,
        }
        returnres

    def_split_by_server(self):
        """Returnsaniteratorofpairs`(mail_server_id,record_ids)`forcurrentrecordset.

        Thesame`mail_server_id`mayrepeatinordertolimitbatchsizeaccordingto
        the`mail.session.batch.size`systemparameter.
        """
        groups=defaultdict(list)
        #TurnprefetchOFFtoavoidMemoryErroronverylargemailqueues,weonlycare
        #aboutthemailserveridsinthiscase.
        formailinself.with_context(prefetch_fields=False):
            groups[mail.mail_server_id.id].append(mail.id)
        sys_params=self.env['ir.config_parameter'].sudo()
        batch_size=int(sys_params.get_param('mail.session.batch.size',1000))
        forserver_id,record_idsingroups.items():
            formail_batchintools.split_every(batch_size,record_ids):
                yieldserver_id,mail_batch

    defsend(self,auto_commit=False,raise_exception=False):
        """Sendstheselectedemailsimmediately,ignoringtheircurrent
            state(mailsthathavealreadybeensentshouldnotbepassed
            unlesstheyshouldactuallybere-sent).
            Emailssuccessfullydeliveredaremarkedas'sent',andthose
            thatfailtobedeliveraremarkedas'exception',andthe
            correspondingerrormailisoutputintheserverlogs.

            :paramboolauto_commit:whethertoforceacommitofthemailstatus
                aftersendingeachmail(meantonlyforschedulerprocessing);
                shouldneverbeTrueduringnormaltransactions(default:False)
            :paramboolraise_exception:whethertoraiseanexceptionifthe
                emailsendingprocesshasfailed
            :return:True
        """
        forserver_id,batch_idsinself._split_by_server():
            smtp_session=None
            try:
                smtp_session=self.env['ir.mail_server'].connect(mail_server_id=server_id)
            exceptExceptionasexc:
                ifraise_exception:
                    #Tobeconsistentandbackwardcompatiblewithmail_mail.send()raised
                    #exceptions,itisencapsulatedintoanFlectraMailDeliveryException
                    raiseMailDeliveryException(_('UnabletoconnecttoSMTPServer'),exc)
                else:
                    batch=self.browse(batch_ids)
                    batch.write({'state':'exception','failure_reason':exc})
                    batch._postprocess_sent_message(success_pids=[],failure_type="SMTP")
            else:
                self.browse(batch_ids)._send(
                    auto_commit=auto_commit,
                    raise_exception=raise_exception,
                    smtp_session=smtp_session)
                _logger.info(
                    'Sentbatch%semailsviamailserverID#%s',
                    len(batch_ids),server_id)
            finally:
                ifsmtp_session:
                    smtp_session.quit()

    def_send(self,auto_commit=False,raise_exception=False,smtp_session=None):
        IrMailServer=self.env['ir.mail_server']
        IrAttachment=self.env['ir.attachment']
        formail_idinself.ids:
            success_pids=[]
            failure_type=None
            processing_pid=None
            mail=None
            try:
                mail=self.browse(mail_id)
                ifmail.state!='outgoing':
                    ifmail.state!='exception'andmail.auto_delete:
                        mail.sudo().unlink()
                    continue

                #removeattachmentsifusersendthelinkwiththeaccess_token
                body=mail.body_htmlor''
                attachments=mail.attachment_ids
                forlinkinre.findall(r'/web/(?:content|image)/([0-9]+)',body):
                    attachments=attachments-IrAttachment.browse(int(link))

                #loadattachmentbinarydatawithaseparateread(),asprefetchingall
                #`datas`(binaryfield)couldbloatthebrowsecache,triggerring
                #soft/hardmemlimitswithtemporarydata.
                attachments=[(a['name'],base64.b64decode(a['datas']),a['mimetype'])
                               forainattachments.sudo().read(['name','datas','mimetype'])ifa['datas']isnotFalse]

                #specificbehaviortocustomizethesendemailfornotifiedpartners
                email_list=[]
                ifmail.email_to:
                    email_list.append(mail._send_prepare_values())
                forpartnerinmail.recipient_ids:
                    values=mail._send_prepare_values(partner=partner)
                    values['partner_id']=partner
                    email_list.append(values)

                #headers
                headers={}
                ICP=self.env['ir.config_parameter'].sudo()
                bounce_alias=ICP.get_param("mail.bounce.alias")
                bounce_alias_static=tools.str2bool(ICP.get_param("mail.bounce.alias.static","False"))
                catchall_domain=ICP.get_param("mail.catchall.domain")
                ifbounce_aliasandcatchall_domain:
                    ifbounce_alias_static:
                        headers['Return-Path']='%s@%s'%(bounce_alias,catchall_domain)
                    elifmail.mail_message_id.is_thread_message():
                        headers['Return-Path']='%s+%d-%s-%d@%s'%(bounce_alias,mail.id,mail.model,mail.res_id,catchall_domain)
                    else:
                        headers['Return-Path']='%s+%d@%s'%(bounce_alias,mail.id,catchall_domain)
                ifmail.headers:
                    try:
                        headers.update(ast.literal_eval(mail.headers))
                    exceptException:
                        pass

                #Writingonthemailobjectmayfail(e.g.lockonuser)which
                #wouldtriggerarollback*after*actuallysendingtheemail.
                #Toavoidsendingtwicethesameemail,provokethefailureearlier
                mail.write({
                    'state':'exception',
                    'failure_reason':_('Errorwithoutexception.Probablyduedosendinganemailwithoutcomputedrecipients.'),
                })
                #Updatenotificationinatransientexceptionstatetoavoidconcurrent
                #updateincaseanemailbounceswhilesendingallemailsrelatedtocurrent
                #mailrecord.
                notifs=self.env['mail.notification'].search([
                    ('notification_type','=','email'),
                    ('mail_id','in',mail.ids),
                    ('notification_status','notin',('sent','canceled'))
                ])
                ifnotifs:
                    notif_msg=_('Errorwithoutexception.Probablyduedoconcurrentaccessupdateofnotificationrecords.Pleaseseewithanadministrator.')
                    notifs.sudo().write({
                        'notification_status':'exception',
                        'failure_type':'UNKNOWN',
                        'failure_reason':notif_msg,
                    })
                    #`test_mail_bounce_during_send`,forceimmediateupdatetoobtainthelock.
                    #seerev.56596e5240ef920df14d99087451ce6f06ac6d36
                    notifs.flush(fnames=['notification_status','failure_type','failure_reason'],records=notifs)

                #protectagainstill-formattedemail_fromwhenformataddrwasusedonanalreadyformattedemail
                emails_from=tools.email_split_and_format(mail.email_from)
                email_from=emails_from[0]ifemails_fromelsemail.email_from

                #buildanRFC2822email.message.Messageobjectandsenditwithoutqueuing
                res=None
                foremailinemail_list:
                    msg=IrMailServer.build_email(
                        email_from=email_from,
                        email_to=email.get('email_to'),
                        subject=mail.subject,
                        body=email.get('body'),
                        body_alternative=email.get('body_alternative'),
                        email_cc=tools.email_split(mail.email_cc),
                        reply_to=mail.reply_to,
                        attachments=attachments,
                        message_id=mail.message_id,
                        references=mail.references,
                        object_id=mail.res_idand('%s-%s'%(mail.res_id,mail.model)),
                        subtype='html',
                        subtype_alternative='plain',
                        headers=headers)
                    processing_pid=email.pop("partner_id",None)
                    try:
                        res=IrMailServer.send_email(
                            msg,mail_server_id=mail.mail_server_id.id,smtp_session=smtp_session)
                        ifprocessing_pid:
                            success_pids.append(processing_pid)
                        processing_pid=None
                    exceptAssertionErroraserror:
                        ifstr(error)==IrMailServer.NO_VALID_RECIPIENT:
                            failure_type="RECIPIENT"
                            #Novalidrecipientfoundforthisparticular
                            #mailitem->ignoreerrortoavoidblocking
                            #deliverytonextrecipients,ifany.Ifthisis
                            #theonlyrecipient,themailwillshowasfailed.
                            _logger.info("Ignoringinvalidrecipientsformail.mail%s:%s",
                                         mail.message_id,email.get('email_to'))
                        else:
                            raise
                ifres: #mailhasbeensentatleastonce,nomajorexceptionoccured
                    mail.write({'state':'sent','message_id':res,'failure_reason':False})
                    _logger.info('MailwithID%randMessage-Id%rsuccessfullysent',mail.id,mail.message_id)
                    #/!\can'tusemail.statehere,asmail.refresh()willcauseanerror
                    #seerevid:odo@openerp.com-20120622152536-42b2s28lvdv3odyrin6.1
                mail._postprocess_sent_message(success_pids=success_pids,failure_type=failure_type)
            exceptMemoryError:
                #preventcatchingtransientMemoryErrors,bubbleuptonotifyuserorabortcronjob
                #insteadofmarkingthemailasfailed
                _logger.exception(
                    'MemoryErrorwhileprocessingmailwithID%randMsg-Id%r.Considerraisingthe--limit-memory-hardstartupoption',
                    mail.id,mail.message_id)
                #mailstatuswillstayonongoingsincetransactionwillberollback
                raise
            except(psycopg2.Error,smtplib.SMTPServerDisconnected):
                #IfanerrorwiththedatabaseorSMTPsessionoccurs,chancesarethatthecursor
                #orSMTPsessionareunusable,causingfurthererrorswhentryingtosavethestate.
                _logger.exception(
                    'ExceptionwhileprocessingmailwithID%randMsg-Id%r.',
                    mail.id,mail.message_id)
                raise
            exceptExceptionase:
                failure_reason=tools.ustr(e)
                _logger.exception('failedsendingmail(id:%s)dueto%s',mail.id,failure_reason)
                mail.write({'state':'exception','failure_reason':failure_reason})
                mail._postprocess_sent_message(success_pids=success_pids,failure_reason=failure_reason,failure_type='UNKNOWN')
                ifraise_exception:
                    ifisinstance(e,(AssertionError,UnicodeEncodeError)):
                        ifisinstance(e,UnicodeEncodeError):
                            value="Invalidtext:%s"%e.object
                        else:
                            value='.'.join(e.args)
                        raiseMailDeliveryException(value)
                    raise

            ifauto_commitisTrue:
                self._cr.commit()
        returnTrue

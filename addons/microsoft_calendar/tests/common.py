importpytz
fromdatetimeimportdatetime,timedelta
fromunittest.mockimportpatch,MagicMock

fromflectra.tests.commonimportHttpCase

fromflectra.addons.microsoft_calendar.models.microsoft_syncimportMicrosoftSync
fromflectra.addons.microsoft_calendar.utils.event_id_storageimportcombine_ids

defmock_get_token(user):
    returnf"TOKEN_FOR_USER_{user.id}"

def_modified_date_in_the_future(event):
    """
    Addsomesecondstotheeventwritedatetobesuretohavealastmodifieddate
    inthefuture
    """
    return(event.write_date+timedelta(seconds=5)).strftime("%Y-%m-%dT%H:%M:%SZ")

defpatch_api(func):
    @patch.object(MicrosoftSync,'_microsoft_insert',MagicMock())
    @patch.object(MicrosoftSync,'_microsoft_delete',MagicMock())
    @patch.object(MicrosoftSync,'_microsoft_patch',MagicMock())
    defpatched(self,*args,**kwargs):
        returnfunc(self,*args,**kwargs)
    returnpatched

#ByinheritingfromTransactionCase,postcommithooks(somethodstaggedwith`@after_commit`inMicrosoftSync),
#arenotcalledbecausenocommitisdone.
#Tobeabletomanuallycallthesepostcommithooks,weneedtoinheritfromHttpCase.
#Note:aspostcommithooksarecalledseparately,donotforgettoinvalidatecacheforrecordsreadduringthetest.
classTestCommon(HttpCase):

    @patch_api
    defsetUp(self):
        super(TestCommon,self).setUp()

        #prepareusers
        self.organizer_user=self.env["res.users"].search([("name","=","MikeOrganizer")])
        ifnotself.organizer_user:
            partner=self.env['res.partner'].create({'name':'MikeOrganizer','email':'mike@organizer.com'})
            self.organizer_user=self.env['res.users'].create({
                'name':'MikeOrganizer',
                'login':'mike@organizer.com',
                'partner_id':partner.id,
            })

        self.attendee_user=self.env["res.users"].search([("name","=","JohnAttendee")])
        ifnotself.attendee_user:
            partner=self.env['res.partner'].create({'name':'JohnAttendee','email':'john@attendee.com'})
            self.attendee_user=self.env['res.users'].create({
                'name':'JohnAttendee',
                'login':'john@attendee.com',
                'partner_id':partner.id,
            })

        #-----------------------------------------------------------------------------------------
        #TocreateFlectraevents
        #-----------------------------------------------------------------------------------------
        self.start_date=datetime(2021,9,22,10,0,0,0)
        self.end_date=datetime(2021,9,22,11,0,0,0)
        self.recurrent_event_interval=2
        self.recurrent_events_count=7
        self.recurrence_end_date=self.end_date+timedelta(
            days=self.recurrent_event_interval*self.recurrent_events_count
        )

        #simpleeventvaluestocreateaFlectraevent
        self.simple_event_values={
            "name":"simple_event",
            "description":"mysimpleevent",
            "active":True,
            "start":self.start_date,
            "stop":self.end_date,
            "partner_ids":[(4,self.organizer_user.partner_id.id),(4,self.attendee_user.partner_id.id)],
        }
        self.recurrent_event_values={
            'name':'recurring_event',
            'description':'arecurringevent',
            "partner_ids":[(4,self.attendee_user.partner_id.id)],
            'recurrency':True,
            'follow_recurrence':True,
            'start':self.start_date.strftime("%Y-%m-%d%H:%M:%S"),
            'stop':self.end_date.strftime("%Y-%m-%d%H:%M:%S"),
            'event_tz':'Europe/London',
            'recurrence_update':'self_only',
            'rrule_type':'daily',
            'interval':self.recurrent_event_interval,
            'count':self.recurrent_events_count,
            'end_type':'count',
            'duration':1,
            'byday':'-1',
            'day':22,
            'we':True,
            'weekday':'WE'
        }

        #-----------------------------------------------------------------------------------------
        #ExpectedvaluesforFlectraeventsconvertedtoOutlookevents(tobepostedthroughAPI)
        #-----------------------------------------------------------------------------------------

        #simpleeventvaluesconvertedintheOutlookformattobepostedthroughtheAPI
        self.simple_event_ms_values={
            "subject":self.simple_event_values["name"],
            "body":{
                'content':self.simple_event_values["description"],
                'contentType':"text",
            },
            "start":{
                'dateTime':pytz.utc.localize(self.simple_event_values["start"]).isoformat(),
                'timeZone':'Europe/London'
            },
            "end":{
                'dateTime':pytz.utc.localize(self.simple_event_values["stop"]).isoformat(),
                'timeZone':'Europe/London'
            },
            "isAllDay":False,
            "organizer":{
                'emailAddress':{
                    'address':self.organizer_user.email,
                    'name':self.organizer_user.display_name,
                }
            },
            "isOrganizer":True,
            "sensitivity":"normal",
            "showAs":"busy",
            "attendees":[
                {
                    'emailAddress':{
                        'address':self.attendee_user.email,
                        'name':self.attendee_user.display_name
                    },
                    'status':{'response':"notresponded"}
                }
            ],
            "isReminderOn":False,
            "location":{'displayName':''},
            "reminderMinutesBeforeStart":0,
        }

        self.recurrent_event_ms_values={
            'subject':self.recurrent_event_values["name"],
            "body":{
                'content':self.recurrent_event_values["description"],
                'contentType':"text",
            },
            'start':{
                'dateTime':self.start_date.strftime("%Y-%m-%dT%H:%M:%S+00:00"),
                'timeZone':'Europe/London'
            },
            'end':{
                'dateTime':self.end_date.strftime("%Y-%m-%dT%H:%M:%S+00:00"),
                'timeZone':'Europe/London'
            },
            'isAllDay':False,
            'isOrganizer':True,
            'isReminderOn':False,
            'reminderMinutesBeforeStart':0,
            'sensitivity':'normal',
            'showAs':'busy',
            'type':'seriesMaster',
            "attendees":[
                {
                    'emailAddress':{
                        'address':self.attendee_user.email,
                        'name':self.attendee_user.display_name
                    },
                    'status':{'response':"notresponded"}
                }
            ],
            'location':{'displayName':''},
            'organizer':{
                'emailAddress':{
                    'address':self.organizer_user.email,
                    'name':self.organizer_user.display_name,
                },
            },
            'recurrence':{
                'pattern':{'dayOfMonth':22,'interval':self.recurrent_event_interval,'type':'daily'},
                'range':{
                    'numberOfOccurrences':self.recurrent_events_count,
                    'startDate':self.start_date.strftime("%Y-%m-%d"),
                    'type':'numbered'
                },
            },
        }

        #-----------------------------------------------------------------------------------------
        #EventscomingfromOutlook(sofromtheAPI)
        #-----------------------------------------------------------------------------------------

        self.simple_event_from_outlook_organizer={
            'type':'singleInstance',
            'seriesMasterId':None,
            'id':'123',
            'iCalUId':'456',
            'subject':'simple_event',
            'body':{
                'content':"mysimpleevent",
                'contentType':"text",
            },
            'start':{'dateTime':self.start_date.strftime("%Y-%m-%dT%H:%M:%S.0000000"),'timeZone':'UTC'},
            'end':{'dateTime':self.end_date.strftime("%Y-%m-%dT%H:%M:%S.0000000"),'timeZone':'UTC'},
            'attendees':[{
                'type':'required',
                'status':{'response':'none','time':'0001-01-01T00:00:00Z'},
                'emailAddress':{'name':self.attendee_user.display_name,'address':self.attendee_user.email}
            }],
            'isAllDay':False,
            'isCancelled':False,
            'sensitivity':'normal',
            'showAs':'busy',
            'isOnlineMeeting':False,
            'onlineMeetingUrl':None,
            'isOrganizer':True,
            'isReminderOn':True,
            'location':{'displayName':''},
            'organizer':{
                'emailAddress':{'address':self.organizer_user.email,'name':self.organizer_user.display_name},
            },
            'reminderMinutesBeforeStart':15,
            'responseRequested':True,
            'responseStatus':{
                'response':'organizer',
                'time':'0001-01-01T00:00:00Z',
            },
        }

        self.simple_event_from_outlook_attendee=self.simple_event_from_outlook_organizer
        self.simple_event_from_outlook_attendee.update(isOrganizer=False)

        #-----------------------------------------------------------------------------------------
        #ExpectedvaluesforOutlookeventsconvertedtoFlectraevents
        #-----------------------------------------------------------------------------------------

        self.expected_flectra_event_from_outlook={
            "name":"simple_event",
            "description":"mysimpleevent",
            "active":True,
            "start":self.start_date,
            "stop":self.end_date,
            "user_id":self.organizer_user,
            "microsoft_id":combine_ids("123","456"),
            "partner_ids":[self.organizer_user.partner_id.id,self.attendee_user.partner_id.id],
        }
        self.expected_flectra_recurrency_from_outlook={
            'active':True,
            'byday':'1',
            'count':0,
            'day':0,
            'display_name':"Every%sDays,until%s"%(
                self.recurrent_event_interval,self.recurrence_end_date.strftime("%Y-%m-%d")
            ),
            'dtstart':self.start_date,
            'end_type':'end_date',
            'event_tz':False,
            'fr':False,
            'interval':self.recurrent_event_interval,
            'month_by':'date',
            'microsoft_id':combine_ids('REC123','REC456'),
            'name':"Every%sDays,until%s"%(
                self.recurrent_event_interval,self.recurrence_end_date.strftime("%Y-%m-%d")
            ),
            'need_sync_m':False,
            'rrule':'DTSTART:%s\nRRULE:FREQ=DAILY;INTERVAL=%s;UNTIL=%s'%(
                self.start_date.strftime("%Y%m%dT%H%M%S"),
                self.recurrent_event_interval,
                self.recurrence_end_date.strftime("%Y%m%dT235959"),
            ),
            'rrule_type':'daily',
            'until':self.recurrence_end_date.date(),
            'weekday':False,
        }

        self.recurrent_event_from_outlook_organizer=[{
            'attendees':[{
                'emailAddress':{'address':self.attendee_user.email,'name':self.attendee_user.display_name},
                'status':{'response':'none','time':'0001-01-01T00:00:00Z'},
                'type':'required'
            }],
            'body':{
                'content':"myrecurrentevent",
                'contentType':"text",
            },
            'start':{'dateTime':self.start_date.strftime("%Y-%m-%dT%H:%M:%S.0000000"),'timeZone':'UTC'},
            'end':{'dateTime':self.end_date.strftime("%Y-%m-%dT%H:%M:%S.0000000"),'timeZone':'UTC'},
            'id':'REC123',
            'iCalUId':'REC456',
            'isAllDay':False,
            'isCancelled':False,
            'isOnlineMeeting':False,
            'isOrganizer':True,
            'isReminderOn':True,
            'location':{'displayName':''},
            'organizer':{'emailAddress':{
                'address':self.organizer_user.email,'name':self.organizer_user.display_name}
            },
            'recurrence':{
                'pattern':{
                    'dayOfMonth':0,
                    'firstDayOfWeek':'sunday',
                    'index':'first',
                    'interval':self.recurrent_event_interval,
                    'month':0,
                    'type':'daily'
                },
                'range':{
                    'startDate':self.start_date.strftime("%Y-%m-%d"),
                    'endDate':self.recurrence_end_date.strftime("%Y-%m-%d"),
                    'numberOfOccurrences':0,
                    'recurrenceTimeZone':'RomanceStandardTime',
                    'type':'endDate'
                }
            },
            'reminderMinutesBeforeStart':15,
            'responseRequested':True,
            'responseStatus':{'response':'organizer','time':'0001-01-01T00:00:00Z'},
            'sensitivity':'normal',
            'seriesMasterId':None,
            'showAs':'busy',
            'subject':"recurrentevent",
            'type':'seriesMaster',
        }]
        self.recurrent_event_from_outlook_organizer+=[
            {
                'attendees':[{
                    'emailAddress':{'address':self.attendee_user.email,'name':self.attendee_user.display_name},
                    'status':{'response':'none','time':'0001-01-01T00:00:00Z'},
                    'type':'required'
                }],
                'body':{
                    'content':"myrecurrentevent",
                    'contentType':"text",
                },
                'start':{
                    'dateTime':(
                        self.start_date+timedelta(days=i*self.recurrent_event_interval)
                    ).strftime("%Y-%m-%dT%H:%M:%S.0000000"),
                    'timeZone':'UTC'
                },
                'end':{
                    'dateTime':(
                        self.end_date+timedelta(days=i*self.recurrent_event_interval)
                    ).strftime("%Y-%m-%dT%H:%M:%S.0000000"),
                    'timeZone':'UTC'
                },
                'id':f'REC123_EVENT_{i+1}',
                'iCalUId':f'REC456_EVENT_{i+1}',
                'seriesMasterId':'REC123',
                'isAllDay':False,
                'isCancelled':False,
                'isOnlineMeeting':False,
                'isOrganizer':True,
                'isReminderOn':True,
                'location':{'displayName':''},
                'organizer':{
                    'emailAddress':{'address':self.organizer_user.email,'name':self.organizer_user.display_name}
                },
                'recurrence':None,
                'reminderMinutesBeforeStart':15,
                'responseRequested':True,
                'responseStatus':{'response':'organizer','time':'0001-01-01T00:00:00Z'},
                'sensitivity':'normal',
                'showAs':'busy',
                'subject':"recurrentevent",
                'type':'occurrence',
            }
            foriinrange(self.recurrent_events_count)
        ]
        self.recurrent_event_from_outlook_attendee=[
            dict(
                d,
                isOrganizer=False,
                attendees=[
                    {
                        'emailAddress':{'address':self.organizer_user.email,'name':self.organizer_user.display_name},
                        'status':{'response':'none','time':'0001-01-01T00:00:00Z'},
                        'type':'required'
                    },
                    {
                        'emailAddress':{'address':self.attendee_user.email,'name':self.attendee_user.display_name},
                        'status':{'response':'none','time':'0001-01-01T00:00:00Z'},
                        'type':'required'
                    },
                ]
            )
            fordinself.recurrent_event_from_outlook_organizer
        ]

        self.expected_flectra_recurrency_events_from_outlook=[
            {
                "name":"recurrentevent",
                "user_id":self.organizer_user,
                "partner_ids":[self.organizer_user.partner_id.id,self.attendee_user.partner_id.id],
                "start":self.start_date+timedelta(days=i*self.recurrent_event_interval),
                "stop":self.end_date+timedelta(days=i*self.recurrent_event_interval),
                "until":self.recurrence_end_date.date(),
                "microsoft_recurrence_master_id":"REC123",
                'microsoft_id':combine_ids(f"REC123_EVENT_{i+1}",f"REC456_EVENT_{i+1}"),
                "recurrency":True,
                "follow_recurrence":True,
                "active":True,
            }
            foriinrange(self.recurrent_events_count)
        ]
        self.env.cr.postcommit.clear()

    defcreate_events_for_tests(self):
        """
        Createsomeeventsfortestpurpose
        """

        #----createsomeeventsthatwillbeupdatedduringtests-----

        #asimpleevent
        self.simple_event=self.env["calendar.event"].search([("name","=","simple_event")])
        ifnotself.simple_event:
            self.simple_event=self.env["calendar.event"].with_user(self.organizer_user).create(
                dict(
                    self.simple_event_values,
                    microsoft_id=combine_ids("123","456"),
                )
            )

        #agroupofevents
        self.several_events=self.env["calendar.event"].search([("name","like","event%")])
        ifnotself.several_events:
            self.several_events=self.env["calendar.event"].with_user(self.organizer_user).create([
                dict(
                    self.simple_event_values,
                    name=f"event{i}",
                    microsoft_id=combine_ids(f"e{i}",f"u{i}"),
                )
                foriinrange(1,4)
            ])

        #arecurrenteventwith7occurrences
        self.recurrent_base_event=self.env["calendar.event"].search(
            [("name","=","recurrent_event")],
            order="id",
            limit=1,
        )
        already_created=self.recurrent_base_event

        ifnotalready_created:
            self.recurrent_base_event=self.env["calendar.event"].with_user(self.organizer_user).create(
                self.recurrent_event_values
            )
        self.recurrence=self.env["calendar.recurrence"].search([("base_event_id","=",self.recurrent_base_event.id)])

        #setidssetbyOutlook
        ifnotalready_created:
            self.recurrence.write({
                "microsoft_id":combine_ids("REC123","REC456"),
            })
            fori,einenumerate(self.recurrence.calendar_event_ids.sorted(key=lambdar:r.start)):
                e.write({
                    "microsoft_id":combine_ids(f"REC123_EVENT_{i+1}",f"REC456_EVENT_{i+1}"),
                    "microsoft_recurrence_master_id":"REC123",
                })
            self.recurrence.invalidate_cache()
            self.recurrence.calendar_event_ids.invalidate_cache()

        self.recurrent_events=self.recurrence.calendar_event_ids.sorted(key=lambdar:r.start)
        self.recurrent_events_count=len(self.recurrent_events)

    defassert_flectra_event(self,flectra_event,expected_values):
        """
        AssertthatanFlectraeventhasthesamevaluesthanintheexpected_valuesdictionary,
        forthekeyspresentinexpected_values.
        """
        self.assertTrue(expected_values)

        flectra_event_values=flectra_event.read(list(expected_values.keys()))[0]
        fork,vinexpected_values.items():
            ifkin("user_id","recurrence_id"):
                v=(v.id,v.name)ifvelseFalse

            ifisinstance(v,list):
                self.assertListEqual(sorted(v),sorted(flectra_event_values.get(k)),msg=f"'{k}'mismatch")
            else:
                self.assertEqual(v,flectra_event_values.get(k),msg=f"'{k}'mismatch")

    defassert_flectra_recurrence(self,flectra_recurrence,expected_values):
        """
        AssertthatanFlectrarecurrencehasthesamevaluesthanintheexpected_valuesdictionary,
        forthekeyspresentinexpected_values.
        """
        flectra_recurrence_values=flectra_recurrence.read(list(expected_values.keys()))[0]

        fork,vinexpected_values.items():
            self.assertEqual(v,flectra_recurrence_values.get(k),msg=f"'{k}'mismatch")

    defassert_dict_equal(self,dict1,dict2):

        #checkmissingkeys
        keys=set(dict1.keys())^set(dict2.keys())
        self.assertFalse(keys,msg="Followingkeysarenotinbothdicts:%s"%",".join(keys))

        #comparekeybykey
        fork,vindict1.items():
            self.assertEqual(v,dict2.get(k),f"'{k}'mismatch")

    defcall_post_commit_hooks(self):
        """
        manuallycallspostcommithooksdefinedwiththedecorator@after_commit
        """

        #needtomanuallyhandlepost-commithookscallsas`self.env.cr.postcommit.run()`clean
        #thequeueattheendofthefirstpost-commithookcall...
        funcs=self.env.cr.postcommit._funcs.copy()
        whilefuncs:
            func=funcs.popleft()
            func()

#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

fromflectraimportapi,fields,models


classMailingTrace(models.Model):
    """MailingTracemodelsthestatisticscollectedaboutemails.Thosestatistics
    arestoredinaseparatedmodelandtabletoavoidbloatingthemail_mailtable
    withstatisticsvalues.Thisalsoallowstodeleteemailssendwithmassmailing
    withoutloosingthestatisticsaboutthem."""
    _name='mailing.trace'
    _description='MailingStatistics'
    _rec_name='id'
    _order='scheduledDESC'

    trace_type=fields.Selection([('mail','Mail')],string='Type',default='mail',required=True)
    display_name=fields.Char(compute='_compute_display_name')
    #maildata
    mail_mail_id=fields.Many2one('mail.mail',string='Mail',index=True)
    mail_mail_id_int=fields.Integer(
        string='MailID(tech)',
        help='IDoftherelatedmail_mail.Thisfieldisanintegerfieldbecause'
             'therelatedmail_mailcanbedeletedseparatelyfromitsstatistics.'
             'HowevertheIDisneededforseveralactionandcontrollers.',
        index=True,
    )
    email=fields.Char(string="Email",help="Normalizedemailaddress")
    message_id=fields.Char(string='Message-ID')
    #document
    model=fields.Char(string='Documentmodel')
    res_id=fields.Integer(string='DocumentID')
    #campaign/wavedata
    mass_mailing_id=fields.Many2one('mailing.mailing',string='Mailing',index=True,ondelete='cascade')
    campaign_id=fields.Many2one(
        related='mass_mailing_id.campaign_id',
        string='Campaign',
        store=True,readonly=True,index=True)
    #Bounceandtracking
    ignored=fields.Datetime(help='Datewhentheemailhasbeeninvalidated.'
                                   'Invalidemailsareblacklisted,opted-outorinvalidemailformat')
    scheduled=fields.Datetime(help='Datewhentheemailhasbeencreated',default=fields.Datetime.now)
    sent=fields.Datetime(help='Datewhentheemailhasbeensent')
    exception=fields.Datetime(help='Dateoftechnicalerrorleadingtotheemailnotbeingsent')
    opened=fields.Datetime(help='Datewhentheemailhasbeenopenedthefirsttime')
    replied=fields.Datetime(help='Datewhenthisemailhasbeenrepliedforthefirsttime.')
    bounced=fields.Datetime(help='Datewhenthisemailhasbounced.')
    #Linktracking
    links_click_ids=fields.One2many('link.tracker.click','mailing_trace_id',string='Linksclick')
    clicked=fields.Datetime(help='Datewhencustomerclickedonatleastonetrackedlink')
    #Status
    state=fields.Selection(compute="_compute_state",
                             selection=[('outgoing','Outgoing'),
                                        ('exception','Exception'),
                                        ('sent','Sent'),
                                        ('opened','Opened'),
                                        ('replied','Replied'),
                                        ('bounced','Bounced'),
                                        ('ignored','Ignored')],store=True)
    failure_type=fields.Selection(selection=[
        ("SMTP","Connectionfailed(outgoingmailserverproblem)"),
        ("RECIPIENT","Invalidemailaddress"),
        ("BOUNCE","Emailaddressrejectedbydestination"),
        ("UNKNOWN","Unknownerror"),
    ],string='Failuretype')
    state_update=fields.Datetime(compute="_compute_state",string='StateUpdate',
                                   help='Laststateupdateofthemail',
                                   store=True)

    @api.depends('trace_type','mass_mailing_id')
    def_compute_display_name(self):
        fortraceinself:
            trace.display_name='%s:%s(%s)'%(trace.trace_type,trace.mass_mailing_id.name,trace.id)

    @api.depends('sent','opened','clicked','replied','bounced','exception','ignored')
    def_compute_state(self):
        self.update({'state_update':fields.Datetime.now()})
        forstatinself:
            ifstat.ignored:
                stat.state='ignored'
            elifstat.exception:
                stat.state='exception'
            elifstat.replied:
                stat.state='replied'
            elifstat.openedorstat.clicked:
                stat.state='opened'
            elifstat.bounced:
                stat.state='bounced'
            elifstat.sent:
                stat.state='sent'
            else:
                stat.state='outgoing'

    @api.model_create_multi
    defcreate(self,values_list):
        forvaluesinvalues_list:
            if'mail_mail_id'invalues:
                values['mail_mail_id_int']=values['mail_mail_id']
        returnsuper(MailingTrace,self).create(values_list)

    def_get_records(self,mail_mail_ids=None,mail_message_ids=None,domain=None):
        ifnotself.idsandmail_mail_ids:
            base_domain=[('mail_mail_id_int','in',mail_mail_ids)]
        elifnotself.idsandmail_message_ids:
            base_domain=[('message_id','in',mail_message_ids)]
        else:
            base_domain=[('id','in',self.ids)]
        ifdomain:
            base_domain=['&']+domain+base_domain
        returnself.search(base_domain)

    defset_opened(self,mail_mail_ids=None,mail_message_ids=None):
        traces=self._get_records(mail_mail_ids,mail_message_ids,[('opened','=',False)])
        traces.write({'opened':fields.Datetime.now(),'bounced':False})
        returntraces

    defset_clicked(self,mail_mail_ids=None,mail_message_ids=None):
        traces=self._get_records(mail_mail_ids,mail_message_ids,[('clicked','=',False)])
        traces.write({'clicked':fields.Datetime.now()})
        returntraces

    defset_replied(self,mail_mail_ids=None,mail_message_ids=None):
        traces=self._get_records(mail_mail_ids,mail_message_ids,[('replied','=',False)])
        traces.write({'replied':fields.Datetime.now()})
        returntraces

    defset_bounced(self,mail_mail_ids=None,mail_message_ids=None):
        traces=self._get_records(mail_mail_ids,mail_message_ids,[('bounced','=',False),('opened','=',False)])
        traces.write({'bounced':fields.Datetime.now()})
        returntraces

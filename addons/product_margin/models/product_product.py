#-*-coding:utf-8-*-
#PartofFlectra.SeeLICENSEfileforfullcopyrightandlicensingdetails.

importtime

fromflectraimportapi,fields,models


classProductProduct(models.Model):
    _inherit="product.product"

    date_from=fields.Date(compute='_compute_product_margin_fields_values',string='MarginDateFrom')
    date_to=fields.Date(compute='_compute_product_margin_fields_values',string='MarginDateTo')
    invoice_state=fields.Selection(compute='_compute_product_margin_fields_values',
        selection=[
            ('paid','Paid'),
            ('open_paid','OpenandPaid'),
            ('draft_open_paid','Draft,OpenandPaid')
        ],string='InvoiceState',readonly=True)
    sale_avg_price=fields.Float(compute='_compute_product_margin_fields_values',string='Avg.SaleUnitPrice',
        help="Avg.PriceinCustomerInvoices.")
    purchase_avg_price=fields.Float(compute='_compute_product_margin_fields_values',string='Avg.PurchaseUnitPrice',
        help="Avg.PriceinVendorBills")
    sale_num_invoiced=fields.Float(compute='_compute_product_margin_fields_values',string='#InvoicedinSale',
        help="SumofQuantityinCustomerInvoices")
    purchase_num_invoiced=fields.Float(compute='_compute_product_margin_fields_values',string='#InvoicedinPurchase',
        help="SumofQuantityinVendorBills")
    sales_gap=fields.Float(compute='_compute_product_margin_fields_values',string='SalesGap',
        help="ExpectedSale-TurnOver")
    purchase_gap=fields.Float(compute='_compute_product_margin_fields_values',string='PurchaseGap',
        help="NormalCost-TotalCost")
    turnover=fields.Float(compute='_compute_product_margin_fields_values',string='Turnover',
        help="SumofMultiplicationofInvoicepriceandquantityofCustomerInvoices")
    total_cost=fields.Float(compute='_compute_product_margin_fields_values',string='TotalCost',
        help="SumofMultiplicationofInvoicepriceandquantityofVendorBills")
    sale_expected=fields.Float(compute='_compute_product_margin_fields_values',string='ExpectedSale',
        help="SumofMultiplicationofSaleCatalogpriceandquantityofCustomerInvoices")
    normal_cost=fields.Float(compute='_compute_product_margin_fields_values',string='NormalCost',
        help="SumofMultiplicationofCostpriceandquantityofVendorBills")
    total_margin=fields.Float(compute='_compute_product_margin_fields_values',string='TotalMargin',
        help="Turnover-Standardprice")
    expected_margin=fields.Float(compute='_compute_product_margin_fields_values',string='ExpectedMargin',
        help="ExpectedSale-NormalCost")
    total_margin_rate=fields.Float(compute='_compute_product_margin_fields_values',string='TotalMarginRate(%)',
        help="Totalmargin*100/Turnover")
    expected_margin_rate=fields.Float(compute='_compute_product_margin_fields_values',string='ExpectedMargin(%)',
        help="Expectedmargin*100/ExpectedSale")

    @api.model
    defread_group(self,domain,fields,groupby,offset=0,limit=None,orderby=False,lazy=True):
        """
            Inheritread_grouptocalculatethesumofthenon-storedfields,asitisnotautomaticallydoneanymorethroughtheXML.
        """
        res=super(ProductProduct,self).read_group(domain,fields,groupby,offset=offset,limit=limit,orderby=orderby,lazy=lazy)
        fields_list=['turnover','sale_avg_price','sale_purchase_price','sale_num_invoiced','purchase_num_invoiced',
                       'sales_gap','purchase_gap','total_cost','sale_expected','normal_cost','total_margin',
                       'expected_margin','total_margin_rate','expected_margin_rate']
        ifany(xinfieldsforxinfields_list):
            #Calculatefirstforeveryproductinwhichlineitneedstobeapplied
            re_ind=0
            prod_re={}
            tot_products=self.browse([])
            forreinres:
                ifre.get('__domain'):
                    products=self.search(re['__domain'])
                    tot_products|=products
                    forprodinproducts:
                        prod_re[prod.id]=re_ind
                re_ind+=1
            res_val=tot_products._compute_product_margin_fields_values(field_names=[xforxinfieldsiffieldsinfields_list])
            forkeyinres_val:
                forlinres_val[key]:
                    re=res[prod_re[key]]
                    ifre.get(l):
                        re[l]+=res_val[key][l]
                    else:
                        re[l]=res_val[key][l]
        returnres

    def_compute_product_margin_fields_values(self,field_names=None):
        iffield_namesisNone:
            field_names=[]
        date_from=self.env.context.get('date_from',time.strftime('%Y-01-01'))
        date_to=self.env.context.get('date_to',time.strftime('%Y-12-31'))
        invoice_state=self.env.context.get('invoice_state','open_paid')
        res={
            product_id:{'date_from':date_from,'date_to':date_to,'invoice_state':invoice_state,'turnover':0.0,
                'sale_avg_price':0.0,'purchase_avg_price':0.0,'sale_num_invoiced':0.0,'purchase_num_invoiced':0.0,
                'sales_gap':0.0,'purchase_gap':0.0,'total_cost':0.0,'sale_expected':0.0,'normal_cost':0.0,'total_margin':0.0,
                'expected_margin':0.0,'total_margin_rate':0.0,'expected_margin_rate':0.0}
            forproduct_idinself.ids
        }
        states=()
        payment_states=()
        ifinvoice_state=='paid':
            states=('posted',)
            payment_states=('in_payment','paid',)
        elifinvoice_state=='open_paid':
            states=('posted',)
            payment_states=('not_paid','in_payment','paid')
        elifinvoice_state=='draft_open_paid':
            states=('posted','draft')
            payment_states=('not_paid','in_payment','paid')
        if"force_company"inself.env.context:
            company_id=self.env.context['force_company']
        else:
            company_id=self.env.company.id
        self.env['account.move.line'].flush(['price_unit','quantity','balance','product_id','display_type'])
        self.env['account.move'].flush(['state','payment_state','move_type','invoice_date','company_id'])
        self.env['product.template'].flush(['list_price'])
        sqlstr="""
                WITHcurrency_rateAS({})
                SELECT
                    l.product_idasproduct_id,
                    SUM(
                        l.price_unit/(CASECOALESCE(cr.rate,0)WHEN0THEN1.0ELSEcr.rateEND)*
                        l.quantity*(CASEWHENi.move_typeIN('out_invoice','in_invoice')THEN1ELSE-1END)*((100-l.discount)*0.01)
                    )/NULLIF(SUM(l.quantity*(CASEWHENi.move_typeIN('out_invoice','in_invoice')THEN1ELSE-1END)),0)ASavg_unit_price,
                    SUM(l.quantity*(CASEWHENi.move_typeIN('out_invoice','in_invoice')THEN1ELSE-1END))ASnum_qty,
                    SUM(ABS(l.balance)*(CASEWHENi.move_typeIN('out_invoice','in_invoice')THEN1ELSE-1END))AStotal,
                    SUM(l.quantity*pt.list_price*(CASEWHENi.move_typeIN('out_invoice','in_invoice')THEN1ELSE-1END))ASsale_expected
                FROMaccount_move_linel
                LEFTJOINaccount_moveiON(l.move_id=i.id)
                LEFTJOINproduct_productproductON(product.id=l.product_id)
                LEFTJOINproduct_templateptON(pt.id=product.product_tmpl_id)
                leftjoincurrency_ratecron
                (cr.currency_id=i.currency_idand
                 cr.company_id=i.company_idand
                 cr.date_start<=COALESCE(i.invoice_date,NOW())and
                 (cr.date_endISNULLORcr.date_end>COALESCE(i.invoice_date,NOW())))
                WHEREl.product_idIN%s
                ANDi.stateIN%s
                ANDi.payment_stateIN%s
                ANDi.move_typeIN%s
                ANDi.invoice_dateBETWEEN%sAND %s
                ANDi.company_id=%s
                ANDl.display_typeISNULL
                ANDl.exclude_from_invoice_tab=false
                GROUPBYl.product_id
                """.format(self.env['res.currency']._select_companies_rates())
        invoice_types=('out_invoice','out_refund')
        self.env.cr.execute(sqlstr,(tuple(self.ids),states,payment_states,invoice_types,date_from,date_to,company_id))
        forproduct_id,avg,qty,total,saleinself.env.cr.fetchall():
            res[product_id]['sale_avg_price']=avgandavgor0.0
            res[product_id]['sale_num_invoiced']=qtyandqtyor0.0
            res[product_id]['turnover']=totalandtotalor0.0
            res[product_id]['sale_expected']=saleandsaleor0.0
            res[product_id]['sales_gap']=res[product_id]['sale_expected']-res[product_id]['turnover']
            res[product_id]['total_margin']=res[product_id]['turnover']
            res[product_id]['expected_margin']=res[product_id]['sale_expected']
            res[product_id]['total_margin_rate']=res[product_id]['turnover']andres[product_id]['total_margin']*100/res[product_id]['turnover']or0.0
            res[product_id]['expected_margin_rate']=res[product_id]['sale_expected']andres[product_id]['expected_margin']*100/res[product_id]['sale_expected']or0.0

        ctx=self.env.context.copy()
        ctx['force_company']=company_id
        invoice_types=('in_invoice','in_refund')
        self.env.cr.execute(sqlstr,(tuple(self.ids),states,payment_states,invoice_types,date_from,date_to,company_id))
        forproduct_id,avg,qty,total,dummyinself.env.cr.fetchall():
            res[product_id]['purchase_avg_price']=avgandavgor0.0
            res[product_id]['purchase_num_invoiced']=qtyandqtyor0.0
            res[product_id]['total_cost']=totalandtotalor0.0
            res[product_id]['total_margin']=res[product_id].get('turnover',0.0)-res[product_id]['total_cost']
            res[product_id]['total_margin_rate']=res[product_id].get('turnover',0.0)andres[product_id]['total_margin']*100/res[product_id].get('turnover',0.0)or0.0
        forproductinself:
            res[product.id]['normal_cost']=product.standard_price*res[product.id]['purchase_num_invoiced']
            res[product.id]['purchase_gap']=res[product.id]['normal_cost']-res[product.id]['total_cost']
            res[product.id]['expected_margin']=res[product.id].get('sale_expected',0.0)-res[product.id]['normal_cost']
            res[product.id]['expected_margin_rate']=res[product.id].get('sale_expected',0.0)andres[product.id]['expected_margin']*100/res[product.id].get('sale_expected',0.0)or0.0
            product.write(res[product.id])
        returnres

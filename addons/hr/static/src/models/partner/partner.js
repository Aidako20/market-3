flectra.define('hr/static/src/models/partner/partner.js',function(require){
'usestrict';

const{
    registerInstancePatchModel,
    registerFieldPatchModel,
}=require('mail/static/src/model/model_core.js');
const{attr,one2one}=require('mail/static/src/model/model_field.js');

registerInstancePatchModel('mail.partner','hr/static/src/models/partner/partner.js',{
    //--------------------------------------------------------------------------
    //Public
    //--------------------------------------------------------------------------

    /**
     *Checkswhetherthispartnerhasarelatedemployeeandlinksthemif
     *applicable.
     */
    asynccheckIsEmployee(){
        awaitthis.async(()=>this.env.models['hr.employee'].performRpcSearchRead({
            context:{active_test:false},
            domain:[['user_partner_id','=',this.id]],
            fields:['user_id','user_partner_id'],
        }));
        this.update({hasCheckedEmployee:true});
    },
    /**
     *Whenapartnerisanemployee,itsemployeeprofilecontainsmoreuseful
     *informationtoknowwhoheisthanitspartnerprofile.
     *
     *@override
     */
    asyncopenProfile(){
        //limitationofpatch,`this._super`becomesunavailableafter`await`
        const_super=this._super.bind(this,...arguments);
        if(!this.employee&&!this.hasCheckedEmployee){
            awaitthis.async(()=>this.checkIsEmployee());
        }
        if(this.employee){
            returnthis.employee.openProfile();
        }
        return_super();
    },
});

registerFieldPatchModel('mail.partner','hr/static/src/models/partner/partner.js',{
    /**
     *Employeerelatedtothispartner.Itiscomputedthrough
     *theinverserelationandshouldbeconsideredread-only.
     */
    employee:one2one('hr.employee',{
        inverse:'partner',
    }),
    /**
     *Whetheranattemptwasalreadymadetofetchtheemployeecorresponding
     *tothispartner.ThispreventsdoingthesameRPCmultipletimes.
     */
    hasCheckedEmployee:attr({
        default:false,
    }),
});

});

flectra.define('point_of_sale.custom_hooks',function(require){
    'usestrict';

    const{Component}=owl;
    const{onMounted,onPatched,onWillUnmount}=owl.hooks;

    /**
     *Introduceerrorhandlersinthecomponent.
     *
     *IMPROVEMENT:Thisisaterriblehook.Therecouldbeabetterwaytohandle
     *theerrorwhentheorderfailedtosync.
     */
    functionuseErrorHandlers(){
        constcomponent=Component.current;

        component._handlePushOrderError=asyncfunction(error){
            //Thiserrorhandlerreceives`error`equivalentto`error.message`oftherpcerror.
            if(error.message==='BackendInvoice'){
                awaitthis.showPopup('ConfirmPopup',{
                    title:this.env._t('Pleaseprinttheinvoicefromthebackend'),
                    body:
                        this.env._t(
                            'Theorderhasbeensynchronizedearlier.Pleasemaketheinvoicefromthebackendfortheorder:'
                        )+error.data.order.name,
                });
            }elseif(error.code<0){
                //XmlHttpRequestErrors
                consttitle=this.env._t('Unabletosyncorder');
                constbody=this.env._t(
                    'Checktheinternetconnectionthentrytosyncagainbyclickingontheredwifibutton(upperrightofthescreen).'
                );
                awaitthis.showPopup('OfflineErrorPopup',{title,body});
            }elseif(error.code===200){
                //OpenERPServerErrors
                awaitthis.showPopup('ErrorTracebackPopup',{
                    title:error.data.message||this.env._t('ServerError'),
                    body:
                        error.data.debug||
                        this.env._t('Theserverencounteredanerrorwhilereceivingyourorder.'),
                });
            }elseif(error.code===700){
                //SwedenFiscalmoduleerrors
                awaitthis.showPopup('ErrorPopup',{
                    title:this.env._t('Fiscaldatamoduleerror'),
                    body:
                        error.data.error.status||
                        this.env._t('Thefiscaldatamoduleencounteredanerrorwhilereceivingyourorder.'),
                });
            }elseif(error.code===701){
                //BelgianFiscalmoduleerrors
                letbodyMessage="";
                if(error.error.errorCode)
                    bodyMessage="'"+error.error.errorCode+"':"+error.error.errorMessage;
                else
                    bodyMessage="Fiscaldatamoduleisnoton.";
                awaitthis.showPopup('ErrorPopup',{
                    title:this.env._t('Fiscaldatamoduleerror'),
                    body:bodyMessage
                });
            }else{
                //???
                awaitthis.showPopup('ErrorPopup',{
                    title:this.env._t('UnknownError'),
                    body:this.env._t(
                        'Theordercouldnotbesenttotheserverduetoanunknownerror'
                    ),
                });
            }
        };
    }

    functionuseAutoFocusToLast(){
        constcurrent=Component.current;
        lettarget=null;
        functionautofocus(){
            constprevTarget=target;
            constallInputs=current.el.querySelectorAll('input');
            target=allInputs[allInputs.length-1];
            if(target&&target!==prevTarget){
                target.focus();
                target.selectionStart=target.selectionEnd=target.value.length;
            }
        }
        onMounted(autofocus);
        onPatched(autofocus);
    }

    /**
     *Usethishookwhenyouwanttodosomethingonpreviouslyselectedand
     *newlyselectedorderwhentheorderchanges.
     *
     *Normally,acomponentisrenderedthenthecurrentorderischanged.When
     *thishappens,wewanttorerenderthecomponentbecausethenewinformation
     *shouldbereflectedinthescreen.Additionally,wemightwanttoremovelisteners
     *tothepreviousorderandattachlistenerstothenewone.Thishookis
     *perfectforthedescribedsituation.
     *
     *Internally,thishookperformsthefollowing:
     *1.callnewOrderCBonmounted
     *2.listentoorderchangesandperformthefollowingsequence:
     *   -callprevOrderCB(prevOrder)
     *   -callnewOrderCB(newOrder)
     *3.callprevOrderCBonwillUnmount
     *
     *@param{Function}prevOrderCBapplythiscallbackonthepreviousorder
     *@param{Function}newOrderCBapplythiscallbackontheneworder
     */
    functiononChangeOrder(prevOrderCB,newOrderCB){
        constcurrent=Component.current;
        prevOrderCB=prevOrderCB?prevOrderCB.bind(current):()=>{};
        newOrderCB=newOrderCB?newOrderCB.bind(current):()=>{};
        onMounted(()=>{
            current.env.pos.on(
                'change:selectedOrder',
                async(pos,newOrder)=>{
                    awaitprevOrderCB(pos.previous('selectedOrder'));
                    awaitnewOrderCB(newOrder);
                },
                current
            );
            newOrderCB(current.env.pos.get_order());
        });
        onWillUnmount(()=>{
            current.env.pos.off('change:selectedOrder',null,current);
            prevOrderCB(current.env.pos.get_order());
        });
    }

    functionuseBarcodeReader(callbackMap,exclusive=false){
        constcurrent=Component.current;
        constbarcodeReader=current.env.pos.barcode_reader;
        for(let[key,callback]ofObject.entries(callbackMap)){
            callbackMap[key]=callback.bind(current);
        }
        onMounted(()=>{
            if(barcodeReader){
                for(letkeyincallbackMap){
                    if(exclusive){
                        barcodeReader.set_exclusive_callback(key,callbackMap[key]);
                    }else{
                        barcodeReader.set_action_callback(key,callbackMap[key]);
                    }
                }
            }
        });
        onWillUnmount(()=>{
            if(barcodeReader){
                for(letkeyincallbackMap){
                    if(exclusive){
                        barcodeReader.remove_exclusive_callback(key,callbackMap[key]);
                    }else{
                        barcodeReader.remove_action_callback(key,callbackMap[key]);
                    }
                }
            }
        });
    }

    functionuseAsyncLockedMethod(method){
        constcomponent=Component.current;
        letcalled=false;
        returnasync(...args)=>{
            if(called){
                return;
            }
            try{
                called=true;
                awaitmethod.call(component,...args);
            }finally{
                called=false;
            }
        };
    }

    return{useErrorHandlers,useAutoFocusToLast,onChangeOrder,useBarcodeReader,useAsyncLockedMethod};
});

flectra.define('point_of_sale.Draggable',function(require){
    'usestrict';

    const{useExternalListener}=owl.hooks;
    const{useListener}=require('web.custom_hooks');
    constPosComponent=require('point_of_sale.PosComponent');
    constRegistries=require('point_of_sale.Registries');

    /**
     *Wrapanelementoracomponentwith{position:absolute}tomakeit
     *draggablearoundthelimitAreaorthenearestpositionedancestor.
     *
     *e.g.
     *```
     *<divclass="limit-area">
     *  <DraggablelimitArea="'.limit-area'">
     *    <divclass="popup">
     *      <headerclass="drag-handle"></header>
     *    </div>
     *    <divclass="popupbody"></div>
     *  </Draggable>
     *</div>
     *```
     *
     *Intheabovesnippet,ifthepopupdivis{position:absolute},
     *thenitbecomesdraggablearoundthe.limit-areaelementifitisdragged
     *thruitsHeader--becauseofthe.drag-handleelement.
     *
     *@trigger'drag-end'whendraggingendedwithpayload`{loc:{top,left}}`
     */
    classDraggableextendsPosComponent{
        constructor(){
            super(...arguments);
            this.isDragging=false;
            this.dx=0;
            this.dy=0;
            //dragwithmouse
            useExternalListener(document,'mousemove',this.move);
            useExternalListener(document,'mouseup',this.endDrag);
            //dragwithtouch
            useExternalListener(document,'touchmove',this.move);
            useExternalListener(document,'touchend',this.endDrag);

            useListener('mousedown','.drag-handle',this.startDrag);
            useListener('touchstart','.drag-handle',this.startDrag);
        }
        mounted(){
            this.limitArea=this.props.limitArea
                ?document.querySelector(this.props.limitArea)
                :this.el.offsetParent;
            this.limitAreaBoundingRect=this.limitArea.getBoundingClientRect();
            if(this.limitArea===this.el.offsetParent){
                this.limitLeft=0;
                this.limitTop=0;
                this.limitRight=this.limitAreaBoundingRect.width;
                this.limitBottom=this.limitAreaBoundingRect.height;
            }else{
                this.limitLeft=-this.el.offsetParent.offsetLeft;
                this.limitTop=-this.el.offsetParent.offsetTop;
                this.limitRight=
                    this.limitAreaBoundingRect.width-this.el.offsetParent.offsetLeft;
                this.limitBottom=
                    this.limitAreaBoundingRect.height-this.el.offsetParent.offsetTop;
            }
            this.limitAreaWidth=this.limitAreaBoundingRect.width;
            this.limitAreaHeight=this.limitAreaBoundingRect.height;

            //absolutelypositiontheelementthenremovethetransform.
            constelBoundingRect=this.el.getBoundingClientRect();
            this.el.style.top=`${elBoundingRect.top}px`;
            this.el.style.left=`${elBoundingRect.left}px`;
            this.el.style.transform='none';
        }
        startDrag(event){
            letrealEvent;
            if(eventinstanceofCustomEvent){
                realEvent=event.detail;
            }else{
                realEvent=event;
            }
            const{x,y}=this._getEventLoc(realEvent);
            this.isDragging=true;
            this.dx=this.el.offsetLeft-x;
            this.dy=this.el.offsetTop-y;
            event.stopPropagation();
        }
        move(event){
            if(this.isDragging){
                const{x:pointerX,y:pointerY}=this._getEventLoc(event);
                constposLeft=this._getPosLeft(pointerX,this.dx);
                constposTop=this._getPosTop(pointerY,this.dy);
                this.el.style.left=`${posLeft}px`;
                this.el.style.top=`${posTop}px`;
            }
        }
        endDrag(){
            if(this.isDragging){
                this.isDragging=false;
                this.trigger('drag-end',{
                    loc:{top:this.el.offsetTop,left:this.el.offsetLeft},
                });
            }
        }
        _getEventLoc(event){
            letcoordX,coordY;
            if(event.touches&&event.touches[0]){
                coordX=event.touches[0].clientX;
                coordY=event.touches[0].clientY;
            }else{
                coordX=event.clientX;
                coordY=event.clientY;
            }
            return{
                x:coordX,
                y:coordY,
            };
        }
        _getPosLeft(pointerX,dx){
            constposLeft=pointerX+dx;
            if(posLeft<this.limitLeft){
                returnthis.limitLeft;
            }elseif(posLeft>this.limitRight-this.el.offsetWidth){
                returnthis.limitRight-this.el.offsetWidth;
            }
            returnposLeft;
        }
        _getPosTop(pointerY,dy){
            constposTop=pointerY+dy;
            if(posTop<this.limitTop){
                returnthis.limitTop;
            }elseif(posTop>this.limitBottom-this.el.offsetHeight){
                returnthis.limitBottom-this.el.offsetHeight;
            }
            returnposTop;
        }
    }
    Draggable.template='Draggable';

    Registries.Component.add(Draggable);

    returnDraggable;
});

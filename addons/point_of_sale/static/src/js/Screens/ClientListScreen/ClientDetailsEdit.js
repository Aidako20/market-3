flectra.define('point_of_sale.ClientDetailsEdit',function(require){
    'usestrict';

    const{_t}=require('web.core');
    const{getDataURLFromFile}=require('web.utils');
    constPosComponent=require('point_of_sale.PosComponent');
    constRegistries=require('point_of_sale.Registries');

    classClientDetailsEditextendsPosComponent{
        constructor(){
            super(...arguments);
            this.intFields=['country_id','state_id','property_product_pricelist'];
            constpartner=this.props.partner;
            this.changes={
                'country_id':partner.country_id&&partner.country_id[0],
                'state_id':partner.state_id&&partner.state_id[0],
            };
            if(!partner.property_product_pricelist)
                this.changes['property_product_pricelist']=this.env.pos.default_pricelist.id;
        }
        mounted(){
            this.env.bus.on('save-customer',this,this.saveChanges);
        }
        willUnmount(){
            this.env.bus.off('save-customer',this);
        }
        getpartnerImageUrl(){
            //Weprioritizeimage_1920inthe`changes`fieldbecausewewant
            //toshowtheuploadedimagewithoutfetchingnewdatafromtheserver.
            constpartner=this.props.partner;
            if(this.changes.image_1920){
                returnthis.changes.image_1920;
            }elseif(partner.id){
                return`/web/image?model=res.partner&id=${partner.id}&field=image_128&write_date=${partner.write_date}&unique=1`;
            }else{
                returnfalse;
            }
        }
        /**
         *Savetofield`changes`allinputchangesfromtheformfields.
         */
        captureChange(event){
            this.changes[event.target.name]=event.target.value;
        }
        saveChanges(){
            letprocessedChanges={};
            for(let[key,value]ofObject.entries(this.changes)){
                if(this.intFields.includes(key)){
                    processedChanges[key]=parseInt(value)||false;
                }else{
                    processedChanges[key]=value;
                }
            }
            if((!this.props.partner.name&&!processedChanges.name)||
                processedChanges.name===''){
                returnthis.showPopup('ErrorPopup',{
                  title:_t('ACustomerNameIsRequired'),
                });
            }
            processedChanges.id=this.props.partner.id||false;
            this.trigger('save-changes',{processedChanges});
        }
        asyncuploadImage(event){
            constfile=event.target.files[0];
            if(!file.type.match(/image.*/)){
                awaitthis.showPopup('ErrorPopup',{
                    title:this.env._t('UnsupportedFileFormat'),
                    body:this.env._t(
                        'Onlyweb-compatibleImageformatssuchas.pngor.jpegaresupported.'
                    ),
                });
            }else{
                constimageUrl=awaitgetDataURLFromFile(file);
                constloadedImage=awaitthis._loadImage(imageUrl);
                if(loadedImage){
                    constresizedImage=awaitthis._resizeImage(loadedImage,800,600);
                    this.changes.image_1920=resizedImage.toDataURL();
                    //Rerendertoreflectthechangesinthescreen
                    this.render();
                }
            }
        }
        _resizeImage(img,maxwidth,maxheight){
            varcanvas=document.createElement('canvas');
            varctx=canvas.getContext('2d');
            varratio=1;

            if(img.width>maxwidth){
                ratio=maxwidth/img.width;
            }
            if(img.height*ratio>maxheight){
                ratio=maxheight/img.height;
            }
            varwidth=Math.floor(img.width*ratio);
            varheight=Math.floor(img.height*ratio);

            canvas.width=width;
            canvas.height=height;
            ctx.drawImage(img,0,0,width,height);
            returncanvas;
        }
        /**
         *LoadingimageisconvertedtoaPromisetoallowawaitwhen
         *loadinganimage.Itresolvestotheloadedimageifsuccesful,
         *else,resolvestofalse.
         *
         *[Source](https://stackoverflow.com/questions/45788934/how-to-turn-this-callback-into-a-promise-using-async-await)
         */
        _loadImage(url){
            returnnewPromise((resolve)=>{
                constimg=newImage();
                img.addEventListener('load',()=>resolve(img));
                img.addEventListener('error',()=>{
                    this.showPopup('ErrorPopup',{
                        title:this.env._t('LoadingImageError'),
                        body:this.env._t(
                            'Encounterederrorwhenloadingimage.Pleasetryagain.'
                        ),
                    });
                    resolve(false);
                });
                img.src=url;
            });
        }
    }
    ClientDetailsEdit.template='ClientDetailsEdit';

    Registries.Component.add(ClientDetailsEdit);

    returnClientDetailsEdit;
});

flectra.define('point_of_sale.OrderFetcher',function(require){
    'usestrict';

    const{EventBus}=owl.core;
    const{Gui}=require('point_of_sale.Gui');
    const{isRpcError}=require('point_of_sale.utils');
    constmodels=require('point_of_sale.models');

    classOrderFetcherextendsEventBus{
        constructor(){
            super();
            this.currentPage=1;
            this.ordersToShow=[];
            this.cache={};
            this.totalCount=0;
        }
        getactiveOrders(){
            constallActiveOrders=this.comp.env.pos.get('orders').models;
            returnthis.searchDomain
                ?allActiveOrders.filter(this._predicateBasedOnSearchDomain.bind(this))
                :allActiveOrders;
        }
        _predicateBasedOnSearchDomain(order){
            functioncheck(order,field,searchWord){
                searchWord=searchWord.toLowerCase();
                switch(field){
                    case'pos_reference':
                        returnorder.name.toLowerCase().includes(searchWord);
                    case'partner_id.display_name':
                        constclient=order.get_client();
                        returnclient?client.name.toLowerCase().includes(searchWord):false;
                    case'date_order':
                        returnmoment(order.creation_date).format('YYYY-MM-DDhh:mmA').includes(searchWord);
                    default:
                        returnfalse;
                }
            }
            for(let[field,_,searchWord]of(this.searchDomain||[]).filter((item)=>item!=='|')){
                //removesurrounding"%"from`searchWord`
                searchWord=searchWord.substring(1,searchWord.length-1);
                if(check(order,field,searchWord)){
                    returntrue;
                }
            }
            returnfalse;
        }
        getnActiveOrders(){
            returnthis.activeOrders.length;
        }
        getlastPageFullOfActiveOrders(){
            returnMath.trunc(this.nActiveOrders/this.nPerPage);
        }
        getremainingActiveOrders(){
            returnthis.nActiveOrders%this.nPerPage;
        }
        /**
         *fornPerPage=10
         *+--------+----------+
         *|nItems|lastPage|
         *+--------+----------+
         *|    2 |      1 |
         *|   10 |      1 |
         *|   11 |      2 |
         *|   30 |      3 |
         *|   35 |      4 |
         *+--------+----------+
         */
        getlastPage(){
            constnItems=this.nActiveOrders+this.totalCount;
            returnMath.trunc(nItems/(this.nPerPage+1))+1;
        }
        /**
         *Callingthismethodspopulatesthe`ordersToShow`thentrigger`update`event.
         *@relatedget
         *
         *NOTE:Thisistightly-coupledwithpagination.Soifthecurrentpagecontainsall
         *activeorders,itwillnotfetchanythingfromtheserverbutonlysets`ordersToShow`
         *totheactiveordersthatfitsthecurrentpage.
         */
        asyncfetch(){
            try{
                letlimit,offset;
                letstart,end;
                if(this.currentPage<=this.lastPageFullOfActiveOrders){
                    //Showonlyactiveorders.
                    start=(this.currentPage-1)*this.nPerPage;
                    end=this.currentPage*this.nPerPage;
                    this.ordersToShow=this.activeOrders.slice(start,end);
                }elseif(this.currentPage===this.lastPageFullOfActiveOrders+1){
                    //Showpartiallytheremainingactiveordersand
                    //someordersfromthebackend.
                    offset=0;
                    limit=this.nPerPage-this.remainingActiveOrders;
                    start=(this.currentPage-1)*this.nPerPage;
                    end=this.nActiveOrders;
                    this.ordersToShow=[
                        ...this.activeOrders.slice(start,end),
                        ...(awaitthis._fetch(limit,offset)),
                    ];
                }else{
                    //Showordersfromthebackend.
                    offset=
                        this.nPerPage-
                        this.remainingActiveOrders+
                        (this.currentPage-(this.lastPageFullOfActiveOrders+1)-1)*
                            this.nPerPage;
                    limit=this.nPerPage;
                    this.ordersToShow=awaitthis._fetch(limit,offset);
                }
                this.trigger('update');
            }catch(error){
                if(isRpcError(error)&&error.message.code<0){
                    Gui.showPopup('ErrorPopup',{
                        title:this.comp.env._t('NetworkError'),
                        body:this.comp.env._t('Unabletofetchordersifoffline.'),
                    });
                    Gui.setSyncStatus('error');
                }else{
                    throwerror;
                }
            }
        }
        /**
         *Thisreturnstheordersfromthebackendthatneedstobeshown.
         *Iftheorderisalreadyincache,thefullinformationaboutthat
         *orderisnotfetchedanymore,instead,weuseinfofromcache.
         *
         *@param{number}limit
         *@param{number}offset
         */
        async_fetch(limit,offset){
            const{ids,totalCount}=awaitthis._getOrderIdsForCurrentPage(limit,offset);
            constidsNotInCache=ids.filter((id)=>!(idinthis.cache));
            if(idsNotInCache.length>0){
                constfetchedOrders=awaitthis._fetchOrders(idsNotInCache);
                awaitthis.comp.env.pos._loadMissingProducts(fetchedOrders);
                //Cachethesefetchedorderssothatnexttime,noneedtofetch
                //themagain,unlessinvalidated.See`invalidateCache`.
                fetchedOrders.forEach((order)=>{
                    this.cache[order.id]=newmodels.Order(
                        {},
                        {pos:this.comp.env.pos,json:order}
                    );
                });
            }
            this.totalCount=totalCount;
            returnids.map((id)=>this.cache[id]);
        }
        async_getOrderIdsForCurrentPage(limit,offset){
            returnawaitthis.rpc({
                model:'pos.order',
                method:'search_paid_order_ids',
                kwargs:{config_id:this.configId,domain:this.searchDomain?this.searchDomain:[],limit,offset},
                context:this.comp.env.session.user_context,
            });
        }
        async_fetchOrders(ids){
            returnawaitthis.rpc({
                model:'pos.order',
                method:'export_for_ui',
                args:[ids],
                context:this.comp.env.session.user_context,
            });
        }
        nextPage(){
            if(this.currentPage<this.lastPage){
                this.currentPage+=1;
                this.fetch();
            }
        }
        prevPage(){
            if(this.currentPage>1){
                this.currentPage-=1;
                this.fetch();
            }
        }
        /**
         *@param{integer|undefined}ididofthecachedorder
         *@returns{Array<models.Order>}
         */
        get(id){
            if(id)returnthis.cache[id];
            returnthis.ordersToShow;
        }
        setSearchDomain(searchDomain){
            this.searchDomain=searchDomain;
        }
        setComponent(comp){
            this.comp=comp;
            returnthis;
        }
        setConfigId(configId){
            this.configId=configId;
        }
        setNPerPage(val){
            this.nPerPage=val;
        }
        setPage(page){
            this.currentPage=page;
        }
        invalidateCache(ids){
            for(letidofids){
                deletethis.cache[id];
            }
        }
        asyncrpc(){
            Gui.setSyncStatus('connecting');
            constresult=awaitthis.comp.rpc(...arguments);
            Gui.setSyncStatus('connected');
            returnresult;
        }
    }

    returnnewOrderFetcher();
});
